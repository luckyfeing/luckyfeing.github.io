<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计之设计模式Mybatis</title>
      <link href="2021/07/30/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FMybatis/"/>
      <url>2021/07/30/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FMybatis/</url>
      
        <content type="html"><![CDATA[<p>其中XMLConfigBuilder在构建Configuration对象时，也会调用XMLMapperBuilder用于读取*Mapper文件，而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。</p><p>SqlSessionFactoryBuilder(使用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml，屏蔽了复杂对象的创建过程，构建核心对象Configuration对象，<br>将该Configuration对象作为参数构建一个SqlSessionFactory对象。)<br>-&gt;SqlSessionFactory（工厂方法模式创建SqlSession，实现类是DefaultSqlSessionFactory）-》SqlSession（通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。委托给Executor执行）</p><p>单例模式 （ErrorContext和LogFactory）<br>ErrorContext是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息。使用ThreadLocal静态常量<br>LogFactory则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p>代理模式（我们只需要编写Mapper.java接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。）<br>Subject: 抽象主题角色<br>Proxy: 代理主题角色<br>RealSubject: 真实主题角色<br>当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理<br>代理关键类(MapperProxyFactory和MapperProxy，MapperProxy类实现了InvocationHandler，MapperProxyFactory通过JDK代理Proxy.newProxyInstance(类加载器，被代理接口数组，实现了InvocationHandler类))</p><p>MappedStatement -》SQL语句<br>ResultMap  -》返回值对应映射<br>ParameterMap -》参数对应映射</p><p>new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));  主要是这段代码：找到对应的MappedStatement<br>调用后续的sqlSession.crud&gt;executor.execute&gt;prepareStatement等一系列方法，完成SQL的执行和返回。</p><p>组合模式(动态SQL，SqlNode接口，有很多实现类，如ForEachSqlNode)</p><p>模板方法模式(在Mybatis中，sqlSession的SQL执行，都是委托给Executor实现的，抽象类BaseExecutor，Executor实现类有SimpleExecutor，BatchExecutor，ReuseExecutor)<br>简单SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。（可以是Statement或PrepareStatement对象）</p><p>重用ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。（可以是Statement或PrepareStatement对象）</p><p>批量BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</p><p>适配器模式（Log接口，不用日志框架，不同的实现类，对象适配）</p><p>装饰者模式（缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）永久缓存实现，<br>然后通过一系列的装饰器来对PerpetualCache永久缓存进行缓存策略等方便的控制。）<br>FifoCache：先进先出算法，缓存回收策略<br>LoggingCache：输出缓存命中的日志信息<br>LruCache：最近最少使用算法，缓存回收策略<br>ScheduledCache：调度缓存，负责定时清空缓存<br>SerializedCache：缓存序列化和反序列化存储<br>SoftCache：基于软引用实现的缓存管理策略<br>SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问<br>WeakCache：基于弱引用实现的缓存管理策略<br>TransactionalCache：事务性的缓存<br>一级缓存，又叫本地缓存，是PerpetualCache类型的永久缓存，保存在执行器中（BaseExecutor），而执行器又在SqlSession（DefaultSqlSession）中，所以一级缓存的生命周期与SqlSession是相同的。<br>二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，所以可配置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保存在Configuration核心配置对象中。<br>Cache对象之间的引用顺序为：SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache</p><p>迭代器模式（PropertyTokenizer是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了Iterator接口，在使用时经常被用到的是Iterator接口中的hasNext这个函数。）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>资料文档整理</title>
      <link href="2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/"/>
      <url>2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>业务你不能瞎编，场景和规模、技术架构，你可以做一下战术美化，然后将我的单体ssm改成spring cloud 一套，引入各种分布式技术栈</p><p>7-9月培训高峰期，吃饭期间会集中做问卷调查，服务器压力非常大，然后将我的单体ssm改成spring cloud 一套，引入各种分布式技术栈了，不过你最好自己先做好业务分析，找个你认为比较合理的爆发点，去想技术方案</p><p>首先要先将自己的项目拆分成微服务，需要画架构图、物理图、做概要设计、详细设计、核心业务时序图等等，需要先自我深挖一波业务，做一下分析。这些可以去百度看看别人怎样画的，自己仿照来画，这样自己对整个项目能拆成多少个微服务，一个核心业务会调用多少个微服务已经很清晰了。不要看做这一步要很多时间，但是能不能顶住面试官的炮火这一步的分析是很重要的，也是自己对业务的提炼。</p><p>我说我们测试组会跟产品先出一份测试用例方案的，会对着来测试，基本大部分业务场景都覆盖了</p><p>我们融入业务之前需要先定好业务指标例如qps多少、tps多少、每个服务需要部署多少个实例来抗请求。<br>融入什么技术之前都需要先划定一个业务场景、设备数量，这样你聊的时候自己就中心有数了，无论面试官聊什么，你都要先定好业务边界，再聊技术方案，这样面试官会感觉你自己是有思考过，有“实干”过的。</p><p>1、你平时是如何设计项目的？<br>使用uml进行业务流程的建模，映射系统用例，对系统用例进行领域分析出类图。<br>对系统用例，进行功能的分析序列图设计，完整阐释领域类之间如何协作完成功能。<br>然后是db的设计，接口契约的设计，工时的预估。</p><p>2、设计一个类似于微博消息系统，能提示消息未读，对已读未读做统计，不要用redis，原始数据结构的设计。<br>当时我给了几张表，发布主题的消息表，个人维度的消息读取数量的统计表，已读消息序号增长表。</p><p>3、设计一个千万级别的分库分表，多维度如何处理？复杂查询如何处理？扩容如何处理？<br>当时我的回答是，用shardingjdbc分库分表，多维度也按不同的维度字段分。复杂查询数据canal监听binlog导入es<br>（1）幂等你们是怎么做的<br>（2）说一说你们现在分布式id的实现方案，有什么缺点</p><p>1、你觉的你是一个什么样的人？<br>自我驱动，用于担当，主动沟通和推进项目，能和团队成员良好协作，完成部门内和跨部门协作任务。</p><p>2、你觉的你能胜任我们提供的这个职位吗？<br>完全可以，工作态度认真积极，自我驱动力强，勇于挑战。</p><p>6.1、如果一个接口慢，造成这个接口慢的原因都有哪些？<br>1、网络IO （说下数据库优化、redis优化）<br>2、磁盘IO （可以用异步优化）<br>3、锁竞争-》优化思路 （分段加锁、锁粒度）<br>4、jvm优化（如果前面没问jvm的话，这时候也可以说一下jvm专栏里的优化方案）</p><p>6.2、如果让你来实现一个注册的功能，要考虑哪些点？<br>1、项目初期没什么数据量，单库单表就可以<br>2、数据量大了以后要考虑分库分表<br>3、超时重试<br>4、接口幂等性<br>5、注册功能属于核心功能，不能降级</p><p>6.3、怎么实现直播间送礼排行榜的功能？(使用redis，只展示前100名)<br>分两种情况考虑<br>1、访问量很小的直播间<br>（1）使用redis sorted set数据结构存储用户id，分数就是送礼金额<br>（2）查询的的时候直接获取前100个</p><p>2、访问量很大的直播间 （在这种情况下，使用上述设计方案，会有两个问题：一个问题是单台redis是扛不住那么高的并发;<br>另一个问题是送礼的人很多，展示的话只需要前100个，多个机器都存全量的key会浪费资源）<br>（1）同一个排行榜放在多个redis实例上，客户端读的时候做个轮询<br>（2）一个redis实例存全量的排行榜，只负责写数据；其他redis存前100名的数据，负责读。写数据时，如果前100名发生变化，就把最新的数据同步到其他节点。</p><p>6.4、一个很大的文件里存的都是些id，怎么统计出重复id的次数？(内存不能一次性加载所有数据)<br>1、把大文件拆分成内存可以放下的小文件比如10个小文件。<br>2、大文件中的id通过一个hash函数计算出hash值，寻址算法找到小文件<br>3、把小文件加载到内存中用HashMap就可以统计了</p><p>6.5、一个文件里都是电话号码，重复的号码需要记录重复次数，你会怎么设计存储？<br>1、电话号码可以分成三段，前面3位、中间4位、后面4位<br>2、仿照Mysql索引树设计，叶子节点挂的是重复次数<br>3、面试官说可以使用混合树（我不了解什么是混合树）</p><p>6.6、 mysql里一个字段的值需要存几百万个id怎么设计？<br>1、这些id先计算出一个base（所有id减去这个base就是个int类型的值）<br>2、搞一个bitmap，通过一个特殊的hash函数计算出（id-base）在bitmap中的位置（这个是唯一的）<br>3、核心思想就是使用bitmap存数据</p><p>6.7、 怎么设计一个接口的降级方案？<br>降级方案要分两种情况<br>1、核心链路的接口不能随便降级，有的接口慢，就得在那等着（同步接口）<br>2、非核心链路参照面试突击里使用Hystrix降级（后置校验；有损降级，提示用户可能失败，异步处理；缓存的本地缓存）</p><p>架构设计</p><p>需求分析阶段: 主要梳理所有用例（Use case）和场景，并抽象出面向系统的用户与角色，梳理出需求提供哪些功能与非功能的需求给这些用户。</p><p>概要设计阶段：根据需求分析的产物：核心需求，对整个系统进行模块划分，并定义好模块之间的交互关系。<br>详细设计阶段：通过多个视图来描述系统的架构，包括但不局限于：逻辑系统、物理视图、数据视图、物理视图</p><p>非功能需求:非功能的需求主要体现在高性能、高可用、可伸缩、可扩展、安全性等维度。<br>非功能需求对应不同系统指标主要分为 4 部分：应用服务器  数据库 缓存  消息队列</p><p>为什么零拷贝更快，具体原理<br>mysql事务acid是如何实现的<br>mysql幻读是如何解决的<br>mysql rr模式的原理<br>redis锁和zk锁的实现原理</p><p>谈谈你对锁优化的理解<br>谈谈你对JMM的理解<br>谈谈你对AQS的理解<br>谈谈你对读写锁的理解<br>谈谈有哪些保证原子性的手段<br>说一说你对ddd 战术部分的理解，代码如何分层<br>聊聊spring cloud各个组件的原理<br>hystrix限流是怎么做的，原理<br>谈一谈你对CompletableFuture的理解，为什么要用这个，超时机制怎么实现的<br>rocketmq中间件里面有哪些组件，说一说都有什么作用<br>mq事务消息的实现原理<br>如何解决缓存热key问题</p><p>Mysql只有在Read-Commit和Repeated-read两种隔离级别下实现MVCC机制</p><p>1、在Repeated-read隔离级别中，对MYSQL MVCC机制的理解：<br>1）mysql执行修改与新增操作SQL语句时，会对修改的数据以及新增的和删除数据记录到undo回滚日志文件中形成一个版本链，<br>并且记录当前操作的表中这一行记录中隐藏的列trx_id（当前事务Id）和roll_pointer（当前事务在undo日志文件中的磁盘地址）<br>2）当开启mysql事务执行SQL查询语句时会生成当前事务的一致性视图（read view），<br>该视图是由当前数据库中未提交事务id的数组（其中最小的事务id为min_trxId）和已经创建事务最大的trx_id(max_trxid)组成的</p><p>3）根据上面查询语句获取到表记录中隐藏的trx_id值与read view视图中的事务id进行对比，<br>如果trx_id&lt;min_trxid，则直接返回当前min_trxid对应的数据；<br>如果min_trxid &lt;= trx_id &lt;=max_trxid ，如果该trxid正好在read view视图中，则返回当前视图中trx_id对应的数据，<br>如果不在read view视图中则会根据roll_pinter指针在版本链中找到为当前记录对应trx_id的数据并且返回；<br>如果trx_id&gt;max_trxId则直接返回sql语句查询到的trx_id对应的数据</p><p>4）对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的 trx_id，<br>同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，<br>在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据。</p><p>2 在Read-commint隔离级别中，对MYSQL MVCC机制的理解：实际跟上述差不太多，唯独是在每次执行查询sql时都会重新生成read view视图</p><p>Archery MySQL监控平台</p><p><a href="https://blog.csdn.net/sinat_36748650/article/details/88033383">https://blog.csdn.net/sinat_36748650/article/details/88033383</a></p><p><a href="https://my.oschina.net/u/4397001/blog/3421494">https://my.oschina.net/u/4397001/blog/3421494</a></p><p><a href="http://www.suoniao.com/article/5ea23be9e2fbc11f0a0517da">http://www.suoniao.com/article/5ea23be9e2fbc11f0a0517da</a>  </p><p><a href="https://gitee.com/shishan100/projects">https://gitee.com/shishan100/projects</a>   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 552448K, used 67990K [0x000000076b780000, 0x0000000797500000, 0x00000007c0000000)</span><br><span class="line">  eden space 537600K, 9% used [0x000000076b780000,0x000000076eb6e7e8,0x000000078c480000)</span><br><span class="line">  from space 14848K, 99% used [0x0000000796680000,0x00000007974f7028,0x0000000797500000)</span><br><span class="line">  to   space 23040K, 0% used [0x0000000794800000,0x0000000794800000,0x0000000795e80000)</span><br><span class="line"> ParOldGen       total 222208K, used 41930K [0x00000006c2600000, 0x00000006cff00000, 0x000000076b780000)</span><br><span class="line">  object space 222208K, 18% used [0x00000006c2600000,0x00000006c4ef2b88,0x00000006cff00000)</span><br><span class="line"> Metaspace       used 62761K, capacity 66234K, committed 66328K, reserved 1105920K</span><br><span class="line">  class space    used 8381K, capacity 8993K, committed 9008K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">2021-07-01T15:03:11.502+0800: 34.466: [GC (Metadata GC Threshold) [PSYoungGen: 236338K-&gt;7762K(513536K)] 273443K-&gt;53629K(667136K), 0.0148958 secs]</span><br><span class="line"> [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line"> </span><br><span class="line">2021-07-01T15:03:11.517+0800: 34.481: [Full GC (Metadata GC Threshold) [PSYoungGen: 7762K-&gt;0K(513536K)] [ParOldGen: 45867K-&gt;41922K(222208K)] 53629K-&gt;41922K(735744K),</span><br><span class="line"> [Metaspace: 56313K-&gt;56313K(1099776K)], 0.2781880 secs] [Times: user&#x3D;1.19 sys&#x3D;0.09, real&#x3D;0.28 secs] </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, sdlExchange);</span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, sdlKey);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(queue, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br></pre></td></tr></table></figure><p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210803161445625.png" alt="image-20210803161445625"></p><p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210803161603524.png" alt="image-20210803161603524"></p><p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210803160430802.png" alt="image-20210803160430802"></p><p>Lifecycle 生命周期  -》SmartLifecycle</p><p>BeanDefinitionRegistryPostProcessor    void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;</p><p>BeanFactoryPostProcessor   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</p><p>储物柜设备上/下线webhook： <a href="https://uat-lockerai.deepblueai.com/locker/mqtt/event">https://uat-lockerai.deepblueai.com/locker/mqtt/event</a></p><p>储物柜设备下线（$events/client_disconnected）</p><p>SELECT * FROM “$events/client_disconnected” where username=’locker’</p><p>储物柜设备上线（$events/client_connected）</p><p>SELECT * FROM “$events/client_connected” where username=’locker’</p><p>spring-boot-starter-actuator度量metric，底层使用的是micrometer-core</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>java基础知识（集合、并发集合、队列、线程（线程池、Thread、Runnable、Callback、Future、CompletableFuture）、synchronized 、CAS 、volatile、ReentrantLock、ReentrantReadWriteLock、JMM、jvm、SPI、javaagent、instruction、JMX）</p><p>阻塞队列：</p><p>　　ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p><p>　　LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p><p>　　PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p><p>　　DelayQueue： 一个使用优先级队列实现的无界阻塞队列。</p><p>　　SynchronousQueue： 一个不存储元素的阻塞队列。</p><p>　　LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列。</p><p>　　LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。</p><p>拒绝策略：</p><p>　　ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。 (默认)</p><p>　　ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</p><p>　　ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务。（重复此过程）</p><p>　　ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。</p><p>JVM：CMS配置：<strong>UseCMSCompactAtFullCollection</strong>  <strong>CMSFullGCsBeforeCompaction=0</strong>    -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>数据结构、场景、底层数据结构、持久化原理及区别、过期策略、淘汰策略、数据恢复、主从集群、sentinel集群、Redis Cluster集群、缓存穿透、击穿、雪崩</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>（架构设计、工作原理、数据结构、zab原子广播协议，消息广播、崩溃恢复（选举、数据同步），场景）</p><p>场景：分布式协调，集群主从（HA高可用），分布式锁，队列，元数据/配置信息管理，注册中心</p><p>redis 分布式锁和 zk 分布式锁的对比</p><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。（返回过期时间的方式减少尝试次数；续期问题：使用watch dog后台线程，进行续期；主从数据丢失问题：多个客户端获取到了锁，使用ReadLock思路；客户端宕机时：key过期之后才能获取到锁）</li><li>zk 分布式锁，获取不到锁，注册个监听器即可，维持一个连接，不需要不断主动尝试获取锁，性能开销较小。写入时需要等到一半以上节点返回ACK之后才能写入，写入性能差，只能主节点进行写入。当节点宕机时，需要选举出新的节点，并完成数据同步之后才能提供服务，这块性能相较于Redis也差。</li></ul><p>znode类型：零时节点，持久化节点，临时顺序节点，持久化顺序节点</p><h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806163835364.png" alt="image-20210806163835364" style="zoom:67%;">节点数据一致，消息广播时，二阶段提交，Leader生成proposal事务，添加全局唯一64位递增事务id叫做zxid。zxid组成：32位为纪元，32为自增id。Leader会为每一个Follower节点分配一个单独的FIFO队列，然后把Proposal发送到队列中，Follower节点收到对应的Proposal之后会把它持久化到磁盘上，写入完成 返回ACK给Leader。Follower节点收过超过半数的ACK后 (Quorum机制) ，提交本地机器上的事务，同时广播commit ，Follower收到commit止呕，完成各自事务的提交。<h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><p>ES（架构设计、原理、近实时1s、数据结构（index，type，document，filed）、倒排索引、优化思路（操作系统会将磁盘文件里的数据自动缓存到 <code>filesystem cache</code> 里面去，尽量让数据留在缓存里：数据预热、冷热分离、document设计（不要做关联操作）、分页优化（不允许深翻页，一页一页翻页scroll api和search_after，scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动；<code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据）），更新删除底层原理（如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。））</p><p>merge原理（buffer 每 refresh 一次，就会产生一个 <code>segment file</code>，所以默认情况下是 1 秒钟一个 <code>segment file</code>，这样下来 <code>segment file</code> 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 <code>segment file</code> 合并成一个，同时这里会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code>，标识所有新的 <code>segment file</code>，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code>。）</p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210802173727433.png" alt="image-20210802173727433" style="zoom: 50%;"><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL（存储引擎，索引，行锁，表锁，意向锁，隔离级别，ACID，当前读、快照读、幻读、MVCC原理（Read Veiw）、Redo log、Undo log、Undo log 、主从复制（半同步复制、异步复制，relay log，并行复制（库级别），半一致性读）、索引调优（explain，最左匹配原则））</p><p><a href="https://blog.csdn.net/weixin_38629422/article/details/105813338?spm=1001.2014.3001.5501">redo日志的刷盘策略</a> <a href="https://www.jianshu.com/p/2b7fdad5fc0c">binlog/redolog/undolog详解</a><br><font color="red">innodb_flush_log_at_trx_commit</font>  0（Redo log buffer写入buffer）  1（Redo log buffer -》保证到redo日志文件） 2（Redo log buffer -》只保证到os cache -》redo日志文件）<br><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806161707243.png" alt="image-20210806161707243" style="zoom:67%;"></p><p><code>redo log</code>是<code>InnoDB</code>存储引擎层的日志，又被称为重写日志，用来记录事务操作的变化，记录的是数据修改之后的值，不管事务提交是否成功，都会被记录下来。<code>redo log</code>实现上采用来大小固定，循环写入的方式，当记录写到末尾时，又会从头开始写，如下图所示。</p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806155610943.png" alt="image-20210806155610943" style="zoom:67%;">`write pos`是当前记录的位置，一边写一边后移，写到4号文件末尾就回到1号文件开头。`check point`是当前要把记录写入到数据文件的位置，也是后移并且循环的。 <font color="red"> 用于系统奔溃恢复(crash-safe)</font><p><code>bin log</code>是mysql数据库service层的，是所有存储引擎共享的日志模块，它用于记录数据库执行的写入性操作，也就是在事务<code>commit</code>阶段进行记录，以二进制的形式保存于磁盘中。<code>bin log</code>是逻辑日志，并且由mysql数据库的service层执行，也就是说使用所有的存储引擎数据库都会记录<code>bin log</code>日志。</p><p><code>bin log</code>是以追加的方式进行写入的，可以通过 <code>max_binlog_size</code> 参数设置<code>bin log</code>文件大小，当文件大小达到某个值时，会生成新的文件来保存日志。</p><h3 id="bin-log刷盘机制"><a href="#bin-log刷盘机制" class="headerlink" title="bin log刷盘机制"></a>bin log刷盘机制</h3><p>在每次事务<code>commit</code>提交时才会记录bin log日志，此时记录仍然在内存中，那么什么时候存储到磁盘中呢？</p><p>mysql通过 <font color="red">sync_binlog</font> 参数控制bin log刷盘时机，取值范围：0～N：<br> 0：不去强求，由系统自行判断何时写入磁盘；<br> 1：每次事务<code>commit</code>的时候都要将bin log写入磁盘；<br> N：每N个事务<code>commit</code>，才会将bin log写入磁盘；</p><p><code>sync_binlog</code> 参数建议设置为1，这样每次事务commit时就会把bin log写入磁盘中，这样也可以保证mysql异常重启之后bin log日志不会丢失。</p><p>一点是主从复制，另一点是数据恢复</p><ul><li>主从复制：在master端开启 <code>bin log</code> ，然后将 <code>bin log</code> 发送给各个slaver端，slaver端读取 <code>bin log</code> 日志，从而使得主从数据库中数据一致</li><li> 数据恢复：通过 <code>bin log</code> 获取想要恢复的时间段数据</li></ul><p><code>undo log</code> 是回滚日志，逻辑日志是记录每条数据的所有版本，比如 <code>update</code> 语句，那么它首先会将该条记录的数据记录到<code>undo log</code>日志中，并且将最新版本的<strong>roll_pointer指针</strong>指向上一个版本，这样就可以形成当前记录的所有版本，这也是MVCC的实现机制。</p><p>undo log在事务开启之前就产生，当事务提交的时候，不会删除undo log，因为可能需要rollback操作，要执行回滚（rollback）操作时，从缓存中读取数据。InnoDB会将事务对应的日志保存在删除list中，后台通过purge线程进行回收处理</p><h3 id="事务执行过程"><a href="#事务执行过程" class="headerlink" title="事务执行过程"></a>事务执行过程</h3><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806154846154.png" alt="image-20210806154846154" style="zoom: 50%;"><p>为什么要分库分表（分表数据量太大，分库是因为一个库不能承担大量的并发请求）</p><p>单库数据迁移（停机迁移，双写保证一致性）</p><p>动态扩容缩容分库分表（预先分配足够的分库分表32*32,只需要更新路由规则，迁移库表即可）</p><p>分布式id（多种解决方案：）</p><p>读写分离（分库分表前要考虑读写分离，如果写请求少， 可以不用分库）</p><p>MQ（rabbitmq、kafka）（架构设计、原理、高可用、容错、对比（rabbitmq微秒级延迟，w级吞吐量，kafka秒级延迟，10w级吞吐量，功能上对比rabbitmq通过exchange和queue支持丰富的路由规则，还有死信队列，实现延迟消费，架构设计下海量消息没办法线性扩展；kafka日志存储文件，默认存储7天，对于需要记录的场景适用，而且性能更高）、数据零丢失（可靠性消息服务）、顺序消费、MQ作用、缺点、）</p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>RabbitMQ镜像集群，高可用。Master和Slave队列，写操作，当访问slave队列时，会路由到master队列；读操作，当访问slave时，转发到master获取队列数据，最后请求由slave返回。问题点是：queue中海量数据存储时，没办法线性扩展。负载均衡是master节点尽量不分配在同一个节点上。</p><p>RabbitMQ普通集群，元数据在每个节点上同步一份，queue不会在每个节点上，如果存在queue的节点宕机之后，数据就获取不到了。不能提供高可用</p><p>Kafka集群，分区和副本进行容错，可以通过增加分区的方式线性扩容，副本用于保证高可用。</p><h3 id="消息幂等性（怎么出现重复消费的情况）"><a href="#消息幂等性（怎么出现重复消费的情况）" class="headerlink" title="消息幂等性（怎么出现重复消费的情况）"></a>消息幂等性（怎么出现重复消费的情况）</h3><p>RabbitMQ手动确认channel.ack,处理过程中应用宕机，会导致重复消费</p><p>Kafka手动确认，每隔一段时间（定时定期），会把消费的offset提交到broker，消费一半，应用宕机的情况下，会再次重复消费</p><p>Kafka reblace重平衡，</p><h3 id="零丢失（可靠性传输）"><a href="#零丢失（可靠性传输）" class="headerlink" title="零丢失（可靠性传输）"></a>零丢失（可靠性传输）</h3><h3 id="积压"><a href="#积压" class="headerlink" title="积压"></a>积压</h3><p>RabbitMQ：增加消费者</p><p>Kafka：新建topic，之后创建成倍如10倍的分区，停掉消费者，写程序监听现有队列，将队列中的消息，重写到新的topic中，开启10倍的机器，消费新topic里的消息（一个消费者可以消费多个分区，但是不会多个消费者消费同一个分区）</p><p>当mq快写满了，临时程序，消费数据，丢弃数据，之后补数据</p><h3 id="rabbitmq消息过期（手动补消息）"><a href="#rabbitmq消息过期（手动补消息）" class="headerlink" title="rabbitmq消息过期（手动补消息）"></a>rabbitmq消息过期（手动补消息）</h3><h3 id="Kafka为啥快"><a href="#Kafka为啥快" class="headerlink" title="Kafka为啥快"></a>Kafka为啥快</h3><p>采用Reactor多路复用网络模型（支持百万连接），页缓存+异步磁盘顺序写入，零拷贝</p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210802163613614.png" alt="image-20210802163613614" style="zoom: 67%;">                                                                        多路复用原理图<p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210802172944621.png" alt="image-20210802172944621" style="zoom:50%;"><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210802173050027.png" alt="image-20210802173050027" style="zoom:50%;"></p><p>​                                                        左图为正常读写过程，右图为零拷贝过程</p><h3 id="Kafka客户端缓冲池机制"><a href="#Kafka客户端缓冲池机制" class="headerlink" title="Kafka客户端缓冲池机制"></a>Kafka客户端缓冲池机制</h3><p>private final ConcurrentMap&lt;topicpartition, deque&gt;  batches = new CopyOnWriteMap&lt;TopicPartition, Deque&gt;();</p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210802164216792.png" alt="image-20210802164216792" style="zoom:67%;">初始化创建BufferPool 就占用固定的内存，比如 32MB。然后把 32MB 划分为 N 多个内存块，Deque<ByteBuffer> free，比如说一个内存块是 16KB，这样的话这个缓冲池里就会有很多的内存块，使用HeapByteBuffer缓冲区。<p>然后你需要创建一个新的 Batch，就从缓冲池里取一个 16KB 的内存块就可以了，然后这个 Batch 就不断的写入消息，但是最多就是写 16KB，因为 Batch 底层的内存块就 16KB。</p><p>接着如果 Batch 被发送到 Kafka 服务器了，此时 Batch 底层的内存块就直接还回缓冲池就可以了。</p><p>下次别人再要构建一个 Batch 的时候，再次使用缓冲池里的内存块就好了。这样就可以利用有限的内存，对他不停的反复重复的利用。因为如果你的 Batch 使用完了以后是把内存块还回到缓冲池中去，那么就不涉及到垃圾回收了。</p><p>如果我现在把一个缓冲池里的内存资源都占满了，现在缓冲池里暂时没有内存块了，怎么办呢？</p><p>阻塞你的写入操作，不让你继续写入消息了。把你给阻塞住，不停的等待，直到有内存块释放出来，然后再继续让你写入消息。</p><h3 id="Offset原理"><a href="#Offset原理" class="headerlink" title="Offset原理"></a>Offset原理</h3><p>segment file包含（多个log和index文件，查找时通过offset找到对应的index文件，再到对应的index文件里查找对应的log文件中数据存储位置，找到最终offset数据）index文件使用稀疏列表，通过二分查找，找到offset范围内的，在log文件里的位置。</p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>如何设计一个高并发系统（系统拆分、缓存、MQ、分库分表、读写分离、ES）</p><p>架构设计（10层）</p><p>工作原理（注册中心，Provider，Consumer，Monitor、Admin）</p><p>序列化（通信协议，序列化协议，hessian数据结构（8种原始类型，3种递归类型（list，map，object），一种特殊类型ref用来表示对共享对象的引用），PB（protocol buffer）效率高-》proto编译器，速度快，应该比 <code>XML</code> 和 <code>JSON</code> 快上了 <code>20~100</code> 倍；它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化）</p><p>负载均衡和集群容错（4种负载均衡策略，6种集群容错策略）</p><p>RandomLoadblance、RoundRobinLoadblance、LeastActiveLoadblance、ConsistentHashLoadblance</p><p>failover失败之后可以配置重试，默认；</p><p>failfast快速失败，写入请求，不需重试；</p><p>failsafe出现异常时忽略，不重要接口，写日志；</p><p>failback失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种；</p><p>forking并发调用多个provide人，只要一个成功就返回，常用于实时性要求比较高的读操作，但是会浪费更多的服务资源；</p><p>broadcast逐个调用所有的 provider。任何一个 provider 出错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><p>SPI（service provide interface，java自带的缺点：加载所有的实现类，Dubbo使用key-value键值对的方式，可以通过key直接获取实现类，@SPI（dubbo）指定默认通信协议为dubbo实现类)</p><p>@Adaptive扩展点自适应,可以把它看成是运行时动态决定使用哪种扩展的方式。dubbo会在运行时对扩展服务动态生成一个代理类，这个类会在运行时动态决定使用哪一个扩展。总结：运行时动态生成代理类，代理类通过url决定生成哪一个类的扩展类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure><p>重点就是看下如何生成这样的代理类，它是通过运行时生成源码文件，然后调用编译器进行编译后生成。</p><p>服务治理（调用链路自动生成（拓扑图），服务访问压力及时长统计（qps，tp90，tp99），失败监控和报警，可用性监控（SLA））</p><p>限流（connections，actives 设置长连接数量，每个长连接下并发执行线程数）</p><p>服务降级（降级使用Mock机制，服务上配置mock，mock=“return null” 或者mock=“true”再使用xxxServiceMock）</p><p>服务重试和超时（retries=“3”，timeout=“2000”）</p><p>幂等性怎么设计（网络超时，重试，重复处理。通用方案，很多情况下都要考虑幂等性）</p><p>接口保证顺序性（使用key如订单id，hash到同一个内存队列或使用Kafka指定key，消息到同一个分区中）</p><p>为什么要进行系统拆分？如何拆分？（不拆分，代码复杂，开发效率低，技术栈要求一致；拆分之前，需要组织结构进行拆分，3-4个人负责一个微服务，需要很强的基础架构和运维能力）</p><p>微服务和传统http地址调用区别（当访问多之后，需要配置对应关系，负载均衡、超时重试、降级、限流）</p><p>SpringCloud（框架、Eureka、Zuul、Gateway、Feign、Hystrix、Ribbon、Sentinel、Seata 、ShardingSphere）<br>Nacos原理：</p><p>配置中心：主动pull，长轮询（超时时间为30s，dataId的MD5对比，服务端29.5s之后执行取消任务并返回，之前挂起，将请求任务存入队列中，管理端更新之后，通过事件通知的方式唤起挂起的长轮询，将队列中的任务删除，并返回。）</p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806151612513.png" alt="image-20210806151612513" style="zoom:67%;"><p>注册中心：命名服务类上订阅监听，创建UDP长连接，更新服务时，通知监听器</p><p>SpringBoot</p><p>分布式事务</p><p>2pc(prepare准备阶段（所有的RM锁住需要的资源，在本地执行这个事务（执行sql，写redo/undo log等），但不提交）,commit提交阶段：commit，rollback) TM RM角色</p><p>1、同步阻塞：最大的问题即同步阻塞，即：所有参与事务的逻辑均处于阻塞状态。<br>2、单点：协调者存在单点问题，如果协调者出现故障，参与者将一直处于锁定状态。<br>3、脑裂：在阶段2中，如果只有部分参与者接收并执行了Commit请求，会导致节点数据不一致。</p><p>3pc</p><ul><li>cancommit是否可以提交，参与者节点会对自身逻辑进行事务尝试，其实说白了就是检查下自身状态的健康性，看有没有能力进行事务操作。</li><li> precommit预提交：参与者收到后开始执行事务操作，并将Undo和Redo信息记录到事务日志中。</li><li>docommit</li></ul><p>引入超时机制</p><ul><li>PreCommit阶段 <strong>协调者和参与者都引入了超时机制</strong>，前一个阶段返回，协调者超时，向所有的参与者发送<strong>“abort”</strong>请求。</li><li>doCommit阶段，协调者收到no或者超时，协调者都会向所有的参与者节点发送abort请求。在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</li></ul><p>避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。</p><p>以上就是3PC相对于2PC的一个提高（相对缓解了2PC中的前两个问题），但是3PC依然没有完全解决数据不一致的问题。</p><p>TCC(Try锁定冻结资源，Confirm确认扣除阶段，Cancel取消阶段)</p><p>问题：空回滚（pre阶段超时，此时cancel，丢包，支持），事务悬挂（执行cancel之后执行pre，堵塞时造成此情况，要避免）</p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210804102939532.png" alt="image-20210804102939532" style="zoom:67%;">本地消息<p>消息最终一致性</p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210804102903400.png" alt="image-20210804102903400" style="zoom:67%;">消息最终一致性<img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210804095858230.png" alt="image-20210804095858230" style="zoom:67%;"><p>最大努力通知</p><p>Seata</p><p><strong>Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。</strong></p><p><strong>Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。</strong></p><p><strong>Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</strong></p><p>分布式事务在Seata中AT模式的执行流程：</p><p><strong>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。</strong></p><p><strong>XID 在微服务调用链路的上下文中传播。</strong></p><p><strong>RM 向 TC 注册分支事务，接着执行这个分支事务并提交（重点：RM在第一阶段就已经执行了本地事务的提交/回滚），最后将执行结果汇报给TC。</strong></p><p><strong>TM 根据 TC 中所有的分支事务的执行情况，发起全局提交或回滚决议。</strong></p><p><strong>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</strong></p><p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210804104558272.png" alt="image-20210804104558272"></p><p>Seata能够在第一阶段直接提交事务，是因为Seata框架为每一个RM维护了一张UNDO_LOG表（这张表需要客户端自行创建），其中保存了每一次本地事务的回滚数据。因此，二阶段的回滚并不依赖于本地数据库事务的回滚，而是RM直接读取这张UNDO_LOG表，并将数据库中的数据更新为UNDO_LOG中存储的历史数据。</p><p>如果第二阶段是提交命令，那么RM事实上并不会对数据进行提交（因为一阶段已经提交了），而实发起一个异步请求删除UNDO_LOG中关于本事务的记录。</p><blockquote><p>由于Seata一阶段直接提交了本地事务，因此会造成隔离性问题，因此Seata的默认隔离级别为Read Uncommitted。然而Seata也支持Read Committed的隔离级别。</p></blockquote><p>IO网络编程</p><p>BIO 传统IO，堵塞式IO</p><ul><li><p>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大；</p></li><li><p>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</p></li></ul><p>NIO （非堵塞式IO，NewIO，java中NIO实现了非堵塞式IO，基于事件驱动的方式）</p><ul><li>并发连接：使用IO多路复用解决；堵塞读：当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；</li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li></ul><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210804114632365.png" alt="image-20210804114632365" style="zoom:67%;">NIO基本实现如图<p>Reactor 模型组成：</p><ul><li>事件分派器（eventDispatch，负责监听和分发事件）</li><li>多线程：事件处理器（eventHandle，处理程序执行 I/O 事件要完成的实际事件）</li></ul><p>Reactor 线程模型：单Reactor单线程，单Reactor多线程，主从Reactor多线程</p><p>AIO</p><p>Netty基于Future +Listener实现，Future虽然提供了异步任务处理机制，但是获取处理结果确不方便，只能通过堵塞get（）方法或者轮询的方式等到任务的结果   <a href="https://www.cnblogs.com/lbhym/p/12753314.html">Netty详解</a></p><p>Netty中的<font color="red">pipeline</font>和<font color="red">channelHandler</font>，通过责任链设计模式来组织代码逻辑，并且能够支持逻辑的添加和删除，能够支持各类协议拓展，如HTTP、Websocket等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;  <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123; <span class="comment">//服务端</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806135818842.png" alt="image-20210806135818842" style="zoom:67%;">一个双向链表结构，每个节点是一个ChannelHandlerContext对象。这个对象能拿到与channel相关的所有上下文信息，这个对象还包含一个重要的对象：ChannelHandler，它的分类如下。<img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806135913812.png" alt="image-20210806135913812" style="zoom:67%;"><p>拆包粘包解决方法：</p><ol><li>FixedLengthFrameDecoder：固定长度拆包器，每个数据包长度都是固定的。</li></ol><p>　　2. LineBasedFrameDecoder：行拆包器，每个数据包之间以换行符作为分隔。<br>　　3. DelimiterBasedFrameDecoder：类似行拆包器，不过我们可以自定义分隔符。<br>　　4. LengthFieldBasedFrameDecoder：基于长度域拆包器，最常用的，只要你的自定义协议中包含数据长度这个部分，就可以使用。它需要三个参数，第一个是数据包最大长度、第二个是参数长度域偏移量、第三个是长度域长度。</p><p>　　<img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/1383122-20200425144254261-1102259668.png" alt="img" style="zoom:67%;"></p><p>　　看看前面通信协议的图，所谓长度域就是数据长度就是数据长度占用的字节，这里是4。长度域偏移量就是数据长度这个部分在通信协议组成部分中的位置，前面几个部分加起来是7，所以它的偏移量就是7。</p><p>ByteBuf和ByteBuffer区别 <a href="https://blog.csdn.net/mrliuzhao/article/details/89453082">ByteBuffer</a></p><h2 id="响应式编程入门"><a href="#响应式编程入门" class="headerlink" title="响应式编程入门"></a>响应式编程入门</h2><p>　　响应式编程就是基于reactor的思想，当你做一个带有一定延迟的才能够返回的io操作时，不会阻塞，而是立刻返回一个流，并且订阅这个流，当这个流上产生了返回数据，可以立刻得到通知并调用回调函数处理数据。</p><h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p>　　Reactor中的发布者（Publisher）由<strong>Flux</strong>和<strong>Mono</strong>两个类定义，它们都提供了丰富的操作符（operator）。一个Flux对象代表一个包含0..N个元素的响应式序列，<font color="red">元素可以是普通对象、数据库查询的结果、http响应体，甚至是异常</font>。而一个Mono对象代表一个包含零/一个（0..1）元素的结果。下图就是一个Flux类型的数据流，Flux往流上发送了3个元素，Subscriber通过订阅这个流来接收通知。</p><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210804153258435.png" alt="image-20210804153258435" style="zoom:67%;">Flux和Mono都可以发出三种“数据信号”：元素值、错误信号、完成信号，错误信号和完成信号都是终止信号，完成信号用于告知下游订阅者该数据流正常结束，错误信号终止数据流的同时将错误传递给下游订阅者。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;reactive&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">Flux.fromIterable(words).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/yuanrw/p/10050509.html">什么是响应式编程？reactor入门</a></p><h2 id="Sentinel流控"><a href="#Sentinel流控" class="headerlink" title="Sentinel流控"></a>Sentinel流控</h2><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210805133711749.png" alt="image-20210805133711749" style="zoom:67%;">**流控规则**：    1、阈值类型：通过什么方式限流：qps：每秒请求量大于3的时候开始限流；并发线程数，减少了线程切换    2、**流控模式**        直接（默认）：接口达到限流条件时，开启限流        关联：当关联的资源达到限流条件时，开启限流 [适合做应用让步]        链路：当从某个接口过来的资源达到限流条件时，开启限流。**针对来源是针对上级微服务，而链路流控是针对上级接口，也就是说它的粒度更细**，访问通过@SentinelResource("message") 指定的接口    3、**流控效果**：        **快速失败（默认）**: 直接失败，抛出异常，不做任何额外的处理，是最简单的效果        **Warm Up**：它从开始阈值到最大QPS阈值会有一个缓冲阶段，一开始的阈值是最大QPS阈值的1/3，然后慢慢增长，直到最大阈值，适用于将突然增大的流量转换为缓步增长的场景。(令牌桶，平滑预热限流)        **排队等待**：让请求以均匀的速度通过，单机阈值为每秒通过数量，其余的排队等待； 它还会让设置一个超时时间，当请求超过超时间时间还未处理，则会被丢弃。（漏桶？）<p><strong>令牌桶算法</strong>：限制数据的平均传输效率的同时还允许一定程度的突发传输，保护自己的系统不被打垮。平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter limiter = RateLimiter.create(<span class="number">5</span>);<span class="comment">//每秒允许5个请求，表示桶容量为5且每秒新增5个令牌，即每隔0.2毫秒新增一个令牌</span></span><br><span class="line"><span class="comment">//permitsPerSecond:每秒新增的令牌数  warmupPeriod:从冷启动速率过渡到平均速率的时间间隔</span></span><br><span class="line"><span class="comment">//系统冷启动后慢慢的趋于平均固定速率（即刚开始速率慢一些，然后慢慢趋于我们设置的固定速率）</span></span><br><span class="line">RateLimiter limiter = RateLimiter.create(<span class="number">10</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">limiter.acquire(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>漏桶算法</strong>：限制数据的传输效率。用于保证别人的系统不被打垮</p><p><strong>降级规则</strong><br><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806100935989.png" alt="image-20210806100935989" style="zoom:67%;"></p><ul><li>平均响应时间：当资源的平均响应时间超过阈值（以 ms 为单位）之后，资源进入准降级状态。</li><li>异常比例：当资源的每秒异常总数占通过量的比值超过阈值之后，资源进入降级状态，即在接下的时间窗口（以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是[0.0,1.0]。 </li><li>异常数：当资源近 1 分钟的异常数目超过阈值之后会进行服务降级。注意由于统计时间窗口是分钟级别的，若时间窗口小于60s，则结束熔断状态后仍可能再进入熔断状态。</li></ul><p><strong>系统保护规则</strong></p><p>是从应用级别的入口流量进行控制，从单台机器的总体 Load、RT、入口 QPS 、CPU使用率和线程数五个维度监控应用数据，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量 (进入应用的流量) 生效。</p><ul><li>Load（仅对 Linux/Unix-like 机器生效）：当系统 load1 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护。系统容量由系统的 maxQps * minRt 计算得出。设定参考值一般是 CPU cores * 2.5。</li><li>RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li>线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li><li>CPU使用率：当单台机器上所有入口流量的 CPU使用率达到阈值即触发系统保护</li></ul><h2 id="SkyWalking"><a href="#SkyWalking" class="headerlink" title="SkyWalking"></a>SkyWalking</h2><p>SkyWalking使用javaagent探针的方式进行监控上报，零侵入。</p><p>UI：从Service 、Instance、Endpoint维度进行统计查看，</p><p>CPM  每分钟请求数，SLA 服务等级协议，P50,P90,P95,P99响应时间  slow endpoint慢端点  heatmap热力图：直观感受平台的整体流量</p><p>apdex 是一个衡量服务器性能的标准。apdex有三个指标：</p><p>满意：请求响应时间小于等于T。<br>可容忍：请求响应时间大于T，小于等于4T。<br>失望：请求响应时间大于4T。<br>T：自定义的一个时间值，比如：500ms。apdex = (满意数 + 可容忍数/2)/ 总数。例如：服务A定义T=200ms，在100个采样中，有20个请求小于200ms，有60个请求在200ms到800ms之间，有20个请求大于800ms。计算apdex = (20 + 60/2)/100 = 0.5。</p><p>拓扑图（依赖关系图）</p><h2 id="Gateway核心架构"><a href="#Gateway核心架构" class="headerlink" title="Gateway核心架构"></a>Gateway核心架构</h2><p>路由(Route) 是 gateway 中最基本的组件之一，表示一个具体的路由信息载体。主要定义了下面的几个信息:<br><strong>id</strong>，路由标识符，区别于其他 Route。<br><strong>uri</strong>，路由指向的目的地 uri，即客户端请求最终被转发到的微服务。<br><strong>order</strong>，用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高。<br><strong>predicate</strong>，断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。<br><strong>filter</strong>，过滤器用于修改请求和响应信息。<br><img src="/2021/07/30/%E8%B5%84%E6%96%99%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86/image-20210806103936840.png" alt="image-20210806103936840" style="zoom:67%;"><br><strong>执行流程大体如下：</strong></p><ol><li>Gateway Client向Gateway Server发送请求</li><li>请求首先会被HttpWebHandlerAdapter进行提取组装成网关上下文</li><li>然后网关的上下文会传递到DispatcherHandler，它负责将请求分发给RoutePredicateHandlerMapping</li><li>RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由是否可用</li><li>如果过断言成功，由FilteringWebHandler创建过滤器链并调用</li><li>请求会一次经过PreFilter–微服务-PostFilter的方法，最终返回响应</li></ol><p>断言-》断言工厂-》AbstractRoutePredicateFactory（继承此抽象类，）</p><p>基于路由权重的断言工厂-》WeightRoutePredicateFactory：接收一个[组名,权重], 然后对于同一个组内的路由按照权重转发</p><p>过滤器-》<strong>Filter</strong>的生命周期只有两个：<strong>“pre” **和</strong>“post”**。</p><ul><li><p>过滤器在请求被路由之前调用，可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等</p></li><li><p>过滤器在路由到微服务以后执行，为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</p></li></ul><p>GatewayFilter：应用到单个路由或者一个分组的路由上。GlobalFilter：应用到所有的路由上。</p><p>局部过滤器-》过滤器工厂（AbstractGatewayFilterFactory）</p><h2 id="均摊算法："><a href="#均摊算法：" class="headerlink" title="均摊算法："></a>均摊算法：</h2><p>99 ，128，19，62四个价格，优化60元，优惠之后均摊价格：99-60<em>99/(99+128+19+62)=79<br>128-60</em>128/(99+128+19+62)=103.06</p></ByteBuffer>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud全家桶</title>
      <link href="2021/07/21/SpringCloud%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
      <url>2021/07/21/SpringCloud%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="全家桶"><a href="#全家桶" class="headerlink" title="全家桶"></a>全家桶</h2><img src="/2021/07/21/SpringCloud%E5%85%A8%E5%AE%B6%E6%A1%B6/image-20210721172650230.png" alt="image-20210721172650230" style="zoom:67%;">作用<ul><li><p>Eureka：各个服务启动时，Eureka Client 都会将服务注册到 Eureka Server，并且 Eureka Client 还可以反过来从 Eureka Server 拉取注册表，从而知道其他服务在哪里</p></li><li><p>Ribbon：服务间发起请求的时候，基于 Ribbon 做负载均衡，从一个服务的多台机器中选择一台</p></li><li><p>Feign：基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求</p></li><li><p>Hystrix：发起请求是通过 Hystrix 的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</p></li><li><p>Zuul：如果前端、移动端要调用后端系统，统一从 Zuul 网关进入，由 Zuul 网关转发请求给对应的服务</p></li></ul><h2 id="Eureka注册发现原理"><a href="#Eureka注册发现原理" class="headerlink" title="Eureka注册发现原理"></a>Eureka注册发现原理</h2><ul><li>client每30秒主动向Server发请求获取注册服务列表，如果服务信息变动，更新本地服务注册列表</li><li>client每30秒向Server发送一次心跳，告诉Server，自己还活着。</li><li>如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。</li><li>中小型的项目建议关闭自我保护（eureka.server.enableSelfPreservation=false）<img src="/2021/07/21/SpringCloud%E5%85%A8%E5%AE%B6%E6%A1%B6/image-20210721174143940.png" alt="image-20210721174143940" style="zoom:67%;"></li></ul><h2 id="Eureka-Server服务列表存储结构"><a href="#Eureka-Server服务列表存储结构" class="headerlink" title="Eureka Server服务列表存储结构"></a>Eureka Server服务列表存储结构</h2><p>使用ConcurrentHashMap存储，ConcurrentHashMap&lt;String, Map&lt;String,Lease<InstanceInfo>&gt;&gt; registry。维护注册表，拉取注册表，更新心跳时间，全在内存中完成。key为服务名称，value为一个服务的多个服务实例，内存Map的key为服务的id，value为带有最近一次发送心跳的时间的实例信息。Lease类中带有最近一次发送心跳的时间，还有一个泛型对象，存有服务信息，如ip，端口，hostname</InstanceInfo></p><h2 id="Eureka-Server多层缓存机制"><a href="#Eureka-Server多层缓存机制" class="headerlink" title="Eureka Server多层缓存机制"></a>Eureka Server多层缓存机制</h2><p> 为了避免同时读写内存数据结构造成的并发冲突问题，还采用了多级缓存机制来进一步提升服务请求的响应速度。<br><img src="/2021/07/21/SpringCloud%E5%85%A8%E5%AE%B6%E6%A1%B6/image-20210721180624777.png" alt="image-20210721180624777" style="zoom:67%;"></p><h3 id="在拉取注册表的时候："><a href="#在拉取注册表的时候：" class="headerlink" title="在拉取注册表的时候："></a>在拉取注册表的时候：</h3><ul><li>首先从 ReadOnlyCacheMap 里查缓存的注册表。</li><li>若没有，就找 ReadWriteCacheMap 里缓存的注册表。</li><li>如果还没有，就从内存中获取实际的注册表数据。</li></ul><h3 id="在注册表发生变更的时候："><a href="#在注册表发生变更的时候：" class="headerlink" title="在注册表发生变更的时候："></a>在注册表发生变更的时候：</h3><ul><li>会在内存中更新变更的注册表数据，同时过期掉 ReadWriteCacheMap。</li><li>此过程不会影响 ReadOnlyCacheMap 提供人家查询注册表。</li><li>一段时间内（默认 30 秒），各服务拉取注册表会直接读 ReadOnlyCacheMap</li><li>30 秒过后，Eureka Server 的后台线程发现 ReadWriteCacheMap 已经清空了，也会清空 ReadOnlyCacheMap 中的缓存</li><li>下次有服务拉取注册表，又会从内存中获取最新的数据了，同时填充各个缓存。</li></ul><h3 id="多级缓存机制的优点是什么？"><a href="#多级缓存机制的优点是什么？" class="headerlink" title="多级缓存机制的优点是什么？"></a>多级缓存机制的优点是什么？</h3><ul><li>尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。</li><li>并且进一步保证对 Eureka Server 的大量请求，都是快速从纯内存走，性能极高。</li></ul><h2 id="Eureka总结（2000个服务，达到日均千万访问量）"><a href="#Eureka总结（2000个服务，达到日均千万访问量）" class="headerlink" title="Eureka总结（2000个服务，达到日均千万访问量）"></a>Eureka总结（2000个服务，达到日均千万访问量）</h2><ul><li>Eureka 通过设置适当的请求频率（拉取注册表 30 秒间隔，发送心跳 30 秒间隔），可以保证一个大规模的系统每秒请求 Eureka Server 的次数在几百次。</li><li>同时通过纯内存的注册表，保证了所有的请求都可以在内存处理，确保了极高的性能</li><li>另外, 多级缓存机制，确保了不会针对内存数据结构发生频繁的读写并发冲突操作，进一步提升性能。</li><li>上述就是 Spring Cloud 架构中，Eureka 作为微服务注册中心可以承载大规模系统每天千万级访问量的原理。</li><li>Eureka2.0闭源了，问题点：内存存储，如果大服务导致存储不足；异步同步，可能导致数据不一致，或者延迟。</li><li>自己设计Eureka，可以将数据分片存储在节点上，并热备存储。</li><li>Consul基于Raft强一致性，不光支持服务注册和发现，居然还可以支持简单的 kv 存储。<strong>多数据中心支持</strong></li></ul><h2 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h2><p>Eureka各个节点都是平等的，没有ZK中角色的概念， 即使N-1个节点挂掉也不会影响其他节点的正常运行。默认情况下，<strong>如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。</strong>但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。</p><p><strong>客户端节点正常的心跳比例低于85%的，也就是超过15%的客户端节点没有正常心跳才会触发自我保护机制</strong>，此时会出现以下几种情况：</p><ol><li>Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。</li><li>Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。</li><li>当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。</li></ol><p>因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。</p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>每个服务所在的机器上部署一个 Consul Agent，作为一个服务所在机器的代理。Consul Agent 可以用来收集你的服务信息然后发送给 Consul Server，还会对你的服务不停的发送请求检查他是否健康。发现别的服务的时候，Consul Agent 也会帮你转发请求给 Consul Server，查询其他服务所在机器。</p><p>Consul Server 一般要求部署 3~5 台机器，以保证高可用以及数据一致性。他们之间会自动实现数据同步，而且 Consul Server 集群会自动选举出一台机器作为 leader，其他的 Consul Server 就是 follower。</p><p><strong>Consul 会基于 Raft 协议</strong>保证高可用和数据一致性，注册和发现都会访问leader节点。</p><p>每个机器上的 Consul Agent 会不断的发送请求检查服务是否健康，是否宕机。如果服务宕机了，那么就会通知 Consul Server。</p><h2 id="Feign（接口访问）"><a href="#Feign（接口访问）" class="headerlink" title="Feign（接口访问）"></a>Feign（接口访问）</h2><h2 id="Ribbon（负载均衡）"><a href="#Ribbon（负载均衡）" class="headerlink" title="Ribbon（负载均衡）"></a>Ribbon（负载均衡）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment">#所有接口重试，需要注意幂等性</span></span><br><span class="line"><span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 自动重试次数，不包含第一次</span></span><br><span class="line"><span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment">#自动重试下一个服务器，不包含第一次</span></span><br></pre></td></tr></table></figure><p>自动重试，如果下游接口，可能网络波动RT时间长达1.5s时，会自动重试，可能这次很快就成功了。</p><h2 id="Hystrix（隔离，熔断，降级）"><a href="#Hystrix（隔离，熔断，降级）" class="headerlink" title="Hystrix（隔离，熔断，降级）"></a>Hystrix（隔离，熔断，降级）</h2><h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><ul><li><code>hystrix.threadpool.default.maxQueueSize</code>：最大排队长度。默认 -1，使用 <code>SynchronousQueue</code>。其他值则使用 <code>LinkedBlockingQueue</code>。如果要从 -1 换成其他值则需重启，即该值不能动态调整，若要动态调整，需要使用到下边这个配置</li><li><code>hystrix.threadpool.default.queueSizeRejectionThreshold</code>：排队线程数量阈值，默认为 5，达到时拒绝，如果配置了该选项，队列的大小是该队列</li></ul><p>注意： 如果 <code>maxQueueSize=-1</code> 的话，则该选项不起作用</p><h3 id="如何设置服务中每个-hystrix-线程池的大小"><a href="#如何设置服务中每个-hystrix-线程池的大小" class="headerlink" title="如何设置服务中每个 hystrix 线程池的大小"></a>如何设置服务中每个 hystrix 线程池的大小</h3><p>假设你的服务 A，每秒钟会接收 30 个请求，同时会向服务 B 发起 30 个请求，然后每个请求的响应时长经验值大概在 200ms，那么你的 hystrix 线程池需要多少个线程呢？</p><p>计算公式是：30（每秒请求数量） * 0.2（每个请求的处理秒数） + 4（给点缓冲 buffer） = 10（线程数量）。</p><h3 id="请求的超时时间设置"><a href="#请求的超时时间设置" class="headerlink" title="请求的超时时间设置"></a>请求的超时时间设置</h3><p>上例中设置超时时间为300ms。如果你的超时时间设置成了 500 毫秒，一个线程每秒最多只能处理 2 个请求了，10 个线程只能处理 20 个请求。一秒钟30个请求过来，大量的线程会全部卡死，来不及处理那么多请求，最后用户会刷不出来页面。哪怕一段时间后，服务 B 的接口性能恢复到 200 毫秒以内了，服务 A 的线程池里卡死的状况也要好一会儿才能恢复过来。</p><p>超时时间设置的越不合理，比如设置的越长，那么这种卡死的情况就需要越长的时间来恢复。</p><p>根据服务的响应时间、系统高峰 QPS、有多少台机器，来计算出来，线程池的大小以及超时时间！</p><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>基于异常比例进行熔断。</p><ul><li><p><code>hystrix.command.default.circuitBreaker.requestVolumeThreshold</code>：当在配置时间窗口内达到此数量的失败后，进行短路。默认 20 个（10s 内请求失败数量达到 20 个，断路器开）</p></li><li><p><code>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds</code>：短路多久以后开始尝试是否恢复，默认 5s</p></li><li><p><code>hystrix.command.default.circuitBreaker.errorThresholdPercentage</code>：出错百分比阈值，当达到此阈值后，开始短路。默认 50%</p></li><li><p>默认10s 内请求失败数量达到 20 个，断路器开，状态为Open状态（或者出错百分比阈值，当达到此阈值后，开始短路。默认 50%）</p></li><li><p>短路状体下，请求过来直接熔断，走降级流程，默认5s</p></li><li><p>5s之后，短路多久以后开始尝试是否恢复，状态置为半开状态，请求去访问下游接口，如果成功，则将状态改为Close状态，如果失败，则继续将状态改为Open状态</p></li></ul><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果线程池已满，则会进行降级处理，用户的请求不会被阻塞，至少可以看到一个执行结果（例如返回友好的提示信息），而不是无休止的等待或者看到系统崩溃。默认不采用排队。加速失败判定时间。</p><p>熔断之后也会降级。</p><ul><li>如果查询数据的服务挂了，你可以查本地的缓存</li><li>如果写入数据的服务挂了，你可以先把这个写入操作记录日志到比如 mysql 里，或者写入 MQ 里，后面再慢慢恢复</li><li>如果 redis 挂了，你可以查 mysql</li><li>如果 mysql 挂了，你可以把操作日志记录到 es 里去，后面再慢慢恢复数据。</li></ul><h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><p><strong>同步执行：</strong>即一旦开始执行该命令，当前线程就得阻塞着直到该命令返回结果，然后才能继续执行下面的逻辑</p><p><strong>异步执行：</strong>命令开始执行会返回一个Future<T>的对象，不阻塞后面的逻辑，开发者自己根据需要去获取结果。</T></p><p><strong>响应式执行：</strong>命令开始执行会返回一个Observable<T> 对象，开发者可以给给Obeservable对象注册上Observer或者Action1对象，响应式地处理命令执行过程中的不同阶段。当调用HystrixCommand的observe()方法，或使用Observable的工厂方法（just(),from()）即为响应式执行，这个功能的实现是基于Netflix的另一个开源项目RxJava（<a href="https://github.com/Netflix/RxJava%EF%BC%89%E6%9D%A5%E7%9A%84%EF%BC%8C%E6%9B%B4%E7%BB%86%E8%8A%82%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%EF%BC%9Ahttps://github.com/Netflix/Hystrix/wiki/How-To-Use#wiki-Reactive-Execution%E3%80%82">https://github.com/Netflix/RxJava）来的，更细节的用法可以参考：https://github.com/Netflix/Hystrix/wiki/How-To-Use#wiki-Reactive-Execution。</a></T></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决方案之接口幂等</title>
      <link href="2021/07/19/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/"/>
      <url>2021/07/19/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li>前端重复提交</li><li>接口超时重试</li><li>消息重复消费</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><img src="/2021/07/19/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/image-20210719152422692.png" alt="image-20210719152422692" style="zoom:67%;">基于Token实现，分成二步，第一步生成token。第二步比较之后先删除 token，在执行业务。<img src="/2021/07/19/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/image-20210719152436778.png" alt="image-20210719152436778" style="zoom:67%;">基于去重表日志记录表实现<img src="/2021/07/19/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/image-20210719152450125.png" alt="image-20210719152450125" style="zoom:67%;">基于Redis唯一标识去重<ul><li>状态机（状态）</li><li>悲观锁（加锁）</li><li>乐观锁（版本号）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件之Kafka与MQ对比</title>
      <link href="2021/07/19/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E4%B8%8EMQ%E5%AF%B9%E6%AF%94/"/>
      <url>2021/07/19/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E4%B8%8EMQ%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka与RabbitMQ对比"><a href="#Kafka与RabbitMQ对比" class="headerlink" title="Kafka与RabbitMQ对比"></a>Kafka与RabbitMQ对比</h2><ul><li><strong>消息顺序</strong>(kafka可以指定key或者指定partition，同一个分区的同一个消费组是顺序的，RabbitMQ单消费者才能保证顺序性)</li><li><strong>消息路由</strong>（RabbitMQ的多种交换机，默认交换机，direct，fanout，topic，header，提供丰富的路由）</li><li>消息时序（RabbitMQ提供消息存活时间，消息长度，队列存活时间，死信队列）</li><li>消息留存（RabbitMQ消费之后就会将消息删除，而Kafka会留存消息，每个主题配置超时时间，直到消息达到超时时间删除消息）</li><li><strong>容错处理</strong>（RabbitMQ提供交付重试和死信交换器（DLX）来处理消息处理故障，开箱即用；Kafka同组消费者只能一个消费分区，堵塞分区之后的数据消费，而RabbitMQ多个消费者可以同时消费，且不会阻塞后面数据消费）</li><li>性能（Kafka吞吐量每秒百万，Kafka 使用顺序磁盘 I/O 来提高性能。从 Kafka 使用分区的架构上看，它在横向扩展上会优于 RabbitMQ，当然 RabbitMQ 在纵向扩展上会有更多的优势）</li><li><strong>消费者复杂度</strong>（RabbitMQ消费者可以多个消费者同时消费，增加消费者时，也可能需要增加分区，不然可能消费者是空闲的，增加分区时，会进行重平衡，导致重复消费的情况）</li></ul><h2 id="优先选择-RabbitMQ-的条件："><a href="#优先选择-RabbitMQ-的条件：" class="headerlink" title="优先选择 RabbitMQ 的条件："></a>优先选择 RabbitMQ 的条件：</h2><ul><li>高级灵活的路由规则</li><li>消息时序控制（控制消息过期或者消息延迟）</li><li>高级的容错处理能力，在消费者更有可能处理消息不成功的情景中（瞬时或者持久）</li><li>更简单的消费者实现</li></ul><h2 id="优先选择-Kafka-的条件："><a href="#优先选择-Kafka-的条件：" class="headerlink" title="优先选择 Kafka 的条件："></a>优先选择 Kafka 的条件：</h2><ul><li>严格的消息顺序</li><li>延长消息留存时间，包括过去消息重放的可能</li><li>传统解决方案无法满足的高伸缩能力</li></ul><p>除了功能性差异和非功能性限制外，还需考虑限制</p><ul><li>当前开发者对这两个消息平台的了解</li><li>托管云解决方案的可用性（如果适用）</li><li>每种解决方案的运营成本</li><li>适用于我们目标栈的 SDK 的可用性</li></ul><p><img src="/2021/07/19/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E4%B8%8EMQ%E5%AF%B9%E6%AF%94/image-20210723142541970.png" alt="image-20210723142541970"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计之设计模式</title>
      <link href="2021/07/13/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/07/13/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="统一建模语言-Unified-Modeling-Language，UML"><a href="#统一建模语言-Unified-Modeling-Language，UML" class="headerlink" title="统一建模语言(Unified Modeling Language，UML)"></a>统一建模语言(Unified Modeling Language，<code>UML</code>)</h2><p>UML作为一种统一的软件建模语言具有广泛的建模能力。UML是在消化、吸收、提炼至今存在的所有软件建模语言的基础上提出的，集百家之所长，它是软件建模语言的集大成者。UML还突破了软件的限制，广泛吸收了其他领域的建模方法，并根据建模的一般原理，结合了软件的特点，因此具有坚实的理论基础和广泛性。UML不仅可以用于软件建模，还可以用于其他领域的建模工作。</p><ul><li>用例图；描述角色以及角色与用例之间的连接关系。说明是谁要使用系统，以及他们使用该系统可以做些什么。一个用例图包含了多个模型元素，如系统、参与者和用例，并且显示了这些元素之间的各种关系，如泛化、关联和依赖。</li><li>类图；类图是描述系统中的类，以及各个类之间的关系的静态视图。能够让我们在正确编写代码以前对系统有一个全面的认识。类图是一种模型类型，确切地说，是一种静态模型类型。类图表示类、接口和它们之间的协作关系。</li><li>对象图；与类图极为相似，它是类图的实例，对象图显示类的多个对象实例，而不是实际的类。它描述的不是类之间的关系，而是对象之间的关系。</li><li>活动图；描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。能够演示出系统中哪些地方存在功能，以及这些功能和系统中其他组件的功能如何共同满足前面使用用例图建模的商务需求。</li><li>状态图；描述类的对象所有可能的状态，以及事件发生时状态的转移条件，可以捕获对象、子系统和系统的生命周期。它可以告知一个对象可以拥有的状态，并且事件(如消息的接收、时间的流逝、错误、条件变为真等)会怎么随着时间的推移来影响这些状态。一个状态图应该连接到所有具有清晰的可标识状态和复杂行为的类;该图可以确定类的行为，以及该行为如何根据当前的状态变化，也可以展示哪些事件将会改变类的对象的状态。状态图是对类图的补充。</li><li>序列图(时序图)；序列图是用来显示参与者如何以一系列顺序的步骤与系统的对象交互的模型。顺序图可以用来展示对象之间是如何进行交互的。顺序图将显示的重点放在消息序列上，即强调消息是如何在对象之间被发送和接收的。</li><li>协作图；和序列图相似，显示对象间的动态合作关系。可以看成是类图和顺序图的交集，协作图建模对象或者角色，以及它们彼此之间是如何通信的。如果强调时间和顺序，则使用序列图;如果强调上下级关系，则选择协作图;这两种图合称为交互图。</li><li>构件图(组件图)；描述代码构件的物理结构以及各种构建之间的依赖关系。用来建模软件的组件及其相互之间的关系，这些图由构件标记符和构件之间的关系构成。在组件图，构件时软件单个组成部分，它可以是一个文件，产品、可执行文件和脚本等。</li><li>部署图(配置图)；用来建模系统的物理部署。例如，计算机和设备，以及它们之间是如何连接的。部署图的使用者是开发人员、系统集成人员和测试人员。部署图用于表示一组物理结点的集合及结点间的相互关系，从而建立了系统物理层面的模型。</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li>继承：带空心三角形的实线表示，student继承person，空心三角形指向person</li><li>实现：带空心三角形的虚线表示，指向接口</li><li>聚合：聚合关系强调是“整体”包含“部分”，但是“部分”可以脱离“整体”而单独存在。比如汽车包含了发动机，而发动机脱离了汽车也能单独存在。<img src="/2021/07/13/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210713142258000.png" alt="image-20210713142258000" style="zoom:67%;"></li><li>组合：组合关系与聚合关系见得最大不同在于：这里的“部分”脱离了“整体”便不复存在。<img src="/2021/07/13/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210713142210958.png" alt="image-20210713142210958" style="zoom:67%;"></li><li>关联：单向关联，双向关联，自关联，用一条带有箭头的实线表示<img src="/2021/07/13/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210713142628986.png" alt="image-20210713142628986" style="zoom:67%;"></li><li>依赖：依赖关系用一条带有箭头的虚线表示。<img src="/2021/07/13/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210713142416879.png" alt="image-20210713142416879" style="zoom:67%;"></li></ul><h2 id="设计模式的作用"><a href="#设计模式的作用" class="headerlink" title="设计模式的作用"></a>设计模式的作用</h2><p>设计模式是一套被反复使用的、多数人知晓、经过分类编目的优秀代码设计经验的总结。<br>特定环境下特定问题的处理方法。<br>1）重用设计和代码：重用设计比重用代码更有意义，自动带来代码重用<br>2）提高扩展性：大量使用面向接口编程，预留扩展插槽，新的功能或特性很容易加入到系统中来<br>3）提高灵活性：通过组合提高灵活性，可允许代码修改平稳发生，对一处修改不会波及到其他模块<br>4） 提高开发效率：正确使用设计模式，可以节省大量的时间</p><h2 id="创建型模式（怎样创建对象）"><a href="#创建型模式（怎样创建对象）" class="headerlink" title="创建型模式（怎样创建对象）"></a>创建型模式（怎样创建对象）</h2><p>特点：将对象的创建与使用分离；这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产</p><ul><li>单例模式（singleton）：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型模式（Prototype）：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法模式（FactoryMethod）:定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂模式（AbstractFactory）:提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者模式（Builder）:将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ul><p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。（通过改变一些对象的组织结构来起到所需的作用，于是统称为结构型模式。就比如说组合模式：这个模式就是把单个对象组合起来，为了实现对象的一致性，所以采用了组合这种结构策略。这就是个对对象结构进行了改变，然后达到了我们所需的目地。）</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><ul><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。代理模式是控制对象访问。代理模式是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；</li><li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。装饰模式的功能实现是由上层调用者决定的。对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。类适配，对象适配，接口适配（接口默认实现类）</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。日志log4j中基于SPI，JDBC中Driver基于Class加载 （会员优惠+商品折扣/订单优惠）</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。黑白棋子，颜色不变，改变location坐标即可。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li></ul><p>以上7种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p><ul><li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。接口推送</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。分单规则</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。灯开关命令，灯对象包含开灯方法和关灯方法，命令具有execute和undo方法，关灯命令类传入灯对象，开灯命令类传入灯对象</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。拦截器Interceptor 拦截器链InterceptorChain   过滤器filter</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。Spring中事件传播机制</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。JDK集合迭代器</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ul><p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ol><li>接口类</li><li>多个具体实现</li><li>factory工厂类，根据条件创建不同实现返回</li><li>客户端，调用工厂类，获取不同实现</li></ol><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">   public abstract Color getColor(String color);</span><br><span class="line">   public abstract Shape getShape(String shape) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂类a，多个工厂实现类b\c，工厂生成类d 由d去生成具体的工厂，客户端类e，使用d生存具体工厂b\c，调用实现类里的方法生成对象</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li>饿汉模式：类加载的时候实例化单例对象，懒加载问题</li><li>懒汉模式：同步方法锁，执行效率问题</li><li>双检测模式：instance = new Singleton()不能保证顺序，先分配空间，之后赋值，最后才生成对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Singleton instance;</span><br><span class="line">public static Singleton newInstance()&#123;</span><br><span class="line">    if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">        sychrinored(Singleton.class)&#123;</span><br><span class="line">            if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">                instance &#x3D; new Singleton();</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态内部类：调用的时候才会加载类，进行实例化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Singleton ()&#123;&#125;</span><br><span class="line">public static Singleton newInstance()&#123;</span><br><span class="line">     SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">private static class SingletonHolder &#123;  </span><br><span class="line">    private static final Singleton INSTANCE &#x3D; new Singleton();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>浅复制：实现Clonable接口，重写clone（）方法，调用父类的clone（）方法 深复制：使用流序列化方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(new Object());</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteArrayInputStream &#x3D; new ByteArrayInputStream(byteArrayOutputStream.toByteArray());</span><br><span class="line">        ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(byteArrayInputStream);</span><br><span class="line">        Object object &#x3D; objectInputStream.readObject();</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>屏蔽对复杂对象的创建，如多属性的配置，用于返回值对象生成</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>类适配，对象适配，接口适配</p><ul><li>类适配:希望将一个类转换成一个满足新接口的类时，使用新类继承旧类，实现接口</li><li>对象适配:希望将一个对象转换成一个满足新接口对象时，新类wrapper持有实现类的实例，实现接口</li><li>接口适配:希望不实现一个接口中所有的方法时，创建一个抽象类，实现所有的方法，继承抽象类</li></ul><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>给对象动态的增加些新的功能，扩展类的功能，强调加强概念。</p><p>装饰类a实现接口并持有接口属性b，装饰类方法中b.method()，当需要加强更多的功能时，可以使用抽象装饰类，多个具体实现类继承抽象类，客户端可用接口实例调用方法</p><p><a href="https://blog.csdn.net/andong154564667/article/details/80258061">装饰模式与代理模式区别</a></p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式强调的是控制权，通过代理类对实际对象进行控制操作</p><p>接口类a，实现类b，代理类c实现接口类a c类中持有实现类b实例属性，通过b的实例属性调用实现类里的方法</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者，只有一个方法，接受通知，执行操作</p><p>被观察者，持有观察者实例，当有变动时通知观察者</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>1、算法/行为接口<br>2、具体实现多个<br>3、context上下文，实例化对象，提供结果方法<br>4、客户端new具体实现类，new context 传入具体实现类，调用方法获取结果</p><ul><li>一般可以和工厂模式一起使用，客户端不用考虑对象实例化</li></ul><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><ol><li>接口类</li><li>抽象类继承接口，默认实现方法</li><li>实现类，实现方法/不实现方法</li><li>客户端调用，未实现方法则调用抽象类的方法，如果实现了方法，则调用实现类的方法</li><li></li></ol><p><a href="http://ifeve.com/spring-interview-questions-and-answers/">http://ifeve.com/spring-interview-questions-and-answers/</a></p><p><a href="https://mp.weixin.qq.com/s/k-PEJNUG7JdHn1AjR8GghQ">Mybatis中9种设计模式</a></p><p><a href="https://mp.weixin.qq.com/s/xpQ6GmuDT25pWzjt5bo9xA">Spring中9种设计模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案之缓存问题</title>
      <link href="2021/07/09/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>2021/07/09/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、缓存处理流程"><a href="#一、缓存处理流程" class="headerlink" title="一、缓存处理流程"></a>一、缓存处理流程</h2><p>前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。</p><p> <img src="/2021/07/09/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/1.png"></p><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截，如token或mac等业务校验；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。当大量不存在key访问时可能撑爆Redis。</li><li>使用布隆过滤器，有一定误判。问题：当key存在时，要删除布隆过滤器里的记录，可以使用带计数器的布隆过滤器</li></ul><h2 id="三、缓存击穿"><a href="#三、缓存击穿" class="headerlink" title="三、缓存击穿"></a>三、缓存击穿</h2><h3 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。<font color="red">引申出热点数据问题，热点发现，将key+标识让key存在多个节点中或者多个存入多个集群中</font></p><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>设置热点数据永远不过期。</li><li>加互斥锁，分布式锁，减少同时查询数据库的压力</li></ul><h2 id="四、缓存雪崩"><a href="#四、缓存雪崩" class="headerlink" title="四、缓存雪崩"></a>四、缓存雪崩</h2><h3 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h3><p>  缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>加锁计数（即限制并发的数量，可以用semphore）或者起一定数量的队列来避免缓存失效时大量请求并发到数据库。但这种方式会降低吞吐量。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li><li>设置热点数据永远不过期。</li></ul><h2 id="热点key"><a href="#热点key" class="headerlink" title="热点key"></a>热点key</h2><p>集群中，key存在某个节点中，当大并发请求时，单台Redis节点，没办法承担这么大的压力，导致Redis宕机。</p><p>解决方案：</p><ul><li>热点发现，可以使用上报的方式，当大量请求访问某个key时，将key（组装成新key）存放集群各个节点或者将key存入各个非集群的节点中</li><li>热点发现，应用内前置缓存</li><li>从节点水平扩容，进行读写分离</li></ul><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>目的就是在系统上线前，将数据加载到缓存中。</p><p>解决思路： </p><ol><li>数据量不大的话，在系统启动的时候直接加载。</li><li>自己写个简单的缓存预热程序。</li></ol><h2 id="大key（value太大）"><a href="#大key（value太大）" class="headerlink" title="大key（value太大）"></a>大key（value太大）</h2><p>当访问缓存时，如果key对应的value过大，读写、加载很容易超时，容易引发网络拥堵。另外缓存的字段较多时，每个字段的变更都会引发缓存数据的变更，频繁的读写，导致慢查询。如果大key过期被缓存淘汰失效，预热数据要花费较多的时间，也会导致慢查询。</p><p>所以我们在设计缓存的时候，要注意<code>缓存的粒度</code>，既不能过大，如果过大很容易导致网络拥堵；也不能过小，如果太小，查询频率会很高，每次请求都要查询多次。</p><p><strong>解决方案：</strong></p><ul><li>方案一：设置一个阈值，当value的长度超过阈值时，对内容启动压缩，降低kv的大小</li><li>方案二：评估<code>大key</code>所占的比例，由于很多框架采用<code>池化技术</code>，如：Memcache，可以预先分配大对象空间。真正业务请求时，直接拿来即用。</li><li>方案三：颗粒划分，将大key拆分为多个小key，独立维护，成本会降低不少</li><li>方案四：大key要设置合理的过期时间，尽量不淘汰那些大key</li></ul><h2 id="缓存数据一致性"><a href="#缓存数据一致性" class="headerlink" title="缓存数据一致性"></a>缓存数据一致性</h2><p>缓存是用来加速的，一般不会持久化储存。所以，一份数据通常会存在<code>DB</code>和<code>缓存</code>中，由此会带来一个问题，如何保证这两者的数据一致性。另外，缓存热点问题会引入多个副本备份，也可能会发生不一致现象。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdmOC0H6kaQlnh3rvWF2hPp1KtrV6wKkUEZxHHicAfQWyXGY1MkNw1NuTiczeqWOEAaxk0f9L48dC4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>解决方案：</strong></p><ul><li>方案一：当缓存更新失败后，进行重试，如果重试失败，将失败的key写入MQ消息队列，通过异步任务补偿缓存，保证数据的一致性。这也是有问题，没法保证数据一定发送到了MQ，改成对账是否会好点？？？</li><li>方案二：设置一个较短的过期时间，通过自修复的方式，在缓存过期后，缓存重新加载最新的数据。 要求对一致性要求不高的情况</li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案之分布式事务</title>
      <link href="2021/07/08/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/07/08/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6867040340797292558">RocketMQ和Kafka事务机制</a></p><p>RocketMQ 解决的是本地事务的执行和发消息这两个动作满足事务的约束。</p><p><img src="/2021/07/08/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjAzNDI3OS04ODBmOThkMzNkMjNiYWIxLnBuZw"></p><p>Kafka 事务消息则是用在一次事务中需要发送多个消息的情况，保证多个消息之间的事务约束，即多条消息要么都发送成功，要么都发送失败</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之垃圾回收器</title>
      <link href="2021/07/07/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>2021/07/07/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Jvm垃圾回收器（终结篇）"><a href="#Jvm垃圾回收器（终结篇）" class="headerlink" title="Jvm垃圾回收器（终结篇）"></a><a href="https://www.cnblogs.com/chenpt/p/9803298.html">Jvm垃圾回收器（终结篇）</a></h2><h2 id="JVM运行原理及优化"><a href="#JVM运行原理及优化" class="headerlink" title="JVM运行原理及优化"></a><a href="https://blog.csdn.net/qq_17164811/article/details/107141112">JVM运行原理及优化</a></h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件之RabbitMQ集群</title>
      <link href="2021/07/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E9%9B%86%E7%BE%A4/"/>
      <url>2021/07/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_40816738/article/details/105704335">集群知识</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM之垃圾回收器三色标记</title>
      <link href="2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/"/>
      <url>2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> JVM 中的垃圾回收是基于 标记-复制、标记-清除和标记-整理三种模式的，那么其中最重要的其实是如何标记，像Serial、Parallel这类的回收器，无论是单线程标记和多线程标记，其本质采用的是暂停用户线程进行全面标记的算法，这种算法的好处就是标记的很干净，而且实现简单，缺点就是标记时间相对很长，导致STW的时间很长。</p><p>那么后来就有了并发标记，适用于CMS和G1，并发标记的意思就是可以在不暂停用户线程的情况下对其进行标记，那么实现这种并发标记的算法就是三色标记法，三色标记法最大的特点就是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断来进行整个GC。</p><h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>要找出存活对象，根据可达性分析，从GC Roots开始进行遍历访问，可达的则为存活对象：如下图，最终结果：A/D/E/F/G 可达</p><img src="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83Nzc5NjA3LTkwZmI1NmQxYjM2MmEwNzQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTA5" style="zoom:80%;">我们把遍历对象图**过程**中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：<ul><li><strong>白色</strong>：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。</li><li><strong>黑色</strong>：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了。</li><li><strong>灰色</strong>：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态。</li></ul><p><img src="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/20200730105400197.gif" alt="img"></p><h3 id="标记过程"><a href="#标记过程" class="headerlink" title="标记过程"></a>标记过程</h3><ol><li>在GC并发标记刚开始时，所以对象均为白色集合。</li><li>将所有GCRoots直接引用的对象标记为灰色集合。</li><li>判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将其所有的子引用对象放入灰色集合，当前对象放入黑色集合</li><li>按照步骤三，以此类推，直至灰色集合中的所有对象变成黑色后，本轮标记完成，且当前白色集合内的对象称为不可达对象，既垃圾对象。</li></ol><h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>由于此过程是在和用户线程并发运行的情况下，对象的引用处于随时可变的情况下，那么就会造成多标和漏标的问题。多标可以理解为浮动垃圾，只是导致部分对象不会被清除，占用内存空间。漏标的问题需要解决，漏标导致对象被清除，导致程序异常。</p><h3 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h3><p><strong>本应该被标记为白色的对象，没有被标记，造成该对象可能不会被回收</strong></p><ul><li>比如E对象在GC扫描D对象时,E还正在被D引用，那么此时E就被标记为灰色，此时业务逻辑的变化，D指向E的引用被置空了，这时候E以及后续子引用本应该被当成垃圾回收，但是此时E已经被标记为灰色，导致E对象以及其子对象没有被及时清理掉，变成了浮动垃圾，</li><li>还有在并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</li></ul><h3 id="漏标"><a href="#漏标" class="headerlink" title="漏标"></a>漏标</h3><p><strong>灰色对象指向白色对象的引用消失了，然后一个黑色的对象重新引用了白色对象。</strong></p><p>D对象引用E对象，E引用G，此时GC正好处于D已经变成黑色，E处于灰色，G是白色的情况下，此时因为业务逻辑的变化，E不引用G了，D对象引用了G，按照三色标记法看，黑色对象是已完成状态，不可能再去找子引用，所以G就不会变成灰色，这样就会造成白色对象此时正在被线程使用中，但是无法被标记成灰色或者白色，造成一个正在被使用的对象被错误回收。</p><img src="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/20200730143812205.png" style="zoom: 50%;"><img src="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/20200730144111702.png">漏标只有**同时满足**以下两个条件时才会发生：**条件一：灰色对象 断开了 白色对象的引用；即灰色对象 原来成员变量的引用 发生了变化。条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。**<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>CMS：Incremental Update算法（增量更新）</p><p>当一个白色对象被一个黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。（破坏条件二）</p><p>G1：SATB（Snapshot At The Beginning）算法（原始快照）</p><p>当原来成员变量的引用发生变化之前，记录下原来的引用对象，既原始快照，当B和C之间的引用马上被断掉时，将这个引用记录下来，使GC依旧能够访问到，那样白色就不会漏标。在并发扫描结束之后，再将这些记录过得引用关系中的灰色对象为根，重新扫描一次。总而言之就是：无论引用关系删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。（破坏条件一）</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>SATB 算法是关注引用的删除。（B-&gt;C 的引用）</li><li>Incremental Update 算法关注引用的增加。（A-&gt;C 的引用）</li><li>G1 如果使用Incremental Update 算法，因为变成灰色的成员还要重新扫，重新再来一遍，效率太低了。所以G1 在处理并发标记的过程比CMS 效率要高，这个主要是解决漏标的算法决定的。</li></ul><h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a><a href="https://blog.csdn.net/u010800201/article/details/107684597">三色标记</a></h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案之秒杀</title>
      <link href="2021/06/22/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E7%A7%92%E6%9D%80/"/>
      <url>2021/06/22/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E7%A7%92%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.csdn.net/qianshangding0708">qianshanding0708</a></p><p>出处：<a href="https://blog.csdn.net/qianshangding0708/article/details/95135402?spm=1001.2014.3001.5501">秒杀架构设计</a></p><h2 id="业务特点"><a href="#业务特点" class="headerlink" title="业务特点"></a>业务特点</h2><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEKSxScibv6T9bianNvT5pHicgKDBULz7GEe3ibED0eGKRCLefsTq6UmPpIw/640?wx_fmt=png" alt="640?wx_fmt=png" style="zoom:67%;"><h3 id="瞬时并发量大"><a href="#瞬时并发量大" class="headerlink" title="瞬时并发量大"></a>瞬时并发量大</h3><p>秒杀时会有大量用户在同一时间进行抢购，瞬时并发访问量突增 10 倍，甚至 100 倍以上都有。</p><h3 id="库存量少"><a href="#库存量少" class="headerlink" title="库存量少"></a>库存量少</h3><p>一般秒杀活动商品量很少，这就导致了只有极少量用户能成功购买到。</p><h3 id="业务简单"><a href="#业务简单" class="headerlink" title="业务简单"></a>业务简单</h3><p>流程比较简单，一般都是下订单、扣库存、支付订单</p><h2 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h2><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEvy0e2h8XA8EQgw7NcDKlAymwjXkyEhepTyYZyiciagTkRf0UgYuWPtEw/640?wx_fmt=png" alt="640?wx_fmt=png" style="zoom:50%;"><h3 id="现有业务的冲击"><a href="#现有业务的冲击" class="headerlink" title="现有业务的冲击"></a>现有业务的冲击</h3><p>秒杀是营销活动中的一种，如果和其他营销活动应用部署在同一服务器上，肯定会对现有其他活动造成冲击，极端情况下可能导致整个电商系统服务宕机</p><h3 id="直接下订单"><a href="#直接下订单" class="headerlink" title="直接下订单"></a>直接下订单</h3><p>下单页面是一个正常的 URL 地址，需要控制在秒杀开始前，不能下订单，只能浏览对应活动商品的信息。简单来说，需要 Disable 订单按钮</p><h3 id="页面流量突增"><a href="#页面流量突增" class="headerlink" title="页面流量突增"></a>页面流量突增</h3><p>秒杀活动开始前后，会有很多用户请求对应商品页面，会造成后台服务器的流量突增，同时对应的网络带宽增加，需要控制商品页面的流量不会对后台服务器、DB、Redis 等组件的造成过大的压力</p><h2 id="架构设计思想"><a href="#架构设计思想" class="headerlink" title="架构设计思想"></a>架构设计思想</h2><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEdUNMCLQrhkpIRBuA5PTPPkRHK8lOP7XSaSlA4pBiabu2QVEicZtZELxg/640?wx_fmt=png" alt="640?wx_fmt=png" style="zoom:50%;"><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>由于活动库存量一般都是很少，对应的只有少部分用户才能秒杀成功。所以我们需要限制大部分用户流量，只准少量用户流量进入后端服务器</p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>秒杀开始的那一瞬间，会有大量用户冲击进来，所以在开始时候会有一个瞬间流量峰值。如何把瞬间的流量峰值变得更平缓，是能否成功设计好秒杀系统的关键因素。实现流量削峰填谷，一般的采用缓存和 MQ 中间件来解决</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>秒杀其实可以当做高并发系统来处理，在这个时候，可以考虑从业务上做兼容，将同步的业务，设计成异步处理的任务，提高网站的整体可用性</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>秒杀系统的瓶颈主要体现在下订单、扣减库存流程中。在这些流程中主要用到 OLTP 的数据库，类似 MySQL、SQLServer、Oracle。由于数据库底层采用 B+ 树的储存结构，对应我们随机写入与读取的效率，相对较低。如果我们把部分业务逻辑迁移到内存的缓存或者 Redis 中，会极大的提高并发效率</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEGpnGxb5tSJic2cLzOMhUu7840yBRMC9DO3C3NOC1vBibDkvqUF4Mzwog/640?wx_fmt=png" alt="img" style="zoom:67%;"><h3 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h3><p>客户端优化主要有两个问题</p><h4 id="秒杀页面"><a href="#秒杀页面" class="headerlink" title="秒杀页面"></a>秒杀页面</h4><p>秒杀活动开始前，其实就有很多用户访问该页面了。如果这个页面的一些资源，比如 CSS、JS、图片、商品详情等，都访问后端服务器，甚至 DB 的话，服务肯定会出现不可用的情况。所以一般我们会把这个页面整体进行静态化，并将页面静态化之后的页面分发到 CDN 边缘节点上，起到压力分散的作用</p><h4 id="防止提前下单"><a href="#防止提前下单" class="headerlink" title="防止提前下单"></a>防止提前下单</h4><p>防止提前下单主要是在静态化页面中加入一个 JS 文件引用，该 JS 文件包含活动是否开始的标记以及开始时的动态下单页面的 URL 参数。同时，这个 JS 文件是不会被 CDN 系统缓存的，会一直请求后端服务的，所以这个 JS 文件一定要很小。当活动快开始的时候（比如提前），通过后台接口修改这个 JS 文件使之生效</p><h3 id="API-接入层优化"><a href="#API-接入层优化" class="headerlink" title="API 接入层优化"></a>API 接入层优化</h3><p>客户端优化，对于不是搞计算机方面的用户还是可以防止住的。但是稍有一定网络基础的用户就起不到作用了，因此服务端也需要加些对应控制，不能信任客户端的任何操作。一般控制分为 2 大类</p><h4 id="限制用户维度访问频率"><a href="#限制用户维度访问频率" class="headerlink" title="限制用户维度访问频率"></a>限制用户维度访问频率</h4><p>针对同一个用户（ Userid 维度），做页面级别缓存，单元时间内的请求，统一走缓存，返回同一个页面</p><h4 id="限制商品维度访问频率"><a href="#限制商品维度访问频率" class="headerlink" title="限制商品维度访问频率"></a>限制商品维度访问频率</h4><p>大量请求同时间段查询同一个商品时，可以做页面级别缓存，不管下回是谁来访问，只要是这个页面就直接返回</p><h3 id="SOA-服务层优化"><a href="#SOA-服务层优化" class="headerlink" title="SOA 服务层优化"></a>SOA 服务层优化</h3><p>上面两层只能限制异常用户访问，如果秒杀活动运营的比较好，很多用户都参加了，就会造成系统压力过大甚至宕机，因此需要后端流量控制</p><p>对于后端系统的控制可以通过消息队列、异步处理、提高并发等方式解决。对于超过系统水位线的请求，直接采取 「Fail-Fast」原则，拒绝掉</p><h2 id="秒杀整体流程图"><a href="#秒杀整体流程图" class="headerlink" title="秒杀整体流程图"></a>秒杀整体流程图</h2><p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEVCxOtzmOCmxhmRiaGOxcF3aA0vwPzgVqYJVqJ7X4oHiczIK4ibTicclGicQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p>秒杀系统核心在于层层过滤，逐渐递减瞬时访问压力，减少最终对数据库的冲击。通过上面流程图就会发现压力最大的地方在哪里？</p><p>MQ 排队服务，只要 MQ 排队服务顶住，后面下订单与扣减库存的压力都是自己能控制的，根据数据库的压力，可以定制化创建订单消费者的数量，避免出现消费者数据量过多，导致数据库压力过大或者直接宕机。</p><p>库存服务专门为秒杀的商品提供库存管理，实现提前锁定库存，避免超卖的现象。同时，通过超时处理任务发现已抢到商品，但未付款的订单，并在规定付款时间后，处理这些订单，将恢复订单商品对应的库存量</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>核心思想：层层过滤</p><ul><li>尽量将请求拦截在上游，降低下游的压力</li><li>充分利用缓存与消息队列，提高请求处理速度以及削峰填谷的作用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件之Kafka实战</title>
      <link href="2021/06/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E5%AE%9E%E6%88%98/"/>
      <url>2021/06/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka如何保证消息的顺序性"><a href="#Kafka如何保证消息的顺序性" class="headerlink" title="Kafka如何保证消息的顺序性"></a>Kafka如何保证消息的顺序性</h2><p><strong>生产端</strong></p><ul><li>生产者发送消息时可以指定Key，如订单号，客户端会对Key进行hash计算，将hash值相同的数据发送到同一个partition中</li><li>生产者发送消息时可以指定partition</li><li>生产者发送消息时可以自定义路由</li></ul><p><strong>消费端</strong></p><ul><li>消费端可以启动对应partition数量的消费端，保证一个消费者只消费一个partition中的数据 </li><li>提升单线程消费性能，消费者可以将批量获取的数据根据Hash算法，存放到多个内存队列中，自动提交改为手动提交，保证多线程下消息顺序性<img src="/2021/06/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E5%AE%9E%E6%88%98/顺序.png" alt="img" style="zoom:67%;"></li></ul><h2 id="Kafka-交付语义–机制详解"><a href="#Kafka-交付语义–机制详解" class="headerlink" title="Kafka-交付语义–机制详解"></a><a href="https://zhuanlan.zhihu.com/p/74212257?from_voters_page=true">Kafka-交付语义–机制详解</a></h2><h2 id="Kafka消息丢失（自带生产端重试）"><a href="#Kafka消息丢失（自带生产端重试）" class="headerlink" title="Kafka消息丢失（自带生产端重试）"></a>Kafka消息丢失（自带生产端重试）</h2><p>重试机制：KafkaProducer通过设定参数<code>retries</code>，如果发送消息到broker时抛出异常，且是允许重试的异常，那么就会最大重试retries参数指定的次数。</p><h3 id="哪些异常可以重试"><a href="#哪些异常可以重试" class="headerlink" title="哪些异常可以重试"></a>哪些异常可以重试</h3><ol><li>重试次数少于参数<code>retries</code>指定的值；</li><li>异常是<strong>RetriableException</strong>类型或者TransactionManager允许重试；</li></ol><h3 id="如何实现重试"><a href="#如何实现重试" class="headerlink" title="如何实现重试"></a>如何实现重试</h3><ol><li>new KafkaProducer()后创建一个后台线程KafkaThread扫描RecordAccumulator中是否有消息；</li><li>调用KafkaProducer.send()发送消息，实际上只是把消息保存到RecordAccumulator中；</li><li>后台线程KafkaThread扫描到RecordAccumulator中有消息后，将消息发送到kafka集群；</li><li>如果发送成功，那么返回成功；</li><li>如果发送失败，那么判断是否允许重试。如果不允许重试，那么返回失败的结果；如果允许重试，把消息再保存到RecordAccumulator中，等待后台线程KafkaThread扫描再次发送；</li></ol><p>RecordAccumulator是保存需要发送的消息或者重试消息的核心。发送消息之前先把消息存放在这里，异步线程KafkaThread启动后从这里取消息然后发送到broker。当发送出错且允许重试时，又会把这些需要重试的消息保存到这里再进行重试。当发送出错且允许重试时，会调用reenqueue()方法将消息暂时存放。保存需要发送的（重试）消息的核心数据结构是Deque。且创建队列时是<code>new ArrayDeque()</code>，没有指定初始容量。</p><h2 id="Kafka消费端重试机制（自己实现）"><a href="#Kafka消费端重试机制（自己实现）" class="headerlink" title="Kafka消费端重试机制（自己实现）"></a>Kafka消费端重试机制（自己实现）</h2><p><img src="/2021/06/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E5%AE%9E%E6%88%98/image-20210719105825408.png" alt="image-20210719105825408"></p><h2 id="kafka发送消息的三种方式"><a href="#kafka发送消息的三种方式" class="headerlink" title="kafka发送消息的三种方式"></a><a href="https://blog.csdn.net/u010442302/article/details/106456474?utm_term=kafka%E4%BD%BF%E7%94%A8callback&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-2-106456474&spm=3001.4430">kafka发送消息的三种方式</a></h2>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计之DDD设计</title>
      <link href="2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8BDDD%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8BDDD%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qianshangding0708/article/details/102952620?spm=1001.2014.3001.5501">架构设计实践五部曲（三）：从领域模型提取数据架构</a></p><p>风控系统为例，文章中采用四色原型法进行业务模型的抽象。</p><p>四色模型</p><ul><li>Moment-Interval Archetype 时标性原型</li></ul><p>表示事物在某个时刻或某一段时间内发生的。使用红色表示，简写为 MI.</p><ul><li>Part-Place-Thing Archetype 参与方 - 地点 - 物品原型.</li></ul><p>表示参与扮演不同角色的人或事物。使用绿色表示。简写为 PPT。</p><ul><li>Role Archetype 角色原型</li></ul><p>角色是一种参与方式，它由人或组织机构、地点或物品来承担。使用黄色表示。简写为 Role。</p><ul><li>Description Archetype 描述原型</li></ul><p>表示资料类型的资源，它可以被其它原型反复使用，并为其它原型提供行为。使用蓝色表示。简写为 DESC。</p><h2 id="领域驱动设计DDD和CQRS落地"><a href="#领域驱动设计DDD和CQRS落地" class="headerlink" title="领域驱动设计DDD和CQRS落地"></a><a href="http://deepoove.com/blog/#/posts/69">领域驱动设计DDD和CQRS落地</a></h2><h2 id="对应的源码"><a href="#对应的源码" class="headerlink" title="对应的源码"></a><a href="https://github.com/luckyfeing/ddd-cargo">对应的源码</a></h2><h2 id="DDD领域驱动设计基本理论知识总结"><a href="#DDD领域驱动设计基本理论知识总结" class="headerlink" title="DDD领域驱动设计基本理论知识总结"></a><a href="https://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html">DDD领域驱动设计基本理论知识总结</a></h2><h2 id="Spring-Boot实现DDD的货运Cargo微服务案例源码"><a href="#Spring-Boot实现DDD的货运Cargo微服务案例源码" class="headerlink" title="Spring Boot实现DDD的货运Cargo微服务案例源码"></a><a href="https://github.com/practicalddd/implementations/tree/master/springboot/sb%2Brabbit%2Bmysql">Spring Boot实现DDD的货运Cargo微服务案例源码</a></h2><h3 id="DDD-cargo事例"><a href="#DDD-cargo事例" class="headerlink" title="DDD cargo事例"></a><a href="https://www.iteye.com/blog/mistbow-1394856">DDD cargo事例</a></h3>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 架构设计 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计之架构设计</title>
      <link href="2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qianshangding0708/article/details/102889690?spm=1001.2014.3001.5501">架构设计实践五部曲（一）：架构与架构图</a></p><p><a href="https://blog.csdn.net/qianshangding0708/article/details/102927609?spm=1001.2014.3001.5501">架构设计实践五部曲（二）：业务架构与产品架构设计实践</a></p><p><a href="https://blog.csdn.net/qianshangding0708/article/details/102952620?spm=1001.2014.3001.5501">架构设计实践五部曲（三）：从领域模型提取数据架构</a></p><p><a href="https://blog.csdn.net/qianshangding0708/article/details/102952622?spm=1001.2014.3001.5501">架构设计实践五部曲（四）：单体式与分布式的应用架构</a></p><p><a href="https://blog.csdn.net/qianshangding0708/article/details/102982579?spm=1001.2014.3001.5501">架构设计实践五部曲（五）：技术架构的战略和战术原则</a></p><p><a href="https://segmentfault.com/a/1190000023053758">分布式单体起因及解决</a></p><p><a href="https://jsldl.blog.csdn.net/article/details/103046573?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.nonecase">中台和微服务区别</a></p><p><a href="https://blog.csdn.net/qianshangding0708/article/details/102813594?spm=1001.2014.3001.5501">没有中台，但有微服务和 PaaS，一样吗？</a></p><p>微服务架构通常采用前后端分离方式，按照一定的规则拆分为多个可以独立运行、独立开发、独立部署、独立运维的微服务或者页面聚合，从而满足业务快速变化及分布式多团队并行开发的需求，还可实现前端页面的复用，做到“一次开发，多端复用”，这也与中台服务的共享理念非常类似。所以，很多企业在进行中台实践时会将两者混淆。</p><p>从使用者的角度来看，大部分的微服务架构都是在支撑一个前台，而中台解决的是企业级能力复用，而这种能力复用一定是多前台、跨部门的。当然，微服务中也会提到复用问题，但这种复用一般指的是组件级别的复用，并未达到企业级的层面。一般而言，一个业务中台会同时抽调多个前台业务中可共享的能力，最终统一支持多个前台业务。</p><p>简单讲就是：中台不一定非得采用微服务架构，能够达到多前台能力复用的目标即可；而微服务架构也不一定要同时支持多前台应用，单应用的微服务化其实更多见。</p><p><a href="https://blog.csdn.net/qianshangding0708/article/details/100017275?spm=1001.2014.3001.5501">我的一年中台实战录</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247521183&idx=1&sn=ad72b0e253fb2bc4281b2a09e44cc27b&chksm=fa4aec2ecd3d6538b51e869bad42d05b663e7237bef6347f8c0dbf4518807669c70c67166648&mpshare=1&scene=24&srcid=07136qesxhWYbCLJZCg7kJtB&sharer_sharetime=1626171770894&sharer_shareid=29c86683e1453c750f38cb077074e5d6#rd">分布式单体</a></p><p><font color="red">架构是面向业务功能、成本、实现难度、时间等因素的取舍，而不是绝对地追求高性能、高并发及高可用等非功能性指标。</font></p><h2 id="平台化和个性化"><a href="#平台化和个性化" class="headerlink" title="平台化和个性化"></a>平台化和个性化</h2><p>平台化要求我们做到通用性，能够适用于不同的业务场景，减少开发和部署的时间，降低实施成本；个性化却要求我们做到灵活性，能够满足不同业务的需求，并可以进行快速迭代，通过差异化构建竞争壁垒！</p><h2 id="前台和中台"><a href="#前台和中台" class="headerlink" title="前台和中台"></a>前台和中台</h2><p>“中台+前台”模式的最难之处在于如何进行“中台”和“前台”解耦：到底是采用“薄（小）中台、厚（大）前台”模式，还是倒过来采用“厚（大）中台、薄（小）前台”的模式，是许多平台化企业都面临的两难抉择。</p><p><strong>回归本质，一切应以业务出发！</strong></p><p>对于模式尚未成型，客户价值尚未清晰，需要快速迭代的业务，应采用“薄中台、厚前台”的模式，给予前台足够的机动性和灵活度，流程和系统紧贴业务快速奔跑。</p><p>相反，对于模式较为确定，客户价值相对清晰，发展趋势较为明确的业务，则应采用“厚中台、薄前台”的模式，提高系统的规范化、流程化的能力，通过效率的提升来逐步降低成本，但同时依然为前台的灵活操作留有一定的空间。</p><p>当然，从前者到后者往往是个渐变的过程，没有办法一刀切。这就需要中台的架构师具有超强的服务意识，能够时刻掌握业务的发展状况、业务的迭代方向，并在这个过程中将前台所采用的“土办法”进行总结、将通用性的能力逐步在中台进行沉淀。逐步形成中央化、模块化、标准化的“武器库”，再通过不同的组合和配置为前台作战小组随时提供其所需的、能够因地制宜的“炮火支援”。</p><p>一把钥匙虽然打不开天下所有的锁，但“中台+前台”的模式就如同为我们提供了一个能够在现场快速“配钥匙”的工具+远程的在线指导。那么哪怕遇上再难打开的锁，再难完成的任务，我们也能信心满满地就地解决了！</p><h2 id="平台和中台"><a href="#平台和中台" class="headerlink" title="平台和中台"></a>平台和中台</h2><p>中台不是凭空而来，亦不是平台化架构换个名字。中台化架构是平台化架构的自然演进。一定规模的互联网IT公司都可能有一个叫共享平台或者平台技术这样的部门，就是把业务基础设施和技术基础设施下沉，然后由对应的研发和产品部门去负责。但久而久之，共享平台就成了资源中心，前端业务找你就是要人干活，平台做的也是接客干活。如前文所述，各平台接客模式协同负责度高，周期长。一个商业系统不仅仅是组织几个component，而是需要解决方案。中台提供的能力可以是service、可以是由service组合的组合能力、亦可以是解决方案(solution)的直接输出。</p><h3 id="中台是平台的自然演进"><a href="#中台是平台的自然演进" class="headerlink" title="中台是平台的自然演进"></a><strong>中台是平台的自然演进</strong></h3><p>前面提到平台化目标是高内聚、低耦合；职责边界清晰；易于集成等。那么中台化架构进一步可总结为：高内聚、低耦合；数据完整性原则；业务可运营原则。当然，从架构方法来讲，宜采用渐进式架构的演进原则。如果一个中台把若干平台聚拢起来，对业务支持的SLA没有变化、也没有在业务运营上有所改变，一定是失败的。</p><img src="/2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20210720181432244.png" alt="image-20210720181432244" style="zoom:67%;">以上图为例，业务在发展过程中，会有若干业务系统。平台化的架构是按项目模式，把公共平台和业务系统的架构师，开发，测试，产品搞在一起协同、排期、研发、上线。中台化架构可以在进一步把平台能力按能力、服务、实体进行管理。把平台划分为系统运行、业务运营2部分。实现80% 甚至更多的业务需求由业务团队自助进入。这反映到前端业务上支持效能提升了，中台的代码基本不用研发，沟通成本也急剧下降。其2，中台的架构师和研发队伍可以把精力放到中台能力提升，从运营视角发掘类似业务全息查询、数据产品这样的创新。<h2 id="平台、中台与康威定律-传统企业IT架构转型的辛酸史"><a href="#平台、中台与康威定律-传统企业IT架构转型的辛酸史" class="headerlink" title="平台、中台与康威定律 - 传统企业IT架构转型的辛酸史"></a><a href="https://www.jianshu.com/p/29b5222f23bb">平台、中台与康威定律 - 传统企业IT架构转型的辛酸史</a></h2><h2 id="架构设计-如何做电商业务中台"><a href="#架构设计-如何做电商业务中台" class="headerlink" title="架构设计-如何做电商业务中台"></a><a href="https://www.cnblogs.com/xuwc/p/14100516.html">架构设计-如何做电商业务中台</a></h2><h2 id="架构设计-从中台到平台"><a href="#架构设计-从中台到平台" class="headerlink" title="架构设计-从中台到平台"></a><a href="https://www.cnblogs.com/xuwc/p/14100442.html">架构设计-从中台到平台</a></h2><h2 id="一文了解前台、中台、后台的职责与关联"><a href="#一文了解前台、中台、后台的职责与关联" class="headerlink" title="一文了解前台、中台、后台的职责与关联 "></a><a href="https://www.sohu.com/a/434689774_617676?sec=wd">一文了解前台、中台、后台的职责与关联 </a></h2>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之nacos高可用</title>
      <link href="2021/06/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>2021/06/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1802966?from=information.detail.nacos%E9%AB%98%E5%8F%AF%E7%94%A8">Nacos 服务模型</a></p><p><a href="https://cloud.tencent.com/developer/article/1768701?from=information.detail.nacos%E9%AB%98%E5%8F%AF%E7%94%A8">Nacos服务注册高可用</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NzEyODIyOA==&mid=2247485760&idx=1&sn=37a08f5a5d4c8f6182cfce127c0f0921&chksm=e9b5808bdec2099de368de44db5c0e2752c41ed7c8fa8009e3bb1052ecc8c35aa1081550d3b8&scene=21#wechat_redirect">Nacos2.0与1.0比较</a></p><p><a href="https://cloud.tencent.com/developer/article/1810137?from=information.detail.nacos%E9%AB%98%E5%8F%AF%E7%94%A8">Nacos 2.0性能优化</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案之二级缓存</title>
      <link href="2021/06/17/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>2021/06/17/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="有赞实现多级缓存的架构设计方案"><a href="#有赞实现多级缓存的架构设计方案" class="headerlink" title="有赞实现多级缓存的架构设计方案"></a><a href="https://mp.weixin.qq.com/s/uWInyKQYkASVKPN8lblkPQ">有赞实现多级缓存的架构设计方案</a></h2><h2 id="什么是二级缓存"><a href="#什么是二级缓存" class="headerlink" title="什么是二级缓存"></a>什么是二级缓存</h2><p>redis cluster提供分布式缓存服务，可以在应用中也缓存一份数据，提供性能。但是可能有数据一致性问题。</p><h2 id="为什么要做二级缓存"><a href="#为什么要做二级缓存" class="headerlink" title="为什么要做二级缓存"></a>为什么要做二级缓存</h2><p>当有热点key或使用次数过多且变动少的数据时，可以将数据缓存在应用中，减少请求到redis中，冲击分布式缓存系统，大量占据内网带宽，最终影响应用层系统稳定性；</p><ul><li>实现思路：<font color="red">有赞TMC，Caffeine(通过Redis 发布订阅做数据同步)</font></li></ul><h2 id="多级缓存解决方案的痛点"><a href="#多级缓存解决方案的痛点" class="headerlink" title="多级缓存解决方案的痛点"></a>多级缓存解决方案的痛点</h2><ul><li>热点探测：如何快速且准确的发现 <strong>热点访问 key</strong> ？</li><li>数据一致性：前置在应用层的本地缓存，如何保障与分布式缓存系统的数据一致性？</li><li>效果验证：如何让应用层查看本地缓存命中率、热点 key 等数据，验证多级缓存效果？</li><li>透明接入：整体解决方案如何减少对应用系统的入侵，做到快速平滑接入？</li></ul><h2 id="有赞二级缓存TMC实现"><a href="#有赞二级缓存TMC实现" class="headerlink" title="有赞二级缓存TMC实现"></a>有赞二级缓存TMC实现</h2><p>TMC，即“透明多级缓存（Transparent Multilevel Cache）”，应用提供的整体缓存解决方案。</p><ul><li>应用层热点探测</li><li>应用层本地缓存</li><li>应用层缓存命中统计</li></ul><p>以帮助应用层解决缓存使用过程中出现的热点访问问题。</p><p>Sass平台，商家会不定期做一些“商品秒杀”、“商品推广”活动，导致“营销活动”、“商品详情”、“交易下单”等链路应用出现<strong>缓存热点访问</strong>的情况：</p><ul><li>活动时间、活动类型、活动商品之类的信息不可预期，导致 缓存热点访问 情况不可提前预知；</li><li>缓存热点访问 出现期间，应用层少数 <strong>热点访问 key</strong> 产生大量缓存访问请求：冲击分布式缓存系统，大量占据内网带宽，最终影响应用层系统稳定性；</li></ul><p>为了应对以上问题，需要一个能够 自动发现热点 并 将热点缓存访问请求前置在应用层本地缓存的解决方案，这就是 TMC 产生的原因。</p><p><font color="red">热点数据发现，将热点数据缓存到本地，实现二级缓存</font></p><h2 id="TMC-整体架构"><a href="#TMC-整体架构" class="headerlink" title="TMC 整体架构"></a>TMC 整体架构</h2><img src="/2021/06/17/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/640" alt="图片" style="zoom:67%;">TMC 整体架构如上图，共分为三层：<ul><li>存储层：提供基础的 kv 数据存储能力，针对不同的业务场景选用不同的存储服务（codis/zankv/aerospike）；</li><li>代理层：为应用层提供统一的缓存使用入口及通信协议，承担分布式数据水平切分后的路由功能转发工作；</li><li>应用层：提供统一客户端给应用服务使用，内置“热点探测”、“本地缓存”等功能，对业务透明；</li></ul><p>本篇聚焦在应用层客户端的“热点探测”、“本地缓存”功能。</p><h2 id="TMC-本地缓存"><a href="#TMC-本地缓存" class="headerlink" title="TMC 本地缓存"></a>TMC 本地缓存</h2><h3 id="如何透明"><a href="#如何透明" class="headerlink" title="如何透明"></a>如何透明</h3><p>TMC 是如何减少对业务应用系统的入侵，做到透明接入的？对于公司 Java 应用服务，在缓存客户端使用方式上分为两类：</p><ul><li>基于 <code>spring.data.redis</code>包，使用 <code>RedisTemplate</code>编写业务代码；</li><li>基于 <code>youzan.framework.redis</code>包，使用 <code>RedisClient</code>编写业务代码；</li></ul><p>不论使用以上那种方式，最终通过 <code>JedisPool</code>创建的 <code>Jedis</code>对象与缓存服务端代理层做请求交互。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5ia9kIeBOeacxAL8g8PV9NS1ujWkgXa6XiazPtAJl84GkrUPN9SCu73tfQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>TMC 对原生 jedis 包的 <code>JedisPool</code>和 <code>Jedis</code>类做了改造，在 JedisPool 初始化过程中集成 TMC“热点发现”+“本地缓存”功能 <code>Hermes-SDK</code>包的初始化逻辑</p><p>使 <code>Jedis</code>客户端与缓存服务端代理层交互时先与 <code>Hermes-SDK</code>交互，从而完成 “热点探测”+“本地缓存”功能的透明接入。</p><p>对于 Java 应用服务，只需使用特定版本的 jedis-jar 包，无需修改代码，即可接入 TMC 使用“热点发现”+“本地缓存”功能，做到了对应用系统的最小入侵。</p><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaccMcwZB3NGaia669PGFbVtUNS9gAgZ3WRwMeADBiaNAI8AF19479UJBQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><p>TMC 本地缓存整体结构分为如下模块：</p><ul><li><strong>Jedis-Client</strong>：Java 应用与缓存服务端交互的直接入口，接口定义与原生 Jedis-Client 无异；</li><li><strong>Hermes-SDK</strong>：自研“热点发现+本地缓存”功能的 SDK 封装，Jedis-Client 通过与它交互来集成相应能力；</li><li><strong>Hermes 服务端集群</strong>：接收 Hermes-SDK 上报的缓存访问数据，进行热点探测，将热点 key 推送给 Hermes-SDK 做本地缓存；</li><li><strong>缓存集群</strong>：由代理层和存储层组成，为应用客户端提供统一的分布式缓存服务入口；</li><li><strong>基础组件</strong>：etcd 集群、Apollo 配置中心，为 TMC 提供“集群推送”和“统一配置”能力；</li></ul><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>1）key 值获取</p><ul><li>Java 应用调用 <strong>Jedis-Client</strong> 接口获取 key 的缓存值时，<strong>Jedis-Client</strong> 会询问 <strong>Hermes-SDK</strong> 该 key 当前是否是 <strong>热点key</strong>；</li><li>对于 <strong>热点key</strong> ，直接从 <strong>Hermes-SDK</strong> 的 热点模块 获取热点 key 在本地缓存的 value 值，不去访问 <strong>缓存集群</strong> ，从而将访问请求前置在应用层；</li><li>对于非 <strong>热点key</strong> ，<strong>Hermes-SDK</strong> 会通过 <code>Callable</code>回调 <strong>Jedis-Client</strong> 的原生接口，从 <strong>缓存集群</strong> 拿到 value 值；</li><li>对于 <strong>Jedis-Client</strong> 的每次 key 值访问请求，<strong>Hermes-SDK</strong> 都会通过其 通信模块 将 <strong>key 访问事件</strong> 异步上报给 <strong>Hermes 服务端集群</strong> ，以便其根据上报数据进行“热点探测”；</li></ul><p>2）key 值过期</p><ul><li>Java 应用调用 <strong>Jedis-Client</strong> 的 <code>set()</code> <code>del()</code> <code>expire()</code>接口时会导致对应 key 值失效，<strong>Jedis-Client</strong> 会同步调用 <strong>Hermes-SDK</strong> 的 <code>invalid()</code>方法告知其“key 值失效”事件；</li><li>对于 <strong>热点 key</strong> ，<strong>Hermes-SDK</strong> 的 热点模块 会先将 key 在本地缓存的 value 值失效，以达到本地数据<strong>强一致</strong>。同时 通信模块 会异步将“key 值失效”事件通过 <strong>etcd 集群</strong> 推送给 Java 应用集群中其他 <strong>Hermes-SDK</strong> 节点；</li><li>其他 <strong>Hermes-SDK</strong> 节点的通信模块收到 “key 值失效”事件后，会调用热点模块将key在本地缓存的value值失效，以达到集群数据<strong>最终一致</strong>；</li></ul><p>3）热点发现</p><ul><li><p><strong>Hermes 服务端集群</strong> 不断收集 <strong>Hermes-SDK</strong>上报的 <strong>key 访问事件</strong>，对不同业务应用集群的缓存访问数据进行周期性（3s 一次）分析计算，以探测业务应用集群中的<strong>热点 key</strong>列表；</p></li><li><p>对于探测到的<strong>热点 key</strong>列表，<strong>Hermes 服务端集群</strong> 将其通过 <strong>etcd 集群</strong> 推送给不同业务应用集群的 <strong>Hermes-SDK</strong> 通信模块，通知其对<strong>热点 key</strong>列表进行本地缓存；</p></li></ul><p>4）配置读取</p><ul><li><strong>Hermes-SDK</strong> 在启动及运行过程中，会从 <strong>Apollo 配置中心</strong> 读取其关心的配置信息（如：启动关闭配置、黑白名单配置、etcd 地址…）；</li><li><strong>Hermes 服务端集群</strong> 在启动及运行过程中，会从 <strong>Apollo 配置中心</strong> 读取其关心的配置信息（如：业务应用列表、热点阈值配置、etcd 地址…）</li></ul><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>TMC 本地缓存稳定性表现在以下方面：</p><ul><li>数据上报异步化：<strong>Hermes-SDK</strong> 使用 <code>rsyslog技术</code>对“key 访问事件”进行异步化上报，不会阻塞业务；</li><li>通信模块线程隔离：<strong>Hermes-SDK</strong> 的 通信模块 使用独立线程池+有界队列，保证事件上报&amp;监听的 I/O 操作与业务执行线程隔离，即使出现非预期性异常也不会影响基本业务功能；</li><li>缓存管控：<strong>Hermes-SDK</strong> 的 热点模块 对本地缓存大小上限进行了管控，使其占用内存不超过 64MB（LRU），杜绝 JVM 堆内存溢出的可能；</li></ul><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>TMC 本地缓存一致性表现在以下方面：</p><ul><li><strong>Hermes-SDK</strong> 的 热点模块 仅缓存 <strong>热点 key</strong> 数据，绝大多数非热点 key数据由 <strong>缓存集群</strong> 存储；</li><li><strong>热点 key</strong> 变更导致 value 失效时，<strong>Hermes-SDK</strong> 同步失效本地缓存，保证 <strong>本地强一致</strong>；</li><li><strong>热点 key</strong> 变更导致 value 失效时，<strong>Hermes-SDK</strong> 通过 <strong>etcd 集群</strong> 广播事件，异步失效业务应用集群中其他节点的本地缓存，保证 <strong>集群最终一致</strong>；</li></ul><h2 id="热点发现"><a href="#热点发现" class="headerlink" title="热点发现"></a>热点发现</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaWWO0sYEvUUfGAicpBbGic4ficlDscJzoFvvjnwzVjKPRJ3lH0EiaIN6C1w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>TMC 热点发现流程分为四步：</p><ul><li><strong>数据收集</strong>：收集 <strong>Hermes-SDK</strong> 上报的 key 访问事件；</li><li><strong>热度滑窗</strong>：对 App 的每个 Key，维护一个时间轮，记录基于当前时刻滑窗的访问热度；</li><li><strong>热度汇聚</strong>：对 App 的所有 Key，以 的形式进行 热度排序汇总；</li><li><strong>热点探测</strong>：对 App，从 热 Key 排序汇总 结果中选出 TopN 的热点 Key ，推送给 <strong>Hermes-SDK</strong>；</li></ul><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p><strong>Hermes-SDK</strong>通过本地 <code>rsyslog</code>将 <strong>key 访问事件</strong>以协议格式放入 <strong>kafka</strong>，<strong>Hermes 服务端集群</strong>的每个节点消费 kafka 消息，实时获取 <strong>key 访问事件</strong>。</p><p>访问事件协议格式如下：</p><ul><li>appName：集群节点所属业务应用</li><li>uniqueKey：业务应用 key 访问事件 的 key</li><li>sendTime：业务应用 key 访问事件 的发生时间</li><li>weight：业务应用 key 访问事件 的访问权值</li></ul><p><strong>Hermes 服务端集群</strong>节点将收集到的 <strong>key 访问事件</strong>存储在本地内存中，内存数据结构为 <code>Map&lt;string,map&gt;</code>，对应业务含义映射为 <code>Map&lt;appname,map&gt;</code>。</p><h3 id="热度滑窗"><a href="#热度滑窗" class="headerlink" title="热度滑窗"></a>热度滑窗</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaAzSRicYl2QyaMK92FhbCk0iaXAicFS9FI6iclPPvNh9RFSCmWcjvuic12sQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="时间滑窗"><a href="#时间滑窗" class="headerlink" title="时间滑窗"></a>时间滑窗</h3><p><strong>Hermes 服务端集群</strong>节点，对每个 App 的每个 key，维护了一个 <strong>时间轮</strong>：</p><ul><li><p>时间轮中共 10 个 <strong>时间片</strong>，每个时间片记录当前 key 对应 3 秒时间周期的总访问次数；</p></li><li><p>时间轮 10 个时间片的记录累加即表示当前 key 从当前时间向前 30 秒时间窗口内的总访问次数；</p></li></ul><h3 id="映射任务"><a href="#映射任务" class="headerlink" title="映射任务"></a>映射任务</h3><p><strong>Hermes 服务端集群</strong>节点，对每个 App 每 3 秒 生成一个 <strong>映射任务</strong>，交由节点内 “缓存映射线程池” 执行。<strong>映射任务</strong>内容如下：</p><ul><li><p>对当前 App，从 <code>Map&lt;appname,map&gt;&lt; appname,map&lt;=&quot;&quot; code=&quot;&quot;&gt;中取出 appName 对应的 Map Map&gt;；</code></p></li><li><p><code>遍历 Map&gt;中的 key，对每个 key 取出其热度存入其 **时间轮** 对应的时间片中；</code></p></li></ul><h3 id="热度汇聚"><a href="#热度汇聚" class="headerlink" title="热度汇聚"></a>热度汇聚</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaib5p9EelHYkAp1IFFGKE3H1Rghuz0Rmw7oIkJSQ6YsElj46Zic1iar6sA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>完成第二步“热度滑窗”后，<strong>映射任务</strong>继续对当前 App 进行“热度汇聚”工作：</p><ul><li><p><code>遍历 App 的 key，将每个 key 的 **时间轮** 热度进行汇总（即 30 秒时间窗口内总热度）得到探测时刻 **滑窗总热度**；</code></p></li><li><p><code>将 &lt; key , 滑窗总热度 &gt; 以排序集合的方式存入 Redis 存储服务 中，即 **热度汇聚结果**；</code></p></li></ul><h3 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h3><ul><li><p>在前几步，<strong>每 3 秒</strong> 一次的 <strong>映射任务</strong> 执行，对每个 App 都会产生一份当前时刻的 <strong>热度汇聚结果</strong>`</p></li><li><p><strong>Hermes 服务端集群</strong> 中的“热点探测”节点，对每个 App，只需周期性从其最近一份 <strong>热度汇聚结果</strong> 中取出达到热度阈值的 TopN 的 key 列表，即可得到本次探测的 <strong>热点 key 列表</strong>；</p></li></ul><p>TMC 热点发现整体流程如下图：<br><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iauF3LXU9IZGEmjDWcouSbPCKTosmsDAtOxelRQ2u1VJnuH57dKQFwLw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h2><h3 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a><code>实时性</code></h3><p><strong>Hermes-SDK</strong> 基于rsyslog + kafka 实时上报 <strong>key 访问事件</strong>。<strong>映射任务</strong>3 秒一个周期完成“热度滑窗” + “热度汇聚”工作，当有 <strong>热点访问场景</strong>出现时最长 3 秒即可探测出对应 <strong>热点 key</strong>。</p><h3 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a><code>准确性</code></h3><p>key 的<strong>热度汇聚结果</strong>由“基于时间轮实现的滑动窗口”汇聚得到，相对准确地反应当前及最近正在发生访问分布。</p><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a><code>扩展性</code></h3><p><strong>Hermes 服务端集群</strong>节点无状态，节点数可基于 kafka 的 partition 数量横向扩展。<br>“热度滑窗” + “热度汇聚” 过程基于 App 数量，在单节点内多线程扩展。</p><h2 id="实战效果"><a href="#实战效果" class="headerlink" title="实战效果"></a>实战效果</h2><h3 id="快手商家某次商品营销活动"><a href="#快手商家某次商品营销活动" class="headerlink" title="快手商家某次商品营销活动"></a>快手商家某次商品营销活动</h3><p>有赞商家通过快手直播平台为某商品搞活动，造成该商品短时间内被集中访问产生访问热点，活动期间 TMC 记录的实际热点访问效果数据如下：</p><p><code>某核心应用的缓存请求&amp;命中率曲线图</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaYeXwQYPHJzIAwxe0IYr1QovhIuy4SsMnNF5sXnwjC7NCm8lgAJoUFA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><code>上图蓝线为应用集群调用get()方法访问缓存次数</code></li><li><code>上图绿线为获取缓存操作命中TMC本地缓存的次数</code></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iae7PHukxPgHAMHMV6J0DuPW3C5Omp9QicrRPoyXTMe55ERyqSEdPT9Zw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><code>上图为本地缓存命中率曲线图</code></li></ul><p>可以看出活动期间缓存请求量及本地缓存命中量均有明显增长，本地缓存命中率达到近 80%（即应用集群中 80% 的缓存查询请求被 TMC 本地缓存拦截）。</p><h3 id="热点缓存对应用访问的加速效果"><a href="#热点缓存对应用访问的加速效果" class="headerlink" title="热点缓存对应用访问的加速效果"></a>热点缓存对应用访问的加速效果</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaPxQnM4gynHMK9SjBrFmyX3UJicicAaSz5pfVDXKSEcZILXv6ibiaGMyBNQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><code>上图为应用接口 QPS 曲线</code></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iamtSn9gZruicrEDeYz0Bkt9BpguuH2ojUcslWuqRpOwrDcPodN8mpy5g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><code>上图为应用接口 RT 曲线</code></li></ul><p>可以看出活动期间应用接口的请求量有明显增长，由于 TMC 本地缓存的效果应用接口的 RT 反而出现下降。</p><h3 id="双十一期间部分应用-TMC-效果展示"><a href="#双十一期间部分应用-TMC-效果展示" class="headerlink" title="双十一期间部分应用 TMC 效果展示"></a>双十一期间部分应用 TMC 效果展示</h3><h4 id="商品域核心应用效果"><a href="#商品域核心应用效果" class="headerlink" title="商品域核心应用效果"></a><code>商品域核心应用效果</code></h4><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaFQcib5MA6WmF8RgOqFh74KWyXHOKcIBRNV1cZud4UVpZwwZrAYicibhSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h4 id="活动域核心应用效果"><a href="#活动域核心应用效果" class="headerlink" title="活动域核心应用效果"></a><code>活动域核心应用效果</code></h4><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaOJXDKynCBVfw1ziaQMHr6hia6LWzlDxstmoCBCof2vkovLPA76Fo3Izw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaj9SmSB5R42ERiaWdLiaYw2Iy6qw02GWHg7HZqFKCJx5zNKxeWeLiaVcaA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="功能展望"><a href="#功能展望" class="headerlink" title="功能展望"></a>功能展望</h2><p>TMC 目前已为商品中心、物流中心、库存中心、营销活动、用户中心、网关&amp;消息等多个核心应用模块提供服务，后续应用也在陆续接入中。<br>TMC 在提供“热点探测” + “本地缓存”的核心能力同时，也为应用服务提供了灵活的配置选择，应用服务可以结合实际业务情况在“热点阈值”、“热点 key 探测数量”、“热点黑白名单”维度进行自由配置以达到更好的使用效果。</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程之线程池ForkJoin</title>
      <link href="2021/06/16/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0ForkJoin/"/>
      <url>2021/06/16/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0ForkJoin/</url>
      
        <content type="html"><![CDATA[<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p><p>我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">long</span> expectedSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> SumTask(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Long result = ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="keyword">long</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="keyword">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, start, middle);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        Long result = subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个大的计算任务0~2000首先分裂为两个小任务0~1000和1000~2000，这两个小任务仍然太大，继续分裂为更小的0~500，500~1000，1000~1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p><p>核心代码<code>SumTask</code>继承自<code>RecursiveTask</code>，在<code>compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="comment">// 获得子任务的结果:</span></span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        <span class="comment">// 汇总结果:</span></span><br><span class="line">        <span class="keyword">return</span> subresult1 + subresult2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fork/Join线程池在Java标准库中就有应用。Java标准库提供的<code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。使用Fork/Join模式可以进行并行计算以提高效率。</p><p><code>ForkJoinPool</code>线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p><p><code>RecursiveAction</code>不带返回值，<code>RecursiveTask</code>带返回值,都是抽象类，继承抽象类<code>ForkJoinTask</code>，而它又实现Future接口。</p><p>重写了protected final boolean exec() 方法，调用方法protected abstract V compute();区别就是这个方法是否带有返回值。</p><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><ul><li><p>ForkJoinPool</p></li><li><p>ForkJoinTask implements Future<V></V></p></li><li><p>ForkJoinWorkerThread extends Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;                  <span class="comment">// the pool this thread works in</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue;   <span class="comment">// work-stealing mechanics</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程之CompletableFuture</title>
      <link href="2021/06/16/java%E7%BA%BF%E7%A8%8B%E4%B9%8BCompletableFuture/"/>
      <url>2021/06/16/java%E7%BA%BF%E7%A8%8B%E4%B9%8BCompletableFuture/</url>
      
        <content type="html"><![CDATA[<h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><p>提交给 CompletableFuture 执行的任务 有四种类型：Runnable、Consumer、Supplier、Function。简单说明这四种任务原型的对比。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/d7YzaYDnrxE0T1fr2rUd1MBuVib4u5Uh3B041DqplUOJbT6mPpfbialfeia7rOlNibGxfeqajjQIGxsKO3jicgVNkhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>runAsync 与 supplierAsync 是 CompletableFutre 的<strong>静态方法</strong>；而thenAccept、thenAsync、thenApply 是CompletableFutre的成员方法。<br><strong>runAsync（Runnable）</strong>    没有返回值的任务<br><strong>supplyAsync（Supplier）</strong>有返回值的任务。</p><p><strong>thenRun（Runnable）</strong> 跟的是一个无参数、无返回值的方法，即 Runnable，所以最终的返回值是 CompletableFuture<Void>类 型<br><strong>thenAccept（Consumer）</strong>跟的是一个有参数、无返回值的方法，称为 Consumer，返回值也是 CompletableFuture<Void>；类型。顾名 思义，只进不出，所以称为 Consumer；前面的 Supplier，是无参数，有返回值，只出不进，和 Consumer 刚好相反。<font color="red">异步任务结束时，会自动回调某个对象的方法；</font><br><strong>thenApply（Function）</strong>跟的是一个有参数、有返回值的方法，称为 Function。返回值是 CompletableFuture<String>；类型。而参数接收的是前一个任务，即 supplyAsync（..）这个任务的返回 值。因此这里只能用 supplyAsync，不能用 runAsync。因为 runAsync 没有返回值，不能为下一个链式方法传入参数。<br><strong>thenApplyAsync（Function）</strong> 异步任务结束之后再异步执行函数<br>exceptionally(e -&gt; { e.printStackTrace(); }) <font color="red">异步任务出错时，会自动回调某个对象的方法；</font>handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);也可以处理异常。区别是handle方法的回调函数，除了可以获取到异常还能获取到正常的返回值，即不管任务是否出错，都会执行handle流程。<br>get() 和join() 提供了<code>join()</code> 方法，它的功能和 get() 方法是一样的，都是阻塞获取值，它们的区别在于 join() 抛出的是 unchecked Exception。</String></Void></Void></p><p>因为初始的时候没有 CompletableFuture 对象，也没有参数可传，所以提交的只能是 Runnable 或者 Supplier，只能是静态方法；</p><p>通过静态方法生成 CompletableFuture 对象之后，便可以链式地提交其他任务了，这个时候就可以提交 Runnable、Consumer、Function且都是<strong>成员方法</strong>。</p><h2 id="串行和并行"><a href="#串行和并行" class="headerlink" title="串行和并行"></a>串行和并行</h2><p>串行执行：使用thenXXX方法，上一个任务执行完成之后执行下一个任务。<br>并行执行：</p><ul><li><p>多个任务并行：<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”。由于 allOf 聚合了多个 CompletableFuture 实例，所以它是没有返回值的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture cfA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>);</span><br><span class="line">CompletableFuture cfB = CompletableFuture.supplyAsync(() -&gt; <span class="number">123</span>);</span><br><span class="line">CompletableFuture cfC = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultC&quot;</span>);</span><br><span class="line"> </span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.allOf(cfA, cfB, cfC);</span><br><span class="line"><span class="comment">// 所以这里的 join() 将阻塞，直到所有的任务执行结束</span></span><br><span class="line">future.join();</span><br></pre></td></tr></table></figure></li><li><p>二个任务并行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cfB = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultB&quot;</span>);</span><br><span class="line"><span class="comment">// 两个任务都执行完成，就执行指定的操作。</span></span><br><span class="line">cfA.thenAcceptBoth(cfB, (resultA, resultB) -&gt; &#123;&#125;);  <span class="comment">//后续的处理不需要返回值</span></span><br><span class="line">cfA.thenCombine(cfB, (resultA, resultB) -&gt; <span class="string">&quot;result A + B&quot;</span>); <span class="comment">//需要返回值</span></span><br><span class="line">cfA.runAfterBoth(cfB, () -&gt; &#123;&#125;);<span class="comment">//不需要 resultA 和 resultB</span></span><br><span class="line"><span class="comment">//两个任务中的其中一个执行完成，就执行指定的操作。</span></span><br><span class="line">cfA.acceptEither(cfB, result -&gt; &#123;&#125;);</span><br><span class="line">cfA.acceptEitherAsync(cfB, result -&gt; &#123;&#125;);</span><br><span class="line">cfA.acceptEitherAsync(cfB, result -&gt; &#123;&#125;, executorService);</span><br><span class="line"> </span><br><span class="line">cfA.applyToEither(cfB, result -&gt; &#123;<span class="keyword">return</span> result;&#125;);</span><br><span class="line">cfA.applyToEitherAsync(cfB, result -&gt; &#123;<span class="keyword">return</span> result;&#125;);</span><br><span class="line">cfA.applyToEitherAsync(cfB, result -&gt; &#123;<span class="keyword">return</span> result;&#125;, executorService);</span><br><span class="line"> </span><br><span class="line">cfA.runAfterEither(cfA, () -&gt; &#123;&#125;);</span><br><span class="line">cfA.runAfterEitherAsync(cfB, () -&gt; &#123;&#125;);</span><br><span class="line">cfA.runAfterEitherAsync(cfB, () -&gt; &#123;&#125;, executorService);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p><p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;System.out.println(<span class="string">&quot;price: &quot;</span> + result);&#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;&#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并行处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">queryCode</span><span class="params">(String name, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query code from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;601857&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">(String code, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query price from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>加了 <strong>Async</strong> 后缀的方法，代表将需要执行的任务放到 ForkJoinPool.commonPool() 中执行(非完全严谨)</p><p>CompletableFuture同时实现了两个接口，分别为Future和CompletionStage，CompletionStage是CompletableFuture提供的一些非常丰富的接口，可以借助这些接口来实现非常复杂的异步计算工作.</p><h2 id="CompletableFuture与Future区别"><a href="#CompletableFuture与Future区别" class="headerlink" title="CompletableFuture与Future区别"></a>CompletableFuture与Future区别</h2><p>Future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：</p><ol><li>将多个异步计算的结果合并成一个</li><li>等待Future集合中的所有任务都完成</li><li>Future完成事件（即，任务完成以后触发执行动作）</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发之并发工具</title>
      <link href="2021/06/15/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
      <url>2021/06/15/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理是Sync实现了<code>AQS</code>，初始化的时候确定count值。await()方法获取资源，当state不为0时，返回失败，失败则通过<code>addWaiter()</code>添加到同步队列中，堵塞线程；<code>countDown()</code>释放资源，使用<code>CAS</code>判断count的数量，<code>doReleaseShared()</code>唤醒等待队列中的线程。这二个方法tryAcquireShared(int acquires)和tryReleaseShared(int arg)，Sync静态内部类进行了重写。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h2><p>所有线程会等待全部线程到达栅栏之后才会继续执行，并且最后到达的线程会完成 Runnable 的任务。重点是使用Condition，堵塞在==等待队列==中。调用await()方法时，count=parties-1，当count为0时，执行barrierAction的run方法，重置generation对象，并执行trip.signalAll()方法将等待队列的线程，加入到同步队列中，LockSupport.unpark(node.thread)唤醒当前线程；当count不为0时，执行trip.await()或trip.awaitNanos(nanos)，将当前线程堵塞在等待队列中，LockSupport.park(this)暂停当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span>  <span class="comment">//用于唤醒/加入等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"><span class="comment">/** The number of parties */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span>  <span class="comment">//parties 是参与线程的个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> <span class="comment">//barrierAction最后一个到达线程要做的任务</span></span></span><br><span class="line"><span class="function"><span class="comment">//线程调用 await() 表示自己已经到达栅栏——》trip.await();</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class="line"><span class="function"><span class="comment">//BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></span><br></pre></td></tr></table></figure><hr><h2 id="CyclicBarrier-与-CountDownLatch-区别"><a href="#CyclicBarrier-与-CountDownLatch-区别" class="headerlink" title="CyclicBarrier 与 CountDownLatch 区别"></a>CyclicBarrier 与 CountDownLatch 区别</h2><p>CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的</p><p>CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的。</p><p>CyclicBarrier的计数器由自己控制，而CountDownLatch的计数器则由使用者来控制，在CyclicBarrier中线程调用await方法不仅会将自己阻塞还会将计数器减1，而在CountDownLatch中线程调用await方法只是将自己阻塞而不会减少计数器的值。</p><p>另外，CountDownLatch只能拦截一轮，而CyclicBarrier可以实现循环拦截。一般来说用CyclicBarrier可以实现CountDownLatch的功能，而反之则不能</p><hr><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，线程池隔离。基于AQS实现，支持公平和非公平二种，堵塞在==同步队列==中。</p><p>实现互斥锁（计数器为 1） 我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p><h4 id="semaphore申请许可"><a href="#semaphore申请许可" class="headerlink" title="semaphore申请许可"></a>semaphore申请许可</h4><p>.acquire();</p><h4 id="semaphore释放许可"><a href="#semaphore释放许可" class="headerlink" title="semaphore释放许可"></a>semaphore释放许可</h4><p>.release();</p><h4 id="Semaphore与ReentrantLock"><a href="#Semaphore与ReentrantLock" class="headerlink" title="Semaphore与ReentrantLock"></a>Semaphore与ReentrantLock</h4><p>Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>此外，Semaphore也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire与tryLock 不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p><p>Semaphore的锁释放操作也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在finally代码块中完成。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程之基础</title>
      <link href="2021/06/11/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/11/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程状态：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED；注意点：就绪和运行状态就是RUNNABLE</p><ol><li>新建：new一个新对象</li><li>就绪：执行start（）方法，Java虚拟机会为其创建方法调用栈和程序计数器，该状态线程未开始运行，表示线程可以运行了，该线程何时开始运行，取决于JVM里线程调度器的调度</li><li>运行：处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体。<ul><li>抢占式调度策略：系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级</li><li>协作式调度策略：只有当一个线程调用了它的sleep()或yield()方法后才会放弃所占用的资源，也就是必须由该线程主动放弃所占用的资源</li></ul></li><li>堵塞：阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）如阻塞IO方法</li><li>死亡：线程结束：正常或异常<ul><li>run()或call()方法执行完成，线程正常结束</li><li>线程抛出一个未捕获的Exception或Error</li><li>直接调用该线程stop()方法来结束该线程——该方法容易导致死锁</li></ul></li></ol><h2 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h2><ul><li>Thread implements Runnable{} private Runnable target; 核心是:target.run()</li><li>Runnable 接口</li><li>Callable 接口</li><li>Future 接口</li><li>FutureTask-&gt;RunnableFuture extends Runnable, Future</li></ul><h2 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FutureTask futureCallable = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;futureTask call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">String result = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">FutureTask futureRunnable = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;futureTask run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,result);</span><br><span class="line"></span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(futureCallable);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(futureRunnable);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(futureCallable.get());</span><br><span class="line">    System.out.println(futureRunnable.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sleep与wait区别"><a href="#sleep与wait区别" class="headerlink" title="sleep与wait区别"></a>sleep与wait区别</h2><ul><li>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的</li><li>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态</li><li>在调用sleep()方法的过程中，线程不会释放对象锁而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</li></ul><h2 id="Java中实现线程阻塞的方法："><a href="#Java中实现线程阻塞的方法：" class="headerlink" title="Java中实现线程阻塞的方法："></a>Java中实现线程阻塞的方法：</h2><p>（1）线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p><p>（2）线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的notify()唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用wait()一样。wait()和notify()方法：两个方法配套使用，wait()使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify()被调用.</p><p>（3）线程礼让，Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield()使得线程放弃当前分得的CPU时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用yield()的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</p><p>（4）线程自闭，join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><p>（5）suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。典型地，suspend()和resume()被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用resume()使其恢复。Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p><h2 id="堵塞和非堵塞"><a href="#堵塞和非堵塞" class="headerlink" title="堵塞和非堵塞"></a>堵塞和非堵塞</h2><p>阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><h2 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h2><p>多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果线程A持有锁L并且想获得锁M，线程B持有锁M并且想获得锁L，那么这两个线程将永远等待下去，这种情况就是最简单的死锁形式</p><h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><ol><li>系统资源的竞争<br>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的</li><li>进程推进顺序非法<br>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞</li></ol><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ol><li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有</li></ol><h2 id="避免死锁的方式"><a href="#避免死锁的方式" class="headerlink" title="避免死锁的方式"></a>避免死锁的方式</h2><ol><li>让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实</li><li>设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量</li><li>既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后变回返回一个失败信息（超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题）</li><li>死锁检测 每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</li></ol><ul><li>释放所有锁，回退，并且等待一段随机的时间后重试，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁</li><li>给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁，如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级</li></ul><h2 id="java-栈信息"><a href="#java-栈信息" class="headerlink" title="java 栈信息"></a>java 栈信息</h2><ol><li>jps获得当前Java虚拟机进程的pid</li><li>jstack pid</li></ol><h2 id="栈信息解读"><a href="#栈信息解读" class="headerlink" title="栈信息解读"></a>栈信息解读</h2><ul><li>“Thread-1”表示线程名称</li><li>“prio=6”表示线程优先级</li><li>“tid=00000000497cec00”表示线程Id</li><li>nid=0x219c线程对应的本地线程Id。因为Java线程是依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码，只有本地线程才是真正的线程实体。Java代码中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体。Linux环境下可以使用”top -H -p JVM进程Id”来查看JVM进程下的本地线程（也被称作LWP）信息，注意这个本地线程是用十进制表示的，nid是用16进制表示的，转换一下就好了</li><li>“ [0x000000000c9ff000]”表示线程占用的内存地址</li><li>“java.lang.Thread.State：BLOCKED”表示线程的状态</li></ul><hr><p>死锁下，看下Thread-1处于BLOCKED状态，Thread-0处于BLOCKED状态。对这两个线程分析一下：</p><ol><li>Thread-1获得了锁&lt;0x00000007d5d19c60&gt;，在等待锁&lt;0x00000007d5d19c50&gt;</li><li>Thread-0获得了锁&lt;0x00000007d5d19c50&gt;，在等待锁&lt;0x00000007d5d19c60&gt;</li></ol><p>由于两个线程都在等待获取对方持有的锁，所以就这么永久等待下去了。</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span>  <span class="comment">//如果被标记了则返回true表示当前已经被中断，否则返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> <span class="comment">//该方法用于判断当前线程是否被中断，并且该方法调用结束的时候会清空中断标识位</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>; <span class="comment">//主要使用本地方法，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> <span class="comment">//该方法用于设置当前线程对象的中断标识位。</span></span></span><br><span class="line"><span class="function">线程状态：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED</span></span><br><span class="line"><span class="function">线程中断状态state：线程状态new| TERMINATED ——》中断操作，中断状态为flase，对这两种状态下的线程是无效的   </span></span><br><span class="line"><span class="function">线程状态RUNNABLE| BLOCKED ——》中断操作，设置中断状态为<span class="keyword">true</span>，线程继续执行，也只会设置中断标志位并不会实际中断线程运行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exit MyThread&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">线程状态WAITING| TIMED_WAITING ——》中断操作，中断状态为<span class="keyword">false</span>，线程对于中断操作是敏感的，会抛出异常并清空中断标志位</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am waiting but facing interruptexception now&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程都一个状态位用于标识当前线程对象是否是中断状态，中断状态有六种：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED</p><ul><li>new：还未调用start方法，线程还未真正启动</li><li>RUNNABLE:线程处于运行状态</li><li>BLOCKED阻塞：synchronized同步方法死循环</li><li>WAITING，TIMED_WAITING：使用wait（）时的中断状态</li><li>TERMINATED 线程已经运行终止</li></ul><ol><li>NEW和TERMINATED对于中断操作几乎是屏蔽的</li><li>RUNNABLE和BLOCKED类似，对于中断操作只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中if(Thread.currentThread().isInterrupted())成立则退出</li><li>WAITING/TIMED_WAITING状态下的线程对于中断操作是敏感的，他们会抛出异常并清空中断标志位，线程中自己捕获异常InterruptedException</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例方法，返回是否中断，不清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//实例方法，设置线程中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//静态方法，返回当前线程是否中断，清除中断状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/yangming1996/p/7612653.html">线程中断文章</a></p><h2 id="线程副本"><a href="#线程副本" class="headerlink" title="线程副本"></a>线程副本</h2><h6 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h6><p>每个线程Thread类都有一个ThreadLocalMap属性，ThreadLocal.ThreadLocalMap threadLocals = null;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        </span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap</p><p>ThreadLocalRandom</p><h2 id="并行流（parallel-streams）"><a href="#并行流（parallel-streams）" class="headerlink" title="并行流（parallel streams）"></a>并行流（parallel streams）</h2><h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h2 id="线程面试："><a href="#线程面试：" class="headerlink" title="线程面试："></a>线程面试：</h2><ol><li>现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？</li></ol><ul><li> 使用Thread的join方法</li></ul><ol><li>Java 中新的 Lock 接口相对于同步代码块（synchronized block）有什么优势？如果让你实现一个高性能缓存，支持并发读取和单一写入，你如何保证数据完整性</li></ol><ul><li> lock 接口的最大优势是它为读和写提供两个单独的锁，可以让你构建高性能数据结构，比如 ConcurrentHashMap 和条件阻塞</li></ul><ol><li>Java 中 wait 和 sleep 方法有什么区别</li></ol><ul><li> 主要的区别就是等待释放锁和监视器。sleep方法在等待时不会释放任何锁或监视器。wait方法多用于线程间通信，而sleep只是在执行时暂停</li></ul><ol><li>如何在 Java 中实现一个阻塞队列</li></ol><ul><li> 如果用wait()和notify()方法成功实现了阻塞队列，可以让他用Java 5的并发类重新实现一次</li></ul><ol><li>如何在Java中编写代码解决生产者消费者问题</li></ol><ul><li> 用Java中 BlockingQueue 的解决方案</li></ul><ol><li>写一段死锁代码。你在Java中如何解决死锁</li></ol><ul><li> 有 N个资源和N个线程去执行某个操作</li></ul><ol><li>什么是原子操作？Java中有哪些原子操作</li></ol><ul><li>[x]</li></ul><ol><li>Java中volatile关键字是什么？你如何使用它？它和Java中的同步方法有什么区别</li></ol><ul><li> volatile变量在并发环境中如何确保可见性、有序性和一致性</li></ul><ol><li>什么是竞态条件？你如何发现并解决竞态条件</li></ol><ul><li>竞态条件是指同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件，代码区成为临界区。最常见的竞态条件为：先检测后执行。<strong>使用synchronized</strong>  <strong>使用CAS中的AtomicInteger</strong></li></ul><ol><li>在 Java 中你如何转储线程（thread dump）？如何分析它</li></ol><ul><li>jstack pid | grep -A 200(16进制线程id)   线程id  线程state</li></ul><ol><li>既然 start() 方法会调用 run() 方法，为什么我们调用 start() 方法，而不直接调用 run() 方法</li></ol><ul><li> 当你调用 start() 方法时，它会新建一个线程然后执行 run() 方法中的代码。如果直接调用 run() 方法，并不会创建新线程，方法中的代码会在当前调用者的线程中执行</li></ul><ol><li>Java 中你如何唤醒阻塞线程</li></ol><ul><li> 有很多原因会导致阻塞，如果是 IO 阻塞，我认为没有方式可以中断线程（如果有的话请告诉我）。另一方面，如果线程阻塞是由于调用了 wait()，sleep() 或 join() 方法，你可以中断线程，通过抛出 InterruptedException 异常来唤醒该线程</li></ul><ol><li>Java 中 CyclicBarriar 和 CountdownLatch 有什么区别</li></ol><ul><li> CyclicBarrier 在屏障打开之后（所有线程到达屏障点），可以重复使用。而 CountDownLatch 不行</li></ul><ol><li>什么是不可变类？它对于编写并发应用有何帮助</li></ol><ul><li>[x]</li></ul><ol><li>你在多线程环境中遇到的最多的问题是什么？你如何解决的？</li></ol><ul><li> 内存干扰、竞态条件、死锁、活锁、线程饥饿是多线程和并发编程中比较有代表性的问题。这类问题无休无止，而且难于定位和调试。 这是基于经验给出的 Java 面试题。你可以看看Java 并发实战课程来了解现实生活中高性能多线程应用所面临的问题。</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li>Java 中绿色线程和本地线程的区别？</li><li>线程和进程的区别？答案</li><li>多线程的上下文切换是什么？</li><li>死锁和活锁的区别？死锁和饥饿的区别？</li><li>Java 中使用什么线程调度算法？</li><li>Java 中线程调度是什么？</li><li>线程中如何处理某个未处理异常？</li><li>什么是线程组？为什么 Java 中不建议使用线程组？</li><li>为什么使用 Executor 框架比直接创建线程要好？</li><li>Java 中 Executor 和 Executors 的区别？答案</li><li>在 windows 和 linux 系统上分别如何找到占用 CPU 最多的线程？</li></ul><h2 id="线程池数量"><a href="#线程池数量" class="headerlink" title="线程池数量"></a>线程池数量</h2><ol><li><p>CPU 密集型应用，线程池大小设置为 N + 1</p></li><li><p>IO 密集型应用，线程池大小设置为 2N </p></li><li><p><em>线程池大小 = （（线程 IO time + 线程 CPU time ）/线程 CPU time ）</em> CPU数目</p><ol><li><em>线程 IO time + 线程 CPU time</em>为请求总耗时，可以通过拦截器获取</li><li>CPU 计算时间 = 请求总耗时 - CPU IO time，只需要知道IO 耗时就可以知道CPU耗时</li><li>CPU数目可以通过系统函数获取</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程之Future</title>
      <link href="2021/06/11/java%E7%BA%BF%E7%A8%8B%E4%B9%8BFuture/"/>
      <url>2021/06/11/java%E7%BA%BF%E7%A8%8B%E4%B9%8BFuture/</url>
      
        <content type="html"><![CDATA[<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><ul><li><strong>Callable</strong></li><li><strong>FutureTask implements</strong> <strong>RunnableFuture</strong></li><li><strong>RunnableFuture</strong>&lt;**V**&gt; <strong>extends</strong> <strong>Runnable</strong>, <strong>Future</strong>&lt;**V**&gt;</li><li><strong>Future</strong></li></ul><p>既然 RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 又实现了 RunnableFuture 接口，所以 FutureTask 既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(task);</span><br><span class="line">        <span class="keyword">new</span> Thread(integerFutureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task运行结果：&quot;</span>+integerFutureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程正在计算&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程池</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task(); </span><br><span class="line"><span class="comment">// 提交任务并获得Future: </span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task); </span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果: </span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure><h2 id="Future方法及作用"><a href="#Future方法及作用" class="headerlink" title="Future方法及作用"></a>Future方法及作用</h2><table><thead><tr><th>方法名</th><th>返回值</th><th>入参</th><th>备注</th><th>总结</th></tr></thead><tbody><tr><td>cancel</td><td>boolean</td><td>（boolean mayInterruptIfRunning）</td><td>用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</td><td>也就是说Future提供了三种功能：判断任务是否完成，能够中断任务，能够获取任务执行结果</td></tr><tr><td>isCancelled</td><td>boolean</td><td>无</td><td>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</td><td></td></tr><tr><td>isDone</td><td>boolean</td><td>无</td><td>方法表示任务是否已经完成，若任务完成，则返回true；</td><td></td></tr><tr><td>get</td><td>V</td><td>无</td><td>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回</td><td></td></tr><tr><td>get</td><td>V</td><td>（long timeout, TimeUnit unit）</td><td>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之并发CAS</title>
      <link href="2021/06/11/java%E5%B9%B6%E5%8F%91%E4%B9%8BCAS/"/>
      <url>2021/06/11/java%E5%B9%B6%E5%8F%91%E4%B9%8BCAS/</url>
      
        <content type="html"><![CDATA[<h2 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h2><ul><li>AtomicInteger  使用自旋的方式，先获取原始值，再进行比较设置CompareAndSwap,当线程竞争激烈时，可能有很多线程会不停的自旋，进入一个无限重复的循环中。导致大量线程空循环，自旋转，性能和效率都不是特别好。<ul><li>解决方式是使用LongAdder、DoubleAdder，原理是base+cell数组，分段处理机制</li></ul></li><li>ABA问题：<ul><li>解决方式是使用AtomicMarkableReference<V>、可以给一个引用标记上一个标记位，来保证原子性。AtomicStampedReference<V>可以给一个引用标记上一个整型的版本戳，来保证原子性。</V></V></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM之类加载</title>
      <link href="2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM类加载过程原理"><a href="#JVM类加载过程原理" class="headerlink" title="JVM类加载过程原理"></a>JVM类加载过程原理</h2><p>类加载:Java命令的作用是启动虚拟机，虚拟机通过输入流，从磁盘上将字节码文件(.class文件)中的内容读入虚拟机，并保存起来的过程就是类加载。</p><p><img src="/2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20210611101027635.png" alt="image-20210611101027635"></p><h2 id="加载-load"><a href="#加载-load" class="headerlink" title="加载(load)"></a>加载(load)</h2><p>通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成一个代表这个类的Java.lang.Class对象；</p><h2 id="链接（link）"><a href="#链接（link）" class="headerlink" title="链接（link）"></a>链接（link）</h2><ul><li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题（文件格式验证，元数据验证，字节码验证，符号引用验证）。</li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配（由于还没有产生对象，实例变量将不再此操作范围内）</li><li>解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法）；</li></ul><h2 id="初始化-Initialize"><a href="#初始化-Initialize" class="headerlink" title="初始化(Initialize)"></a>初始化(Initialize)</h2><p>激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value1  = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value2  = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    value2 = <span class="number">66</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="何时触发初始化"><a href="#何时触发初始化" class="headerlink" title="何时触发初始化"></a>何时触发初始化</h2><ol><li>为一个类型创建一个新的对象实例时（比如new、反射、序列化）</li><li>调用一个类型的静态方法时（即在字节码中执行invokestatic指令）</li><li>调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式</li><li>调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）</li><li>初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）</li><li>JVM启动包含main方法的启动类时。</li></ol><h2 id="类加载特性"><a href="#类加载特性" class="headerlink" title="类加载特性"></a>类加载特性</h2><p>在虚拟机的生命周期中一个类只被加载一次。<br>类加载的原则：延迟加载，能少加载就少加载，因为虚拟机的空间是有限的。<br>类加载的时机：<br>  1）第一次创建对象要加载类.<br>  2）调用静态方法时要加载类,访问静态属性时会加载类。<br>  3）加载子类时必定会先加载父类。<br>  4）创建对象引用不加载类.<br>  5) 子类调用父类的静态方法时<br>      (1)当子类没有覆盖父类的静态方法时，只加载父类，不加载子类<br>      (2)当子类有覆盖父类的静态方法时，既加载父类，又加载子类<br>  6）访问静态常量，如果编译器可以计算出常量的值，则不会加载类,例如:public static final int a =123;否则会加载类,例如:public static final int a = math.PI。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器的<strong>作用</strong>：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区中数据的访问入口。 类加载器主要分为三层：</p><ul><li><strong>引导类加载器<code>BootstrapClassLoader</code>：</strong> 用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取 <code>Java\jdk1.8\jre\lib\rt.jar</code>，通过<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>可以获取加载的路径。可以通过使用参数添加自己的类，如<code>java -Xbootclasspath/a:/D:/test/tes  HelloWorld</code></li><li><strong>扩展类加载器<code>ExtClassLoader</code>：</strong> 负责<code>jre/lib/ext</code>目录下的jar包或 <code>-D java.ext.dirs</code> 指定目录下的jar包装入工作库</li><li><strong>系统类加载器<code>AppClassLoader</code>：</strong> 负责<code>java -classpath</code> 或 <code>-D java.class.path</code> 所指目录下的类与jar包装入工作，是最常用的加载器</li></ul><p><img src="/2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20210611112354965.png" alt="image-20210611112354965"></p><p><strong>类缓存：</strong> 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间，不过JVM垃圾回收机制可以回收这些Class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类的加载器</span></span><br><span class="line">        ClassLoader loader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(loader);  <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载的父类加载器--&gt;扩展类加载器</span></span><br><span class="line">        ClassLoader parent = loader.getParent();</span><br><span class="line">        System.out.println(parent);  <span class="comment">//sun.misc.Launcher$ExtClassLoader@74a14482</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）</span></span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1);  <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试当前类是哪个加载器加载的</span></span><br><span class="line">        ClassLoader classLoader = Class.forName(<span class="string">&quot;com.dbright.Test.Test02&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);  <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试JDK内部类是谁加载的</span></span><br><span class="line">        classLoader = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);  <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何获取系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双亲委派机制：如果上层加载器存在不会使用下层定义类</strong><br>ClassLoader是基类，类加载器继承它。其它类寄存器是Launcher启动类的静态类，继承URLClassLoader类，使用模板方法设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; loadClass(String name)  <span class="comment">//使用双亲委派机制，加载类</span></span><br><span class="line">Class&lt;?&gt; findClass(String name)  <span class="comment">//自定义类加载器，不打破双亲委派机制，重写这个方法即可</span></span><br></pre></td></tr></table></figure><h2 id="类中代码加载顺序"><a href="#类中代码加载顺序" class="headerlink" title="类中代码加载顺序"></a>类中代码加载顺序</h2><ol><li>父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</li><li>子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</li><li>父类非静态代码块(包括非静态初始化块，非静态属性 )</li><li>父类构造方法</li><li>子类非静态代码块(包括非静态初始化块，非静态属性 )</li><li>子类构造方法</li></ol><p>==静态块==：用static声明，JVM加载类时执行，仅执行一次。有多个静态变量或块时，按声明顺序加载<br>==构造块==：类中直接用{}定义，每一次创建对象时执行<br>==执行顺序优先级==：静态块&gt;main()&gt;构造块&gt;构造方法</p><h2 id="Tomcat类加载"><a href="#Tomcat类加载" class="headerlink" title="Tomcat类加载"></a>Tomcat类加载</h2><img src="/2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20210624151753640.png" alt="image-20210624151753640" style="zoom:67%;"><p>在Java的内存分配中，总共3种常量池：</p><h2 id="字符串常量池-String-Constant-Pool"><a href="#字符串常量池-String-Constant-Pool" class="headerlink" title="字符串常量池(String Constant Pool)"></a>字符串常量池(String Constant Pool)</h2><p>1.1:字符串常量池在Java内存区域的哪个位置？<br>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；<br>在JDK7.0版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。<br>1.2:字符串常量池是什么？<br>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。<br>在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；<br>在JDK7.0中，StringTable的长度可以通过参数指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize&#x3D;66666</span><br></pre></td></tr></table></figure><p>1.3:字符串常量池里放的是什么？<br>在JDK6.0及之前版本中，String Pool里放的都是字符串常量；<br>在JDK7.0中，由于String#intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用。关于String在内存中的存储和String#intern()方法的说明，可以参考我的另外一篇博客：<br>需要说明的是：字符串常量池中的字符串只存在一份！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;hello,world!&quot;;</span><br><span class="line">String s2 &#x3D; &quot;hello,world!&quot;;</span><br></pre></td></tr></table></figure><p>即执行完第一行代码后，常量池中已存在 “hello,world!”，那么 s2不会在常量池中申请新的空间，而是直接把已存在的字符串内存地址返回给s2。(这里具体的字符串如何分配就不细说了，可以看我的另一篇博客)</p><p>即执行完第一行代码后，常量池中已存在 “hello,world!”，那么 s2不会在常量池中申请新的空间，而是直接把已存在的字符串内存地址返回给s2。(这里具体的字符串如何分配就不细说了，可以看我的另一篇博客)</p><h2 id="class常量池-Class-Constant-Pool"><a href="#class常量池-Class-Constant-Pool" class="headerlink" title="class常量池(Class Constant Pool)"></a>class常量池(Class Constant Pool)</h2><p>2.1:class常量池简介：<br>我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)；<br>每个class文件都有一个class常量池。<br>2.2:什么是字面量和符号引用：<br>字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;<br>符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。</p><h2 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h2><p>运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用<br>JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发之LongAdder详解</title>
      <link href="2021/06/09/java%E5%B9%B6%E5%8F%91%E4%B9%8BLongAdder%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/06/09/java%E5%B9%B6%E5%8F%91%E4%B9%8BLongAdder%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzU3OTc1MDM1Mg==&mid=2247503711&idx=2&sn=e6e18d492dac91ec195ac3768549ac83&chksm=fd63dfe0ca1456f6dc9a06f8c4c23850c002d4c62b22d29d756d051ba24c99b77b4f2b37d56d&scene=178&cur_album_id=1709316523971887110#rd">巧妙使用LongAdder替换AtomicLong</a></p><p>LongAdder性能高的原因是通过使用Cell数组，以空间换效率避免共享变量的竞争，在LongAdder中内部使用base变量保存Long值 ，当没有线程冲突时，使用CAS更新base的值，而存在线程冲突时，没有执行CAS成功的线程将CAS操作Cell数组，将数组中的元素置为1，即cell[i]=1，最后获取计数时会计算cell[i]的总和在加base，即为最后的计数结果。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/d7YzaYDnrxFeoicR91WjOEdnuDcibsUicADoJdjTdkA7THMoayv22nb4F81LibrnnK0ntlfkSC4fEcvCdQhhWgNafQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/d7YzaYDnrxFeoicR91WjOEdnuDcibsUicADImAFeVB4IrzktumC8oV2LMG0UiayiaHNWBJ7LQqWRkODY5xYe08jSucg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>限流-总结</title>
      <link href="2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/"/>
      <url>2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><ul><li>固定窗口</li><li>滑动窗口</li><li>漏桶算法</li><li>令牌桶算法</li><li>信号量</li><li>线程池隔离</li></ul><h3 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h3><p>为一定时间段的流量设置一个阈值，超过则触发限流策略（丢弃或者停留），然后直到下一个时间段重新置零开始计数。</p><p><strong>弊端</strong>：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为<font color="red">突刺现象</font></p><p>可以使用AtomicLong#incrementAndGet()，Redis中的String类型的原子操作并设置过期时间<br>可以使用Redis，key 为当前秒的时间戳，value 就是访问次数的累加，当次数超出了我们限制的范围内，直接拒绝即可</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>以当前时间为截止时间，往前取一定的时间，比如取60s的时间，在这60s时间内最大的访问数为100。此时算法的执行逻辑为，先清除这60s 之前的所有请求记录，再计算当前集合内请求数是否大于设定的最大请求数100，如果大于100则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。</p><p><strong>实现方式</strong>：借助Redis的有序集合ZSet来实现时间窗口算法限流，实现的过程是：</p><p>第一步：先使用ZSet的key存储限流的ID，score用来存储请求的时间。</p><p>第二步：每次有请求访问来了之后，先清空之前时间窗口的访问量，统计目前时间窗口的个数与最大允许访问量对比。</p><p>第三步：如果大于等于最大访问量则返回 false 执行限流操策略，负责允许执行业务逻辑，并且在 ZSet 中添加一条有效的访问记录。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>可以准备一个队列，用来保存请求，另外通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。弊端：无法应对短时间的突发流量<br><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/漏桶.jpg" alt="2021-01-2120-56-37.png" style="zoom: 50%;"></p><p><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/image-20210607132324808.png" alt="image-20210607132324808"></p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行<br><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/令牌桶.png" alt="2021-01-2120-59-20.png" style="zoom: 80%;"></p><h2 id="限流用法"><a href="#限流用法" class="headerlink" title="限流用法"></a>限流用法</h2><ul><li>单节点限流： 可以在网关层添加（网关服务限流）或者在对应的服务端添加拦截（应用服务限流），如Gateway中自定义限流规则。使用某种限流算法，使用Guava包中的限流算法，将数据统计保存在对应的节点</li><li>集群限流：     可以在网关层添加（网关服务限流）或者在对应的服务端添加拦截（应用服务限流），如Gateway中自定义限流规则。指定访问的服务集群使用某种限流算法，使用Redis记录集群的限流统计情况</li><li>具体服务限流：服务端提供的API中会指定serviceId，如FeignClient注解里的，服务隔离如Hystrix使用信号量或线程池；Sentinel使用线程量进行隔离，使用QPS和调用关系进行限流，支持集群流量控制，热点参数限流，系统自适应保护</li><li>具体接口限流：服务端提供的Controller类的接口，可以在方法上增加自定义注解，使用AOP的方式和限流算法实现具体接口服务的限流，比如可以使用信号量</li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网关-API-Gateway详解</title>
      <link href="2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在 Spring Cloud Gateway 中有如下几个核心概念需要我们了解：</p><p>1）Route</p><p>Route 是网关的基础元素，由 ID、目标 URI、断言、过滤器组成。当请求到达网关时，由 Gateway Handler Mapping 通过断言进行路由匹配（Mapping），当断言为真时，匹配到路由。</p><p>2）Predicate</p><p>Predicate 是 <a href="http://c.biancheng.net/java/">Java</a> 8 中提供的一个函数。输入类型是 Spring Framework ServerWebExchange。它允许开发人员匹配来自 HTTP 的请求，例如请求头或者请求参数。简单来说它就是匹配条件。</p><p>3）Filter</p><p>Filter 是 Gateway 中的过滤器，可以在请求发出前后进行一些业务上的处理。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>客户端向 Spring Cloud Gateway 发出请求，如果请求与网关程序定义的路由匹配，则该请求就会被发送到网关 Web 处理程序，此时处理程序运行特定的请求过滤器链。</p><p>过滤器之间用虚线分开的原因是过滤器可能会在发送代理请求的前后执行逻辑。所有 pre 过滤器逻辑先执行，然后执行代理请求；代理请求完成后，执行 post 过滤器逻辑。<br><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/5-1ZR6093952150.png" alt="Spring Cloud Gateway工作原理" style="zoom:80%;"></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>启动服务发现，从注册中心加载注册的服务，路由的uri: lb://user-service，网关会替换成对应的服务ip：port</p><h2 id="路由断言工厂"><a href="#路由断言工厂" class="headerlink" title="路由断言工厂"></a>路由断言工厂</h2><ul><li>Path 路由断言工厂 predicates:下添加，可添加多个  - Path=/blog/detail/{segment}  测试地址：<a href="http://localhost:2001/blog/detail/36185">http://localhost:2001/blog/detail/36185</a></li><li>Query 路由断言工厂  - Query=foo, ba.    测试链接：<a href="http://localhost:2001/?foo=baz">http://localhost:2001/?foo=baz</a></li><li>Method 路由断言工厂 - Method=GET</li><li>Header 路由断言工厂  - Header=X-Request-Id, \d+ 请求中带有请求头名为 x-request-id，其值与 \d+ 正则表达式匹配（值为一个或多个数字）</li><li>自定义路由断言工厂  继承 AbstractRoutePredicateFactory 类，重写 apply 方法的逻辑，命名需要以RoutePredicateFactory结尾</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//CheckAuth 就是这个路由断言工厂的名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckAuthRoutePredicateFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractRoutePredicateFactory</span>&lt;<span class="title">CheckAuthRoutePredicateFactory</span>.<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckAuthRoutePredicateFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="title">apply</span><span class="params">(Config config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;进入了CheckAuthRoutePredicateFactory\t&quot;</span> + config.getName());</span><br><span class="line">            <span class="keyword">if</span> (config.getName().equals(<span class="string">&quot;zhangsan&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">customer_route</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://c.biancheng.net</span></span><br><span class="line">      <span class="attr">predicates:</span>   <span class="comment">#CheckAuth就是这个路由断言工厂的名称</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CheckAuth</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zhangsan</span></span><br></pre></td></tr></table></figure><h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><ul><li>AddRequestHeader 过滤器工厂  filters: - AddRequestHeader=X-Request-Foo, Bar</li><li>RemoveRequestHeader 过滤器工厂 - RemoveRequestHeader=X-Request-Foo</li><li> SetStatus 过滤器工厂   - SetStatus=401</li><li> RedirectTo过滤器工厂   - RedirectTo=302, <a href="http://baidu.com/">http://baidu.com</a></li><li>自定义过滤器工厂，继承 AbstractGatewayFilterFactory 类，重写 apply 方法的逻辑，命名需要以 GatewayFilterFactory 结尾</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckAuth2GatewayFilterFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractGatewayFilterFactory</span>&lt;<span class="title">CheckAuth2GatewayFilterFactory</span>.<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckAuth2GatewayFilterFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Config config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;进入了CheckAuth2GatewayFilterFactory&quot;</span> + config.getName());</span><br><span class="line">      ServerHttpRequest request = exchange.getRequest().mutate()</span><br><span class="line">      .build();</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      chain.filter(exchange.mutate().request(request).build());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CheckAuth2</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">张三</span></span><br></pre></td></tr></table></figure><p>如果你的配置是 Key、Value 这种形式的，那么可以不用自己定义配置类，直接继承 AbstractNameValueGatewayFilterFactory 类即可。</p><p>AbstractNameValueGatewayFilterFactory 类继承了 AbstractGatewayFilterFactory，定义了一个 NameValueConfig 配置类，NameValueConfig 中有 name 和 value 两个字段。</p><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>全局过滤器作用于所有的路由，不需要单独配置，可以用它来实现很多统一化处理的业务需求，比如权限认证、IP 访问限制等。接口定义类 org.springframework.cloud.gateway.filter.GlobalFilter，具体代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">  <span class="function">Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有转发、路由、负载等相关的 GlobalFilter,通过 @Order 来指定执行的顺序，数字越小，优先级越高。<br><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/5-1ZR61152494J.png" alt="框架自带全局过滤器"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// IP 的访问限制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPCheckFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = exchange.getRequest().getHeaders();</span><br><span class="line">        <span class="comment">// 此处写得非常绝对, 只作演示用, 实际中需要采取配置的方式</span></span><br><span class="line">        <span class="keyword">if</span> (getIp(headers).equals(<span class="string">&quot;127.0.0.1&quot;</span>)) &#123;</span><br><span class="line">            ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">            ResponseData data = <span class="keyword">new</span> ResponseData();</span><br><span class="line">            data.setCode(<span class="number">401</span>);</span><br><span class="line">            data.setMessage(<span class="string">&quot;非法请求&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] datas = JsonUtils.toJson(data).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            DataBuffer buffer = response.bufferFactory().wrap(datas);</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里从请求头中获取用户的实际IP,根据Nginx转发的请求头获取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getIp</span><span class="params">(HttpHeaders headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gateway 的 Filter 只有 pre 和 post 两种,使用<font color="red">GatewayFilterChain</font>过滤器链，先执行所有的pre方法，再执行过滤器链，之后执行post方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GlobalFilter <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;first pre filter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;third post filter&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>Spring Cloud Gateway内置的 <font color="red">RequestRateLimiterGatewayFilterFactory</font> 提供限流的能力，基于令牌桶算法实现。目前，它内置的 <code>RedisRateLimiter</code> ，依赖Redis存储限流配置，以及统计数据。当然你也可以实现自己的RateLimiter，只需实现 <code>org.springframework.cloud.gateway.filter.ratelimit.RateLimiter</code> 接口，或者继承 <code>org.springframework.cloud.gateway.filter.ratelimit.AbstractRateLimiter</code>。</p><blockquote><p><strong>漏桶算法</strong>：流量突发问题</p><p>想象有一个水桶，水桶以一定的速度出水（以一定速率消费请求），当水流速度过大水会溢出（访问速率超过响应速率，就直接拒绝）。</p><p>漏桶算法的两个变量：</p><ul><li>水桶漏洞的大小：rate</li><li>最多可以存多少的水：burst</li></ul><p><strong>令牌桶算法</strong>：</p><p>系统按照恒定间隔向水桶里加入令牌（Token），如果桶满了的话，就不加了。每个请求来的时候，会拿走1个令牌，如果没有令牌可拿，那么就拒绝服务。</p><p><strong>TIPS</strong></p><ul><li>Redis Rate Limiter的实现基于这篇文章： <a href="https://stripe.com/blog/rate-limiters">Stripe</a></li><li>Spring官方引用的令牌桶算法文章： <a href="https://en.wikipedia.org/wiki/Token_bucket">Token Bucket Algorithm</a> ，有兴趣可以看看。</li></ul></blockquote><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-center</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">TimeBetween=上午0:00,下午11:59</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-Foo,</span> <span class="string">Bar</span></span><br><span class="line">            <span class="comment"># 必须是RequestRateLimiter,表示请求限流拦截器</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span> </span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="comment"># 令牌桶每秒填充平均速率(允许用户每秒处理多少个请求)</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">1</span></span><br><span class="line">                <span class="comment"># 令牌桶的上限(最大请求量)</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">2</span></span><br><span class="line">                <span class="comment"># 使用SpEL表达式从Spring容器中获取Bean对象</span></span><br><span class="line">                <span class="attr">key-resolver:</span> <span class="string">&quot;#&#123;@pathKeyResolver&#125;&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Raonfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照Path限流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">pathKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(</span><br><span class="line">            exchange.getRequest().getPath().toString()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对用户限流</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">userKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对ip限流</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">ipKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(</span><br><span class="line">            exchange.getRequest().getHeaders().getFirst(<span class="string">&quot;X-Forwarded-For&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;request_rate_limiter.&#123;localhost&#125;.timestamp&quot;</span></span><br><span class="line">2) <span class="string">&quot;request_rate_limiter.&#123;localhost&#125;.tokens&quot;</span></span><br></pre></td></tr></table></figure><p>大括号中就是我们的限流 Key，这里是 IP，本地的就是 localhost。</p><ul><li>timestamp：存储的是当前时间的秒数，也就是 System.currentTimeMillis()/1000 或者 Instant.now().getEpochSecond()。</li><li>tokens：存储的是当前这秒钟对应的可用令牌数量。</li></ul><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>内置了 <font color="red">HystrixGatewayFilterFactory </font>来实现路由级别的熔断，配置了一个 Hystrix 过滤器，该过滤器会使用 Hystrix 熔断与回退，原理是将请求包装成 RouteHystrixCommand 执行，RouteHystrixCommand 继承于 com.netflix.hystrix.HystrixObservableCommand。</p><p>fallbackUri 是发生熔断时回退的 URI 地址，目前只支持 forward 模式的 URI。如果服务被降级，该请求会被转发到该 URI 中。在网关中创建一个回退的接口，用于熔断时处理返回给调用方的信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line"><span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/user-service/**</span></span><br><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hystrix</span></span><br><span class="line"><span class="attr">args:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fallbackcmd</span></span><br><span class="line"><span class="attr">fallbackUri:</span> <span class="string">forward:/fallback</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/fallback&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fallback&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域实战"><a href="#跨域实战" class="headerlink" title="跨域实战"></a>跨域实战</h2><p>在 Spring Cloud Gateway 中配置跨域有两种方式，分别是代码配置方式和配置文件方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ServerWebExchange ctx, WebFilterChain chain) -&gt; &#123;</span><br><span class="line">            ServerHttpRequest request = ctx.getRequest();</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">                HttpHeaders requestHeaders = request.getHeaders();</span><br><span class="line">                ServerHttpResponse response = ctx.getResponse();</span><br><span class="line">                HttpMethod requestMethod = requestHeaders.getAccessControlRequestMethod();</span><br><span class="line">                HttpHeaders headers = response.getHeaders();</span><br><span class="line">                headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, requestHeaders.getOrigin());</span><br><span class="line">                headers.addAll(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS,</span><br><span class="line">                        requestHeaders.getAccessControlRequestHeaders());</span><br><span class="line">                <span class="keyword">if</span> (requestMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestMethod.name());</span><br><span class="line">                &#125;</span><br><span class="line">                headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (request.getMethod() == HttpMethod.OPTIONS) &#123;</span><br><span class="line">                    response.setStatusCode(HttpStatus.OK);</span><br><span class="line">                    <span class="keyword">return</span> Mono.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(ctx);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//应该使用这种</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsWebFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        config.addAllowedMethod(CorsConfiguration.ALL);</span><br><span class="line">        config.addAllowedOrigin(CorsConfiguration.ALL);</span><br><span class="line">        config.addAllowedHeader(CorsConfiguration.ALL);</span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;OPTIONS&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PATCH&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source =</span><br><span class="line">            <span class="keyword">new</span> UrlBasedCorsConfigurationSource(<span class="keyword">new</span> PathPatternParser());</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="attr">exposedHeaders:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">content-type</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">content-type</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">allowedMethods:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">OPTIONS</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">POST</span></span><br></pre></td></tr></table></figure><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>网关是给接口做代理转发的，后端对应的是 REST API，返回数据格式是 JSON。如果不做处理，当发生异常时，Gateway 默认给出的错误信息是页面，不方便前端进行异常处理。所以需要对异常信息进行处理，并返回 JSON 格式的数据给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonExceptionHandler</span> <span class="keyword">extends</span> <span class="title">DefaultErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes, ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">            ErrorProperties errorProperties, ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorAttributes, resourceProperties, errorProperties, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取异常属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(ServerRequest request, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> code = <span class="number">500</span>;</span><br><span class="line">        Throwable error = <span class="keyword">super</span>.getError(request);</span><br><span class="line">        <span class="keyword">if</span> (error <span class="keyword">instanceof</span> org.springframework.cloud.gateway.support.NotFoundException) &#123;</span><br><span class="line">            code = <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response(code, <span class="keyword">this</span>.buildMessage(request, error));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定响应处理方法为JSON处理的方法， 默认返回html页面</span></span><br><span class="line"><span class="comment">     * protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(ErrorAttributes errorAttributes) &#123;</span></span><br><span class="line"><span class="comment">     *  return RouterFunctions.route(acceptsTextHtml(), this::renderErrorView).andRoute(RequestPredicates.all(),      *  this::renderErrorResponse);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(RequestPredicates.all(), <span class="keyword">this</span>::renderErrorResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据code获取对应的HttpStatus，原始int statusCode = (int) errorAttributes.get(&quot;status&quot;);</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorAttributes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpStatus <span class="title">getHttpStatus</span><span class="params">(Map&lt;String, Object&gt; errorAttributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> statusCode = (<span class="keyword">int</span>) errorAttributes.get(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildMessage</span><span class="params">(ServerRequest request, Throwable ex)</span> </span>&#123;</span><br><span class="line">        StringBuilder message = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Failed to handle request [&quot;</span>);</span><br><span class="line">        message.append(request.methodName());</span><br><span class="line">        message.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        message.append(request.uri());</span><br><span class="line">        message.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            message.append(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">            message.append(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建返回的JSON数据格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status       状态码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorMessage 异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">response</span><span class="params">(<span class="keyword">int</span> status, String errorMessage)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, status);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>, errorMessage);</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; ServerProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorHandlerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerProperties serverProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorHandlerConfiguration</span><span class="params">(ServerProperties serverProperties, ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">            ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer,</span></span></span><br><span class="line"><span class="function"><span class="params">            ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverProperties = serverProperties;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">        <span class="keyword">this</span>.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);</span><br><span class="line">        <span class="keyword">this</span>.serverCodecConfigurer = serverCodecConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorWebExceptionHandler <span class="title">errorWebExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line">        JsonExceptionHandler exceptionHandler = <span class="keyword">new</span> JsonExceptionHandler(errorAttributes, </span><br><span class="line">            <span class="keyword">this</span>.resourceProperties,<span class="keyword">this</span>.serverProperties.getError(), <span class="keyword">this</span>.applicationContext);</span><br><span class="line">        exceptionHandler.setViewResolvers(<span class="keyword">this</span>.viewResolvers);</span><br><span class="line">        exceptionHandler.setMessageWriters(<span class="keyword">this</span>.serverCodecConfigurer.getWriters());</span><br><span class="line">        exceptionHandler.setMessageReaders(<span class="keyword">this</span>.serverCodecConfigurer.getReaders());</span><br><span class="line">        <span class="keyword">return</span> exceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>RetryGatewayFilter 是 Spring Cloud Gateway 对请求重试提供的一个 GatewayFilter Factory。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">zuul-encrypt-service</span></span><br><span class="line">       <span class="attr">uri:</span> <span class="string">lb://zuul-encrypt-service</span></span><br><span class="line">         <span class="attr">predicates:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">Path=/data/**</span></span><br><span class="line">         <span class="attr">filters:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Retry</span></span><br><span class="line">         <span class="attr">args:</span></span><br><span class="line">         <span class="attr">retries:</span> <span class="number">3</span>  <span class="comment">#重试次数，默认值是 3 次。</span></span><br><span class="line">         <span class="attr">series:</span> <span class="string">SERVER_ERROR</span> <span class="comment">#状态码配置（分段），符合某段状态码才会进行重试逻辑，默认值是 SERVER_ERROR，值是 5，也就是 5XX（5 开头的状态码）。INFORMATIONAL(1), SUCCESSFUL(2), REDIRECTION(3), CLIENT_ERROR(4), SERVER_ERROR(5);</span></span><br><span class="line">         <span class="attr">statuses:</span> <span class="comment">#状态码配置，和series不同的是这里是具体状态码的配置，取值请参考org.springframework.http.HttpStatus</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">NOT_FOUND</span></span><br><span class="line">             <span class="bullet">-</span> <span class="string">REQUEST_TIMEOUT</span>              </span><br><span class="line">             <span class="bullet">-</span> <span class="string">BAD_GATEWAY</span></span><br><span class="line">         <span class="attr">methods:</span> <span class="comment">#指定哪些方法的请求需要进行重试逻辑，默认值是 GET 方法</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">exceptions:</span> <span class="comment">#指定哪些异常需要进行重试逻辑。默认值是java.io.IOException和   org.springframework.cloud.gateway.support.TimeoutException。</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">org.springframework.cloud.gateway.support.TimeoutException</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">java.io.IOException</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">java.util.concurrent.TimeoutException</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">com.netflix.hystrix.exception.HystrixRuntimeException</span></span><br></pre></td></tr></table></figure><h2 id="Spring-Cloud-Gateway-工作原理"><a href="#Spring-Cloud-Gateway-工作原理" class="headerlink" title="Spring Cloud Gateway 工作原理"></a>Spring Cloud Gateway 工作原理</h2><p><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/image-20210715141646667.png" alt="image-20210715141646667"><br>当客户端向 Spring Cloud Gateway 发起请求，该请求会被 HttpWebHandlerAdapter 获取，并且对请求进行提取，从而组装成网关上下文。</p><p>将组成的上下文信息传递到 DispatcherHandler 组件。DispatcherHandler 作为请求分发处理器，主要负责将请求分发到对应的处理器进行处理。这里请求的处理器包括 RoutePredicate HandlerMapping (路由断言处理映射器) 。</p><p>路由断言处理映射器用于路由的查找，以及找到 路由后返回对应的 FilteringWebHandler。 </p><p>其负责组装 Filter 链表并执行过滤处理，之后再将请求转交给应用服务，应用服务处理完后，最后返回 Response 给客户端 。</p><p>其中 FilteringWebHandler 处理请求的时候会交给 Filter 进行过滤的处理。这里需要注意的是由于 Filter 是双向的所以，当客户端请求服务的时候，会通过 Pre Filter 中的 Filter 处理请求。当服务处理完请求以后返回客户端的时候，会通过 Post Filter 再进行一次处理。 </p><h2 id="Gateway详解"><a href="#Gateway详解" class="headerlink" title="Gateway详解"></a><a href="https://mp.weixin.qq.com/s/xs8Ls_Lgd7uigGSYG0gGBQ">Gateway详解</a></h2>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网关 </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign之加载原理</title>
      <link href="2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/"/>
      <url>2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>作者： 吉姆餐厅ak</p><p>地址：<a href="https://mp.weixin.qq.com/s?__biz=MzUwOTk1MTE5NQ==&mid=2247483724&idx=1&sn=03b5193f49920c1d286b56daff8b1a09&chksm=f90b2cf8ce7ca5ee6b56fb5e0ffa3176126ca3a68ba60fd8b9a3afd2fd1a2f8a201a2b765803&token=302932053&lang=zh_CN&scene=21#wechat_redirect">【Feign终极解析】</a></p><p><strong>概述</strong></p><blockquote><p>Feign是SpringCloud对底层通信组件封装后，暴露的一种声明式的客户端。本篇从源码角度带你过一遍装配流程，揭开feign的底层面纱。<br>主要包括feign整合ribbon，hystrix，sleuth，以及生成的代理类最终注入到spring容器的过程。篇幅略长，耐心读完，相信你会有所收获。</p></blockquote><hr><h2 id="Feign架构图-地址"><a href="#Feign架构图-地址" class="headerlink" title="Feign架构图 地址"></a>Feign架构图 地址</h2><p>一些核心类及大致流程：</p><p><img src="/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="图片"></p><p><strong>大体步骤：</strong><br><strong>一、注册FeignClient配置类和FeignClient BeanDefinition</strong></p><p><strong>二、实例化Feign上下文对象FeignContext</strong></p><p><strong>三、创建 Feign.builder 对象</strong> </p><p><strong>四、生成负载均衡代理类</strong></p><p><strong>五、生成默认代理类</strong> </p><p><strong>六、注入到spring容器</strong></p><hr><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>主要围绕上面六个步骤详细分析。</p><hr><h3 id="一、注册FeignClient配置类和FeignClient-BeanDefinition"><a href="#一、注册FeignClient配置类和FeignClient-BeanDefinition" class="headerlink" title="一、注册FeignClient配置类和FeignClient BeanDefinition"></a>一、注册FeignClient配置类和FeignClient BeanDefinition</h3><p>从启动类注解开始，来看下<code>@EnableFeignClients</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在启动类开启feign装配的注解，跟进该注解，看看做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patterned after Spring Integration IntegrationComponentScanRegistrar</span></span><br><span class="line">    <span class="comment">// and RibbonClientsConfigurationRegistgrar</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FeignClientsRegistrar.class);</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeignClientsRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、先注册默认配置</span></span><br><span class="line">        registerDefaultConfiguration(metadata, registry);</span><br><span class="line">        <span class="comment">//2、注册所有的feignClient beanDefinition</span></span><br><span class="line">        registerFeignClients(metadata, registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们分别来看一下上面<code>registerBeanDefinitions</code>中的两个方法：</strong><br>1） 注册默认配置方法：<code>registerDefaultConfiguration</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">            .getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">            name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// name 默认以 default 开头，后续会根据名称选择配置</span></span><br><span class="line">        registerClientConfiguration(registry, name,</span><br><span class="line">                defaultAttrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法为读取启动类上面<code>@EnableFeignClients</code>注解中声明feign相关配置类，默认name为default，一般情况下无需配置。用默认的<code>FeignAutoConfiguration</code>即可。<br>上面有个比较重要的方法：注册配置<code>registerClientConfiguration</code>，启动流程一共有两处读取feign的配置类，这是第一处。根据该方法看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object configuration)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">            .genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">    builder.addConstructorArgValue(name);</span><br><span class="line">    builder.addConstructorArgValue(configuration);</span><br><span class="line">    registry.registerBeanDefinition(</span><br><span class="line">            name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">            builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面将bean配置类包装成<code>FeignClientSpecification</code>，注入到容器。该对象非常重要，包含FeignClient需要的重试策略，超时策略，日志等配置，如果某个服务没有设置，则读取默认的配置。</p><p>2、扫描FeignClient</p><p>该方法主要是扫描类路径，对所有的FeignClient生成对应的<code>BeanDefinition</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//获取扫描目录下面所有的bean deanDefinition</span></span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">                    .findCandidateComponents(basePackage);</span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">                    AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">                    Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                            <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                            .getAnnotationAttributes(</span><br><span class="line">                                    FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">                    String name = getClientName(attributes);</span><br><span class="line">                    <span class="comment">//这里是第二处</span></span><br><span class="line">                    registerClientConfiguration(registry, name,</span><br><span class="line">                            attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//注册feignClient</span></span><br><span class="line">                    registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>可以看到上面又调用了<code>registerClientConfiguration</code>注册配置的方法，这里是第二处调用。这里主要是将扫描的目录下，每个项目的配置类加载的容器当中。</strong><br>注册到容器中，什么时候会用到呢？具体又如何使用呢？别着急，后面会有介绍。</p><p>我们先会回到继续主流程，继续看注册feignClient的方法，跟进<code>registerFeignClient</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        String className = annotationMetadata.getClassName();</span><br><span class="line">        <span class="comment">//声明代理类名称</span></span><br><span class="line">        BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">                .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">        <span class="comment">//logger.info(&quot;TEX do some replacement&quot;);</span></span><br><span class="line">            <span class="comment">//attributes.put(&quot;value&quot;, ((String)attributes.get(&quot;value&quot;)).replace(&#x27;_&#x27;,&#x27;-&#x27;));</span></span><br><span class="line">        validate(attributes);</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;url&quot;</span>, getUrl(attributes));</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;path&quot;</span>, getPath(attributes));</span><br><span class="line">        String name = getName(attributes);</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;type&quot;</span>, className);</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;decode404&quot;</span>, attributes.get(<span class="string">&quot;decode404&quot;</span>));</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;fallback&quot;</span>, attributes.get(<span class="string">&quot;fallback&quot;</span>));</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">        String alias = name + <span class="string">&quot;FeignClient&quot;</span>;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line">        beanDefinition.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">        BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">                <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">        <span class="comment">//将bean definition加入到spring容器</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>划重点，上面出现了一行相当关键代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class);</span><br></pre></td></tr></table></figure><p>springCloud FeignClient其实是利用了spring的代理工厂来生成代理类，所以这里将所有的<code>feignClient</code>的描述信息<code>BeanDefinition</code>设定为<code>FeignClientFactoryBean</code>类型，该类又继承<code>FactoryBean</code>,很明显，这是一个代理类。<br>在spring中，<code>FactoryBean</code>是一个工厂bean，用作创建代理bean，所以得出结论，feign将所有的feignClient bean包装成<code>FeignClientFactoryBean</code>。扫描方法到此结束。</p><p><strong>代理类什么时候会触发生成呢？ 在spring刷新容器时，当实例化我们的业务service时，如果发现注册了FeignClient，spring就会去实例化该FeignClient，同时会进行判断是否是代理bean，如果为代理bean，则调用<code>FeignClientFactoryBean</code>的<code>T getObject() throws Exception;</code>方法生成代理bean。</strong></p><hr><p><strong>先来隆重介绍一下FeignClientFactoryBean，后面四步都基于此类。</strong></p><p>先看一下代理feignClient代理生成入口：<code>getObject</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 二、实例化Feign上下文对象FeignContext</span></span><br><span class="line">        FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">        <span class="comment">// 三、生成builder对象，用来生成feign</span></span><br><span class="line">        Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断生成的代理对象类型，如果url为空，则走负载均衡，生成有负载均衡功能的代理类</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">            String url;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">                url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                url = <span class="keyword">this</span>.name;</span><br><span class="line">            &#125;</span><br><span class="line">            url += cleanPath();</span><br><span class="line">            <span class="comment">// 四、生成负载均衡代理类</span></span><br><span class="line">            <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">                    <span class="keyword">this</span>.name, url));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果指定了url，则生成默认的代理类</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">        &#125;</span><br><span class="line">        String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">        <span class="comment">// 五、生成默认代理类</span></span><br><span class="line">        <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">                <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>getObject()</code>逻辑比较多，每一行都会做一些初始化配置，来逐步分析。</p><h3 id="二、实例化Feign上下文对象FeignContext"><a href="#二、实例化Feign上下文对象FeignContext" class="headerlink" title="二、实例化Feign上下文对象FeignContext"></a>二、实例化Feign上下文对象FeignContext</h3><p>上述方法中第一行便是实例化<code>FeignContext</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FeignContext context = applicationContext.getBean(FeignContext.class);</span><br></pre></td></tr></table></figure><p>获取<code>FeignContext</code>对象，如果没有实例化，则主动实例化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Feign.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;FeignClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HasFeatures <span class="title">feignFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">&quot;Feign&quot;</span>, Feign.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignContext <span class="title">feignContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FeignContext context = <span class="keyword">new</span> FeignContext();</span><br><span class="line">        <span class="comment">//将feign的配置类设置到feign的容器当中</span></span><br><span class="line">        context.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到feign的配置类设置到feign的容器当中，而集合中的元素 正是上面我们提到的两处调用<code>registerClientConfiguration</code>方法添加进去的，前后呼应。</p><p>然而，当我们引入了<code>sleuth</code>之后，获取的<code>feignContext</code>确是<code>TraceFeignClientAutoConfiguration</code>中配置的实例<code>sleuthFeignContext</code>:</p><p><img src="/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/FeignContext.jpg" alt="图片"></p><p>可以看到上面创建了一个<code>TraceFeignContext</code>实例，因为该对象继承<code>FeignContext</code>，同时又加了<code>@Primary</code>注解，所以在上面第2步中通过类型获取:<br><code>applicationContext.getBean(FeignContext.class);</code>，最终拿到的是<code>TraceFeignContext</code>。</p><hr><h3 id="三、构造FeignBuilder"><a href="#三、构造FeignBuilder" class="headerlink" title="三、构造FeignBuilder"></a>三、构造FeignBuilder</h3><p>继续跟进该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Feign.Builder builder = feign(context);</span><br><span class="line"><span class="keyword">protected</span> Feign.<span class="function">Builder <span class="title">feign</span><span class="params">(FeignContext context)</span> </span>&#123;</span><br><span class="line">        Logger logger = getOptional(context, Logger.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger = <span class="keyword">new</span> Slf4jLogger(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、构造 Feign.Builder</span></span><br><span class="line">        Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">                <span class="comment">// required values</span></span><br><span class="line">                .logger(logger)</span><br><span class="line">                .encoder(get(context, Encoder.class))</span><br><span class="line">                .decoder(get(context, Decoder.class))</span><br><span class="line">                .contract(get(context, Contract.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、设置重试策略，log等组件</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//设置log级别</span></span><br><span class="line">        Logger.Level level = getOptional(context, Logger.Level.class);</span><br><span class="line">        <span class="keyword">if</span> (level != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.logLevel(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置重试策略</span></span><br><span class="line">        Retryer retryer = getOptional(context, Retryer.class);</span><br><span class="line">        <span class="keyword">if</span> (retryer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.retryer(retryer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//feign的错误code解析接口</span></span><br><span class="line">        ErrorDecoder errorDecoder = getOptional(context, ErrorDecoder.class);</span><br><span class="line">        <span class="keyword">if</span> (errorDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.errorDecoder(errorDecoder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超时时间设置，连接超时时间：connectTimeout默认10s，请求请求超时时间：readTimeout默认60s</span></span><br><span class="line">        Request.Options options = getOptional(context, Request.Options.class);</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.options(options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拦截器设置，可以看出拦截器也是可以针对单独的feignClient设置</span></span><br><span class="line">        Map&lt;String, RequestInterceptor&gt; requestInterceptors = context.getInstances(</span><br><span class="line">                <span class="keyword">this</span>.name, RequestInterceptor.class);</span><br><span class="line">        <span class="keyword">if</span> (requestInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.requestInterceptors(requestInterceptors.values());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (decode404) &#123;</span><br><span class="line">            builder.decode404();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码有两处逻辑，分别来看：</p><p>1、<code>Feign.Builder builder = get(context, Feign.Builder.class)</code> ，又会有以下三种情况：</p><p>1）单独使用Feign，没有引入 <code>sleuth</code>、<code>hystrix</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">(Retryer retryer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Feign.builder().retryer(retryer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）引入了<code>hystrix</code>,没有引入<code>sleuth</code>:<br>通过加载<code>FeignClientsConfiguration</code>的配置创建<code>HystrixFeign</code>的静态内部类：<code>HystrixFeign.Builder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line">    <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）同时引入<code>hystrix</code> 和 <code>sleuth</code>:<br>加载<code>TraceFeignClientAutoConfiguration</code>的配置创建：<code>HystrixFeign.Builder</code>：</p><p><img src="/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/HystrixFeign.Builder.jpg" alt="图片"></p><p>注意：</p><ul><li><p><code>TraceFeignClientAutoConfiguration</code>的配置类加载一定是在<code>FeignClientsConfiguration</code>之前（先加载先生效），而<code>FeignClientsConfiguration</code>加载是通过<code>FeignAutoConfiguration</code>完成的，所以上图中引入了条件注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureBefore(&#123;FeignAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>创建创建的<code>builder</code>对象和第二种情况一下，只是做了一层包装：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SleuthFeignBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SleuthFeignBuilder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Feign.<span class="function">Builder <span class="title">builder</span><span class="params">(Tracer tracer, HttpTraceKeysInjector keysInjector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HystrixFeign.builder()</span><br><span class="line">                <span class="comment">//各组件`client，retryer，decoder`进行增强，装饰器模式。</span></span><br><span class="line">                .client(<span class="keyword">new</span> TraceFeignClient(tracer, keysInjector))</span><br><span class="line">                .retryer(<span class="keyword">new</span> TraceFeignRetryer(tracer))</span><br><span class="line">                .decoder(<span class="keyword">new</span> TraceFeignDecoder(tracer))</span><br><span class="line">                .errorDecoder(<span class="keyword">new</span> TraceFeignErrorDecoder(tracer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、设置重试策略，log等组件<br>Feign.builder在获取之后又分别指定了重试策略，日志级别，错误代码code等，在上一步中调用<code>SleuthFeignBuilder.build()</code>时已经设置过默认值了，这里为什么要重复设置呢？</p><p>我们跟进去get()方法，一探究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(FeignContext context, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据name，也就是服务名称来生成builder</span></span><br><span class="line">    T instance = context.getInstance(<span class="keyword">this</span>.name, type);</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No bean found of type &quot;</span> + type + <span class="string">&quot; for &quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里获取AnnotationConfigApplicationContext容器</span></span><br><span class="line">    AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">            type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getBean(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">                <span class="comment">//这里创建容器createContext(name)</span></span><br><span class="line">                <span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来了，上述代码将FeignContext做了缓存，每个服务对应一个FeignContext，服务名作为key。<br>继续跟进<code>createContext(name)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意：这里的容器并不是spring的容器，而是每次都重新创建一个</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">//加载每个服务对应的配置类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">                    .getConfiguration()) &#123;</span><br><span class="line">                context.register(configuration);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加载启动类@EnableFeignClients注解指定的配置类</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">                    context.register(configuration);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注册默认的配置类：FeignClientsConfiguration</span></span><br><span class="line">        context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line">                <span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">        context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line">                <span class="keyword">this</span>.propertySourceName,</span><br><span class="line">                Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">            context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//刷新容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到上述AnnotationConfigApplicationContext容器并非spring容器，只是利用了spring刷新容器的方法来实例化配置类，以服务名作为key，配置隔离。</p><p><strong>重点来了，上面加载配置的顺序为：先加载每个服务的配置类，然后加载启动类注解上的配置类，最后加载默认的配置类。这样做有什么好处？ spring刷新容器的方法也是对所有的bean进行了缓存，如果已经创建，则不再实例化。所以优先选取每个FeignClient的配置类，最后默认的配置类兜底。</strong></p><p>所以这也证明了<code>sleuth</code>的配置一定在<code>feign</code>的配置类之前加载。<br>至此，<code>FeignBuilder</code>构造流程结束。</p><hr><h3 id="四、生成负载均衡代理类"><a href="#四、生成负载均衡代理类" class="headerlink" title="四、生成负载均衡代理类"></a>四、生成负载均衡代理类</h3><p>再贴一下生成代理类的入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断url是否为空 </span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">        <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br></pre></td></tr></table></figure><p>这里有个重要判断：判断FeignClient声明的url是否为空，来判断具体要生成的代理类。如下：<br>这么做有什么意义？<br>1）如果为空，则默认走Ribbon代理，也就是这个入口，会有加载ribbon的处理。<br><code>@FeignClient(&quot;MyFeignClient&quot;)</code><br>2）如果不为空，指定url，则走默认生成代理类的方式，也就是所谓的硬编码。<br><code>@FeignClient(value = &quot;MyFeignClient&quot;,url = &quot;http://localhost:8081&quot;)</code><br>这样处理方便开发人员进行测试，无需关注注册中心，直接http调用，是个不错的开发小技巧。</p><blockquote><p>生产环境也可以用上述第二种方式，指定域名的方式。</p></blockquote><p>我们跟进<code>loadBalance</code>方法：</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得FeignClient</span></span><br><span class="line">    Client client = getOptional(context, Client.class);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.client(client);</span><br><span class="line">        <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-ribbon?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Client client = getOptional(context, Client.class);</code>这里会从<code>FeignContext</code>上下文中获取<code>Client</code>对象，该对象有三种实例，具体是哪个实现呢？</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uFNav9vzn7gzOXibHkfzwkMFkb2WACcAtDssEL4PwBbMShJicYrbcTCFK6SoEbLReSkpX1ps3ibJOME2R8mC5lYIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这里又会有三种情况：<br>1）没有整合<code>ribbon</code>、<code>sleuth</code>：<br>获取默认的<code>Client</code>：<code>Default</code>实例。</p><p>2）整合了<code>ribbon</code>,没有整合<code>sleuth</code>:<br>获取<code>LoadBalanceFeignClient</code>实例。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uFNav9vzn7gzOXibHkfzwkMFkb2WACcAt2iaJ6lJiadicjp2vYuaQiblfFuztibNBTqMVPJcvt4RKvSicl5BkibPHZO2mA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>3）整合了<code>ribbon</code> 和 <code>sleuth</code>:<br>会获取<code>TraceFeignClient</code>实例，该实例是对<code>LoadBalanceFeignClient</code>的一种包装，实现方式通过<code>BeanPostProcessor</code>实现：<code>FeignBeanPostProcessor</code>中定义了包装逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.traceFeignObjectWrapper.wrap(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>wrap</code>方法最终返回<code>TraceFeignClient</code>实例。</p><p>继续回到主流程，先来看下<code>Targeter</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line">        &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                HardCodedTarget&lt;T&gt; target)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该对象定义在<code>FeignClientFactoryBean</code>静静态代码块中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Targeter targeter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Targeter targeterToUse;</span><br><span class="line">    <span class="comment">//判断类路径是否引入了hystrixFeign</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;feign.hystrix.HystrixFeign&quot;</span>,</span><br><span class="line">            FeignClientFactoryBean.class.getClassLoader())) &#123;</span><br><span class="line">        targeterToUse = <span class="keyword">new</span> HystrixTargeter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        targeterToUse = <span class="keyword">new</span> DefaultTargeter();</span><br><span class="line">    &#125;</span><br><span class="line">    targeter = targeterToUse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会初始化<code>Targeter</code>，该类是生成feign代理类的工具类，有两种实现，正是上面的<code>HystrixTargeter</code>,<code>DefaultTargeter</code>。<br>因为我们引入了<code>hystrix</code>，所以<code>Targeter</code>实现类为<code>HystrixTargeter</code>。我们继续跟进<code>targeter.target</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面通过<code>build()</code>方法获取生成代理类的工具类<code>ReflectiveFeign</code>，再通过<code>newInstance</code>正式创建代理类。<br>继续跟进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">      <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                           logLevel, decode404);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">      <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder,</span><br><span class="line">                              errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会创建Feign的方法工厂<code>synchronousMethodHandlerFactory</code>,<code>Feign</code>通过该工厂为每个方法创建一个<code>methodHandler</code>，每个<code>methodHandler</code>中包含Feign对应的配置：<code>retryer</code>、<code>requestInterceptors</code>等。</p><p>继续跟进<code>newInstance</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建所有的 MethodHandler</span></span><br><span class="line">   Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">   Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">   List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">     <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//判断是否启用默认handler</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">       DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">       defaultMethodHandlers.add(handler);</span><br><span class="line">       methodToHandler.put(method, handler);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建InvocationHandler，接收请求，转发到methodHandler</span></span><br><span class="line">   InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">   <span class="comment">//生成代理类</span></span><br><span class="line">   T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将默认方法绑定到代理类</span></span><br><span class="line">   <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">     defaultMethodHandler.bindTo(proxy);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> proxy;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>InvocationHandler</code>最终创建的实例为<code>HystrixInvocationHandler</code>，核心方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(setter) &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> HystrixInvocationHandler.<span class="keyword">this</span>.dispatch.get(method).invoke(args);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (Error) t;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>整个流程：Feign调用方发起请求，发送至hystrix的HystrixInvocationHandler，通过服务名称，找到对应方法的methodHandler，methodHandler中封装了loadBalanceClient、retryer、RequestInterceptor等组件，如果引入了sleuth,这几个组件均是sleuth的包装类。然后通过以上组件构造<code>http</code>请求完成整个过程。</p><hr><h3 id="五、生成默认代理类"><a href="#五、生成默认代理类" class="headerlink" title="五、生成默认代理类"></a>五、生成默认代理类</h3><p>理解了第四步的逻辑，生成默认代理类就很容易理解了，唯一不同点就是<code>client</code>的实现类为<code>loadBalanceClient</code>。</p><blockquote><p>注意：不管是哪种代理类，最终发起请求还是由<code>Feign.Default</code>中的<code>execute</code>方法完成，默认使用<code>HttpUrlConnection</code>实现。</p></blockquote><hr><h3 id="六、注入spring容器"><a href="#六、注入spring容器" class="headerlink" title="六、注入spring容器"></a>六、注入spring容器</h3><p>总结：通过<code>spring refresh()</code>方法，触发<code>FeignClientFactoryBean.getObject()</code>方法获得了代理类，然后完成注入<code>spring</code>容器的过程。该实现方式同<code>Dubbo</code>的实现方式类似，有兴趣的可以自行研究噢。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能相关知识</title>
      <link href="2021/06/02/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>2021/06/02/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="如何获取VU和TPS"><a href="#如何获取VU和TPS" class="headerlink" title="如何获取VU和TPS"></a>如何获取VU和TPS</h2><ul><li><p>VU获取方式：</p><p>已有系统：可选取高峰时刻，在一定时间内使用系统的人数，这些人数可认为是在线用户数，并发用户数可以取10%，例如在半个小时内，使用系统的用户数为10万，那么取10%（即1万）作为并发用户数基本就够了。</p><p>新系统：没有历史数据作参考，建议通过业务部门进行评估。</p></li><li><p>TPS获取方式：</p><p>已有系统：可选取高峰时刻，在一定时间内（如3分钟<del>10分钟），获取系统总业务量，计算单位时间（秒）内完成的笔数，乘以2</del>5倍作为峰值的TPS，例如峰值3分钟内处理订单18万笔，平均TPS是1000，峰值TPS可以是2000~5000。</p><p>新系统：没有历史数据作参考，建议通过业务部门进行评估。</p></li></ul><h2 id="如何评价系统的性能"><a href="#如何评价系统的性能" class="headerlink" title="如何评价系统的性能"></a>如何评价系统的性能</h2><p>针对服务器端的性能，以TPS为主来衡量系统的性能，并发用户数为辅来衡量系统的性能，如果必须要用并发用户数来衡量的话，需要一个前提，那就是交易在多长时间内完成，因为在系统负载不高的情况下，将思考时间（思考时间的值等于交易响应时间）加到串联链路中，并发用户数基本可以增加一倍，因此用并发用户数来衡量系统的性能没太大的意义。同样的，如果系统间的吞吐能力差别很大，那么同样的并发下TPS差距也会很大。</p><ul><li>系统的性能由TPS决定，跟并发用户数没有多大关系。</li><li>系统的最大TPS是一定的（在一个范围内），但并发用户数不一定，可以调整。</li><li>建议性能测试的时候，不要设置过长的思考时间，以最坏的情况下对服务器施压。</li><li>一般情况下，大型系统（业务量大、机器多）做压力测试，10000~50000个用户并发，中小型系统做压力测试，5000个用户并发比较常见。</li></ul><h2 id="软件性能的关注点"><a href="#软件性能的关注点" class="headerlink" title="软件性能的关注点"></a>软件性能的关注点</h2><p>用户关注的是用户操作的相应时间。</p><p><strong>管理员的角度考虑</strong></p><p>1、 响应时间<br>2、 服务器资源使用情况是否合理<br>3、 应用服务器和数据库资源使用是否合理<br>4、 系统能否实现扩展<br>5、 系统最多支持多少用户访问、系统最大业务处理量是多少<br>6、 系统性能可能存在的瓶颈在哪里<br>7、 更换那些设备可以提高性能<br>8、 系统能否支持7×24小时的业务访问</p><p><strong>开发（设计）人员角度考虑</strong></p><p>1、 架构设计是否合理<br>2、 数据库设计是否合理<br>3、 代码是否存在性能方面的问题<br>4、 系统中是否有不合理的内存使用方式<br>5、 系统中是否存在不合理的线程同步方式<br>6、 系统中是否存在不合理的资源竞争</p><h2 id="容量规划步骤"><a href="#容量规划步骤" class="headerlink" title="容量规划步骤"></a>容量规划步骤</h2><h3 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h3><p>一般每个服务都有对外承诺的服务质量，那么我们就需要根据这个目标来做容量规划及硬件方面的投入。</p><p>比如 A 网站能承受 3000 QPS，响应时间小于 200 ms。SLA（服务等级协议）</p><h3 id="收集指标"><a href="#收集指标" class="headerlink" title="收集指标"></a>收集指标</h3><p>我们需要通过测试来了解当前服务的数据指标。没有测试出你的服务上限的话，规划出来也是没有效果的。</p><p>测试主要分为下面 2 个步骤</p><ul><li>测试服务器的主要功能 ：业务维度 QPS、TPS</li><li>测试服务器硬件资源 ： CPU、内存、硬盘、网络</li></ul><h3 id="趋势预测"><a href="#趋势预测" class="headerlink" title="趋势预测"></a>趋势预测</h3><p>整体过程如下</p><ul><li>首先确定资源度量指标 ：比如内存消耗、硬盘消耗、CPU 消耗</li><li>其实对拥有的资源确定约束访问 : 比如 总内存大小、总硬盘大小等</li><li>最后根据监控趋势图（ Zabbix 、Metrics）算出具体容量超出时间点 ： 比如内存何时会耗尽</li></ul><h3 id="容量部署"><a href="#容量部署" class="headerlink" title="容量部署"></a>容量部署</h3><p>一旦确定未来需要多少容量才能满足业务需求，就可以着手新的设备，并进行部署。</p><p>通过自动化部署工具（ Ansible、 Salt ） 最大限度的减少部署时间</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重点理解</title>
      <link href="2021/05/19/%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3/"/>
      <url>2021/05/19/%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="运行时区域"><a href="#运行时区域" class="headerlink" title="运行时区域"></a>运行时区域</h3><ul><li><strong>程序计数器</strong>是jvm执行程序的流水线，存放一些跳转指令。</li><li><strong>本地方法栈</strong>是jvm调用操作系统方法所使用的栈。</li><li><strong>虚拟机栈</strong>是jvm执行java代码所使用的栈。</li><li><strong>方法区</strong>存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</li><li><strong>虚拟机堆</strong>是jvm执行java代码所使用的堆。<h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3></li><li>方法区中类静态属性引用的对象（static声明的引用类型字段）</li><li>方法区中常量引用的对象（final声明的引用类型字段）</li><li>栈中引用的对象</li><li>本地方法栈中引用的对象<h3 id="方法区（永久代）包含哪些内容"><a href="#方法区（永久代）包含哪些内容" class="headerlink" title="方法区（永久代）包含哪些内容"></a>方法区（永久代）包含哪些内容</h3></li><li>运行时常量池</li><li>字段和方法数据</li><li>构造函数和普通方法的字节码内容</li><li>一些特殊方法</li><li><a href="https://blog.csdn.net/aaqian1/article/details/113771134">方法区中一个模块：静态区，用于存放静态变量和静态代码块，JDK1.7开始类的静态变量(class statics)转移到了java heap</a><h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3>在JDK1.8中，使用元空间代替永久代来实现方法区，但是方法区并没有改变。变动的只是方法区中内容的物理存放位置。<font color="red">类型信息（元数据信息）等其他信息被移动到了元空间中；但是运行时常量池和字符串常量池被移动到了堆中。但是不论它们物理上如何存放，逻辑上还是属于方法区的。</font></li></ul><p>使用本地内存，不在虚拟机中。默认仅受本地内存限制。测试可以使用String类型的intern()方法，</p><p>运行时常量池（字面量），JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中。</p><blockquote><p>JDK1.7中永久代逻辑属于方法区，实际物理上还是放在堆区内，所以方法区内的运行时常量池、类信息都在堆内</p><p>JDK1.8中方法区实现改成了元空间，直接放到了直接内存，但是运行时常量池物理上还是在堆区，虽然物理存放的地方变了，逻辑上看元空间、运行时常量池还是属于方法区</p></blockquote><h3 id="为什么移除永久代"><a href="#为什么移除永久代" class="headerlink" title="为什么移除永久代"></a>为什么移除永久代</h3><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li>静态常量池（*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间）<br>主要用于存放两大类常量：<strong>字面量</strong>(Literal)和<strong>符号引用量</strong>(Symbolic References)</li><li>运行时常量池（jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在<strong>方法区</strong>中，常说的常量池，就是指方法区中的运行时常量池。）</li><li><a href="https://blog.csdn.net/zm13007310400/article/details/77534349?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">常量池</a></li></ul><h3 id="字面量-Literal"><a href="#字面量-Literal" class="headerlink" title="字面量(Literal)"></a><strong>字面量</strong>(Literal)</h3><p>相当于Java语言层面常量的概念，如1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等</p><h3 id="符号引用量-Symbolic-References"><a href="#符号引用量-Symbolic-References" class="headerlink" title="符号引用量(Symbolic References)"></a><strong>符号引用量</strong>(Symbolic References)</h3><p>符号引用则属于编译原理方面的概念，包括了如下三种类型的常量</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是<strong>具备动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String类的intern()**方法。</p><p>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p><p>运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用</p><p>JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。</p><h3 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a><strong>常量池的好处</strong></h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。<br>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><ul><li><p>修饰方法时（字节码文件方法使用flags: ACC_SYNCHRONIZED）</p></li><li><p>修饰对象时（字节码文件中使用monitorenter，monitorexit）</p></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>无锁</li><li>偏向锁（当有一个线程使用时，使用cas由无锁升级为偏向锁）</li><li>轻量级锁（当再有线程使用时，使用cas由偏向锁升级为轻量级锁）</li><li>重量级锁（操作系统的互斥锁，此时先进行自旋，之后再升级为重量级锁）</li></ul><h3 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h3><p>对象由对象头、数据实例、对齐填充组成</p><p>对象头由markword、类型指针、数组长度组成</p><p>markword组成是核心：是否偏向锁标识位，锁类型标识位</p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li>锁粗化</li><li>锁消除</li><li>自适应自旋</li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><code>RabbitMQ</code>延时队列问题：当过期时间不一致时，前面过期时间长的数据会堵塞后面过期时间短的数据-》可以使用延时插件，解决。<br>目前采用的是定时任务处理的方式，时效性要求不是那么高，可以通过减少任务执行间隔时间，减少延时。<br>当数据量大时 1）可以使用任务分片 2）多线程处理</p><h2 id="EMQ"><a href="#EMQ" class="headerlink" title="EMQ"></a>EMQ</h2><p>企业级：千万级并发连接，百万级消息吞吐，毫秒级消息时延。大规模分布式，高可用集群架构，弹性伸缩部署，5G 时代大型物联网应用首选技术方案。企业版支持通过规则引擎，无需编写代码即可以将消息持久化到各类型数据库中，如 MySQL、PostgreSQL、InfluxDB、ClickHouse 等。也可以通过规则配置，将消息流转至其他消息服务器，如 Kafka、RabbitMQ、Pulsar 等。</p><p>开源版本：支持分布式集群架构。EMQ X 3.0 单集群可支持千万级别的 MQTT 并发连接。</p><ol><li>稳定承载大规模的 MQTT 客户端连接，单服务器节点支持50万到100万连接。</li><li>分布式节点集群，快速低延时的消息路由，单集群支持1000万规模的路由。</li><li>消息服务器内扩展，支持定制多种认证方式、高效存储消息到后端数据库。</li><li>完整物联网协议支持，MQTT、MQTT-SN、CoAP、LwM2M、WebSocket 或私有协议支持。</li></ol><h2 id="获取数据方式"><a href="#获取数据方式" class="headerlink" title="获取数据方式"></a>获取数据方式</h2><ul><li>轮询（减少时间间隔，减少延时）</li><li>长连接（减少连接，一直持有连接）</li><li>长轮询（一次请求，比如连接时间为30s，前25s等待数据响应，最后5s）</li></ul><h2 id="Feign实战"><a href="#Feign实战" class="headerlink" title="Feign实战"></a>Feign实战</h2><h3 id="启动扫描"><a href="#启动扫描" class="headerlink" title="启动扫描"></a>启动扫描</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &#123;&quot;com.hf&quot;&#125;)</span>   <span class="comment">//可以配置configuration</span></span><br></pre></td></tr></table></figure><h3 id="配置Feign客户端"><a href="#配置Feign客户端" class="headerlink" title="配置Feign客户端"></a>配置Feign客户端</h3><ul><li>name:注册的服务名</li><li>configuration：配置信息，可以@Bean，</li><li><code>fallback</code>：降级返回,实现接口类，可以对每个方法进行返回，并需注入到Spring中，</li><li><code>fallbackFactory</code>: 降级工厂。可以返回匿名内部类的对象，对方法进行个性化返回，也可以设置成默认返回对象，如JsonResult。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;order-service&quot; configuration = SSOFeignConfig.class, fallbackFactory = OAuthTokenClientFallBackFactory.class,fallback=xxx.class)</span></span><br></pre></td></tr></table></figure><h4 id="fallback和fallbackFactory区别"><a href="#fallback和fallbackFactory区别" class="headerlink" title="fallback和fallbackFactory区别"></a><code>fallback</code>和<code>fallbackFactory</code>区别</h4><p>1）<code>fallbackFactory</code>可捕获到<code>Throwable throwable</code>对象，此处异常是Feign包装后的异常，如要抛出未封装的异常，可以使用<code>ErrorDecoder</code>返回异常<br>2）<code>fallbackFactory</code>可返回共用降级返回值</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>可以给请求增加些共用的参数，如：传递<code>traceId</code>，传递Authorization=Basic xxxssasefwxxa，传递token，可以通过拦截器拦截请求，将GET请求且body不为空的情况，转换成body参数放在url后</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestInterceptor#apply(RequestTemplate template)</span><br></pre></td></tr></table></figure><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>Encoder  -》new SpringFormEncoder(new SpringEncoder(messageConverters));</p><h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>Decoder  -》SpringDecoder</p><h3 id="统一异常处理器"><a href="#统一异常处理器" class="headerlink" title="统一异常处理器"></a>统一异常处理器</h3><p><strong>默认情况下,GET方式请求无论是连接异常还是读取异常,都会进行重试</strong>。<strong>非GET方式请求,只有连接异常时,才会进行重试</strong></p><p>当请求之后，返回的status不为200的时候，通过response.body()获取返回的数据，之后可以返回一个统一的异常。方法的返回值是Exception对象</p><p>当出现异常时不处理，使用<code>HystrixBadRequestException</code>异常，此时就不会走降级处理（不走fallback或fallbackFactory逻辑）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ErrorDecoder#decode(String s,Response response)</span><br></pre></td></tr></table></figure><h3 id="Feign配置"><a href="#Feign配置" class="headerlink" title="Feign配置"></a>Feign配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">logger-level:</span> <span class="string">basic</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">2048</span> <span class="comment">#最小压缩文件，调大点，可以减少CPU压力</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p><font color="red">配置超时时间，但是它的配置会被Ribbon和Hystrix的超时时间所覆盖，配置Feign超时时间即是否开启重试和Hystrix </font></p></blockquote><h2 id="Fegin集成Hystrix和Ribbon原理"><a href="#Fegin集成Hystrix和Ribbon原理" class="headerlink" title="Fegin集成Hystrix和Ribbon原理"></a>Fegin集成Hystrix和Ribbon原理</h2><p>扫描FeignClient注解的包下的类，注册FeignClientFactoryBean，getObject获取代理对象，通过注入的Targeter，生成代理对象。http请求调用时，会走<font color="red">HystrixInvocationHandler</font>里的invoke方法，实现了InvocationHandler类，使用的是jdk的动态代理。<br>构建了HystrixCommand对象<br><a href="https://blog.csdn.net/songhaifengshuaige/article/details/80489460">Feign集成Hystrix源码分析以及扩展</a></p><p>Ribbon</p><p>Hystrix</p><p>Nacos</p><p>Zookeeper  -&gt; </p><p>Redis  -&gt;  Redisson</p><p>ES   -&gt; high-level  low-level</p><p>Kafka  -&gt;</p><h2 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h2><p><a href="https://github.com/youngperson/blog/issues/41">全链路压测相关知识点</a><br><a href="https://tech.youzan.com/stress_testing/">有赞全链路压测</a><br><a href="https://zhuanlan.zhihu.com/p/30511486?from=timeline&isappinstalled=0">饿了么全链路压测平台的实现与原理</a><br><a href="https://my.oschina.net/cctester/blog/994727">阿里巴巴的全链路压测</a><br><a href="https://github.com/yonyou-auto-dev/TITAN">开源压测系统</a></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h3><p>第一范式：每一列原子不可再分<br>第二范式：满足第一范式，每一列与主键都相关，没有部分依赖<br>第三范式：满足第二范式，每一列与主键直接相关，不能间接相关，没有传递依赖</p><p>范式的目的在于：</p><ul><li>减少冗余，冗余会带来存储空间增加</li><li>减少异常（delete，update，insert），如果数据冗余之后，修改时需要也更新，否则会导致数据异常</li><li>让数据组织的更加和谐（使结构更清晰，但是对于人操作更麻烦）</li></ul><p>反范式：核心是增加冗余而提高性能</p><p>范式等级与复杂度是递进的。通过范式的不断升级，我们会发现应用的范式等级越高，则表越多。表多会带来很多问题：</p><ul><li>查询时要连接多个表，增加了查询的复杂度</li><li>查询时需要连接多个表，降低了数据库查询性能</li></ul><p>而现在的情况，磁盘空间成本基本可以忽略不计，所以数据冗余所造成的问题也并不是应用数据库范式的理由。</p><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行化</li></ul><h3 id="脏读、不可重复读（MVCC）、幻读（Next-Key-lock）"><a href="#脏读、不可重复读（MVCC）、幻读（Next-Key-lock）" class="headerlink" title="脏读、不可重复读（MVCC）、幻读（Next-Key lock）"></a>脏读、不可重复读（MVCC）、幻读（Next-Key lock）</h3><h3 id="MVCC实现"><a href="#MVCC实现" class="headerlink" title="MVCC实现"></a><code>MVCC</code>实现</h3><p>借助Redo log实现MVCC多版本控制，表中数据含有三个隐藏字段：事务id，回滚指针，自增id</p><h3 id="快照读、当前读"><a href="#快照读、当前读" class="headerlink" title="快照读、当前读"></a>快照读、当前读</h3><ul><li>快照读：普通的查询</li><li>当前读：insert、update、delete 、select *** for update 排它锁、select * form t lock in share mode 共享锁</li></ul><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><ul><li><p>表锁</p></li><li><p>行锁 （通过索引项加锁）</p></li><li><p>间隙锁（锁住间隙）</p></li><li><p>Next-Key lock （间隙锁+行锁）</p></li><li><p>意向锁：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。</p></li></ul><p>①在mysql中有表锁，<br>  LOCK TABLE my_tabl_name READ; 用读锁锁表，会阻塞其他事务修改表数据。<br>  LOCK TABLE my_table_name WRITe; 用写锁锁表，会阻塞其他事务读和写。<br>②Innodb引擎又支持行锁，行锁分为<br>  共享锁，一个事务对一行的共享只读锁。<br>  排它锁，一个事务对一行的排他读写锁。<br>③意向锁的作用 <a href="https://blog.csdn.net/sinat_36748650/article/details/88033383">mysql锁的作用</a></p><h3 id="Bin-log"><a href="#Bin-log" class="headerlink" title="Bin log"></a>Bin log</h3><p><strong>三种数据格式</strong></p><ul><li><strong>statement</strong> 执行的SQL语句</li><li><strong>row</strong>  存放的数据是改变之前和之后的数据，因此日志量较大。</li><li><strong>mix</strong>  混合</li></ul><p><strong>日志刷盘参数</strong>：sync_binlog 值为0，1，N。0不fsync刷盘，1执行fsync刷盘，N表示N次事务提交，进行fsync刷盘</p><p><strong>日志逻辑</strong>：log buffer  -》 os cache  -》 磁盘 </p><p>Server层日志，跟Redo log结合使用，crashSafe能力，使用的二阶段提交的方式保证数据一致性</p><h3 id="Redo-log和Undo-log"><a href="#Redo-log和Undo-log" class="headerlink" title="Redo log和Undo log"></a>Redo log和Undo log</h3><ul><li>Redo log灾难恢复日志，</li><li>Undo log回滚日志</li></ul><p>Redo log刷盘参数：</p><h3 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h3><p>从库开启一个I/O线程，向主库请求<strong>Binlog</strong>日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到<strong>中继日志（Relay log）</strong>中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</p><h3 id="半同步复制和异步复制"><a href="#半同步复制和异步复制" class="headerlink" title="半同步复制和异步复制"></a>半同步复制和异步复制</h3><ul><li>异步复制：<strong>主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能会造成数据的不一致。</strong>主库提交一个事务并写入到Binlog，当日志还未传入从库时，主库宕机了或因磁盘损坏等故障导致该事务的Binlog丢失了，那从库就不会得到这个事务，也就造成了主从数据的不一致</li><li>半同步复制: 当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，所以这样就保证了一个事务至少有两份日志，一份保存在主库的Binlog，另一份保存在其中一个从库的Relay-log中，从而保证了数据的安全性和一致性。</li></ul><blockquote><p>在半同步复制时，如果主库的一个事务提交成功了，在推送到从库的过程当中，从库宕机了或网络故障，导致从库并没有接收到这个事务的Binlog，此时主库会等待一段时间（这个时间由rpl_semi_sync_master_timeout的毫秒数决定），如果这个时间过后还无法推送到从库，那MySQL会自动从半同步复制切换为异步复制，当从库恢复正常连接到主库后，主库又会自动切换回半同步复制。</p></blockquote><p>复制架构</p><ul><li>一主多从模式：当从节点变多之后，每个从库在主库上都会有一个独立的Binlog Dump线程来推送binlog日志，所以随着从库数量的增加，主库的IO压力和网络压力也会随之增加。</li><li>多级复制模式：主从直接，增加一个中间节点，由中间节点，进行数据同步，<strong>以此来减轻一级主库的推送压力。</strong>经过两次复制才能到达从库，增加了复制的延时。</li><li>双主模式：主从切换场景，可以理解为高可用。当数据未同步时，主挂了之后，从作为主节点。当从节点恢复时，二个节点数据已不一致，此时数据复制，保证数据一致。</li></ul><h3 id="MySQL相关文章"><a href="#MySQL相关文章" class="headerlink" title="MySQL相关文章"></a>MySQL相关文章</h3><p><a href="https://blog.csdn.net/keil_wang/article/details/88669587">https://blog.csdn.net/keil_wang/article/details/88669587</a><br><a href="https://www.cnblogs.com/mao3714/p/8734838.html">https://www.cnblogs.com/mao3714/p/8734838.html</a></p><p><a href="http://blog.itpub.net/22664653/viewspace-1063134/">http://blog.itpub.net/22664653/viewspace-1063134/</a><br><a href="https://blog.csdn.net/u010833547/article/details/109293213">https://blog.csdn.net/u010833547/article/details/109293213</a><br><a href="https://www.cnblogs.com/klvchen/p/10861850.html">https://www.cnblogs.com/klvchen/p/10861850.html</a><br><a href="https://www.xz577.com/j/22908.html">https://www.xz577.com/j/22908.html</a><br><a href="https://blog.csdn.net/weixin_45701550/article/details/111145914">https://blog.csdn.net/weixin_45701550/article/details/111145914</a><br><a href="https://blog.csdn.net/weixin_42512836/article/details/113388876">https://blog.csdn.net/weixin_42512836/article/details/113388876</a><br><a href="https://cxyroad.blog.csdn.net/article/details/103790555">https://cxyroad.blog.csdn.net/article/details/103790555</a><br><a href="https://blog.csdn.net/z69183787/article/details/107188434">https://blog.csdn.net/z69183787/article/details/107188434</a><br><a href="https://www.jianshu.com/p/c53c8ab650b5">https://www.jianshu.com/p/c53c8ab650b5</a></p><h2 id="Binlog同步（Canal）"><a href="#Binlog同步（Canal）" class="headerlink" title="Binlog同步（Canal）"></a>Binlog同步（Canal）</h2><p><a href="https://blog.csdn.net/yehongzhi1994/article/details/107880162">Canal入门</a><br><a href="https://blog.csdn.net/yehongzhi1994/article/details/108034330">Canal集成Kafka到Redis</a><br>消息顺序问题：MySQL的Binlog保证了顺序性，因此只需要使到达MQ的数据能保证顺序性即可。Kafka可以指定Partition或者Key<br><a href="https://blog.csdn.net/fomeiherz/article/details/103054693">Canal高可用集群搭建</a><br><a href="https://www.cnblogs.com/caoweixiong/p/13303862.html">Canal集群实战</a><br><a href="https://blog.csdn.net/fcly2013/article/details/79430484">Canal原理及问题点</a></p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h2 id="多线程作用"><a href="#多线程作用" class="headerlink" title="多线程作用"></a>多线程作用</h2><p>接口归并处理     -》（多个查询互相不影响）<br>大数据量分段处理 -》（大任务拆成小任务）</p><p>并发：单核CPU并发交替处理<br>并行：多核CPU并行处理</p><h2 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h2><p><a href="https://blog.csdn.net/lijing742180/article/details/81158008">https://blog.csdn.net/lijing742180/article/details/81158008</a><br><a href="https://www.cnblogs.com/LZHOO97/p/12689089.html">https://www.cnblogs.com/LZHOO97/p/12689089.html</a><br><a href="https://testerhome.com/topics/26890">https://testerhome.com/topics/26890</a><br><a href="https://testerhome.com/articles/20770">https://testerhome.com/articles/20770</a><br><a href="https://my.oschina.net/u/3519247/blog/4448724">https://my.oschina.net/u/3519247/blog/4448724</a><br><a href="https://www.cnblogs.com/imyalost/p/7733386.html">https://www.cnblogs.com/imyalost/p/7733386.html</a><br><a href="https://www.cnblogs.com/imyalost/p/7751981.html">https://www.cnblogs.com/imyalost/p/7751981.html</a><br><a href="https://www.cnblogs.com/paulwinflo/p/4872018.html">https://www.cnblogs.com/paulwinflo/p/4872018.html</a></p><p>面试突击第一季 第二季<br>面试突击系列课程笔记存放在儒猿技术窝官方码云仓库<br>链接：<a href="https://gitee.com/shishan100/Java-Interview-Advanced">https://gitee.com/shishan100/Java-Interview-Advanced</a><br>烦请随手给一个star</p><p>面试突击 第三季笔记：<br>有的笔记就是跟那一讲的视频放在一起的，有的笔记是发在公众号石杉的架构笔记的，会在那一讲视频对应的笔记里说明、<br>（ 每一节课程详情点击进去，然后点击“详情” 这个tab 。往下拉，下面就是笔记了）</p><p>面试突击三，java高级部分资料地址<br><a href="https://www.jianguoyun.com/p/DfTsrhgQwe6LCRjondUD">https://www.jianguoyun.com/p/DfTsrhgQwe6LCRjondUD</a></p><h2 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;match **&gt;</span><br><span class="line">   @type elasticsearch</span><br><span class="line">   @log_level &quot;info&quot;</span><br><span class="line">   include_tag_key true</span><br><span class="line">   hosts &quot;http:&#x2F;&#x2F;10.16.32.197:9200,http:&#x2F;&#x2F;10.16.33.39:9200,http:&#x2F;&#x2F;10.16.33.215:9200&quot;</span><br><span class="line">   logstash_format true</span><br><span class="line">   logstash_prefix &quot;order-center-prod&quot;</span><br><span class="line">   logstash_dateformat &quot;%Y.%m.%d&quot;</span><br><span class="line">   type_name &quot;fluentd&quot;</span><br><span class="line">   &lt;buffer&gt;</span><br><span class="line">     @type &quot;file&quot;</span><br><span class="line">     path &quot;&#x2F;var&#x2F;log&#x2F;fluentd-buffers&#x2F;*.buffer&quot;</span><br><span class="line">     flush_mode interval</span><br><span class="line">     retry_type exponential_backoff</span><br><span class="line">     flush_thread_count 2</span><br><span class="line">     flush_interval 5s</span><br><span class="line">     retry_forever </span><br><span class="line">     retry_max_interval 30</span><br><span class="line">     chunk_limit_size 2M</span><br><span class="line">     queue_limit_length 8</span><br><span class="line">     overflow_action block</span><br><span class="line">   &lt;&#x2F;buffer&gt;</span><br><span class="line"> &lt;&#x2F;match&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>熔断限流隔离降级之Hystrix</title>
      <link href="2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/"/>
      <url>2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/javaer_lee/article/details/87942816">Hystrix的线程池隔离和信号量隔离</a><br><a href="https://www.cnblogs.com/ming-blogs/p/14596721.html">Hystrix隔离区别</a></p><p><img src="/2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/image-20210527114240029.png" alt="image-20210527114240029"></p><p>信号量的调用是同步的，也就是说，每次调用都得阻塞调用方的线程，直到结果返回。这样就导致了无法对访问做超时（只能依靠调用协议超时，无法主动释放）</p><p><img src="/2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/image-20210527114658951.png" alt="image-20210527114658951"></p><p><img src="/2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/image-20210714111632368.png" alt="image-20210714111632368"></p><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><ol><li>当Hystrix Command请求后端服务失败数量超过一定比例(默认50%)，断路器会切换到开路状态(Open)；此时所有请求会直接失败而不会发送到后端服务.；</li><li>断路器保持在开路状态一段时间后(默认5秒),，自动切换到半开路状态(HALF-OPEN)，这时熔断器只允许一个请求通过.；</li><li>当该请求调用成功时,，熔断器恢复到关闭状态， 若该请求失败, 熔断器继续保持打开状态,，接下来的请求被禁止通过；</li><li>如此循环反复</li></ol><h2 id="异步RPC"><a href="#异步RPC" class="headerlink" title="异步RPC"></a>异步RPC</h2><p>异步RPC主要目的是提高并发，比如你的接口，内部调用了3个服务，时间分别为T1, T2, T3。如果是顺序调用，则总时间是T1 + T2 + T3；如果并发调用，总时间是Max(T1,T2,T3)。</p><p>当然，这里有1个前提条件，这3个调用直接，互相不依赖。</p><p>同样，一般成熟的RPC框架，本身都提高了异步化接口，Future或者Callback形式。</p><p>同样，Hystrix也提高了同步调用、异步调用方式</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熔断限流隔离降级之Sentinel</title>
      <link href="2021/05/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BSentinel/"/>
      <url>2021/05/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BSentinel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Sentinel 是面向分布式服务架构的高可用防护组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障微服务的稳定性。</p></blockquote><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。<br>在接下来的文档中，我们都会用资源来描述代码块。</p><p>只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><h2 id="流量控制规则"><a href="#流量控制规则" class="headerlink" title="流量控制规则"></a>流量控制规则</h2><p>限流行为控制（流量控制）流量控制、整形</p><p><img src="/2021/05/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BSentinel/sentinel-flow-index-overview-cn.jpg" alt="img"></p><h3 id="流量控制有以下几个角度"><a href="#流量控制有以下几个角度" class="headerlink" title="流量控制有以下几个角度:"></a>流量控制有以下几个角度:</h3><p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；<br>运行指标，例如 QPS、线程池、系统负载等；<br>控制的效果，例如直接限流、冷启动、排队等。<br>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h2 id="隔离规则-流量控制"><a href="#隔离规则-流量控制" class="headerlink" title="隔离规则(流量控制)"></a>隔离规则(流量控制)</h2><p>服务隔离，避免影响到其它的资源，防止服务雪崩<br>隔离(流量控制)： 线程数(0: thread count)，qps(1: QPS)</p><ul><li><p>线程数（信号量）：当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p></li><li><p><code>QPS</code>（每秒请求数）：时间窗口内，请求的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rate limiter control behavior.</span></span><br><span class="line"><span class="comment"> * 0. default(reject directly), 1. warm up(冷启动), 2. rate limiter(匀速器,漏桶算法), 3. warm up + rate limiter</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://sentinelguard.io/zh-cn/docs/flow-control.html#%E5%9F%BA%E4%BA%8E%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">基于调用关系的流量控制</a></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flow control strategy based on invocation chain.  //流控策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RuleConstant#STRATEGY_DIRECT&#125; for direct flow control (by origin);  //调用方限流</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RuleConstant#STRATEGY_RELATE&#125; for relevant flow control (with relevant resource); //关联流量控制</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RuleConstant#STRATEGY_CHAIN&#125; for chain flow control (by entrance resource).  //链路限流</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="熔断规则"><a href="#熔断规则" class="headerlink" title="熔断规则"></a>熔断规则</h2><p>熔断降级，快速失败，避免影响到其它的资源，最终产生雪崩的效果（默认慢请求数量为5，默认最小请求数量为5）</p><ul><li>响应时间：通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</li><li>异常比例：</li><li>异常数：</li></ul><h2 id="权限规则"><a href="#权限规则" class="headerlink" title="权限规则"></a>权限规则</h2><p>AUTHORITY_WHITE  白名单规则<br>AUTHORITY_BLACK  黑名单规则</p><h2 id="系统负载保护规则"><a href="#系统负载保护规则" class="headerlink" title="系统负载保护规则"></a>系统负载保护规则</h2><p>Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。<br>在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之引用</title>
      <link href="2021/05/13/java%E4%B9%8B%E5%BC%95%E7%94%A8/"/>
      <url>2021/05/13/java%E4%B9%8B%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="java引用"><a href="#java引用" class="headerlink" title="java引用"></a>java引用</h2><ul><li>强引用：在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用：<code>SoftReference</code>用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常</li><li>弱引用：<code>WeakReference</code>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用：<code>PhantomReference</code>也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知<br><img src="/2021/05/13/java%E4%B9%8B%E5%BC%95%E7%94%A8/647994-20170215235519441-1287012986.png" alt="img"></li></ul><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><ul><li><p>弱引用的构造函数有二个，带引用队列的参数和不带引用队列的参数（<code>ReferenceQueue</code>）。如果带引用队列，当回收时，会将对象存入引用队列。</p></li><li><p>弱引用的构造函数有二个，带引用队列的参数和不带引用队列的参数（<code>ReferenceQueue</code>）。如果带引用队列，当回收时，会将对象存入引用队列。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控之Micrometer</title>
      <link href="2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BMicrometer/"/>
      <url>2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BMicrometer/</url>
      
        <content type="html"><![CDATA[<h2 id="Micrometer-简介"><a href="#Micrometer-简介" class="headerlink" title="Micrometer 简介"></a>Micrometer 简介</h2><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，它提供了多种度量指标类型（Timers、Guauges、Counters等），同时支持接入不同的监控系统，例如 Influxdb、Graphite、Prometheus 等。我们可以通过 Micrometer 收集 Java 性能数据，配合 Prometheus 监控系统实时获取数据，并最终在 Grafana 上展示出来，从而很容易实现应用的监控。</p><p>Micrometer 中有两个最核心的概念，分别是计量器（Meter）和计量器注册表（MeterRegistry）。计量器用来收集不同类型的性能指标信息，Micrometer 提供了如下几种不同类型的计量器：</p><ul><li>计数器（Counter）: 表示收集的数据是按照某个趋势（增加／减少）一直变化的，也是最常用的一种计量器，例如接口请求总数、请求错误总数、队列数量变化等。</li><li>计量仪（Gauge）: 表示搜集的瞬时的数据，可以任意变化的，例如常用的 CPU Load、Mem 使用量、Network 使用量、实时在线人数统计等，</li><li>计时器（Timer）: 用来记录事件的持续时间，这个用的比较少。</li><li>分布概要（Distribution summary）: 用来记录事件的分布情况，表示一段时间范围内对数据进行采样，可以用于统计网络请求平均延迟、请求延迟占比等。</li></ul><h2 id="MeterRegistry"><a href="#MeterRegistry" class="headerlink" title="MeterRegistry"></a>MeterRegistry</h2><p>MeterRegistry在Micrometer是一个抽象类，主要实现包括：</p><ul><li>SimpleMeterRegistry：每个Meter的最新数据可以收集到SimpleMeterRegistry实例中，但是这些数据不会发布到其他系统，也就是数据是位于应用的内存中的。</li><li>CompositeMeterRegistry：多个MeterRegistry聚合，内部维护了一个MeterRegistry的列表。</li><li>全局的MeterRegistry：工厂类io.micrometer.core.instrument.Metrics中持有一个静态final的CompositeMeterRegistry实例globalRegistry。</li></ul><blockquote><p>使用者也可以自行继承MeterRegistry去实现自定义的MeterRegistry。</p></blockquote><p>SimpleMeterRegistry适合做调试的时候使用，它的简单使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MeterRegistry registry = <span class="keyword">new</span> SimpleMeterRegistry();</span><br><span class="line">Counter counter = registry.counter(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">counter.increment();</span><br></pre></td></tr></table></figure><p>CompositeMeterRegistry实例初始化的时候，内部持有的MeterRegistry列表是空的，如果此时用它新增一个Meter实例，Meter实例的操作是无效的</p><p>CompositeMeterRegistry实例初始化的时候，内部持有的MeterRegistry列表是空的，如果此时用它新增一个Meter实例，Meter实例的操作是无效的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompositeMeterRegistry composite = <span class="keyword">new</span> CompositeMeterRegistry();</span><br><span class="line">Counter compositeCounter = composite.counter(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">compositeCounter.increment(); <span class="comment">// &lt;- 实际上这一步操作是无效的,但是不会报错</span></span><br><span class="line"></span><br><span class="line">SimpleMeterRegistry simple = <span class="keyword">new</span> SimpleMeterRegistry();</span><br><span class="line">composite.add(simple); <span class="comment">// &lt;- 向CompositeMeterRegistry实例中添加SimpleMeterRegistry实例</span></span><br><span class="line"></span><br><span class="line">compositeCounter.increment(); <span class="comment">// &lt;-计数成功</span></span><br></pre></td></tr></table></figure><p>全局的MeterRegistry的使用方式更加简单便捷，因为一切只需要操作工厂类Metrics的静态方法：</p><p>全局的MeterRegistry的使用方式更加简单便捷，因为一切只需要操作工厂类Metrics的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">Counter counter = Metrics.counter(<span class="string">&quot;counter&quot;</span>, <span class="string">&quot;tag-1&quot;</span>, <span class="string">&quot;tag-2&quot;</span>);</span><br><span class="line">counter.increment();</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_20161461/article/details/109049911">Micrometer集成 Prometheus 监控 Java 应用性能</a></p><p><img src="/2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BMicrometer/image-20210728141151918.png" alt="image-20210728141151918"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
            <tag> Micrometer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熔断限流隔离降级之对比</title>
      <link href="2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8B%E5%AF%B9%E6%AF%94/"/>
      <url>2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8B%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="Hystrix具有的功能"><a href="#Hystrix具有的功能" class="headerlink" title="Hystrix具有的功能"></a><strong>Hystrix具有的功能</strong></h2><ul><li>线程池隔离/信号量隔离    Sentinel 不支持线程池隔离；信号量隔离对应 Sentinel 中的线程数限流。</li><li>熔断器    Sentinel 支持按平均响应时间、异常比率、异常数来进行熔断降级。</li><li>Command 创建    直接使用 Sentinel SphU API 定义资源即可，资源定义与规则配置分离。</li><li>规则配置    在 Sentinel 中可通过 API 硬编码配置规则，也支持多种动态规则源</li><li>注解支持    Sentinel 也提供注解支持</li><li>开源框架支持    Sentinel 提供 Servlet、Dubbo、Spring Cloud、gRPC 的适配模块，开箱即用；若之前使用 Spring Cloud Netflix，可迁移至 Spring Cloud Alibaba</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th align="left">功能</th><th align="left">Sentinel</th><th align="left">Hystrix</th><th align="left">Resilience4j</th></tr></thead><tbody><tr><td align="left">隔离策略</td><td align="left">信号量隔离（并发线程数限流），QPS</td><td align="left">线程池隔离/信号量隔离</td><td align="left">信号量隔离/线程池</td></tr><tr><td align="left">熔断降级策略</td><td align="left">基于响应时间、异常比率、异常数</td><td align="left">基于异常比率</td><td align="left">基于异常比率、响应时间</td></tr><tr><td align="left">实时统计实现</td><td align="left">滑动窗口（LeapArray）</td><td align="left">滑动窗口（基于 RxJava）</td><td align="left">Ring Bit Buffer</td></tr><tr><td align="left">动态规则配置</td><td align="left">支持多种数据源</td><td align="left">支持多种数据源</td><td align="left">有限支持</td></tr><tr><td align="left">扩展性</td><td align="left">多个扩展点</td><td align="left">插件的形式</td><td align="left">接口的形式</td></tr><tr><td align="left">基于注解的支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">限流</td><td align="left">基于 QPS，支持基于调用关系的限流</td><td align="left">有限的支持</td><td align="left">Rate Limiter（信号量、令牌桶）</td></tr><tr><td align="left">流量整形</td><td align="left">支持预热模式、匀速器模式、预热排队模式(流量规则处可配置)</td><td align="left">不支持</td><td align="left">简单的 Rate Limiter 模式</td></tr><tr><td align="left">系统自适应保护</td><td align="left">支持</td><td align="left">不支持</td><td align="left">不支持</td></tr><tr><td align="left">控制台</td><td align="left">提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td><td align="left">简单的监控查看</td><td align="left">不提供控制台，可对接其它监控系统</td></tr></tbody></table><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h2><ol><li><a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7">https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7</a></li><li><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">https://github.com/Netflix/Hystrix/wiki/How-it-Works</a></li><li><a href="https://github.com/alibaba/Sentinel/wiki/Guideline:-%E4%BB%8E-Hystrix-%E8%BF%81%E7%A7%BB%E5%88%B0-Sentinel#%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94">https://github.com/alibaba/Sentinel/wiki/Guideline:-%E4%BB%8E-Hystrix-%E8%BF%81%E7%A7%BB%E5%88%B0-Sentinel#%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hystrix </tag>
            
            <tag> Resilience4j </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熔断限流隔离降级之Resilience4j入门</title>
      <link href="2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BResilience4j%E5%85%A5%E9%97%A8/"/>
      <url>2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BResilience4j%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="重要参考资料"><a href="#重要参考资料" class="headerlink" title="重要参考资料"></a>重要参考资料</h2><p><a href="https://resilience4j.readme.io/docs">官网</a><br><strong><a href="https://www.jianshu.com/p/5531b66b777a">Resilience4j-轻量级熔断框架</a></strong> </p><h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><ul><li><strong><em>resilience4j-circuitbreaker: Circuit breaking</em></strong> 熔断器（超过故障率的熔断）</li><li><strong><em>resilience4j-ratelimiter: Rate limiting</em></strong>  限流（高频控制是可以限制服务调用频率）一个是基于信号量的，一个是基于令牌桶的</li><li><strong><em>resilience4j-bulkhead: Bulkheading</em></strong>    一种是基于信号量的*<strong>Bulkhead**<em>，另一种是基于有等待队列的固定大小的线程池</em></strong>ThreadPoolBulkhead***的（降级）</li><li><strong><em>resilience4j-retry: Automatic retrying (sync and async)</em></strong>   重试</li><li><strong><em>resilience4j-cache: Result caching</em></strong></li><li><strong><em>resilience4j-timelimiter: Timeout handling</em></strong>  超时控制器（）</li></ul><h2 id="监控模块"><a href="#监控模块" class="headerlink" title="监控模块"></a>监控模块</h2><ul><li>resilience4j-micrometer: Micrometer Metrics exporter</li><li>resilience4j-metrics: Dropwizard Metrics exporter</li><li>resilience4j-prometheus: Prometheus Metrics exporter</li></ul><h2 id="熔断-CircuitBreaker"><a href="#熔断-CircuitBreaker" class="headerlink" title="熔断 CircuitBreaker"></a>熔断 CircuitBreaker</h2><p><code>CircuitBreaker</code>通过具有三种正常状态的有限状态机实现：CLOSED，OPEN和HALF_OPEN以及两个特殊状态DISABLED和FORCED_OPEN。当熔断器关闭时，所有的请求都会通过熔断器。如果失败率超过设定的阈值，熔断器就会从关闭状态转换到打开状态，这时所有的请求都会被拒绝。当经过一段时间后，熔断器会从打开状态转换到半开状态，这时仅有一定数量的请求会被放入，并重新计算失败率，如果失败率超过阈值，则变为打开状态，如果失败率低于阈值，则变为关闭状态。</p><p>可以在注解上使用属性：<code>fallbackMethod = &quot;getDefaultGirlById&quot;</code>指定降级的方法</p><h2 id="RateLimiter、Bulkhead、Retry详解"><a href="#RateLimiter、Bulkhead、Retry详解" class="headerlink" title="RateLimiter、Bulkhead、Retry详解"></a><a href="https://www.jianshu.com/p/36b381e2b57e">RateLimiter、Bulkhead、Retry详解</a></h2><h3 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a><code>RateLimiter</code></h3><ul><li><code>SemaphoreBasedRateLimiter</code>使用一个计数信号量，当请求超过计数值，则在超时时间内等待，基于*<strong>java concurrent**<em>并发包中的</em></strong>Semaphore***实现</li><li><code>AtomicRateLimiter</code> 令牌桶</li></ul><p>令牌桶是*<strong>RateLimeter**<em>默认的实现，它的好处是比信号量的</em></strong>RateLimeter*<strong>更高效，因为桶中的令牌可以被减为负数，它会提前计算在限定时间内能否拿到令牌，而不是信号量为**<em>0</em></strong>之后就一直阻塞。</p><h3 id="Bulkhead"><a href="#Bulkhead" class="headerlink" title="Bulkhead"></a><code>Bulkhead</code></h3><ul><li>信号量*<strong>Bulkhead**<em>,基于</em></strong>java concurrent*<strong>并发包中的**<em>Semaphore</em></strong>实现</li><li>固定线程池*<em>ThreadPoolBulkhead**</em></li></ul><h3 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a><code>Retry</code></h3><p>一种实现类</p><h2 id="降级-Fallback"><a href="#降级-Fallback" class="headerlink" title="降级 Fallback"></a>降级 Fallback</h2><p><code>fallback</code>和前面讲解的组件不同，它不是组件，只是Resilience4j里面都会用到的方法。不管是熔断、重试、流控还是隔离等，一旦触发的限制规则，都可以降级执行我们定义好的降级方法。</p><p>Try 有 isFailure() 和 isSuccess() ，返回Boolean值，用来判断 Resilience4j 是否成功。</p><p>Try接口有个默认的方法recover，用来实现fallback，它首先判断是不是方法调用失败，如果是才执行fallback方法。例如上文的Bulkhead的代码，可以设置降级时返回错误日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try&lt;String&gt; result = Try.of(decoratedSupplier)</span><br><span class="line">               .recover(throwable -&gt; <span class="string">&quot;错误日志为：&quot;</span>+throwable.getMessage());</span><br><span class="line">       <span class="keyword">return</span> result.get();</span><br></pre></td></tr></table></figure><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//断路器监控</span></span><br><span class="line">CircuitBreaker.Metrics metrics = circuitBreaker.getMetrics();</span><br><span class="line"><span class="comment">// 获取故障率</span></span><br><span class="line"><span class="keyword">float</span> failureRate = metrics.getFailureRate();</span><br><span class="line"><span class="comment">// 获取调用失败次数</span></span><br><span class="line"><span class="keyword">int</span> failedCalls = metrics.getNumberOfFailedCalls();</span><br><span class="line"><span class="comment">// Returns the failure rate in percentage.</span></span><br><span class="line"><span class="keyword">float</span> failureRate = metrics.getFailureRate();</span><br><span class="line"><span class="comment">// Returns the current number of buffered calls.</span></span><br><span class="line"><span class="keyword">int</span> bufferedCalls = metrics.getNumberOfBufferedCalls();</span><br><span class="line"><span class="comment">// Returns the current number of failed calls.</span></span><br><span class="line"><span class="keyword">int</span> failedCalls = metrics.getNumberOfFailedCalls();</span><br><span class="line"><span class="comment">// Returns the current number of successed calls.</span></span><br><span class="line"><span class="keyword">int</span> successCalls = metrics.getNumberOfSuccessfulCalls();</span><br><span class="line"><span class="comment">// Returns the max number of buffered calls.</span></span><br><span class="line"><span class="keyword">int</span> maxBufferCalls = metrics.getMaxNumberOfBufferedCalls();</span><br><span class="line"><span class="comment">// Returns the current number of not permitted calls.</span></span><br><span class="line"><span class="keyword">long</span> notPermittedCalls = metrics.getNumberOfNotPermittedCalls();</span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="https://github.com/wangchao1980/demo-resilience4j">基于注解实现</a></p><ul><li>@CircuitBreaker(name = “girl”, fallbackMethod = “getDefaultGirlById”)</li><li>@RateLimiter(name = “girl”)</li><li>@Bulkhead(name = “girl”)</li><li>@Retry(name = “girl”) 放在类上</li></ul><p><a href="https://segmentfault.com/a/1190000022908483">java编程式使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Resilience4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之哈希冲突详解</title>
      <link href="2021/05/07/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/07/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="如何解决哈希冲突"><a href="#如何解决哈希冲突" class="headerlink" title="如何解决哈希冲突"></a><strong>如何解决哈希冲突</strong></h2><p><strong>1 开放寻址法</strong></p><p>开放寻址得核心思想是，如果出现散列冲突，我们就重新探测一个空闲位置，将其插入。</p><p><strong>开放寻址方法一：线性探测</strong><br><strong>开放寻址方法二：二次探测</strong><br><strong>开放寻址方法三：双重散列</strong></p><p><strong>2 链表法</strong></p><p>扩展1：word文档中单词拼写如何实现</p><p>常用得英文单词有20w个左右，假设单词得平均长度是10个字母，平均一个单词占用10个字节得内存空间，那20w也才2MB左右，就算扩大10倍也才20MB.对于现在得计算机来说，这个大小完全可以放在内存里面，所以我们可以用散列表来存储整个英文单词词典，当用于输入某个英文单词得时候，我们拿用户输入得单词去散列表中查找，如果查到，则说明拼写正确，如果没有查找到，则说明查找可能有误给与提示，借助散列表这种数据结构，我们就可以轻松实现快速判读是否存在拼写错误。</p><p>扩展2：假设我们有10w条url访问日志，如何按照访问次数给url排序</p><p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p><p>扩展3：有两个字符串数组，每个数组大约有10w条字符串，如何快速找到两个数组中相同得字符串</p><p>将一个字符串数组作为一个散列表，然后用另一个字符串数组得查找，如果有则找到，没有位NULL。</p><p>原文链接：<a href="https://blog.csdn.net/qq_38635597/article/details/88692008">https://blog.csdn.net/qq_38635597/article/details/88692008</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之ThreadLocal详解</title>
      <link href="2021/05/06/java%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/06/java%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal解读"><a href="#ThreadLocal解读" class="headerlink" title="ThreadLocal解读"></a><a href="https://juejin.cn/post/6950541060892262431">ThreadLocal解读</a></h2><p>每<code>Thread</code>维护一个<code>ThreadLocal.ThreadLocalMap</code>类型的变量<code>threadLocals</code>和 <code>ThreadLocal.ThreadLocalMap inheritableThreadLocals</code>。而<code>ThreadLocalMap</code>是<code>ThreadLocal</code>内部类，<code>ThreadLocalMap</code>内部又有一个继承了<code>WeakReference</code>的内部类<code>Entry</code>，存放<code>key-valued</code>的，从继承关系看<code>key</code>是<code>ThreadLocal</code>类型的对象引用，且是弱引用（<strong>记住<code>key</code>是弱引用很关键</strong>）。ThreadLocalMap使用开放寻址的方式解决哈希冲突。</p><p><em>解决哈希冲突的办法：开放寻址 和链表</em></p><ul><li><code>ThreadLocal</code>让每个线程访问自己本地的变量来确保线程安全。</li><li>每一个线程维护一个<code>ThreadLocalMap</code>，简易版的<code>HashMap</code>，<code>key</code>为<code>ThradLocal</code>实例引用，解决哈希冲突的方式是开放寻址法，所以不适合存大量数据。</li><li>get和set过程中都会清理过时的数据（key=null），为了防止内存泄漏，但是不一定会清理掉所有的过时数据，不然会影响正常操作性能。</li><li>使用完<code>ThreadLocal</code>一定要调用<code>remove</code>，不然会内存泄漏，因为key是弱引用会被下次gc，而value的强引用会一直存在，若线程一直不销毁，value就一直不gc掉，导致内存泄漏。</li></ul><h2 id="InheritableThreadLocal源码解析"><a href="#InheritableThreadLocal源码解析" class="headerlink" title="InheritableThreadLocal源码解析"></a><a href="https://juejin.cn/post/6950543994166181924">InheritableThreadLocal源码解析</a></h2><p>Thread初始化，会调用一个<code>init()</code>。当父类的<code>inheritableThreadLocals</code>不为null，会将父线程的map复制给子线程</p><ul><li><code>InheritableThreadLocal</code>可以实现子线程获取父线程的本地变量。</li><li>子线程初始化时，若父线程（当前线程）的本地变量<code>inheritableThreadLocals</code>不为null，则复制给子线程。</li><li><code>ThreadLocal</code>留个<code>childValue</code>的用意，就是让<code>InheritableThreadLocal</code>实现，并且可以让客户端自定义重写<code>childValue</code>对从父线程复制到子线程的值做特殊处理。</li><li>若父线程使用<code>InheritableThreadLocal</code>设置了自定义引用类型的值，复制给子线程时存在并发问题，需要自行实现<code>childValue</code>的深拷贝。</li></ul><p>如果使用线程池创建子线程，子线程只会初始化一次，父线程中使用<code>InheritableThreadLocal</code>设置值，因为复制机制是在线程初始化的时候，那么父线程只有在线程池初始化子线程时同步复制一次数据，后续父线程再修改值，就无法同步更新到线程池中的子线程了，这该怎么办呢？</p><p>只要在每次提交任务时复制就可以了，这就要对线程池以及<code>InheritableThreadLocal</code>做一些定制化处理，让复制机制放在每次提交任务的时候，阿里有一个开源项目给出了解决方案</p><h2 id="TransmittableThreadLocal原理"><a href="#TransmittableThreadLocal原理" class="headerlink" title="TransmittableThreadLocal原理"></a><a href="https://github.com/alibaba/transmittable-thread-local">TransmittableThreadLocal原理</a></h2><p><code>JDK</code>的<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/InheritableThreadLocal.html"><code>InheritableThreadLocal</code></a>类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong>。</p><p>本库提供的<a href="https://github.com/alibaba/transmittable-thread-local/blob/master/src/main/java/com/alibaba/ttl/TransmittableThreadLocal.java"><code>TransmittableThreadLocal</code></a>类继承并加强<code>InheritableThreadLocal</code>类，解决上述的问题</p><p>整个<code>TransmittableThreadLocal</code>库的核心功能（用户<code>API</code>与框架/中间件的集成<code>API</code>、线程池<code>ExecutorService</code>/<code>ForkJoinPool</code>/<code>TimerTask</code>及其线程工厂的<code>Wrapper</code>）</p><p><code>ThreadLocal</code>的需求场景即<code>TransmittableThreadLocal</code>的潜在需求场景，如果你的业务需要『在使用线程池等会池化复用线程的执行组件情况下传递<code>ThreadLocal</code>值』则是<code>TransmittableThreadLocal</code>目标场景。</p><p>下面是几个典型场景例子。</p><ol><li>分布式跟踪系统 或 全链路压测（即链路打标）</li><li>日志收集记录系统上下文</li><li><code>Session</code>级<code>Cache</code></li><li>应用容器或上层框架跨应用代码给下层<code>SDK</code>传递信息</li></ol><p>使用类<a href="https://github.com/alibaba/transmittable-thread-local/blob/master/src/main/java/com/alibaba/ttl/TransmittableThreadLocal.java"><code>TransmittableThreadLocal</code></a>来保存值，并跨线程池传递。</p><p><code>TransmittableThreadLocal</code>继承<code>InheritableThreadLocal</code>，使用方式也类似。相比<code>InheritableThreadLocal</code>，添加了</p><ol><li><code>copy</code>方法<br>用于定制 <strong>任务提交给线程池时</strong> 的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong> 的拷贝行为，缺省传递的是引用。<br>注意：如果跨线程传递了对象引用因为不再有线程封闭，与<code>InheritableThreadLocal.childValue</code>一样，使用者/业务逻辑要注意传递对象的线程安全。</li><li><code>protected</code>的<code>beforeExecute</code>/<code>afterExecute</code>方法<br>执行任务(<code>Runnable</code>/<code>Callable</code>)的前/后的生命周期回调，缺省是空操作。</li></ol><h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a><a href="https://blog.csdn.net/thewindkee/article/details/89390145">为什么使用弱引用</a></h2><p>从表面上看，发生内存泄漏，是因为Key使用了弱引用类型。但其实是因为整个Entry的key为null后，没有主动清除value导致。很多文章大多分析ThreadLocal使用了弱引用会导致内存泄漏，但为什么使用弱引用而不是强引用？</p><p>下面我们分两种情况讨论：</p><ul><li>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li><li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</li></ul><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。</p><p><font color="red"><strong>当threadLocal 不为静态变量，且被回收的时候才会导致weakRef为null。</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之并发编程-MESI缓存一致性协议</title>
      <link href="2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BMESI%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BMESI%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6878226618318323726">https://juejin.cn/post/6878226618318323726</a></p><p><a href="https://www.cnblogs.com/yanlong300/p/8986041.html?utm_source=so">https://www.cnblogs.com/yanlong300/p/8986041.html?utm_source=so</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 硬件原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之并发编程</title>
      <link href="2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多任务和高并发的内存交互"><a href="#多任务和高并发的内存交互" class="headerlink" title="多任务和高并发的内存交互"></a>多任务和高并发的内存交互</h2><p>多任务和高并发是衡量一台计算机处理器的能力重要指标之一。一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。<strong>物理机</strong>的并发问题与<strong>虚拟机</strong>中的情况有很多相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p><h2 id="硬件内存模型"><a href="#硬件内存模型" class="headerlink" title="硬件内存模型"></a>硬件内存模型</h2><p>由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的<strong>高速缓存（cache）</strong>来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：<strong>缓存一致性（Cache Coherence）</strong>。</p><p>在早期通过总线上加LOCK#锁的形式来解决缓存不一致的问题。因为<font color="red">CPU和其他部件进行通信都是通过总线来进行的</font>，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。<font color="red">由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</font></p><p>在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、Intel 的MESI、MOSI及Dragon Protocol等。MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。<a href="https://juejin.cn/post/6878226618318323726">MESI缓存一致性协议详解</a></p><p><img src="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20160507133204381" alt="物理机内存交互关系"></p><p>除此之外，为了使得处理器内部的运算单元能尽可能被充分利用，处理器可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）</strong>优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的<strong>指令重排序（Instruction Recorder）</strong>优化。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a><font color="red">Java内存模型</font></h2><p>内存模型可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象，不同架构下的物理机拥有不一样的内存模型，Java虚拟机也有自己的内存模型，即<strong>Java内存模型（Java Memory Model, <code>JMM</code>）</strong>。在C/C++语言中直接使用物理硬件和操作系统内存模型，导致不同平台下并发访问出错。而JMM的出现，能够屏蔽掉各种硬件和操作系统的内存访问差异，实现平台一致性，是的Java程序能够<strong>“一次编写，到处运行”。</strong></p><p>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题.是一个抽象的概念.</p><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>Java内存模型的主要目标是<strong>定义程序中各个变量的访问规则</strong>，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。</p><p>Java内存模型中规定了所有的变量都存储在主内存（物理内存）中，每条线程还有自己的工作内存（可以与前面讲的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。</p><p><img src="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20160507135725155" alt="img"></p><p><font color="red">注意：这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分，这两者基本上没有关系。</font></p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>由上面的交互关系可知，关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述两个操作<strong>必须按顺序执行，而没有保证必须是连续执行</strong>。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。</p><p><font color="cornflowerblue">Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</font></p><ul><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><p><font color="red">这8种内存访问操作很繁琐，后文会使用一个等效判断原则，即先行发生（happens-before）原则来确定一个内存访问在并发环境下是否安全。</font></p><h2 id="happen-before原则"><a href="#happen-before原则" class="headerlink" title="happen-before原则"></a>happen-before原则</h2><p><font color="red">前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。</font></p><p><font color="red">为了解决多线程的可见性问题，就搞出了happens-before原则，让线程之间遵守这些原则。编译器还会优化我们的语句，所以等于是给了编译器优化的约束。</font></p><p><font color="red"><strong>JVM会对代码进行编译优化，会出现指令重排序情况</strong>，为了避免编译优化对并发编程安全性的影响，<strong>需要happens-before规则定义一些禁止编译优化的场景</strong>，保证并发编程的正确性。</font></p><p>熟悉 Java 并发编程的都知道，JMM(Java 内存模型) 中的 happen-before(简称 hb)规则，该规则定义了 Java 多线程操作的有序性和可见性，防止了编译器重排序对程序结果的影响。<strong>按照官方的说法：</strong></p><p>当一个变量被多个线程读取并且至少被一个线程写入时，如果读操作和写操作没有 HB 关系，则会产生数据竞争问题。 要想保证<code>操作 B</code> 的线程看到<code>操作 A</code> 的结果（无论 <code>A</code> 和 <code>B</code> 是否在一个线程），那么在 <code>A</code> 和 <code>B</code> 之间必须满足 HB 原则，如果没有，将有可能导致重排序。 当缺少 happen-before 关系时，就可能出现重排序问题。原则如下：</p><ol><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：在监视器锁上的解锁操作必须在同一个监视器上的加锁操作之前执行。</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li><strong>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</strong></li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li></ol><p><strong>实现可见性的原理则是 cache protocol 和 memory barrier。通过缓存一致性协议和内存屏障实现可见性。</strong></p><p><font color="red">happen-before 原则是 JMM 的核心所在，只有满足了 hb 原则才能保证有序性和可见性，否则编译器将会对代码重排序。hb 甚至将 lock 和 volatile 也定义了规则。</font></p><h2 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h2><p>关键字volatile是JVM中最轻量的同步机制。volatile变量具有2种特性：</p><ul><li>保证变量的可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入，这个新值对于其他线程来说是立即可见的。</li><li>屏蔽指令重排序：指令重排序是编译器和处理器为了高效对程序进行优化的手段，下文有详细的分析。</li></ul><p>volatile语义并不能保证变量的原子性。对任意单个volatile变量的读/写具有原子性，但类似于i++、i–这种复合操作不具有原子性，因为自增运算包括读取i的值、i值增加1、重新赋值3步操作，并不具备原子性。</p><p>由于volatile只能保证变量的可见性和屏蔽指令重排序，只有满足下面2条规则时，才能使用volatile来保证并发安全，否则就需要加锁（使用synchronized、lock或者java.util.concurrent中的Atomic原子类）来保证并发中的原子性。</p><ul><li>运算结果不存在数据依赖（重排序的数据依赖性），或者只有单一的线程修改变量的值（重排序的as-if-serial语义）</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul><p>因为需要在本地代码中插入许多内存屏蔽指令在屏蔽特定条件下的重排序，volatile变量的写操作与读操作相比慢一些，但是其性能开销比锁低很多。</p><h2 id="long-double非原子协定"><a href="#long-double非原子协定" class="headerlink" title="long/double非原子协定"></a>long/double非原子协定</h2><p>JMM要求lock、unlock、read、load、assign、use、store、write这8个操作都必须具有原子性，但对于64为的数据类型（long和double，具有非原子协定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为2次32位操作进行。（与此类似的是，在栈帧结构的局部变量表中，long和double类型的局部变量可以使用2个能存储32位变量的变量槽（Variable Slot）来存储的，关于这一部分的详细分析，详见详见周志明著《深入理解Java虚拟机》8.2.1节）</p><p>如果多个线程共享一个没有声明为volatile的long或double变量，并且同时读取和修改，某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。不过这种情况十分罕见。因为非原子协议换句话说，同样允许long和double的读写操作实现为原子操作，并且目前绝大多数的虚拟机都是这样做的。</p><h2 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>JMM保证的原子性变量操作包括read、load、assign、use、store、write，而long、double非原子协定导致的非原子性操作基本可以忽略。如果需要对更大范围的代码实行原子性操作，则需要JMM提供的lock、unlock、synchronized等来保证。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>前面分析volatile语义时已经提到，可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。JMM在变量修改后将新值同步回主内存，依赖主内存作为媒介，在变量被线程读取前从内存刷新变量新值，保证变量的可见性。普通变量和volatile变量都是如此，只不过volatile的特殊规则保证了这种可见性是立即得知的，而普通变量并不具备这种严格的可见性。除了volatile外，synchronized和final也能保证可见性。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>JMM的有序性表现为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指“线程内表现为串行的语义”（as-if-serial），后半句值“指令重排序”和普通变量的”工作内存与主内存同步延迟“的现象。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。从硬件架构上来说，指令重排序是指CPU采用了允许将多条指令不按照程序规定的顺序，分开发送给各个相应电路单元处理，而不是指令任意重排。重排序分成三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p><img src="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20160507141035261" alt="重排序"></p><h3 id="JMM的重排序屏障"><a href="#JMM的重排序屏障" class="headerlink" title="JMM的重排序屏障"></a>JMM的重排序屏障</h3><p>从Java源代码到最终实际执行的指令序列，会经过三种重排序。但是，为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。对于编译器的重排序，JMM会根据重排序规则禁止特定类型的编译器重排序；对于处理器重排序，JMM会插入特定类型的内存屏障，通过内存的屏障指令禁止特定类型的处理器重排序。这里讨论JMM对处理器的重排序，为了更深理解JMM对处理器重排序的处理，先来认识一下常见处理器的重排序规则：</p><p><img src="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20160507142016867" alt="重排序屏障"></p><p>其中的N标识处理器不允许两个操作进行重排序，Y表示允许。其中Load-Load表示读-读操作、Load-Store表示读-写操作、Store-Store表示写-写操作、Store-Load表示写-读操作。可以看出：常见处理器对写-读操作都是允许重排序的，并且常见的处理器都不允许对存在数据依赖的操作进行重排序（对应上面数据转换那一列，都是N，所以处理器不允许这种重排序）。</p><h4 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h4><p>那么这个结论对我们有什么作用呢？比如第一点：处理器允许写-读操作两者之间的重排序，那么在并发编程中读线程读到可能是一个未被初始化或者是一个NULL等，出现不可预知的错误，基于这点，JMM会在适当的位置插入内存屏障指令来禁止特定类型的处理器的重排序。内存屏障指令一共有4类：</p><ul><li>LoadLoad Barriers：确保Load1数据的装载先于Load2以及所有后续装载指令</li><li>StoreStore Barriers：确保Store1的数据对其他处理器可见（会使缓存行无效，并刷新到内存中）先于Store2及所有后续存储指令的装载</li><li>LoadStore Barriers：确保Load1数据装载先于Store2及所有后续存储指令刷新到内存</li><li>StoreLoad Barriers：确保Store1数据对其他处理器可见（刷新到内存，并且其他处理器的缓存行无效）先于Load2及所有后续装载指令的装载。该指令会使得该屏障之前的所有内存访问指令完成之后，才能执行该屏障之后的内存访问指令。</li></ul><blockquote><p><strong>写屏障 Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，应用所有已经在存储缓存（store buffer）中的保存的指令。</strong></p></blockquote><blockquote><p><strong>读屏障Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先应用所有已经在失效队列中的失效操作的指令。</strong></p></blockquote><h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>根据上面的表格，处理器不会对存在数据依赖的操作进行重排序。这里数据依赖的准确定义是：如果两个操作同时访问一个变量，其中一个操作是写操作，此时这两个操作就构成了数据依赖。常见的具有这个特性的如i++、i—。如果改变了具有数据依赖的两个操作的执行顺序，那么最后的执行结果就会被改变。这也是不能进行重排序的原因。例如：</p><ul><li>写后读：<code>a = 1; b = a;</code></li><li>写后写：<code>a = 1; a = 2;</code></li><li>读后写：<code>a = b; b = 1;</code></li></ul><p>重排序遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。但是这里所说的<font color="red">数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</font>。</p><h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>as-if-serial语义的意思指：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变</strong>。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>如果代码中存在控制依赖的时候，会影响指令序列执行的并行度（因为高效）。也是为此，编译器和处理器会采用猜测（Speculation）执行来克服控制的相关性。所以重排序破坏了程序顺序规则（该规则是说指令执行顺序与实际代码的执行顺序是一致的，但是处理器和编译器会进行重排序，只要最后的结果不会改变，该重排序就是合理的）。</p><p><font color="red">在单线程程序中，由于as-ifserial语义的存在，对存在控制依赖的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</font></p><h2 id="先行发生原则（happens-before）"><a href="#先行发生原则（happens-before）" class="headerlink" title="先行发生原则（happens-before）"></a>先行发生原则（happens-before）</h2><p>前面所述的内存交互操作必须要满足一定的规则，而happens-before就是定义这些规则的一个等效判断原则。happens-before是JMM定义的2个操作之间的次序关系：如果操作A线性发生于操作B，则A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。如果两个操作满足happens-before原则，那么不需要进行同步操作，JVM能够保证操作具有顺序性，此时不能够随意的重排序。否则，无法保证顺序性，就能进行指令的重排序。</p><p>happens-before原则主要包括：</p><ul><li><strong>程序次序规则：</strong>在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。</li><li><strong>管程锁定规则：</strong>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</li><li><strong>volatile变量规则：</strong>就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li><li><strong>线程启动规则：</strong>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li><li><strong>线程终止规则：</strong>在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。也称线程join()规则。</li><li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</li><li><strong>传递性规则：</strong>这个简单的，就是happens-before原则具有传递性，即hb(A, B) ， hb(B, C)，那么hb(A, C)。</li><li><strong>对象终结规则：</strong>这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</li></ul><p><strong>注意：不同操作时间先后顺序与先行发生原则之间没有关系，二者不能相互推断，衡量并发安全问题不能受到时间顺序的干扰，一切都要以happens-before原则为准</strong></p><p><strong>示例代码1</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码，假设线程A在时间上先调用setValue(1)，然后线程B调用getValue()方法，那么线程B收到的返回值一定是1吗？</p><p>按照happens-before原则，两个操作不在同一个线程、没有通道锁同步、线程的相关启动、终止和中断以及对象终结和传递性等规则都与此处没有关系，因此这两个操作是不符合happens-before原则的，这里的并发操作是不安全的，返回值并不一定是1。</p><p>对于该问题的修复，可以使用lock或者synchronized套用“管程锁定规则”实现先行发生关系；或者将value定义为volatile变量（两个方法的调用都不存在数据依赖性），套用“volatile变量规则”实现先行发生关系。如此一来，就能保证并发安全性。</p><p><strong>示例代码2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下操作在同一个线程中</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面的代码符合“程序次序规则”，满足先行发生关系，但是第2条语句完全可能由于重排序而被处理器先执行，时间上先于第1条语句。</p><h2 id="as-if-serial和happens-before区别"><a href="#as-if-serial和happens-before区别" class="headerlink" title="as-if-serial和happens-before区别"></a>as-if-serial和happens-before区别</h2><ul><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li><li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign之详解</title>
      <link href="2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/6271376-285b0cf66bc1b24c.png" alt="img"></p><h2 id="1、Feign介绍"><a href="#1、Feign介绍" class="headerlink" title="1、Feign介绍"></a>1、Feign介绍</h2><p>Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求。Spring Cloud引入 Feign并且集成了Ribbon实现客户端负载均衡调用。</p><h4 id="Feign解决了什么问题？"><a href="#Feign解决了什么问题？" class="headerlink" title="Feign解决了什么问题？"></a>Feign解决了什么问题？</h4><p>封装了Http调用流程，更适合面向接口化的变成习惯</p><h2 id="2、Feign工作原理"><a href="#2、Feign工作原理" class="headerlink" title="2、Feign工作原理"></a>2、Feign工作原理</h2><h4 id="Feign远程调用流程图"><a href="#Feign远程调用流程图" class="headerlink" title="Feign远程调用流程图"></a>Feign远程调用流程图</h4><p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/6271376-7635e2dc9b32e3ec.png" alt="img"></p><h4 id="1-基于面向接口的动态代理方式生成实现类"><a href="#1-基于面向接口的动态代理方式生成实现类" class="headerlink" title="(1) 基于面向接口的动态代理方式生成实现类"></a>(1) 基于面向接口的动态代理方式生成实现类</h4><p>在使用feign 时，会定义对应的接口类，在接口类上使用Http相关的注解，标识HTTP请求参数信息</p><p>在Feign 底层，通过基于面向接口的动态代理方式生成实现类，将请求调用委托到动态代理实现类，基本原理如下所示：</p><p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/14126519-4949493085b0f547.png" alt="img"></p><h4 id="2-根据Contract协议规则，解析接口类的注解信息，解析成内部表现："><a href="#2-根据Contract协议规则，解析接口类的注解信息，解析成内部表现：" class="headerlink" title="(2) 根据Contract协议规则，解析接口类的注解信息，解析成内部表现："></a>(2) 根据Contract协议规则，解析接口类的注解信息，解析成内部表现：</h4><p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/6271376-cebfed0fa4f18190.png" alt="img"></p><h4 id="3-基于-RequestBean，动态生成Request"><a href="#3-基于-RequestBean，动态生成Request" class="headerlink" title="(3) 基于 RequestBean，动态生成Request"></a>(3) 基于 RequestBean，动态生成Request</h4><p>根据传入的Bean对象和注解信息，从中提取出相应的值，来构造Http Request 对象</p><h4 id="4-使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）"><a href="#4-使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）" class="headerlink" title="(4) 使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）"></a>(4) 使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）</h4><p>Feign 最终会将请求转换成Http 消息发送出去，传入的请求对象最终会解析成消息体，如下所示：</p><p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/14126519-b5c571b44f453707.png" alt="img"></p><h4 id="5-拦截器负责对请求和返回进行装饰处理"><a href="#5-拦截器负责对请求和返回进行装饰处理" class="headerlink" title="(5) 拦截器负责对请求和返回进行装饰处理"></a>(5) 拦截器负责对请求和返回进行装饰处理</h4><p>在请求转换的过程中，Feign 抽象出来了拦截器接口，用于用户自定义对请求的操作，比如，如果希望Http消息传递过程中被压缩，可以定义一个请求拦截器。</p><h4 id="6-日志记录"><a href="#6-日志记录" class="headerlink" title="(6) 日志记录"></a>(6) 日志记录</h4><h4 id="7-基于重试器发送HTTP请求"><a href="#7-基于重试器发送HTTP请求" class="headerlink" title="(7) 基于重试器发送HTTP请求"></a>(7) 基于重试器发送HTTP请求</h4><p>Feign 内置了一个重试器，当HTTP请求出现IO异常时，Feign会有一个最大尝试次数发送请求</p><h4 id="8-发送Http请求"><a href="#8-发送Http请求" class="headerlink" title="(8) 发送Http请求"></a>(8) 发送Http请求</h4><p>Feign 真正发送HTTP请求是委托给 feign.Client 来做的。</p><p>Feign 默认底层通过JDK 的 java.net.HttpURLConnection 实现了feign.Client接口类,<strong>在每次发送请求的时候，都会创建新的HttpURLConnection 链接</strong>，这也就是为什么默认情况下Feign的性能很差的原因。可以通过拓展该接口，使用Apache HttpClient 或者OkHttp3等基于连接池的高性能Http客户端。</p><p><strong>Feign 整体框架非常小巧，在处理请求转换和消息解析的过程中，基本上没什么时间消耗。真正影响性能的，是处理Http请求的环节。</strong></p><h2 id="3、Feign优化"><a href="#3、Feign优化" class="headerlink" title="3、Feign优化"></a>3、Feign优化</h2><h3 id="（1）GZIP压缩"><a href="#（1）GZIP压缩" class="headerlink" title="（1）GZIP压缩"></a>（1）GZIP压缩</h3><p>gzip是一种数据格式，采用deflate算法压缩数据。当Gzip压缩到一个纯文本数据时，可以减少70％以上的数据大小。</p><p>gzip作用：网络数据经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。</p><p>只配置Feign请求-应答的GZIP压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># feign gzip</span></span><br><span class="line"><span class="comment"># 局部配置。只配置feign技术相关的http请求-应答中的gzip压缩。</span></span><br><span class="line"><span class="comment"># 配置的是application client和application service之间通讯是否使用gzip做数据压缩。</span></span><br><span class="line"><span class="comment"># 和浏览器到application client之间的通讯无关。</span></span><br><span class="line"><span class="comment"># 开启feign请求时的压缩， application client -&gt; application service</span></span><br><span class="line">feign.compression.request.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 开启feign技术响应时的压缩，  application service -&gt; application client</span></span><br><span class="line">feign.compression.response.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置可以压缩的请求/响应的类型。</span></span><br><span class="line">feign.compression.request.mime-types=text/xml,application/xml,application/json</span><br><span class="line"><span class="comment"># 当请求的数据容量达到多少的时候，使用压缩。默认是2048字节。</span></span><br><span class="line">feign.compression.request.min-request-size=512</span><br></pre></td></tr></table></figure><p>配置全局的GZIP压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring boot gzip</span></span><br><span class="line"><span class="comment"># 开启spring boot中的gzip压缩。就是针对和当前应用所有相关的http请求-应答的gzip压缩。</span></span><br><span class="line">server.compression.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 哪些客户端发出的请求不压缩，默认是不限制</span></span><br><span class="line">server.compression.excluded-user-agents=gozilla,traviata</span><br><span class="line"><span class="comment"># 配置想压缩的请求/应答数据类型，默认是 text/html,text/xml,text/plain</span></span><br><span class="line">server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain</span><br><span class="line"><span class="comment"># 执行压缩的阈值，默认为2048</span></span><br><span class="line">server.compression.min-response-size=512</span><br></pre></td></tr></table></figure><h3 id="（2）替换为HttpClient客户端（使用HTTP连接池提供性能）"><a href="#（2）替换为HttpClient客户端（使用HTTP连接池提供性能）" class="headerlink" title="（2）替换为HttpClient客户端（使用HTTP连接池提供性能）"></a>（2）替换为HttpClient客户端（使用HTTP连接池提供性能）</h3><p>Feign的HTTP客户端支持3种框架，分别是；HttpURLConnection、HttpClient、OKHttp。Feign中默认使用HttpURLConnection。</p><ul><li>HttpURLConnection是JDK自带的HTTP客户端技术，并不支持连接池，如果要实现连接池的机制，还需要自己来管理连接对象。对于网络请求这种底层相对复杂的操作，如果有可用的其他方案，也没有必要自己去管理连接对象。</li><li>Apache提供的<strong>HttpClient</strong>框架相比传统JDK自带的HttpURLConnection，它封装了访问http的请求头，参数，内容体，响应等等；它不仅使客户端发送HTTP请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性；另外高并发大量的请求网络的时候，<strong>还是用“HTTP连接池”提升吞吐量</strong>。</li><li>OKHttp是一个处理网络请求的开源项目,是安卓端最火热的轻量级框架。<strong>OKHttp拥有共享Socket,减少对服务器的请求次数，通过连接池,减少了请求延迟等技术特点</strong>。</li></ul><p>本案例中，通过替换Feign底层的HTTP客户端实现为HttpClient，来提升Feign的通讯性能。</p><p>修改全局配置文件：开启feign技术对底层httpclient的依赖。 切换底层实现技术。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feign.httpclient.enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>作者：Finnnnnnnn<br>链接：<a href="https://www.jianshu.com/p/e0218c142d03">https://www.jianshu.com/p/e0218c142d03</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>在通过Feign来实现远程服务调用时，需要提供一个本地接口来继承服务标准工程提供的服务接口。这个本地接口不需要给予任何实现，在底层Spring容器会为这个接口提供一个<strong>基于JDK实现的代理对象</strong>，这个代理对象<strong>由Feign技术提供具体的HandlerInterceptor逻辑</strong>，实现远程的调用。实现过程<strong>类似通过代码调用LoadBalancerClient实现的Rest远程访问</strong>。　　</p><p>而本地接口继承服务标准接口后，需要提供注解**@FeignClient<strong>，注解的属性</strong>name代表当前接口要调用的远程服务的应用命名**。</p><p>在Feign处理远程服务调用时，传递参数是通过HTTP协议传递的，参数存在的位置是请求头或请求体中。请求头传递的参数必须依赖@RequestParam注解来处理请求参数，请求体传递的参数必须依赖@RequestBody注解来处理请求参数。如果传递的是对象，不要使用@RequestParam注解，使用@SpringQueryMap注解，其实就是转换成立map传递</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fegin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之Synchronized详解</title>
      <link href="2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h2><p>synchronized可以修饰普通方法，静态方法和代码块。<strong>当synchronized修饰一个方法或者一个代码块的时候，它能够保证在同一时刻最多只有一个线程执行该段代码。</strong></p><ul><li>对于普通同步方法，锁是当前实例对象（不同实例对象之间的锁互不影响）。字节码文件中flags为ACC_SYNCHRONIZED</li><li>对于静态同步方法，锁是当前类的Class对象。字节码文件中flags为ACC_SYNCHRONIZED</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。使用monitorenter和monitorexit</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><h2 id="满足三大特性"><a href="#满足三大特性" class="headerlink" title="满足三大特性"></a>满足三大特性</h2><p>同时满足了可见性，原子性和有序性</p><h2 id="synchronized实现的原理"><a href="#synchronized实现的原理" class="headerlink" title="synchronized实现的原理"></a>synchronized实现的原理</h2><p>synchronized的功能是基于monitorenter和monitorexit指令实现的。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。</p><p>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><blockquote><p>monitorenter和monitorexit指令的底层是lock和unlock指令。</p></blockquote><h2 id="对象完整组成"><a href="#对象完整组成" class="headerlink" title="对象完整组成"></a>对象完整组成</h2><p>当线程进入synchronized方法或者代码块时需要先获取锁，退出时需要释放锁。那么这个锁信息到底存在哪里呢？其实这个锁是存在对象的对象头中的。</p><h3 id="对象组成"><a href="#对象组成" class="headerlink" title="对象组成"></a>对象组成</h3><ul><li>对象头</li><li>实例数据：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</li><li>对齐填充：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。</li></ul><h3 id="对象头组成"><a href="#对象头组成" class="headerlink" title="对象头组成"></a>对象头组成</h3><ul><li>Mark Word：标记字段。用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，如哈希码（HashCode）、GC分代年龄、锁状态标志位、是否是偏向锁、线程持有的锁、偏向线程ID、偏向时间戳等等</li><li>Klass Pointer：类型指针。是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li><li>数组长度:只有数组才有</li></ul><p>Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。下图是Java对象头的存储结构（32位虚拟机）：Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/201812081002.png" alt="img"></p><p>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）：<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/1775037-20191120172456251-137179273.png"></p><p>其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。Epoch是指偏向锁的时间戳。</p><p>JDK1.6以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈，处理方式从偏向锁升级到轻量级锁，最终升级到重量级锁。</p><blockquote><p>轻量级锁中ptr_to_lock_record：指向栈中锁记录的指针。栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。</p><p>重量级锁中ptr_to_heavyweight_monitor：指向monitor对象（也称为管程或监视器锁）的起始地址，每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor对象可以与对象一起创建销毁或当前线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。</p></blockquote><h2 id="锁升级流程"><a href="#锁升级流程" class="headerlink" title="锁升级流程"></a>锁升级流程</h2><ul><li>step1:当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</li><li>step2:当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</li><li>step3:当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</li><li>step4:当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</li><li>step5:偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</li><li>step6:轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</li><li>step7:自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</li></ul><h2 id="monitor对象介绍"><a href="#monitor对象介绍" class="headerlink" title="monitor对象介绍"></a>monitor对象介绍</h2><p>在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>ObjectMonitor</code>中有两个队列，<code>_WaitSet</code> 和 <code>_EntryList</code>，用来保存<code>ObjectWaiter</code>对象列表( 每个等待锁的线程都会被封装成<code>ObjectWaiter</code>对象)</p><p>其中<code>_Owner</code>指向持有<code>ObjectMonitor</code>对象的线程。当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>集合，当线程获取到对象的monitor后进入 <code>_Owner</code> 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1。</p><p>若线程调用 wait() 方法，将释放当前持有的monitor，<code>_Owner</code>变量恢复为null，count自减1，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。</p><p>若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)</p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/20201012143023373.png" alt="在这里插入图片描述" style="zoom: 67%;">由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因<p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/20201106151259493.png" alt="在这里插入图片描述" style="zoom: 50%;"><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/20201106151509444.png" alt="在这里插入图片描述" style="zoom: 50%;"></p><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>乐观锁</strong>是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。数据库中的共享锁也是一种乐观锁。</p><p><strong>悲观锁</strong>是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中典型的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如ReentrantLock。数据库中的排他锁也是一种悲观锁。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>Java 6之前的synchronized会导致争用不到锁的线程进入阻塞状态，线程在阻塞状态和runnbale状态之间切换是很耗费系统资源的，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁。为了缓解上述性能问题，Java 6开始，引入了轻量锁与偏向锁，默认启用了自旋，他们都属于<strong>乐观锁</strong>。</p><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。 何谓自旋锁？ 所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。 自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。 自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整； 如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>在方法体之外引用方法内的对象。在方法执行完毕之后，方法中创建的对象应该被 GC 回收，但由于该对象被其他变量引用，导致 GC 无法回收。这个无法回收的对象称为“逃逸”对象。Java 中的逃逸分析，就是对这种对象的分析。Java JIT 会通过逃逸分析的方式，去分析加锁的代码段/共享资源，他们是否被一个或者多个线程使用，或者等待被使用。即便开发人员对代码段/共享资源加上Synchronized（锁），只要 JIT 发现这个代码段/共享资源只被一个线程访问，也会把这个 Synchronized（锁）去掉。从而避免竞态，提高访问资源的效率。</p><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。 如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。 锁粗化概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。下面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：</p><p> <strong>获取锁</strong></p><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><p><strong>释放锁</strong> 偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态；</li><li>撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><hr><p>下图是偏向锁的获取和释放流程<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/201812081006.png"></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下： </p><p><strong>获取锁</strong></p><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li><li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li></ol><p><strong>释放锁</strong> 轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；</p><hr><p>下图是轻量级锁的获取和释放过程<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/201812081005.png" alt="img"></p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之并发抽象队列同步器AQS</title>
      <link href="2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/"/>
      <url>2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>静态内部类：Node   ——》构成双向链表的CLH<font color="red">同步队列</font>——》前驱节点为-1即SIGNAL时，使用LockSupport类堵塞线程</p><p>内部类：ConditionObject，使用Node类——》构成单链表的<font color="red">等待队列</font>——》使用LockSupport类堵塞线程</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>AbstractQueuedSynchronizer类的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;  <span class="comment">//CHM同步队列的头节点，懒加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;  <span class="comment">//CHM同步队列的尾节点，懒加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;            <span class="comment">//表示当前锁的状态，在不同的功能实现中代表不同的含义。比如在独占并且不可重入的锁实现中：0代表当前锁未被占用，1代表锁被占用；而在独占并且可重入的锁实现中：0代表当前锁未被占用，而大于0则表示被占用，且表示当前持有锁的线程重入的次数。可以通过getState、setState、compareAndSetState来检查或修改同步状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;   <span class="comment">//父类AbstractOwnableSynchronizer里的变量，当前持有独占锁的线程</span></span><br></pre></td></tr></table></figure><p>Node类的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;  <span class="comment">//代表此节点对应线程因超时或中断从而取消了争抢锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;  <span class="comment">//代表当本节点线程释放锁或取消争抢锁时，需要唤醒当前线程节点的后继节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;  <span class="comment">//代表当前节点正在等待一个Condition</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;  <span class="comment">//释放共享锁需要传播到其它节点   </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;          <span class="comment">//等待状态，取值为上述4个值，还有初始值为0</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;               <span class="comment">//当前节点的前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;               <span class="comment">//当前节点的后驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;           <span class="comment">//当前节点的线程</span></span><br><span class="line">Node nextWaiter;                  <span class="comment">//下一个等待Condition的node</span></span><br></pre></td></tr></table></figure><p>ConditionObject类的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;   <span class="comment">//等待节点的头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;    <span class="comment">//等待节点的尾节点</span></span><br></pre></td></tr></table></figure><h2 id="LockSupport类介绍"><a href="#LockSupport类介绍" class="headerlink" title="LockSupport类介绍"></a>LockSupport类介绍</h2><p>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程。主要是通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作的。</p><blockquote><p>每个线程都有一个许可(permit)，permit只有两个值1和0,默认是0。</p><ol><li>当调用unpark(thread)方法，就会将thread线程的许可permit设置成1(注意多次调用unpark方法，不会累加，permit值还是1)。</li><li>当调用park()方法，如果当前线程的permit是1，那么将permit设置为0，并立即返回。如果当前线程的permit是0，那么当前线程就会阻塞，直到别的线程将当前线程的permit设置为1.park方法会将permit再次设置为0，并返回。</li></ol><p>注意：因为permit默认是0，所以一开始调用park()方法，线程必定会被阻塞。调用unpark(thread)方法后，会自动唤醒thread线程，即park方法立即返回。</p></blockquote><p><a href="https://juejin.cn/post/6913925439723405319">AQS基础之 CLH锁</a><br><a href="https://blog.csdn.net/qq_33330687/article/details/80676340">ConditionObject原理</a><br><a href="https://blog.csdn.net/weixin_39687783/article/details/85058686">LockSupport中的park与unpark原理</a></p><p><a href="https://segmentfault.com/a/1190000014436679">LockSupport原理分析</a></p><p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/image-20210721135610511.png" alt="image-20210721135610511"></p><p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/image-20210802113255084.png" alt="image-20210802113255084"></p><p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/image-20210802113316367.png" alt="image-20210802113316367"></p><p>ReetrantLock：state表示重入次数，cas获取锁<br>ReetrantReadWriteLock：state中高16位表示read数量，低16位表示write数量</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程之堵塞区别</title>
      <link href="2021/04/23/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A0%B5%E5%A1%9E%E5%8C%BA%E5%88%AB/"/>
      <url>2021/04/23/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A0%B5%E5%A1%9E%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Thread-sleep-和Object-wait-的区别"><a href="#Thread-sleep-和Object-wait-的区别" class="headerlink" title="Thread.sleep()和Object.wait()的区别"></a>Thread.sleep()和Object.wait()的区别</h2><p>（1）Thread.sleep()不会释放占有的锁资源，Object.wait()会释放占有的锁资源；</p><p>（2）Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</p><p>（3）Thread.sleep()到时间了会自动唤醒，然后继续执行；</p><p>（4）Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；</p><p>（5）Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；</p><p>其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</p><h2 id="Thread-sleep-和Condition-await-的区别"><a href="#Thread-sleep-和Condition-await-的区别" class="headerlink" title="Thread.sleep()和Condition.await()的区别"></a>Thread.sleep()和Condition.await()的区别</h2><p>这个题目的回答思路跟Object.wait()是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。</p><p>实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程</p><h2 id="Object-wait-和Condition-await-的区别"><a href="#Object-wait-和Condition-await-的区别" class="headerlink" title="Object.wait()和Condition.await()的区别"></a>Object.wait()和Condition.await()的区别</h2><p>类似，都会释放锁，Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。Object.wait()是native方法</p><h2 id="Thread-sleep-和LockSupport-park-的区别"><a href="#Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="Thread.sleep()和LockSupport.park()的区别"></a>Thread.sleep()和LockSupport.park()的区别</h2><p>LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。</p><p>（1）从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；</p><p>（2）Thread.sleep()没法从外部唤醒，只能自己醒过来；</p><p>（3）LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</p><p>（4）Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；</p><p>（5）LockSupport.park()方法不需要捕获中断异常；</p><p>（6）Thread.sleep()本身就是一个native方法；</p><p>（7）LockSupport.park()底层是调用的Unsafe的native方法；</p><h2 id="Object-wait-和LockSupport-park-的区别"><a href="#Object-wait-和LockSupport-park-的区别" class="headerlink" title="Object.wait()和LockSupport.park()的区别"></a>Object.wait()和LockSupport.park()的区别</h2><p>二者都会阻塞当前线程的运行，他们有什么区别呢？经过上面的分析相信你一定很清楚了，真的吗？往下看！</p><p>（1）Object.wait()方法需要在synchronized块中执行；</p><p>（2）LockSupport.park()可以在任意地方执行；</p><p>（3）Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；</p><p>（4）LockSupport.park()不需要捕获中断异常【本文由公从号“彤哥读源码”原创】；</p><p>（5）Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；</p><p>（6）LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</p><p>（7）如果在wait()之前执行了notify()会怎样？抛出IllegalMonitorStateException异常；</p><p>（8）如果在park()之前执行了unpark()会怎样？线程不会被阻塞，直接跳过park()，继续执行后续内容；</p><h2 id="LockSupport-park-会释放锁资源吗？"><a href="#LockSupport-park-会释放锁资源吗？" class="headerlink" title="LockSupport.park()会释放锁资源吗？"></a>LockSupport.park()会释放锁资源吗？</h2><p>不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。</p><ul><li><input disabled type="checkbox"> <img src="/2021/04/23/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A0%B5%E5%A1%9E%E5%8C%BA%E5%88%AB/20191031000413242.png" alt="img"></li></ul><p><img src="/2021/04/23/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A0%B5%E5%A1%9E%E5%8C%BA%E5%88%AB/image-20210423103045076.png" alt="image-20210423103045076"></p><p>park()/unpark()底层原理</p><p>park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存之Caffeine与Guava对比</title>
      <link href="2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/"/>
      <url>2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="GuavaCache和Caffeine差异"><a href="#GuavaCache和Caffeine差异" class="headerlink" title="GuavaCache和Caffeine差异"></a>GuavaCache和Caffeine差异</h2><ol><li>剔除算法方面，GuavaCache采用的是<strong>「LRU」</strong>算法，而Caffeine采用的是<strong>「Window TinyLFU」</strong>算法，这是两者之间最大，也是根本的区别。</li><li>立即失效方面，Guava会把立即失效 (例如：expireAfterAccess(0) and expireAfterWrite(0)) 转成设置最大Size为0。这就会导致剔除提醒的原因是SIZE而不是EXPIRED。Caffiene能正确识别这种剔除原因。</li><li>取代提醒方面，Guava只要数据被替换，不管什么原因，都会触发剔除监听器。而Caffiene在取代值和先前值的引用完全一样时不会触发监听器。</li><li>异步化方方面，Caffiene的很多工作都是交给线程池去做的（默认：ForkJoinPool.commonPool()），例如：剔除监听器，刷新机制，维护工作等。</li></ol><h3 id="内存占用对比"><a href="#内存占用对比" class="headerlink" title="内存占用对比"></a>内存占用对比</h3><p>Caffeine可以根据使用情况延迟初始化，或者动态调整它内部数据结构。这样能减少对内存的占用。如下图所示，使用了gradle memoryOverhead对内存占用进行了压测。结果可能会受到JVM的指针压缩、对象Padding等影响：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/%E5%AF%B9%E6%AF%94.png" alt="img"></p><h2 id="LRU-P-K-W-TinyLFU"><a href="#LRU-P-K-W-TinyLFU" class="headerlink" title="LRU P.K. W-TinyLFU"></a>LRU P.K. W-TinyLFU</h2><p>缓存的驱逐策略是为了预测哪些数据在短期内最可能被再次用到，从而提升缓存的命中率。由于简洁的实现、高效的运行时表现以及在常规的使用场景下有不错的命中率，LRU（Least Recently Used）策略或许是最流行的驱逐策略,，它在保持算法简单的前提下，效果还不错。但LRU对未来的预测有明显的局限性，它会认为<strong>「最后到来的数据是最可能被再次访问」</strong>的，从而给予它最高的优先级。</p><p>现代缓存扩展了对历史数据的使用，结合就近程度（recency）和访问频次（frequency）来更好的预测数据。其中一种保留历史信息的方式是使用<strong>「popularity sketch」</strong>（一种压缩、概率性的数据结构）来从一大堆访问事件中定位频繁的访问者。可以参考<strong>「CountMin Sketch」</strong>算法，它由计数矩阵和多个哈希方法实现。发生一次读取时，矩阵中每行对应的计数器增加计数，估算频率时，取数据对应是所有行中计数的最小值。这个方法让我们从空间、效率、以及适配矩阵的长宽引起的哈希碰撞的错误率上做权衡：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80bzIyT0ZjbXpIbE4wbXBTQlNITGdYTUp0VWRNQmliYzFOODRiaWJPWUlvNGZ1STA1MWlhd0RwN3VzVTVra3VmSGR4TDNkM3VMWGliVXZOQWpmU3hjWTNRencvNjQw" alt="img"></p><p>Window TinyLFU（W-TinyLFU）算法将Sketch作为过滤器，当新来的数据比要驱逐的数据高频时，这个数据才会被缓存接纳（admission）。这个许可窗口给予每个数据项积累热度的机会，而<strong>「不是立即过滤掉」</strong>。这避免了持续的未命中，特别是在突然流量暴涨的的场景中，一些短暂的重复流量就不会被长期保留。为了刷新历史数据，一个时间衰减进程被周期性或增量的执行，给所有计数器减半：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80bzIyT0ZjbXpIbE4wbXBTQlNITGdYTUp0VWRNQmliYzEzeEY1OHVYakZ2S1FXTktRVXNhYW94UkhGbDBXRmUyaWNDemdlS05zVnlUVWo1a1EyRGFkQUFRLzY0MA" alt="img"></p><p>对于长期保留的数据，W-TinyLFU使用了分段LRU（Segmented LRU，缩写SLRU）策略。起初，一个数据项存储被存储在试用段（probationary segment）中，在后续被访问到时，它会被提升到保护段（protected segment）中（保护段占总容量的80%）。保护段满后，有的数据会被淘汰回试用段，这也可能级联的触发试用段的淘汰。这套机制确保了访问间隔小的热数据被保存下来，而被重复访问少的冷数据则被回收：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80bzIyT0ZjbXpIbE4wbXBTQlNITGdYTUp0VWRNQmliYzFvQjdwamJGVmc4MlFVdm9QQ1EwNVJVbVp5aEZod3ZYb05aT2pYZDk3aWJDZG9SdFlQQjJjdnBRLzY0MA" alt="img"></p><p>如图中数据库和搜索场景的结果展示，通过考虑就近程度和频率能大大提升LRU的表现。一些高级的策略，像ARC，LIRS和W-TinyLFU都提供了接近最理想的命中率。想看更多的场景测试，请查看相应的论文，也可以在使用simulator来测试自己的场景：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80bzIyT0ZjbXpIbE4wbXBTQlNITGdYTUp0VWRNQmliYzFmTFNmZlBqMDdpY2h6Znk3aWNyYTVtOWE3Z2pvMjZjcXZNcUVYcHdPNjFGcEs2THpyeVdmbWJaZy82NDA" alt="img"></p><h2 id="Guava迁移"><a href="#Guava迁移" class="headerlink" title="Guava迁移"></a>Guava迁移</h2><p>那么，如果我的项目之前用的是GuavaCache，如何以尽可能低的成本迁移到Caffeine上来呢？嘿嘿，Caffeine已经想到了这一点，它提供了一个适配器，让你用Guava的接口操作它的缓存。代码片段如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guava&#x27;s LoadingCache interface</span></span><br><span class="line">LoadingCache&lt;Key, Graph&gt; graphs = CaffeinatedGuava.build(</span><br><span class="line">    Caffeine.newBuilder().maximumSize(<span class="number">10_000</span>),</span><br><span class="line">    <span class="keyword">new</span> CacheLoader&lt;Key, Graph&gt;() &#123; <span class="comment">// Guava&#x27;s CacheLoader</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Graph <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> createExpensiveGraph(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Caffeine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存之Caffeine</title>
      <link href="2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine/"/>
      <url>2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/crazymakercircle/p/14385641.html">Caffeine</a></p><p>Caffeine提供了灵活的构造来创建具有以下功能组合的缓存：</p><ul><li><a href="https://github.com/ben-manes/caffeine/wiki/Population">自动将条目自动加载</a>到缓存中，可以选择异步<a href="https://github.com/ben-manes/caffeine/wiki/Population">加载</a></li><li>基于<a href="https://github.com/ben-manes/caffeine/wiki/Efficiency">频率和新近度</a>超过最大值时<a href="https://github.com/ben-manes/caffeine/wiki/Eviction#size-based">基于大小的逐出</a></li><li>自上次访问或上次写入以来测得<a href="https://github.com/ben-manes/caffeine/wiki/Eviction#time-based">的基于时间</a>的条目<a href="https://github.com/ben-manes/caffeine/wiki/Eviction#time-based">到期</a></li><li>发生第一个陈旧的条目请求时，<a href="https://github.com/ben-manes/caffeine/wiki/Refresh">异步刷新</a></li><li>键自动包装在<a href="https://github.com/ben-manes/caffeine/wiki/Eviction#reference-based">弱引用中</a></li><li>值自动包装在<a href="https://github.com/ben-manes/caffeine/wiki/Eviction#reference-based">弱引用或软引用中</a></li><li>逐出（或以其他方式删除）条目的<a href="https://github.com/ben-manes/caffeine/wiki/Removal">通知</a></li><li><a href="https://github.com/ben-manes/caffeine/wiki/Compute">写入传播</a>到外部资源</li><li>缓存访问<a href="https://github.com/ben-manes/caffeine/wiki/Statistics">统计信息的</a>累积</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前面刚说到Guava Cache，他的优点是封装了get，put操作；提供线程安全的缓存操作；提供过期策略；提供回收策略；缓存监控。当缓存的数据超过最大值时，使用LRU算法替换。这一篇我们将要谈到一个新的本地缓存框架：Caffeine Cache。它也是站在巨人的肩膀上-Guava Cache，借着他的思想优化了算法发展而来。</p><p>按 Caffeine Github 文档描述，Caffeine 是基于 JAVA 8 的高性能缓存库。并且在 spring5 (springboot 2.x) 后，spring 官方放弃了 Guava，而使用了性能更优秀的 Caffeine 作为默认缓存组件。</p><h2 id="Caffine-Cache"><a href="#Caffine-Cache" class="headerlink" title="Caffine Cache"></a>Caffine Cache</h2><p>Caffeine Cache：<a href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p><h2 id="1-缓存填充策略"><a href="#1-缓存填充策略" class="headerlink" title="1. 缓存填充策略"></a>1. 缓存填充策略</h2><p>Caffeine Cache提供了三种缓存填充策略：手动、同步加载和异步加载。</p><h3 id="手动加载"><a href="#手动加载" class="headerlink" title="手动加载"></a>手动加载</h3><p>在每次get key的时候指定一个同步的函数，如果key不存在就调用这个函数生成一个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手动加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">manulOperator</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(<span class="number">10</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//如果一个key不存在，那么会进入指定的函数生成value</span></span><br><span class="line">    Object value = cache.get(key, t -&gt; setValue(key).apply(key));</span><br><span class="line">    cache.put(<span class="string">&quot;hello&quot;</span>,value);</span><br><span class="line">    <span class="comment">//判断是否存在如果不存返回null</span></span><br><span class="line">    Object ifPresent = cache.getIfPresent(key);</span><br><span class="line">    <span class="comment">//移除一个key</span></span><br><span class="line">    cache.invalidate(key);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Function&lt;String, Object&gt; <span class="title">setValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t -&gt; key + <span class="string">&quot;value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p>构造Cache时候，build方法传入一个CacheLoader实现类。实现load方法，通过key加载value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步加载</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">syncOperator</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">100</span>)</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .build(k -&gt; setValue(key).apply(key));</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Function&lt;String, Object&gt; <span class="title">setValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t -&gt; key + <span class="string">&quot;value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>AsyncLoadingCache是继承自LoadingCache类的，异步加载使用Executor去调用方法并返回一个CompletableFuture。异步加载缓存使用了响应式编程模型。</p><p>如果要以同步方式调用时，应提供CacheLoader。要以异步表示时，应该提供一个AsyncCacheLoader，并返回一个CompletableFuture。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">asyncOperator</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    AsyncLoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">100</span>)</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .buildAsync(k -&gt; setAsyncValue(key).get());</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">setAsyncValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;value&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-回收策略"><a href="#2-回收策略" class="headerlink" title="2. 回收策略"></a>2. 回收策略</h2><p>Caffeine提供了3种回收策略：基于大小回收，基于时间回收，基于引用回收。</p><h3 id="基于大小的过期方式"><a href="#基于大小的过期方式" class="headerlink" title="基于大小的过期方式"></a>基于大小的过期方式</h3><p>基于大小的回收策略有两种方式：一种是基于缓存大小，一种是基于权重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据缓存的计数进行驱逐</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10000</span>)</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据缓存的权重来进行驱逐（权重只是用于确定缓存大小，不会用于决定该缓存是否被驱逐）</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">    .maximumWeight(<span class="number">10000</span>)</span><br><span class="line">    .weigher(key -&gt; function1(key))</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"><span class="comment">//maximumWeight与maximumSize不可以同时使用。</span></span><br></pre></td></tr></table></figure><h3 id="基于时间的过期方式"><a href="#基于时间的过期方式" class="headerlink" title="基于时间的过期方式"></a>基于时间的过期方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于固定的到期策略进行退出</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line">LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于不同的到期策略进行退出</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache2 = Caffeine.newBuilder()</span><br><span class="line">    .expireAfter(<span class="keyword">new</span> Expiry&lt;String, Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterCreate</span><span class="params">(String key, Object value, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(seconds);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterUpdate</span><span class="params">(<span class="meta">@Nonnull</span> String s, <span class="meta">@Nonnull</span> Object o, <span class="keyword">long</span> l, <span class="keyword">long</span> l1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterRead</span><span class="params">(<span class="meta">@Nonnull</span> String s, <span class="meta">@Nonnull</span> Object o, <span class="keyword">long</span> l, <span class="keyword">long</span> l1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build(key -&gt; function(key));</span><br></pre></td></tr></table></figure><p>Caffeine提供了三种定时驱逐策略：</p><ul><li>expireAfterAccess(long, TimeUnit)：在最后一次访问或者写入后开始计时，在指定的时间后过期。假如一直有请求访问该key，那么这个缓存将一直不会过期。</li><li>expireAfterWrite(long, TimeUnit)：在最后一次写入缓存后开始计时，在指定的时间后过期。</li><li>expireAfter(Expiry)：自定义策略，过期时间由Expiry实现独自计算。</li></ul><p>缓存的删除策略使用的是惰性删除和定时删除。这两个删除策略的时间复杂度都是O(1)。</p><h3 id="基于引用的过期方式"><a href="#基于引用的过期方式" class="headerlink" title="基于引用的过期方式"></a>基于引用的过期方式</h3><p><img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine/up-e3834f3657dfc4f839a56428067a1e346ba.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当key和value都没有引用时驱逐缓存</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .weakKeys()</span><br><span class="line">    .weakValues()</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当垃圾收集器需要释放内存时驱逐</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">    .softValues()</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：AsyncLoadingCache不支持弱引用和软引用。</span></span><br></pre></td></tr></table></figure><blockquote><p>Caffeine.weakKeys()： 使用弱引用存储key。如果没有其他地方对该key有强引用，那么该缓存就会被垃圾回收器回收。由于垃圾回收器只依赖于身份(identity)相等，因此这会导致整个缓存使用身份 (==) 相等来比较 key，而不是使用 equals()。</p><p>Caffeine.weakValues() ：使用弱引用存储value。如果没有其他地方对该value有强引用，那么该缓存就会被垃圾回收器回收。由于垃圾回收器只依赖于身份(identity)相等，因此这会导致整个缓存使用身份 (==) 相等来比较 key，而不是使用 equals()。</p><p>Caffeine.softValues() ：使用软引用存储value。当内存满了过后，软引用的对象以将使用最近最少使用(least-recently-used ) 的方式进行垃圾回收。由于使用软引用是需要等到内存满了才进行回收，所以我们通常建议给缓存配置一个使用内存的最大值。 softValues() 将使用身份相等(identity) (==) 而不是equals() 来比较值。</p><p>Caffeine.weakValues()和Caffeine.softValues()不可以一起使用。</p></blockquote><h2 id="3-移除事件监听"><a href="#3-移除事件监听" class="headerlink" title="3. 移除事件监听"></a>3. 移除事件监听</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .removalListener((String key, Object value, RemovalCause cause) -&gt;</span><br><span class="line">                     System.out.printf(<span class="string">&quot;Key %s was removed (%s)%n&quot;</span>, key, cause))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>RemovalCause枚举值:</p><ul><li><strong>「EXPLICIT」</strong>：调用方法（例如：cache.invalidate(key)、cache.invalidateAll）显示剔除数据；</li><li><strong>「REPLACED」</strong>：不是真正被剔除，而是用户调用一些方法（例如：put()，putAll()等）盖了之前的值；</li><li><strong>「COLLECTED」</strong>：表示缓存中的Key或者Value被垃圾回收掉了；</li><li><strong>「EXPIRED」</strong>: expireAfterWrite/expireAfterAccess约定时间内没有任何访问导致被剔除；</li><li><strong>「SIZE」</strong>：超过maximumSize限制的元素个数被剔除的原因；</li></ul><h2 id="4-写入外部存储"><a href="#4-写入外部存储" class="headerlink" title="4. 写入外部存储"></a>4. 写入外部存储</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheWriter 方法可以将缓存中所有的数据写入到第三方。</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache2 = Caffeine.newBuilder()</span><br><span class="line">    .writer(<span class="keyword">new</span> CacheWriter&lt;String, Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 写入到外部存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key, Object value, RemovalCause cause)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 删除外部存储</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"><span class="comment">//如果你有多级缓存的情况下，这个方法还是很实用。</span></span><br><span class="line"><span class="comment">//注意：CacheWriter不能与弱键或AsyncLoadingCache一起使用。</span></span><br></pre></td></tr></table></figure><h2 id="5-统计"><a href="#5-统计" class="headerlink" title="5. 统计"></a>5. 统计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与Guava Cache的统计一样。</span></span><br><span class="line">Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .recordStats()</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//通过使用Caffeine.recordStats(), 可以转化成一个统计的集合. 通过 Cache.stats() 返回一个CacheStats。CacheStats提供以下统计方法：</span></span><br><span class="line"><span class="comment">//hitRate(): 返回缓存命中率</span></span><br><span class="line"><span class="comment">//evictionCount(): 缓存回收数量</span></span><br><span class="line"><span class="comment">//averageLoadPenalty(): 加载新值的平均时间</span></span><br></pre></td></tr></table></figure><h2 id="6-刷新机制"><a href="#6-刷新机制" class="headerlink" title="6.刷新机制"></a>6.刷新机制</h2><p>在构造Cache时通过refreshAfterWrite方法指定刷新周期，例如refreshAfterWrite(10, TimeUnit.SECONDS)表示10秒钟刷新一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里我们就可以从数据库或者其他地方查询最新的数据</span></span><br><span class="line">        <span class="keyword">return</span> getValue(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要注意的是，Caffeine的刷新机制是<strong>「被动」</strong>的。举个例子，假如我们申明了10秒刷新一次。我们在时间T访问并获取到值v1，在T+5秒的时候，数据库中这个值已经更新为v2。但是在T+12秒，即已经过了10秒我们通过Caffeine从本地缓存中获取到的<strong>「还是v1」</strong>，并不是v2。在这个获取过程中，Caffeine发现时间已经过了10秒，然后会将v2加载到本地缓存中，下一次获取时才能拿到v2。即它的实现原理是在get方法中，调用afterRead的时候，调用refreshIfNeeded方法判断是否需要刷新数据。这就意味着，如果不读取本地缓存中的数据的话，无论刷新时间间隔是多少，本地缓存中的数据永远是旧的数据！</p><h2 id="实例分享"><a href="#实例分享" class="headerlink" title="实例分享"></a>实例分享</h2><p>SpringBoot 1.x版本中的默认本地cache是Guava Cache。在2.x（Spring Boot 2.0(spring 5) ）版本中已经用Caffine Cache取代了Guava Cache。毕竟有了更优的缓存淘汰策略。</p><p>下面我们来说在SpringBoot2.x版本中如何使用cache。</p><blockquote><p>Caffeine常用配置说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initialCapacity&#x3D;[integer]: 初始的缓存空间大小</span><br><span class="line">maximumSize&#x3D;[long]: 缓存的最大条数</span><br><span class="line">maximumWeight&#x3D;[long]: 缓存的最大权重</span><br><span class="line">expireAfterAccess&#x3D;[duration]: 最后一次写入或访问后经过固定时间过期</span><br><span class="line">expireAfterWrite&#x3D;[duration]: 最后一次写入后经过固定时间过期</span><br><span class="line">refreshAfterWrite&#x3D;[duration]: 创建缓存或者最近一次更新缓存后经过固定的时间间隔，刷新缓存</span><br><span class="line">weakKeys: 打开key的弱引用</span><br><span class="line">weakValues：打开value的弱引用</span><br><span class="line">softValues：打开value的软引用</span><br><span class="line">recordStats：开发统计功能</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">expireAfterWrite和expireAfterAccess同时存在时，以expireAfterWrite为准。</span><br><span class="line">maximumSize和maximumWeight不可以同时使用</span><br><span class="line">weakValues和softValues不可以同时使用</span><br></pre></td></tr></table></figure><p>需要说明的是，使用配置文件的方式来进行缓存项配置，一般情况能满足使用需求，但是灵活性不是很高，如果我们有很多缓存项的情况下写起来会导致配置文件很长。所以一般情况下你也可以选择使用bean的方式来初始化Cache实例。</p></blockquote><p>SpringBoot 有俩种使用 Caffeine 作为缓存的方式：</p><ul><li>直接引入 Caffeine 依赖，然后使用 Caffeine 方法实现缓存。</li><li>引入 Caffeine 和 Spring Cache 依赖，使用 SpringCache 注解方法实现缓存。</li></ul><h2 id="1-直接引入-Caffeine-依赖"><a href="#1-直接引入-Caffeine-依赖" class="headerlink" title="1. 直接引入 Caffeine 依赖"></a>1. 直接引入 Caffeine 依赖</h2><h3 id="Pom"><a href="#Pom" class="headerlink" title="Pom"></a>Pom</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- caffeine cache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Conf"><a href="#Conf" class="headerlink" title="Conf"></a>Conf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.conf;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineCacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache&lt;String, Object&gt; <span class="title">caffeineCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">            <span class="comment">// 设置最后一次写入或访问后经过固定时间过期</span></span><br><span class="line">            .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">// 初始的缓存空间大小</span></span><br><span class="line">            .initialCapacity(<span class="number">100</span>)</span><br><span class="line">            <span class="comment">// 缓存的最大条数</span></span><br><span class="line">            .maximumSize(<span class="number">1000</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.service;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.bean.UserInfo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUserInfo</span><span class="params">(UserInfo userInfo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">UserInfo <span class="title">getByName</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Impl"><a href="#Impl" class="headerlink" title="Impl"></a>Impl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.bean.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.service.UserInfoService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟数据库存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, UserInfo&gt; userInfoMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Cache&lt;String, Object&gt; caffeineCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserInfo</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        userInfoMap.put(userInfo.getId(), userInfo);</span><br><span class="line">        <span class="comment">// 加入缓存</span></span><br><span class="line">        caffeineCache.put(String.valueOf(userInfo.getId()),userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getByName</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先从缓存读取</span></span><br><span class="line">        caffeineCache.getIfPresent(id);</span><br><span class="line">        UserInfo userInfo = (UserInfo) caffeineCache.asMap().get(String.valueOf(id));</span><br><span class="line">        <span class="keyword">if</span> (userInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, 我来自Caffeine Cache&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> userInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果缓存中不存在，则从库中查找</span></span><br><span class="line">        userInfo = userInfoMap.get(id);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, 我来自DataBase&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果用户信息不为空，则加入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (userInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            caffeineCache.put(String.valueOf(userInfo.getId()),userInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        userInfoMap.remove(id);</span><br><span class="line">        <span class="comment">// 从缓存中删除</span></span><br><span class="line">        caffeineCache.asMap().remove(String.valueOf(id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.bean.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.service.UserInfoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/caffeine&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineCacheController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userInfo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = userInfoService.getByName(id);</span><br><span class="line">        <span class="keyword">if</span> (userInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没有该用户&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/userInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        userInfo.setId(<span class="number">1</span>);</span><br><span class="line">        userInfo.setName(<span class="string">&quot;HLee&quot;</span>);</span><br><span class="line">        userInfoService.addUserInfo(userInfo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deleteUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        userInfoService.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务：</span></span><br><span class="line"><span class="comment">//localhost:2000/spring-master/caffeine/userInfo</span></span><br><span class="line"><span class="comment">//localhost:2000/spring-master/caffeine/userInfo/1</span></span><br><span class="line"><span class="comment">//localhost:2000/spring-master/caffeine/delete/1</span></span><br></pre></td></tr></table></figure><h2 id="2-引入-Caffeine-和-Spring-Cache-依赖"><a href="#2-引入-Caffeine-和-Spring-Cache-依赖" class="headerlink" title="2. 引入 Caffeine 和 Spring Cache 依赖"></a>2. 引入 Caffeine 和 Spring Cache 依赖</h2><h3 id="Pom-1"><a href="#Pom-1" class="headerlink" title="Pom"></a>Pom</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Conf-1"><a href="#Conf-1" class="headerlink" title="Conf"></a>Conf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置缓存管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;caffeineCacheManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CaffeineCacheManager cacheManager = <span class="keyword">new</span> CaffeineCacheManager();</span><br><span class="line">        cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">// 设置最后一次写入或访问后经过固定时间过期</span></span><br><span class="line">                .expireAfterAccess(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">// 初始的缓存空间大小</span></span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                <span class="comment">// 缓存的最大条数</span></span><br><span class="line">                .maximumSize(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean-1"><a href="#Bean-1" class="headerlink" title="Bean"></a>Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.service;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.bean.UserInfo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUserInfo</span><span class="params">(UserInfo userInfo)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">UserInfo <span class="title">getByName</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Impl-1"><a href="#Impl-1" class="headerlink" title="Impl"></a>Impl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> mydlq.club.example.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> mydlq.club.example.service.UserInfoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;caffeineCacheManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟数据库存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, UserInfo&gt; userInfoMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#userInfo.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserInfo</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        userInfoMap.put(userInfo.getId(), userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getByName</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfoMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#userInfo.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">updateUserInfo</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!userInfoMap.containsKey(userInfo.getId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取旧的值</span></span><br><span class="line">        UserInfo oldUserInfo = userInfoMap.get(userInfo.getId());</span><br><span class="line">        <span class="comment">// 替换内容</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(oldUserInfo.getAge())) &#123;</span><br><span class="line">            oldUserInfo.setAge(userInfo.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(oldUserInfo.getName())) &#123;</span><br><span class="line">            oldUserInfo.setName(userInfo.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(oldUserInfo.getSex())) &#123;</span><br><span class="line">            oldUserInfo.setSex(userInfo.getSex());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的对象存储，更新旧对象信息</span></span><br><span class="line">        userInfoMap.put(oldUserInfo.getId(), oldUserInfo);</span><br><span class="line">        <span class="comment">// 返回新对象信息</span></span><br><span class="line">        <span class="keyword">return</span> oldUserInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        userInfoMap.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userInfo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = userInfoService.getByName(id);</span><br><span class="line">        <span class="keyword">if</span> (userInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没有该用户&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/userInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        userInfoService.addUserInfo(userInfo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/updateInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">updateUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        UserInfo newUserInfo = userInfoService.updateUserInfo(userInfo);</span><br><span class="line">        <span class="keyword">if</span> (newUserInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;不存在该用户&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUserInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deleteUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        userInfoService.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Caffeine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之原则</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="原则（可读性、可维护性、可扩展性、复杂性、风险）"><a href="#原则（可读性、可维护性、可扩展性、复杂性、风险）" class="headerlink" title="原则（可读性、可维护性、可扩展性、复杂性、风险）"></a>原则（可读性、可维护性、可扩展性、复杂性、风险）</h2><h3 id="单一职责原则-降低复杂性"><a href="#单一职责原则-降低复杂性" class="headerlink" title="单一职责原则(降低复杂性)"></a>单一职责原则(降低复杂性)</h3><p>事例：设计一个视频播放系统，要求：如果是VIP用户就播放完整影片，否则只允许试看5分钟。简单的实现是，播放方法中检验是否有权限，这样会有一个问题就是，当权限判断变更时，需要调整权限方法的代码，修改了播放类。</p><p><font color="red">单一职责的优点</font>：</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li><li>可读性提高。</li><li>可维护性提高。</li><li>变更引起的风险降低。</li></ul><p><font color="red">单一职责的核心就是拆分</font>，职责的拆分，它不仅适用于类，也适用于方法，每一个方法的功能都应该是相互独立，职责清晰的，这不仅提高了程序的可读性和可维护性，方法的复用性也会提高。一个功能过于“丰富”的方法，通常很难被复用。</p><h3 id="里氏替换原则（子类继承抽象类）"><a href="#里氏替换原则（子类继承抽象类）" class="headerlink" title="里氏替换原则（子类继承抽象类）"></a>里氏替换原则（子类继承抽象类）</h3><p><strong>所有引用基类的地方必须能透明地使用其子类的对象。</strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</p><p>事例：系统在发送短信时，需要将发送记录保存到数据库中，如果子类重写了父类的方法，修改了业务逻辑，日志记录功能将会丢失，这是非常危险的。</p><p><font color="red">继承的优点</font>：</p><ol><li>代码共享。</li><li>提高代码的复用性。</li><li>提高类的开放性，可以被子类增强。</li></ol><p><font color="red">继承的缺点</font>：</p><ol><li>较强的侵入性，子类必须拥有父类的所有方法和属性。</li><li>增加了耦合，父类的特性改变，子类也必须跟着改变。</li></ol><p>继承有它的优点，自然也有它的缺点，如果子类不能完整的实现父类的方法，或者父类的方法在子类的实现中“变味儿”了，则建议断开继承关系，采用依赖、组合等关系来代替。</p><h3 id="依赖倒置原则（面向接口编程）"><a href="#依赖倒置原则（面向接口编程）" class="headerlink" title="依赖倒置原则（面向接口编程）"></a>依赖倒置原则（面向接口编程）</h3><ol><li><strong>高层模块不依赖低层模块，而是互相依赖其抽象。</strong></li><li><strong>抽象不依赖细节，细节依赖于抽象。</strong></li></ol><p>通常一个业务逻辑会由N个原子逻辑组成，原子逻辑是不可分割的，也就是低层模块，由N个原子逻辑组成的业务逻辑就是高层模块。</p><p>事例：用户下订单是一个高层模块，下单需要发起支付，扣减库存等操作就是低层模块，订单服务应该依赖支付、库存服务的接口，而不是实现细节。当支付服务的规则有变更时，修改接口，所有的实现类都必须做相应的调整，否则编译会不通过，这就是<strong>实现依赖于抽象</strong>，低层依赖于高层，依赖倒置了。</p><p>为了满足依赖倒置原则，开发的时候尽量遵循如下规则：</p><ol><li>类尽量有抽象父类或接口。</li><li>变量、形参尽量是抽象类或接口。</li><li>尽量不要从具体类再派生出子类。</li><li>尽量不要重写基类方法，会影响依赖的稳定性。</li><li>结合里氏替换原则使用，可以用子类对象透明的代替基类对象。</li></ol><h3 id="接口隔离原则（降低复杂性）"><a href="#接口隔离原则（降低复杂性）" class="headerlink" title="接口隔离原则（降低复杂性）"></a>接口隔离原则（降低复杂性）</h3><ol><li><strong>客户端不应该依赖它不需要的接口。</strong></li><li><strong>类间的依赖关系应该建立在最小的接口上。</strong></li></ol><p>事例：博客系统中，普通用户只能查看博客，管理员可以增删改查，因此博客服务要分别为普通用户和管理员用户配置实现类，实现最小的接口。普通用户的博客服务类只有查询方法。</p><p>接口尽量细化，建立单一接口，避免定义过度“臃肿而庞大”的接口。要做到极致的接口隔离原则，就是一个接口只有一个方法，但是开发中我们绝不会这么去做，粒度太小了，导致接口数量剧增，难以开发。但是接口粒度太大灵活性会降低，所以如何定义好一个接口的粒度需要开发人员长期的实践和经验积累。</p><h3 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h3><p><strong>一个类应该对它<font color="red">依赖的类</font>了解的越少越好。</strong></p><p>迪米特法则的核心是：只与朋友交流。它的<font color="red">目的是减少类间的依赖，提高内聚，降低耦合</font>。 朋友类的定义：成员变量，方法的入参、出参属于朋友类，出现在方法体内部的则不是朋友类。一个类应该对其所依赖的类知道的越少越好，你的内部实现不管多复杂我并不关心，我只管调用你的<code>public</code>方法。</p><p>事例：简单工厂，通过不同的枚举类型，创建不同的产品。需要知道工厂类和枚举类，不符合最少知道原则。可使用多方法工厂模式解决，但是当需要添加新的产品的时候，需要修改工厂类，添加新的方法，因此违反了开闭原则</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>使用合成替换继承</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</strong>大白话就是：对于一个程序而言，应该通过扩展来实现需求变化，而不是修改现有的代码。</p><p>开闭原则的核心是：封装程序中变与不变的地方。用接口或抽象来封装规则，描述契约，这是基本稳定不变的，通过派生子类来实现细节，扩展功能，这是易变的，尽量依赖抽象，避免依赖实现。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 代码设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础知识</title>
      <link href="2021/04/21/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/04/21/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h2><p>1、请求次数不同；<br>2、重定向时地址栏会发生变化，而转发时地址栏不会发生变化；<br>3、重定向两次请求不共享数据，转发一次请求共享数据。<br>4、重定向方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(<span class="number">302</span>);<span class="comment">//[设置响应码为302，表示重定向]</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;http://www.baidu.com&quot;</span>);<span class="comment">//设置新请求的URL</span></span><br><span class="line"></span><br><span class="line">response.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);<span class="comment">//二种实现方式，原理一致</span></span><br></pre></td></tr></table></figure><h2 id="response响应正文"><a href="#response响应正文" class="headerlink" title="response响应正文"></a>response响应正文</h2><p>response是响应对象，向客户端输出响应正文（响应体）可以使用response的响应流，repsonse一共提供了两个响应流对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = response.getWriter()：<span class="comment">//获取字符流；如果响应正文内容为字符</span></span><br><span class="line">ServletOutputStream out = response.getOutputStream()：<span class="comment">//获取字节流；如果响应内容是字节，例如下载时</span></span><br></pre></td></tr></table></figure><p>注意，在一个请求中，不能同时使用这两个流！也就是说，要么你使用repsonse.getWriter()，要么使用response.getOutputStream()，但不能同时使用这两个流。不然会抛出IllegalStateException异常。</p><h2 id="字符响应流"><a href="#字符响应流" class="headerlink" title="字符响应流"></a>字符响应流</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>在使用response.getWriter()时需要注意默认字符编码为ISO-8859-1，如果希望设置字符流的字符编码为utf-8，可以使用response.setCharaceterEncoding(“utf-8”)来设置。这样可以保证输出给客户端的字符都是使用UTF-8编码的！但客户端浏览器并不知道响应数据是什么编码的！如果希望通知客户端使用UTF-8来解读响应数据，那么还是使用response.setContentType(“text/html;charset=utf-8”)方法比较好，因为这个方法不只会调用response.setCharaceterEncoding(“utf-8”)，还会设置content-type响应头，客户端浏览器会使用content-type头来解读响应数据。</p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>response.getWriter()是PrintWriter类型，所以它有缓冲区，缓冲区的默认大小为8KB。也就是说，在响应数据没有输出8KB之前，数据都是存放在缓冲区中，而不会立刻发送到客户端。当Servlet执行结束后，服务器才会去刷新流，使缓冲区中的数据发送到客户端。<br>如果希望响应数据马上发送给客户端：</p><ul><li>向流中写入大于8KB的数据；</li><li>调用response.flushBuffer()方法来手动刷新缓冲区；</li></ul><h2 id="设置响应头信息"><a href="#设置响应头信息" class="headerlink" title="设置响应头信息"></a>设置响应头信息</h2><p>可以使用response对象的setHeader()方法来设置响应头！使用该方法设置的响应头最终会发送给客户端浏览器！<br>response.setHeader(“content-type”, “text/html;charset=utf-8”)：设置content-type响应头，该头的作用是告诉浏览器响应内容为html类型，编码为utf-8。而且同时会设置response的字符流编码为utf-8，即response.setCharaceterEncoding(“utf-8”)；<br>response.setHeader(“Refresh”,”5; URL=<a href="http://www.baidu.com“)：5秒后自动跳转到百度主页。">http://www.baidu.com“)：5秒后自动跳转到百度主页。</a></p><h2 id="设置状态码及其他方法"><a href="#设置状态码及其他方法" class="headerlink" title="设置状态码及其他方法"></a>设置状态码及其他方法</h2><p>response.setContentType(“text/html;charset=utf-8”)：等同与调用response.setHeader(“content-type”, “text/html;charset=utf-8”)；<br>response.setCharacterEncoding(“utf-8”)：设置字符响应流的字符编码为utf-8；<br>response.setStatus(200)：设置状态码；<br>response.sendError(404, “您要查找的资源不存在”)：当发送错误状态码时，Tomcat会跳转到固定的错误页面去，但可以显示错误信息。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch入门</title>
      <link href="2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/"/>
      <url>2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ES版本"><a href="#ES版本" class="headerlink" title="ES版本"></a>ES版本</h2><h2 id="V5-x"><a href="#V5-x" class="headerlink" title="V5.x"></a><strong>V5.x</strong></h2><ul><li>Lucene 6.x,</li><li>性能提升，默认打分机制从 TF-IDF 改为 BM 25</li><li>支持 Ingest 节点、 Completion suggested 、Java REST 客户端</li><li>Type 标记成 deprecated,支持了 Keyword 的类型</li><li>性能优化<ul><li>减少了内部争竞争，防止对同一文档进行并发更新的竞争以及在同步事务日志时减少了锁定要求，索引吞吐量已得到了极大的提高</li><li>Instant Aggregations，在 Shard 层面提供了 Aggregation 缓存</li><li>新增了 Profile API</li></ul></li></ul><h2 id="V6-x"><a href="#V6-x" class="headerlink" title="V6.x"></a><strong>V6.x</strong></h2><ul><li>Lucene 7.x</li><li><strong>Removal of types，在 6.0 里面，开始不支持一个 index 里面存在多个 type</strong></li><li>跨多个Elasticsearch集群搜索，保留原来的索引在 5.x 群集，跨群集搜索来同时搜索 6.x 和 5.x 群集</li><li>跨群集复制（CCR）</li><li>更友好的的升级及数据迁移，在主要版本之间的迁移更为简化，体验升级</li><li>性能优化<ul><li>稀疏区域改进，降低了存储成本</li><li>通过索引排序，可加快排序的查询性能</li></ul></li></ul><h2 id="V7-x"><a href="#V7-x" class="headerlink" title="V7.x"></a><strong>V7.x</strong></h2><ul><li>Lucene 8.0</li><li><strong>重大改进-正式废除单个索引下多 Type 的支持（只有_doc这一个默认type）</strong></li><li>7.1开始，Security 功能免费使用</li><li>ECK，允许用户在 Kubernetes 上配置，管理和操作 Elasticsearch 集群</li><li>TransportClient 被废弃以至于，ES7 的 Java 代码，只能使用 restclient</li><li>新功能<ul><li>新的集群协调</li><li>功能更完善的 REST Client</li><li>Script Score Query，下一代的评分方式</li></ul></li><li>性能优化<ul><li>默认的 Primary Shard 数从 5 改为 1，避免 Over Sharding</li><li>性能优化，更快的 Top K 检索</li></ul></li></ul><h2 id="ES客户端"><a href="#ES客户端" class="headerlink" title="ES客户端"></a>ES客户端</h2><p>Elasticsearch(ES)有两种连接方式：TransportClient、RestClient。TransportClient通过TCP方式访问ES(只支持java),RestClient方式通过http<br>API 访问ES(没有语言限制)。</p><p>Elasticsearch计划在Elasticsearch<br>7.0中弃用TransportClient，在8.0中完全删除它。故在实际使用过程中建议您使用Java高级REST client。不管是transport client还是rest client都是线程安全的，都应该使用单例。</p><p>TransportClient: TransportClient<br>是ElasticSearch（java）客户端封装对象，使用transport远程连接到Elasticsearch集群，默认用的TCP端口是9300，该transport<br>node并不会加入集群，而是简单的向ElasticSearch集群上的节点发送请求。</p><p>Rest Client: Java Low Level REST Client：elasticsearch client<br>低级别客户端。它允许通过http请求与Elasticsearch集群进行通信。API本身不负责数据的编码解码，由用户去编码解码。它与所有的ElasticSearch版本兼容。</p><p>Java High Level REST Client：Elasticsearch<br>client官方高级客户端。基于低级客户端，它定义的API,已经对请求与响应数据包进行编码解码。</p><h2 id="ES索引生命周期管理"><a href="#ES索引生命周期管理" class="headerlink" title="ES索引生命周期管理"></a>ES索引生命周期管理</h2><p><a href="https://juejin.cn/post/6911843658006265863">索引生命周期管理方案</a><br><code>Elastic Stack 6.6</code> 版本后推出Index Lifecycle Management(索引生命周期管理)，支持针对索引的全生命周期托管管理，并且<code>Kibana</code> 上也提供了一套 UI 界面来配置策略。</p><h2 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h2><p> ES                       -&gt;                  数据库<br> 索引 index           -&gt;                  表<br> 文档 document    -&gt;                  行（记录）<br> 字段 fields           -&gt;                   列<br> 映射 mapping      -&gt;                  表结构<br> 近实时 NRT         -&gt;                  Near real time 近实时的搜索,从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级<br> 节点 node            -&gt;                  每一个服务器 </p><h3 id="集群相关概念"><a href="#集群相关概念" class="headerlink" title="集群相关概念"></a>集群相关概念</h3><p>分片（shard）：把索引库拆分为多份，分别放在不同的节点上，比如有3个节点，3个节点的所有数据内容加在一起是一个完整的索引库。分别保存到三个节点上水平扩展，提高吞吐量。每个shard都是一个lucene index。<br>备份（replica）：每个shard的备份。</p><p>shard = primary shard（主分片）<br>replica = replica shard（备份节点）</p><h3 id="倒排索引概念"><a href="#倒排索引概念" class="headerlink" title="倒排索引概念"></a>倒排索引概念</h3><p>也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。 它是文档检索系统中最常用的数据结构。<br> <strong>根据单词去搜索包含单词的文档，并且显示在文档中的词频（TF)和位置(POS)</strong></p><p><img src="/2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/8045c22ea2684a60aefb7871c2b37b4e~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p><img src="/2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/a03a9ef91555428fb1287d83cbf169f9~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h2 id="Elasticsearch-7-10-之-Search-shard-routing"><a href="#Elasticsearch-7-10-之-Search-shard-routing" class="headerlink" title="Elasticsearch 7.10 之 Search shard routing"></a>Elasticsearch 7.10 之 Search shard routing</h2><p><a href="https://juejin.cn/post/6908999948605112333">Search shard routing</a></p><h2 id="lucene"><a href="#lucene" class="headerlink" title="lucene"></a>lucene</h2><p>就是一个jar包，里面包含了封装好的各种建立倒排索引，以及进行搜索的代码，包括各种算法。我们就用java开发的时候，引入lucene jar，然后基于lucene的api进行去进行开发就可以了。用lucene，我们就可以去将已有的数据建立索引，lucene会在本地磁盘上面，给我们组织索引的数据结构。</p><p><img src="/2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/0b9302f5543e4f1dab3ed0ab5c88fb7d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h2 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h2><p>分片机制：（我们之前随随便便就将一些document插入到es集群中去了，我们有没有care过数据怎么进行分片的，数据到哪个shard中去） </p><p>cluster discovery：（集群发现机制，我们再次启动一个es进程，这个进程作为一个node自动就发现了集群，并且加入了进去，还接受了部分数据，replica shard） </p><p>shard负载均衡：（举例，假设现在有3个节点，总共有25个shard要分配到3个节点上去，es会自动进行均匀分配，以保持每个节点的均衡的读写负载请求） </p><p>shard副本： 请求路由，集群扩容，shard重分配</p><p>增减或减少节点时的数据rebalance:保持负载均衡</p><p>master节点:创建或删除索引,增加或删除节点</p><p>节点平等的分布式架构:节点对等，每个节点都能接收所有的请求,自动请求路由,响应收集</p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>订阅发布者模式和生产消费者模式区别</title>
      <link href="2021/04/20/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB/"/>
      <url>2021/04/20/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>订阅发布者模式本质上也是一种生产者消费者模式，订阅者是消费者，发布者是生产者。如果一定要说个区别，就是抽象级别的区别吧。</p><p>订阅者肯定是个消费者，但消费者不一定是订阅者，发布者一定是个生产者，但生产者不一定是个发布者。</p><p><font color="red">订阅发布者模式有时也称为观察者模式</font>，订阅发布者（观察这和被观察者）存在着主动被动的关系，而生产者消费者比较中性吧。 订阅发布模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。而生产者消费者关系可以是1对1，1对多，多对1，多对多关系</p><p>补充：在23种设计模式中的观察者模式中，并没有中间介-队列的概念，但生产者消费者模式在多线程环境下好像天生就有队列的概念。在订阅发布者之间引入消息队列后，可以实现订阅者和发布者之间的解耦，任务可以很好的以异步方式进行处理，所以说是否有中间队列不是订阅发布者模式和生产者消费者模式的区别</p><p>那么到底什么是观察者模式呢. 先看看生活中的观察者模式。</p><p>好莱坞有句名言. “不要给我打电话， 我会给你打电话”. 这句话就解释了一个观察者模式的来龙去脉。 其中“我”是发布者， “你”是订阅者。</p><p>我来公司面试的时候，完事之后每个面试官都会对我说：“请留下你的联系方式， 有消息我们会通知你”。 在这里“我”是订阅者， 面试官是发布者。所以我不用每天或者每小时都去询问面试结果， 通讯的主动权掌握在了面试官手上。而我只需要提供一个联系方式。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>监控之Skywalking的原理</title>
      <link href="2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>SkyWalking是一款广受欢迎的国产APM（Application Performance Monitoring，应用性能监控）产品，主要针对微服务、Cloud Native和容器化（Docker、Kubernetes、Mesos）架构的应用。SkyWalking的核心是一个分布式追踪系统，目前是Apache基金会的顶级项目。</p><p>要通过SkyWalking将Java应用数据上报至链路追踪控制台，首先需要完成埋点工作。SkyWalking既支持自动探针（Dubbo、gRPC、JDBC、OkHttp、Spring、Tomcat、Struts、Jedis等），也支持手动埋点（OpenTracing）。<img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84%E5%8E%9F%E7%90%86/xtrace_dg_report_by_skywalking.png" alt="img"></p><p><a href="https://blog.csdn.net/u010928589/article/details/105343949/">agent插件加载原理</a><br><a href="https://blog.csdn.net/u010928589/article/details/106542794?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161890434816780261969574%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161890434816780261969574&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-106542794.nonecase&utm_term=agent&spm=1018.2226.3001.4450">agent采集trace数据</a><br><a href="https://blog.csdn.net/u010928589/article/details/106608864?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161890434816780261969574%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161890434816780261969574&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-106608864.nonecase&utm_term=agent&spm=1018.2226.3001.4450">agent启动服务分析以及性能影响</a></p><p><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84%E5%8E%9F%E7%90%86/skywalking.jpg" alt="skywalking"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>监控之Skywalking的UI详解</title>
      <link href="2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="UI指标"><a href="#UI指标" class="headerlink" title="UI指标"></a>UI指标</h2><h3 id="cpm-每分钟请求数"><a href="#cpm-每分钟请求数" class="headerlink" title="cpm 每分钟请求数"></a>cpm 每分钟请求数</h3><p>cpm 全称 call per minutes，是吞吐量(Throughput)指标。 下图是拼接的全局、服务、实例和接口的吞吐量及平均吞吐量。<br><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/9c0da3123eb845bc8f81029b0cf86956tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="SLA-服务等级协议"><a href="#SLA-服务等级协议" class="headerlink" title="SLA 服务等级协议"></a>SLA 服务等级协议</h3><p>SLA 全称 Service-Level Agreement，直译为 “服务等级协议”，用来表示提供服务的水平。<br><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/d43aabb380f949c9b1c8892992fb4650tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>在IT中，SLA可以衡量平台的可用性，下面是N个9的计算：</p><ol><li>1年 = 365天 = 8760小时</li><li>99     = 8760 * 1%     =&gt; 3.65天</li><li>99.9   = 8760 * 0.1%   =&gt; 8.76小时</li><li>99.99  = 8760 * 0.01%  =&gt; 52.6分钟</li><li>99.999 = 8760 * 0.001% =&gt; 5.26分钟</li></ol><p>因此，全年只要发生一次较大规模宕机事故，4个9肯定没戏，一般平台3个9差不多。 但2个9就基本不可用了，相当于全年有87.6小时不可用，每周(一个月按4周算)有1.825小时不可用。 下图是服务、实例、接口的SLA，一般看年度、月度即可。</p><h3 id="Percent-Response-百分位数统计"><a href="#Percent-Response-百分位数统计" class="headerlink" title="Percent Response 百分位数统计"></a>Percent Response 百分位数统计</h3><p>表示采集样本中某些值的占比，Skywalking 有 <code>p50、p75、p90、p95、p99</code> 一些列值。 “p99:390” 表示 99% 请求的响应时间在390ms以内。而99%一般用于抛掉一些极端值，表示绝大多数请求。</p><h3 id="Slow-Endpoint-慢端点"><a href="#Slow-Endpoint-慢端点" class="headerlink" title="Slow Endpoint 慢端点"></a>Slow Endpoint 慢端点</h3><p>Endpoint 表示具体的服务，例如一个接口。全局Top N的数据，通过这个可以观测平台性能情况。</p><h3 id="Heatmap-热力图"><a href="#Heatmap-热力图" class="headerlink" title="Heatmap 热力图"></a>Heatmap 热力图</h3><p>Heapmap 可译为热力图、热度图都可以，途中颜色越深，表示请求数越多，这和GitHub Contributions很像，commit越多，颜色越深。 横坐标是响应时间，鼠标放上去，可以看到具体的数量。 通过热力图，一方面可以直观感受平台的整体流量，另一方面也可以感受整体性能。</p><h3 id="apdex（性能指数）"><a href="#apdex（性能指数）" class="headerlink" title="apdex（性能指数）"></a>apdex（性能指数）</h3><p><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/d7e83272482e42169ae7ff6e48167cd8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>是一个衡量服务器性能的标准。 apdex有三个指标：</p><ul><li>满意：请求响应时间小于等于T。</li><li>可容忍：请求响应时间大于T，小于等于4T。</li><li>失望：请求响应时间大于4T。</li></ul><p>T：自定义的一个时间值，比如：500ms。 apdex = （满意数 + 可容忍数/2）/ 总数。 例如：服务A定义T=200ms，在100个采样中，有20个请求小于200ms，有60个请求在200ms到800ms之间，有20个请求大于800ms。计算apdex = (20 + 60/2)/100 = 0.5。</p><h3 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h3><p><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/ab8042af99c4472f90b567421e6bf00b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL深入</title>
      <link href="2021/03/18/MySQL%E6%B7%B1%E5%85%A5/"/>
      <url>2021/03/18/MySQL%E6%B7%B1%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>分享思路： 会先从一个简单的update语句入手，分析它在被执行时是如何与InnoDB存储引擎的各种机制结合起来的，并依次完成整个update语句的执行，在本次分享开始前可以先尝试思考如下面试题：</p><p>1.数据页和缓存页是什么？如何知道哪些缓存页是空闲的，哪些缓存页是可被清除的？</p><p>2.mysql预读机制了解过吗，什么情况下会触发它？mysql是为了应对什么样的场景才设计预读机制？</p><p>3.类比redis在内存中也存在冷热数据共存的场景，如何考虑利用lru链表解决预读机制的思想、来对redis缓存的设计进行优化？</p><p>4.内存极度不够用情况下，可能每当要加载一个数据页时就要先把一个缓存页刷到磁盘中，出现双倍IO的性能问题，对于这种现象如何考虑优化Mysql内核参数来尽量避免该情况的性能损耗？</p><p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144719056.png" alt="image-20210318144719056"></p><p>先来思考一个问题。磁盘数据如何加载到mysql中？</p><p>一般我们要更新一条数据，数据一开始肯定是存放在磁盘中的，用到时才会被加载到mysql，存放的数据在逻辑概念上我们称为表，物理层面上在磁盘中是按数据页形式存放的，那么加载到mysql中的就称为缓存页。</p><p>每个缓存页都有对应的一份描述信息，存放了缓存页的一些元数据相关的一些信息，通过描述信息可以快速定位到缓存页，最开始描述信息指向的缓存页当然都是空闲没有数据的，从磁盘加载数据页信息流程如下图所示：</p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144742613.png" alt="image-20210318144742613" style="zoom:33%;"><p>那么从磁盘中加载一个数据页到mysql中真的就这么简单吗？<br>会不会同一份数据页加载到mysql中出现重复加载的情况？<br>如何快速知道当前数据页是否已经加载到mysql中了？</p><p>这时候可能很多人已经想到了：缓存。对于已经加载到mysql中的数据页，我们大可以设计一个缓存将加载过的数据页信息缓存一下，一方面可以防止同一份数据页重复加载到mysql，另一方面当我们需要使用到数据页的信息时，可以通过缓存信息快速定位mysql中对应的缓存页，没错，InnoDB存储引擎中就是按照这样的思路设计了一个数据页缓存：</p><p>这时候可能很多人已经想到了：缓存。对于已经加载到mysql中的数据页，我们大可以设计一个缓存将加载过的数据页信息缓存一下，一方面可以防止同一份数据页重复加载到mysql，另一方面当我们需要使用到数据页的信息时，可以通过缓存信息快速定位mysql中对应的缓存页，没错，InnoDB存储引擎中就是按照这样的思路设计了一个数据页缓存：</p><p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144815867.png" alt="image-20210318144815867"></p><p>这个时候又有一个问题，既然现在我们已经知道磁盘中的数据页是加载到buffer pool缓冲池中的，那么我们怎么样才能知道哪些缓存页是空闲的？</p><p>哪些缓存页是没有被加载过数据页信息的呢？毕竟加载过的数据的缓存页和没加载过数据的缓存页混在一起，倘若此时想找一个空闲的缓存页肯定也是一件很麻烦的事。InnoDB存储引擎在设计时当然也考虑到了这点，这里它引入了free链表这个数据结构，将那些还没有被使用的缓存页的描述信息用双向循环链表给组合在一起，需要用到时就卸一个节点出来存放数据页信息，如下图所示：</p><p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144830908.png" alt="image-20210318144830908"></p><p>lru链表实现的目的就是为让哪些被访问的缓存页能够尽量排到靠前位置，那么此时如果此时内存不够需要淘汰掉一些缓存页时，此时就可以到lru链表尾部，将哪些最近最少被访问的尾部节点给刷盘释放缓存页腾出内存来。</p><p>到这里为此，为了更新一个sql，我们已经把该sql所需要的数据、通过InnoDB存储引擎的各种底层机制，给加载到了Buffer Pool缓冲池中了，接下来就是在InnoDB中执行更新操作。</p><p>我们在来看看。 在InnoDB中执行更新操作是怎么回事？</p><p>此时我们需要的数据已经从磁盘中加载到缓冲池中了，下一步当然就是执行更新操作了：先对需要更新的那行数据加锁、原始数据写一份到redo log中便于可能的回滚操作、执行update操作，此时缓存页的数据就被更新了，当然就和磁盘中的数据页的数据就不一致了，这样的缓存页我们称之为脏页，如下图所示：</p><p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144904374.png" alt="image-20210318144904374"></p><p>那么，如何才能知道缓冲池中，那些缓存页是脏页呢？如果能把脏页和空闲缓存页分离出来，我们就可以把那些脏页的数据及时给刷到磁盘中、再释放掉脏页内存，在内存不够的情况下不就可以重复利用了吗？<br>这里InnoDB的设计方法类似free链表，设计了一个flush链表，也就是那些在缓冲池中被更新过数据的缓存页，这些缓存页的描述信息都会被添加到flush链表中（这里提到的free链表、lru链表、flush链表都是双向循环链表，且节点都为缓存页的描述信息，其中flush链表的节点同时也在lru链表中），如下图所示：</p><p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144925987.png" alt="image-20210318144925987"></p><p>然后的话。有了这种机制，会不会导致缓冲池内存不足触发脏页刷盘？</p><p>经过以上流程执行了一段时间后，直到InnoDB缓冲池中的内存即将不够用了，此时如果再来一条sql语句的更新操作，要想成功把磁盘中的数据加载到缓存页中，就需要先清理下内存中的缓存页了。通过之前提到的lru链表，可以找到lru链表表尾的节点，这些节点之所以在表尾，是因为基本上没什么人访问它们，那它们在内存不够用的场景下，当然要被优先给清理掉啊；</p><p>因为flush链表的节点也在lru链表中，此时在缓存页清理时需要做一个简单的判断：若缓存页既在lru表尾的节点同时也在flush链表中，就需要先把脏页给刷盘了，然后再释放掉缓存页的内存，保证那些事务修改的数据能够落库；若缓存页不在flush链表，那更简单直接释放缓存页内存，然后将这些释放完内存缓存页的描述信息，重现给添加到free链表中，完成一次大的循环（free链表-&gt;lru链表-&gt;flush链表-&gt;free链表），如下图所示：</p><p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144959394.png" alt="image-20210318144959394"></p><p>最后一个就是存在的问题就是： mysql的预读机制带来的问题以及优化后的lru链表对该问题的解决方案</p><p>mysql预读机制可能会扰乱我们之前设想的lru链表的处理逻辑。当一个数据页被加载到缓冲池中时，可能顺带会把其他无关紧要的数据页也加载到缓冲池中，这些顺带加载到内存的数据页，它们往往被访问的频率是非常低的，但是由于lru链表的特点，新加入的总是会优先被排在lru的链表头，导致这些顺带进来的、访问频率比较低的缓存页排在比较靠前的位置，导致free链表不够时，lru链表反而会把那些本来访问频率较高、但是此时被排挤到lru链表尾的缓存页给刷盘清理了，这是很不合理的。</p><p>优化后的lru链表主要引入了冷热数据分离的思想解决了mysql预读机制带来的问题。把lru链表分为热数据区和冷数据区，热数据区主要存放那些访问频率高的缓存页，冷数据区存放访问频率较低的缓存页；从磁盘加载数据到lru链表时，首先会将加载到的缓存页直接先放到冷数据链的表头，如果1000ms（默认，可配置）后冷数据的缓存页又被访问了，此时就认为这些1000ms之后被访问的缓存页，在不久的未来可能还会被访问，可以认为它们是热数据了，就会把这些缓存页从冷数据区的链表给移动到热数据区链表的表头，通过该步骤可以将热数据从冷数据堆中给巧妙的分离出来，如下图所示</p><p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318145057335.png" alt="image-20210318145057335"></p><p>此时如果要加载其他数据页发现缓冲池内存不够，实际上后台一直会有一个线程开启的一个定时任务，不断的从lru链表的尾部将缓存页给刷到磁盘中并释放缓存页，lru链表冷热数据分离的设计，确保了定时任务从lru链表尾部回收的缓存页都是访问频率很低的数据，对性能的影响也就降到了最低。</p><p>1.数据页和缓存页是什么？如何知道哪些缓存页是空闲的，哪些缓存页是可被清除的？</p><p>2.mysql预读机制了解过吗，什么情况下会触发它？mysql是为了应对什么样的场景才设计预读机制？</p><p>3.类比redis在内存中也存在冷热数据共存的场景，如何考虑利用lru链表解决预读机制的思想、来对redis缓存的设计进行优化？</p><p>4.内存极度不够用情况下，可能每当要加载一个数据页时就要先把一个缓存页刷到磁盘中，出现双倍IO的性能问题，对于这种现象如何考虑优化Mysql内核参数来尽量避免该情况的性能损耗？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>总结-面试系列文章</title>
      <link href="2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
      <url>2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://www.jb51.net/article/101062.htm">脏页、内存映射、延迟写、sync、fsync、fdatasync</a><br><a href="https://www.jianshu.com/p/92f33aa0ff52">page cache</a><br><a href="https://www.jianshu.com/p/92f33aa0ff52">零拷贝（transferTo方法</a><br><a href="https://www.jianshu.com/p/193cae9cbf07">零拷贝</a><br>trasferTo方法的缺点：如果我想在传输时修改数据本身，就无能为力了。还有一种方式就是内存映射。</p><p>Linux 会以页为单位管理内存，无论是将磁盘中的数据加载到内存中，还是将内存中的数据写回磁盘，操作系统都会以页面为单位进行操作，哪怕我们只向磁盘中写入一个字节的数据，我们也需要将整个页面中的全部数据刷入磁盘中。</p><p>Linux 同时支持正常大小的内存页和大内存页（Huge Page），绝大多数处理器上的内存页的默认大小都是 4KB，虽然部分处理器会使用 8KB、16KB 或者 64KB 作为默认的页面大小，但是 4KB 的页面仍然是操作系统默认内存页配置的主流；除了正常的内存页大小之外，不同的处理器上也包含不同大小的大页面，我们在 x86 处理器上就可以使用 2MB 的内存页。</p><p>4KB 的内存页其实是一个历史遗留问题，在上个世纪 80 年代确定的 4KB 一直保留到了今天。虽然今天的硬件比过去丰富了很多，但是我们仍然沿用了过去主流的内存页大小。执行命令：getconf PAGE_SIZE。获取系统的page大小，一般为4096即4K。在windows上查询为65536即64K。</p><p>对于系统的所有文件I/O请求，操作系统都是通过page cache机制实现的，对于操作系统而言，磁盘文件都是由一系列的数据块顺序组成，数据块的大小随系统不同而不同，x86 linux系统下是4KB(一个标准页面大小)。内核在处理文件I/O请求时，首先到page cache中查找(page cache中的每一个数据块都设置了文件以及偏移信息)，如果未命中，则启动磁盘I/O，将磁盘文件中的数据块加载到page cache中的一个空闲块。之后再copy到用户缓冲区中。</p><p>很明显，同一块文件数据，在内存中保存了两份，这既占用了不必要的内存空间、冗余的拷贝、以及造成的CPU cache利用率不高。针对此问题，操作系统提供了<strong>内存映射</strong>机制（linux中mmap、windows中Filemapping）</p><p>由于页面缓存的存在，当程序调用write()写字节时，只需将其复制到页面缓存中，并将页面标记为dirty。磁盘I/O通常不会立即发生，因此你的程序不会阻塞等待磁盘。不利的一面是，如果计算机崩溃，您的写操作将永远无法完成，因此像数据库事务日志这样的关键文件必须调用fsync()立刻写入到磁盘(但是仍然需要担心驱动器控制器的缓存，也可能造成并不会立刻写入到物理磁盘)。另一方面，读取通常会阻塞程序，直到数据可用为止。内核使用<strong>预先加载技术</strong>来缓解这个问题，其中一个例子是提前读取，内核将几个页面预加载到页面缓存中，等待你的读取。你可以通过调整内核的一些选项来调整预先加载行为，可以控制<strong>顺序读取文件</strong>还是<strong>随机读取文件</strong>。Linux确实对内存映射文件进行预读，但我不确定Windows是否如此。最后，可以在Linux中使用O_DIRECT绕过页面缓存，或者在Windows中使用NO_BUFFERING绕过页面缓存，这是数据库软件经常做的事情。</p><p><a href="https://juejin.cn/post/6939881308114354207">内核空间和用户空间、零拷贝</a></p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><p><a href="https://juejin.cn/post/6863631783028588558?utm_source=gold_browser_extension?utm_source=gold_browser_extension">Java新特性</a></p><p><a href="http://www.hellojava.com/a/86057.html">Java序列化为什么要实现Serializable接口</a></p><p><strong>为什么要进实现Serializable接口：</strong>为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来，这是java中的提供的保存对象状态的机制—序列化。</p><p><strong>在什么情况下需要使用到Serializable接口呢？</strong><br>　　1、当想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>　　2、当想用套接字在网络上传送对象的时候；<br>　　3、当想通过RMI传输对象的时候；<br>　　<br><strong>serialVersionUID</strong><br>serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。<strong>如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。</strong>类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。显式地定义serialVersionUID有两种用途：<br>　　a. 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；<br>　　b. 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p><p><a href="https://juejin.cn/post/6939852157478764551">happens-before规则</a><br><a href="https://juejin.cn/post/6939841279329042439">BIO、BIO、AIO详解</a><br><a href="https://juejin.cn/post/6890377431137484807">String的hashCode详解</a></p><p>hash冲突解决方法是：使用链表</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><a href="https://baijiahao.baidu.com/s?id=1684596804166445688&wfr=spider&for=pc">volatile是如何实现可见性和有序性的</a></p><p><a href="https://blog.csdn.net/weixin_36759405/article/details/82856542">volatile内存屏障</a></p><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p><a href="https://www.jianshu.com/p/6189034c6984">懒汉双检查单例模式</a></p><p><a href="https://blog.csdn.net/emmmsuperdan/article/details/81564412">可见性、有序性、原子性</a></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a href="https://juejin.cn/post/6934866839247781919">Synchronized</a></p><p><a href="https://juejin.cn/post/6904880910408433678">为什么推荐ReentrantLock而不是Synchronized</a></p><p>synchronized的锁强度依次为：无锁状态、偏向锁状态、轻量级锁、重量级锁，会随着多线程的竞争强度逐渐升级。这个是众所周知的,最近在看《并发编程的艺术》中提到了锁只能升级而无法降级，但是我记得在之前的某些资料中看到过:<strong>锁是可以降级的，只不过条件比较苛刻</strong>。不知道对于此有什么具体的权威的资料可以参考呢？</p><p>并没有 JDK 标准，完全看各家 JVM 是咋实现的了。</p><p>像 HotSpot JVM 其实就支持锁降级，但是锁升降级效率较低，如果频繁升降级的话对性能就会造成很大影响。重量级锁降级发生于 STW 阶段，降级对象为仅仅能被 VMThread 访问而没有其他 JavaThread 访问的对象。</p><p>被锁的对象都被垃圾回收了有没有锁还有啥关系？因此基本认为锁不可降级。</p><p><a href="https://juejin.cn/post/6911277200402546695">ReentrantReadWriteLock详解</a></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><a href="https://juejin.cn/post/6939477784498716679">集合</a><br><a href="https://blog.csdn.net/fuzhongmin05/article/details/72638721">集合</a></p><p><strong>队列Queue-》Deque</strong></p><ul><li>PriorityQueue </li><li>ConcurrentLinkedQueue 基于单链表实现</li><li>ArrayDeque</li><li>ConcurrentLinkedDeque 基于双链表实现</li></ul><p>堵塞队列BlockingQueue》BlockingDeque</p><ul><li><p>LinkedBlockingDeque 双端双向链表堵塞队列</p></li><li><p>LinkedBlockingQueue</p></li><li><p>ArrayBlockQueue</p></li><li><p>LinkedTransferQueue</p></li><li><p>PriorityBlockingQueue</p></li><li><p>SynchronousQueue</p></li><li><p>DelayQueue</p></li></ul><h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><ul><li><a href="https://juejin.cn/post/6937266785854947358">ConcurrentHashMap</a>: key和value不能为null，<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505119&idx=1&sn=f68a4c4943b13e34969c1643a3cda916&source=41#wechat_redirect">死循环</a>，<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505071&idx=1&sn=5b9bbe01a71cbfae4d277dd21afd6714&source=41#wechat_redirect">为啥不能为null</a></li><li><a href="https://blog.csdn.net/vernonzheng/article/details/8244984">ConcurrentSkipListMap</a></li><li>ConcurrentSkipListSet 基于ConcurrentSkipListMap实现，key,value不能为空</li><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet  基于CopyOnWriteArrayList实现，添加时判断是否存在，添加时，加可重入非公平锁ReentrantLock，复制新的数组对象，进行写操作，写完之后释放锁。此时查询操作不影响。</li><li><a href="https://www.sohu.com/a/426750225_120591934">SkipList自己实现</a> </li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd">线程池除了常见的4种拒绝策略，你还知道哪些</a></p><p><a href="https://juejin.cn/post/6936098056299347975">源码分析</a><br><a href="https://juejin.cn/post/6937121827445538847">线程及线程池</a></p><p><font color="red">ForkJoinPool</font>的核心是采用分治法的思想，将一个大任务拆分为若干互不依赖的子任务，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务。同时，为了最大限度地提高并行处理能力，采用了工作窃取算法来运行任务，也就是说当某个线程处理完自己工作队列中的任务后，尝试当其他线程的工作队列中窃取一个任务来执行，直到所有任务处理完毕。所以为了减少线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。<br><font color="red">parallelStream</font>是一个并行执行的流，其使用 fork/join （ForkJoinPool）并行方式来拆分任务和加速处理过程。<br><a href="https://blog.csdn.net/qq_37896194/article/details/113125334">parallelStream问题点（线程安全和commonPool卡顿）</a></p><h2 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h2><p><a href="https://www.cnblogs.com/xiaoblog/p/4729309.html">spring集成hessian</a><br><a href="https://blog.csdn.net/zh350229319/article/details/71191347">spring集成hessian</a><br><a href="https://www.jianshu.com/p/6a36dd1fcca8">java序列化之Hessian</a></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><a href="https://juejin.cn/post/6936524515883089950">Class文件结构</a></p><p><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码结构</a></p><p><a href="https://juejin.cn/post/6938276102553108511">类加载机制</a><br><a href="https://juejin.cn/post/6934124106795188238">类加载机制</a><br><a href="https://juejin.cn/post/6938233964725272606">Java中的常量池</a></p><p><a href="https://juejin.cn/post/6937494243552264200">JVM生命周期</a><br><a href="https://juejin.cn/post/6931372159356895246">JVM结构</a><br><a href="https://juejin.cn/post/6936390496122044423">JVM问题</a><br><a href="https://juejin.cn/post/6938255230563778597">java虚拟机类型</a></p><p><a href="https://juejin.cn/post/6938599768071340040">JVM垃圾回收</a><br><a href="https://juejin.cn/post/6894500808583610382">JVM垃圾回收</a><br><a href="https://juejin.cn/post/6905300467027771405">回收算法</a><br><a href="https://juejin.cn/post/6926056104590278664">垃圾回收器CMS详解</a><br><a href="https://juejin.cn/post/6926056104590278664">垃圾回收器G1</a><br><a href="https://juejin.cn/post/6936013918212980743">JVM基本参数</a><br><a href="https://juejin.cn/post/6911624328472133646">MAT深度</a><br><a href="https://juejin.cn/post/6929038616417009671">JVM总结</a><br><a href="https://juejin.cn/post/6911668514096955406">JVM总结</a></p><p><a href="https://juejin.cn/post/6894398706225774606">JVM 性能调优监控工具</a><br><a href="https://juejin.cn/post/6920102335582568456">JVM 性能调优监控工具</a><br><a href="https://juejin.cn/post/6894500808583610382">CMS GC问题分析与解决</a><br><a href="https://juejin.cn/post/6894501519001911310">CMS GC问题分析与解决</a><br><a href="https://juejin.cn/post/6934218573963329549">JVM性能优化实战</a><br><a href="https://juejin.cn/post/6920468146906202119">JVM性能调优实战</a><br><a href="https://juejin.cn/post/6921527104009928717">JVM性能调优实战</a><br><a href="https://juejin.cn/post/6921278948030709768">JVM性能调优实战</a><br><a href="https://juejin.cn/post/6905172888601493517">性能</a><br><a href="https://juejin.cn/post/6915648411643412488">JVM如何调优</a><br><a href="https://juejin.cn/post/6913788257843019783">代码优化细节</a><br><a href="https://juejin.cn/post/6927291610732429325">性能调优</a><br><a href="https://juejin.cn/post/6918668597715795975">记一次线上服务器oom 排查过程</a></p><p><a href="https://juejin.cn/post/6937652257185857566">对象的实例化与对象的访问</a><br><a href="https://juejin.cn/post/6929273950438424589">hashCode()底层 JDK C++ 源码实现</a></p><p><a href="https://juejin.cn/post/6935407834863501349">伪共享</a></p><p><a href="https://www.cnblogs.com/MoreThinking/p/9908001.html">垃圾回收算法</a><br><a href="https://www.cnblogs.com/zeussbook/p/12726824.html">Java垃圾回收CMS、G1、ZGC</a></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>当bean继承spring 的FactoryBean时，使用applicationContext.getBean(beanName)得到的是bean的getObject方法的返回值，而不是bean本身。此时需要的话请用 applicationContext.getBean(‘&amp;’+beanName)将得到bean本身。</p><p>而且使用 applicationContext.getBean(beanName)的时候bean的getObject只会调用一次，此后都是直接返回原先的对象， 使用applicationContext.getBean(‘&amp;’+beanName)后再调用bean.getObject方法就可以多次调用bean.getObject方法体，从而改变返回对象的值</p><h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据beanName从缓存中拿实例</span></span><br><span class="line">    <span class="comment">//先从一级缓存拿</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//从二级缓存中拿</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//如果还拿不到，并且允许bean提前暴露</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">//从三级缓存中拿到对象工厂</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//从工厂中拿到对象</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">//升级到二级缓存</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;======get instance from 3 level cache-&gt;beanName-&gt;&quot;</span> + beanName + <span class="string">&quot;-&gt;value-&gt;&quot;</span> + singletonObject );</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">//删除三级缓存</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring规范"><a href="#Spring规范" class="headerlink" title="Spring规范"></a>Spring规范</h2><ul><li>xxxConfigurer</li><li>xxxSupport</li><li>xxxFactoryBean   配置bean</li><li>xxxBuilder  建造者模式，屏蔽复制对象的构建过程</li><li>xxxAdapter  xxxInterceptorAdapter</li><li>xxxHandler  处理器</li><li>xxxListener</li><li>xxxLoader</li><li>Advisor 通知器可以获取Advice通知<br>PointcutAdvisor带切入点的通知器<br>Advised被增强的类——》AdvisedSupport  -&gt;ProxyCreatorSupport  -&gt;ProxyFactory<br>通过DefaultAopProxyFactory implements AopProxyFactory创建AopProxy</li><li>AdvisorAdapter -》getInterceptor</li></ul><h2 id="Spring校验机制"><a href="#Spring校验机制" class="headerlink" title="Spring校验机制"></a>Spring校验机制</h2><p><a href="https://blog.csdn.net/csdn_mrsongyang/article/details/106115243">Validation实战</a></p><h2 id="Spring中Resource"><a href="#Spring中Resource" class="headerlink" title="Spring中Resource"></a>Spring中Resource</h2><p><a href="https://www.cnblogs.com/deityjian/p/11487644.html">Resource-&gt;ResourceLoader</a></p><h2 id="Spring属性占位符"><a href="#Spring属性占位符" class="headerlink" title="Spring属性占位符"></a>Spring属性占位符</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;configBean&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:$&#123;collectiongaode.dir&#125;/conf/db.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul><li>Spring AOP</li><li>Spring AspectJ<ul><li>@Before: 前置通知, 在方法执行之前执行</li><li>@After: 后置通知, 在方法执行之后执行 。</li><li>@AfterRunning: 返回通知, 在方法返回结果之后执行</li><li>@AfterThrowing: 异常通知, 在方法抛出异常之后</li><li>@Around: 环绕通知, 围绕着方法执行</li></ul></li></ul><h2 id="Spring-transaction"><a href="#Spring-transaction" class="headerlink" title="Spring  transaction"></a>Spring  transaction</h2><p>事务隔离级别，传播行为</p><p><a href="https://blog.csdn.net/weixin_44605704/article/details/108754813">事务失效</a></p><p>事务失效解决方法：</p><ul><li>AopContext.currentProxy(); 需要</li><li>getBean</li><li>注入自己</li></ul><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p><a href="https://www.cnblogs.com/zhao307/p/5555597.html">四种HandlerMapping</a><br><a href="https://juejin.cn/post/6922276487995326472">spring mvc原理</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种方案：使用自定义类实现OncePerRequestFilter,使用ServletComponentScan,使用FilterRegistrationBean</span></span><br><span class="line"><span class="comment">//自定义拦截器可以实现OncePerRequestFilter保证一次请求只调用一次doFilterInternal方法，内部的forward不会再多执行一次</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">timeFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setEnable(<span class="keyword">false</span>); <span class="comment">//也可保证只调用一次</span></span><br><span class="line">    TimeFilter timeFilter = <span class="keyword">new</span> TimeFilter();</span><br><span class="line">    registrationBean.setFilter(timeFilter);</span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    urls.add(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    registrationBean.setUrlPatterns(urls);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Async"><a href="#Spring-Async" class="headerlink" title="Spring Async"></a>Spring Async</h2><p><a href="https://my.oschina.net/guangshan/blog/1807721">Spring中AOP失效</a></p><h2 id="Spring工具类"><a href="#Spring工具类" class="headerlink" title="Spring工具类"></a>Spring工具类</h2><p><a href="https://cloud.tencent.com/developer/article/1497786">AnnotationUtils、AnnotatedElementUtils、AnnotationConfigUtils</a><br><a href="https://www.cnblogs.com/binarylei/p/10415585.html">注解工具类</a></p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p><a href="https://www.cnblogs.com/liaojie970/p/9395505.html">SpringBoot默认异常处理</a><br><a href="https://www.cnblogs.com/myitnews/p/13548435.html">application.properties配置详解</a><br><a href="https://www.cnblogs.com/myitnews/p/12329126.html">WebMvcConfigurer 与 WebMvcConfigurationSupport的坑</a></p><ul><li>WebMvcConfigurer、WebMvcConfigurationSupport、WebMvcConfigurerAdapter</li><li>HandlerInterceptorAdapter</li></ul><h2 id="Spring-Statemachine"><a href="#Spring-Statemachine" class="headerlink" title="Spring Statemachine"></a>Spring Statemachine</h2><p><a href="https://www.jianshu.com/p/9ee887e045dd">Spring Statemachine 概念及应用</a></p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><font color="red">AuthenticationManager</font>其中可以包含多个List<AuthenticationProvider> providers，还有父类的AuthenticationManager parent对象<br>AuthenticationManager    ——》ProviderManager<br>AuthenticationManager    ——》OAuth2AuthenticationManager</AuthenticationProvider></p><p><font color="red">AuthenticationProvider  </font>——》主要用来进行认证操作的类 调用其中的authenticate()方法去进行认证操作<br>1、 使用AuthenticationManager的实现类里的Authentication authenticate(Authentication authentication)方法认证<br>2、 从providers中循环获取AuthenticationProvider对象，判断是否supports支持Authentication的类对象<br>3、 如果返回true就使用AuthenticationProvider实现类里的authenticate方法，返回Authentication对象。不为空，复制给最开始的Authentication对象的实例；为空，则继续循环认证。一直认证失败，则使用父类的AuthenticationManager对象进行认证</p><p>AuthenticationProvider ——》AbstractUserDetailsAuthenticationProvider ——》DaoAuthenticationProvider（重写retrieveUser方法，获取注入的<font color="red">UserDetailsService</font>对象，通过loadUserByUsername方法获取用户详情<font color="red">UserDetails</font>对象（可以使用User也可自己实现），之后调用createSuccessAuthentication方法，创建UsernamePasswordAuthenticationToken对象）<br>AuthenticationProvider ——》RememberMeAuthenticationProvider</p><p>**<font color="red">Authentication </font>**是Spring Security方式的认证主体<br>Principal ——》Authentication ——》AbstractAuthenticationToken ——》UsernamePasswordAuthenticationToken<br>Principal ——》Authentication ——》AbstractAuthenticationToken ——》OAuth2Authentication<br>Principal ——》Authentication ——》AbstractAuthenticationToken ——》RememberMeAuthenticationToken</p><p><font color="red">UserDetailsService </font>是Spring Security查询密码的封装服务，通过<strong>扩展这个接口来显示获取我们的用户信息</strong><br>UserDetailsService ——》UserDetailsManager ——》InMemoryUserDetailsManager （内存保存用户名和密码）<br>UserDetailsService ——》自定义数据库Service操作（从数据库获取密码）</p><p><font color="red">SecurityContextHolder</font><strong>持有的是安全上下文（security context）的信息</strong>。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权等等，这些都被保存。默认<strong>使用ThreadLocal 策略来存储认证信息</strong>。在web环境下，Spring Security在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。</p><p><font color="red">SecurityContext </font>持有Authentication对象和其他可能需要的信息<br><font color="red">GrantedAuthority </font>对认证主题的应用层面的授权<strong>，含当前用户的权限信息</strong>，通常使用角色表示<br><font color="red">AuthenticationSuccessHandler</font> 认证成功处理器<br><font color="red">AuthenticationFailureHandler</font> 认证失败处理器</p><h3 id="Spring-Security-内置拦截器顺序及用途-核心"><a href="#Spring-Security-内置拦截器顺序及用途-核心" class="headerlink" title="Spring Security 内置拦截器顺序及用途(核心)"></a>Spring Security 内置拦截器顺序及用途(核心)</h3><p>1、<font color="red">ChannelProcessingFilter</font>，使用它因为我们可能会指向不同的协议(如:Http,Https)<br>2、<font color="red">SecurityContextPersistenceFilter</font>，负责从SecurityContextRepository 获取或存储 SecurityContext。SecurityContext 代表了用户安全和认证过的session<br>3、<font color="red">ConcurrentSessionFilter</font>,使用SecurityContextHolder的功能，更新来自“安全对象”不间断的请求,进而更新SessionRegistry<br>4、<font color="red">认证进行机制</font>，UsernamePasswordAuthenticationFilter，CasAuthenticationFilter，BasicAuthenticationFilter等等–SecurityContextHolder可能会修改含有Authentication这样认证信息的token值<br>5、<font color="red">SecurityContextHolderAwareRequestFilter</font>,如果你想用它的话，需要初始化spring security中的HttpServletRequestWrapper到你的servlet容器中。<br>6、<font color="red">JaasApiIntegrationFilter</font>，如果JaasAuthenticationToken在SecurityContextHolder的上下文中，在过滤器链中JaasAuthenticationToken将作为一个对象。<br>7、<font color="red">RememberMeAuthenticationFilter</font>，如果还没有新的认证程序机制更新SecurityContextHolder，并且请求已经被一个“记住我”的服务替代，那么将会有一个Authentication对象将存放到这（就是 已经作为cookie请求的内容）。<br>8、<font color="red">AnonymousAuthenticationFilter</font>，如果没有任何认证程序机制更新SecurityContextHolder，一个匿名的对象将存放到这。<br>9、<font color="red">ExceptionTranslationFilter</font>，为了捕获spring security的错误，所以一个http响应将返回一个Exception或是触发AuthenticationEntryPoint。<br>10、<font color="red">FilterSecurityInterceptor</font>，当连接被拒绝时，保护web URLS并且抛出异常。</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/Spring-Security.png" alt="Spring-Security"></p><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p><font color="red">WebSecurityConfigurerAdapter</font>（配套的注解：@EnableWebSecurity开启Security；@EnableGlobalMethodSecurity(prePostEnabled = true)//保证post之前的注解可以使用）<br>1、configure(HttpSecurity http)：这个方法是我们配置拦截的地方，可以配置拦截器，可以配置成功处理器和失败处理器等<br>2、configure(WebSecurity web)：这个方法主要用于访问一些静态的东西控制。其中ignoring()方法可以让访问跳过filter验证<br>3、configureGlobal(AuthenticationManagerBuilder auth)：这个方法是主要进行验证的地方，配置真实认证类</p><p><font color="red">SecurityConfigurerAdapter</font>(配置不带web的Security)<br>1、 public void configure(HttpSecurity http) 配置拦截。。。。</p><p><font color="red">ResourceServerConfigurerAdapter </font>资源服务（@EnableResourceServer，@AutoConfigureAfter(AuthorizationConfig.class)）<br>1、 public void configure(HttpSecurity http) 配置拦截的地方，可以配置拦截器，可以配置成功处理器和失败处理器等<br>@EnableResourceServer注解使用@Import(ResourceServerConfiguration.class)，ResourceServerConfiguration类继承WebSecurityConfigurerAdapter类，因此，应该是可以不单独配置WebSecurityConfigurerAdapter类的。<br>可以使用http.exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint),配置异常处理，可以自定义返回值</p><p><font color="red">AuthorizationServerConfigurerAdapter </font>认证服务（@EnableAuthorizationServer）<br>1、public void configure(ClientDetailsServiceConfigurer clients)   配置JdbcClientDetailsService，自带表配置<br>2、public void configure(AuthorizationServerEndpointsConfigurer endpoints) 配置TokenStore。。。。<br>3、public void configure(AuthorizationServerSecurityConfigurer security)  配置allowFormAuthenticationForClients</p><p>@EnableOAuth2Client 启动OAuth2客户端<br>@EnableAuthorizationServer 启动OAuth2认证服务</p><h3 id="OAUTH2四种模式"><a href="#OAUTH2四种模式" class="headerlink" title="OAUTH2四种模式"></a>OAUTH2四种模式</h3><p>1、授权码模式：authorization_code<br>2、简单模式：implicit<br>3、密码模式：password<br>4、客户端模式：client_credentials</p><h3 id="OAUTH2对外暴露接口"><a href="#OAUTH2对外暴露接口" class="headerlink" title="OAUTH2对外暴露接口"></a>OAUTH2对外暴露接口</h3><p>TokenEndpoint类暴露Controller的/oauth/token请求，支持get和post方式，获取<strong>access_token</strong>，grant_type=refresh_token刷新<br>CheckTokenEndpoint类暴露/oauth/check_token请求，验证token<br>AuthorizationEndpoint类暴露/oauth/authorize请求，支持get和post方式<br>通过类FrameworkEndpointHandlerMapping，获取带@FrameworkEndpoint注解，创建RequestMappingInfo</p><h3 id="OAUTH2原理"><a href="#OAUTH2原理" class="headerlink" title="OAUTH2原理"></a>OAUTH2原理</h3><p><a href="https://blog.csdn.net/bluuusea/article/details/80284458?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">获取token/刷新token流程</a></p><h3 id="源码解析系列"><a href="#源码解析系列" class="headerlink" title="源码解析系列"></a>源码解析系列</h3><p><a href="https://blog.csdn.net/Lammonpeter/article/details/100922926">源码解析</a><br><a href="https://my.oschina.net/liuyuantao/blog/1922049?from=singlemessage">源码解析实战</a><br><a href="https://segmentfault.com/a/1190000019347662">oauth2数据库版</a><br><a href="https://www.jianshu.com/p/c1c6c966c3a7">oauth_client_details表详解</a><br><a href="https://www.andaily.com/spring-oauth-server/db_table_description.html">其它表详解</a></p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul><li>SqlSession:作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li><li>Executor:MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li><li>StatementHandler:封装了JDBC  Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</li><li>ParameterHandler:负责对用户传递的参数转换成JDBC Statement 所需要的参数，</li><li>ResultSetHandler:负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</li><li>TypeHandler:负责java数据类型和jdbc数据类型之间的映射和转换</li><li>MappedStatement:MappedStatement维护了一条&lt;select|update|delete|insert&gt;节点的封装，</li><li>SqlSource:负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回BoundSql 表示动态生成的SQL语句以及相应的参数信息 </li><li>Configuration:MyBatis所有的配置信息都维持在Configuration对象之中。</li></ul><p><a href="https://www.jianshu.com/p/7dab1e397437">MyBatis 流式查询</a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a href="https://blog.csdn.net/kongtiao5/article/details/82771694">缓存三种问题及解决方案</a><br><a href="https://juejin.cn/post/6934930917500649486">三个问题及解决方案</a></p><p><a href="https://juejin.cn/post/6917577839185231879">redis使用Hash替换String</a><br><a href="https://juejin.cn/post/6901951315962757134">Redisson 源码解析</a><br><a href="https://juejin.cn/post/6937642117107810334">Caffeine</a><br><a href="https://blog.csdn.net/xiangliangyu/article/details/8165644">redis数据丢失及解决</a><br><a href="https://cloud.tencent.com/developer/article/1760408">Redis 数据持久化</a></p><h3 id="Redisson分布式锁中WatchDog实现机制"><a href="#Redisson分布式锁中WatchDog实现机制" class="headerlink" title="Redisson分布式锁中WatchDog实现机制"></a>Redisson分布式锁中WatchDog实现机制</h3><p>客户端加锁(lock)成功后，会启用一个watch dog后台线程，使用netty时间轮HashedWheelTimer算法，每隔delay=10秒检查如果客户端还持有锁，则重新设置锁的过期时间为lockWatchdogTimeout=30秒（默认)，其中delay = lockWatchdogTimeout/3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延期操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//Lua脚本延期锁的过期时间</span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="comment">//延期成功</span></span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// 继续循环延期操作</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每隔10秒检查一次</span></span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p><a href="https://developer.51cto.com/art/201904/594615.htm">倒排索引</a></p><p><a href="https://www.cnblogs.com/huangfox/p/9460361.html">为什么要移除Type</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">简单部署和使用</a></p><p><a href="https://baijiahao.baidu.com/s?id=1663609942544356335&wfr=spider&for=pc">集群角色分离</a></p><p><a href="https://blog.csdn.net/truelove12358/article/details/105577414">倒排索引与B+Tree对比</a></p><p> <a href="https://www.cnblogs.com/LBSer/p/4119841.html">FST（finite state transducers）</a></p><p><a href="https://elasticsearch.cn/article/6178#tip3">Elasticsearch中数据是如何存储的（Lucene）</a></p><p><a href="https://blog.csdn.net/wx1528159409/article/details/105973336">ES的数据写入原理，refresh和flush</a></p><p><a href="https://liubowen.blog.csdn.net/article/details/81950081?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">Elasticsearch原理（三）：写入流程</a></p><p><a href="https://blog.csdn.net/xiaoyu_BD/article/details/81735473">Elasticsearch原理（一）：实时架构</a></p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html">持久化变更</a></p><p>Master Node：主节点<br>Master eligible nodes：合格节点<br>Data Node：数据节点<br>Coordinating Node：协调节点<br>Ingest Node：ingest节点<br>machine learning：机器学习节点</p><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/794174-20200508142929527-1342544356.png" alt="img"></p><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/794174-20200508142947572-369187416.png" alt="img"></p><ul><li>Master Node：主节点，该节点不和应用创建连接，每个节点都保存了集群状态，master节点不占用磁盘IO和CPU，内存使用量一般。</li><li>Master eligible nodes：合格节点，每个节点部署后不修改配置信息，默认就是一个 eligible 节点，该节点可以参加选主流程，成为Mastere节点。该节点也保存了集群节点的状态。eligible节点比Master节点更节省资源，因为它还未成为 Master 节点，只是有资格成功Master节点。</li><li>Data Node：数据节点，该节点和索引应用创建连接、接收索引请求，该节点真正存储数据，ES集群的性能取决于该节点的个数（每个节点最优配置的情况下），data节点会占用大量的CPU、IO和内存。</li><li>Coordinating Node：协调节点，该节点和检索应用创建连接、接受检索请求，但其本身不负责存储数据，可当负责均衡节点，该节点不占用io、cpu和内存。</li><li>Ingest Node：ingest 节点可以看作是数据前置处理转换的节点，支持 pipeline管道 设置，可以使用 ingest 对数据进行过滤、转换等操作，类似于 logstash 中 filter 的作用，功能相当强大。</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><a href="https://juejin.cn/post/6929795131042168846">数据一致性</a><br><a href="https://juejin.cn/post/6931884966813007879?utm_source=gold_browser_extension">CAP理论</a><br><a href="https://juejin.cn/post/6931144402597330951">BASE 理论</a><br><a href="https://juejin.cn/post/6898288789371027470">CAP和BASE理论</a><br><a href="https://juejin.cn/post/6938444096990248997">Paxos 共识算法</a></p><p><a href="https://juejin.cn/post/6914964637478256654">Paxos算法</a><br><a href="https://juejin.cn/post/6844903838399348749">故障恢复(重试、超时、退避)</a><br><a href="https://juejin.cn/post/6886261194110271502">Basic Paxos</a></p><p><a href="https://juejin.cn/post/6908889730843148295">浅析分布式中的 CAP、BASE、2PC、3PC、Paxos、Raft、ZAB</a><br><a href="https://juejin.cn/post/6898288336906125325">Raft 协议实战系列</a><br><a href="https://juejin.cn/post/6930774718114955278">Gossip协议</a><br><a href="https://juejin.cn/post/6902004920543952909">Redis Cluster Gossip 协议</a><br><a href="https://zhuanlan.zhihu.com/p/130332285">分布式一致性算法-Paxos、Raft、ZAB、Gossip</a></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><a href="https://juejin.cn/post/6874788280378851335">分布式事务概念详解</a><br><a href="https://juejin.cn/post/6919698046628560903">最终一致性</a><br><a href="https://juejin.cn/post/6899645923024355336">seata实践</a><br><a href="https://juejin.cn/post/6844903913691283469#heading-13">seata三种模式详解</a><br><a href="https://juejin.cn/post/6912462666187407367">https://juejin.cn/post/6912462666187407367</a><br><a href="https://juejin.cn/post/6893927391333187597">XA事务</a><br><a href="https://juejin.cn/post/6904106776925323272">Saga模型设计</a><br><a href="https://juejin.cn/post/6892759955921698830">事务TCC架构设计原理</a><br><a href="https://juejin.cn/post/6850418108599894023">Seata分布式事务几种常见模式分析</a><br><a href="https://juejin.cn/post/6924496491960778760">分布式事务</a><br><a href="https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/107273472">探秘蚂蚁金服分布式事务 Seata 的AT、Saga和TCC模式</a><br><a href="https://www.jianshu.com/p/e4b662407c66">saga详解</a><br><a href="https://juejin.cn/post/6922346183553712136">分布式事务及seata</a></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><a href="https://juejin.cn/post/6867040340797292558">RocketMQ 和 Kafka事务消息</a></p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p><a href="https://juejin.cn/post/6865212415622823949">Zookeeper基础知识</a><br><a href="https://juejin.cn/post/6934623205823315976">zookeeper选举同步</a><br><a href="https://www.cnblogs.com/wuzhenzhao/p/9994450.html">监听源码解析NIO创建tcp连接</a><br><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/1383365-20190820101928955-908505489.png" alt="img"></p><h2 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h2><p><a href="https://juejin.cn/post/6844903953008689165">XXL-JOB</a></p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p><a href="https://juejin.cn/post/6939881308114354207">Netty零拷贝</a></p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>Dubbo缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p><p><strong>Transporter</strong>: mina, netty, grizzy<br><strong>Serialization</strong>: dubbo, hessian2, java, json<br><strong>Dispatcher</strong>: all, direct, message, execution, connection<br><strong>ThreadPool</strong>: fixed, cached<br><a href="https://blog.csdn.net/u010634066/article/details/80509411">connections和粘滞连接</a></p><p><a href="https://juejin.cn/post/6907931653243568142">SPI可扩展机制</a><br><a href="https://juejin.cn/post/6907932891087388679">Dubbo RPC 实现原理机制</a></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><a href="https://blog.csdn.net/ETTTTTSS/article/details/103792608">普通集群及镜像集群</a><br><a href="https://blog.csdn.net/u013905744/article/details/86736536">Spring RabbitMQ源码解析</a></p><p>注重类：</p><ul><li>RabbitListenerAnnotationBeanPostProcessor</li><li>RabbitListenerContainerFactory</li><li>RabbitListenerEndpointRegistrar</li><li>AbstractMessageListenerContainer -》MessageListenerContainer<ul><li>SimpleRabbitListenerContainerFactory</li><li>DirectRabbitListenerContainerFactory</li></ul></li><li>@RabbitListener</li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p><a href="https://juejin.cn/post/6901905073752768526">kafka简单实战</a><br><a href="https://juejin.cn/post/6922339184011280392">滴滴开源Kafka管理平台，支持分区不足扩容、分区热点迁移、topic资源治理</a><br><a href="https://blog.csdn.net/lizhitao/article/details/25667831">kafka基本参数配置</a><br><a href="https://shuyi.tech/archives/head-first-of-kafka-rebalance">重平衡</a><br><a href="https://www.jianshu.com/p/c2ca54bd7c52">partition重分配流程</a><br><a href="https://blog.csdn.net/qq_29493353/article/details/88535092">Kafka数据丢失</a><br><a href="https://blog.csdn.net/yuanlong122716/article/details/105160545/">springboot-kafka综合实战</a><br><a href="https://blog.csdn.net/slslslyxz/article/details/108492931">手动确认</a><br><a href="https://blog.csdn.net/yuanlong122716/article/details/105160545/">SpringBoot集成kafka全面实战</a><br><a href="https://blog.csdn.net/qq_43253123/article/details/82884387">Spring Cloud Stream 和 Kafka案例教程</a></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><a href="https://juejin.cn/post/6844904137172189198">分布式锁实现</a><br><a href="https://juejin.cn/post/6922275721431744525">Redis分布式锁演进</a></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><a href="https://juejin.cn/post/6905923569084006414">分库分表</a><br><a href="http://www.2cto.com/database/201508/429967.html">锁机制</a><br><a href="https://juejin.cn/post/6844904051453198343">幻读</a><br><a href="http://blog.itpub.net/22664653/viewspace-750824/">next-key lock实例及问题</a><br><a href="https://www.cnblogs.com/yanggb/p/11252966.html">回表查询和覆盖索引</a></p><p><a href="https://juejin.cn/post/6844904042292838408">分库分表</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd">数据库规范</a></p><ul><li>数据库命令规范</li><li>数据库基本设计规范</li><li>数据库字段设计规范</li><li>索引设计规范</li><li>数据库 SQL 开发规范</li><li>数据库操作行为规范</li></ul><p><a href="https://www.jianshu.com/p/b3f9007be020">mysql为什么要使用自增主键</a><br><a href="https://juejin.cn/post/6860252224930070536">binlog、redolog、undolog</a></p><p><a href="https://juejin.cn/post/6865571676902391821">Explain执行计划详解</a></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p><a href="https://juejin.cn/post/6861783980354895885">MyCat实战</a><br><a href="https://blog.csdn.net/u010391342/article/details/89526366">ShardingSphere实战</a><br><a href="https://blog.csdn.net/xinzhifu1/article/details/109309303">ShardingSphere分片策略</a></p><p>标准分片策略-》包含精准（=，in分片）、范围（between and）<br>复合分片策略-》多个分片字段（如order_id,user_id）<br>行表达式分片策略-》简单的行分片<br>Hint分片策略 -》外部配置，sql执行前通过HintManager指定分库分表策略，可以在主从模式下通过hintManager.setMasterRouteOnly();指定读主库</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p><a href="https://blog.csdn.net/zxl315/article/details/80420688">选择HikariCP作为默认数据库连接池的五大理由</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUzNTY4NTYxMA==&mid=2247483699&idx=1&sn=5efd1f9d872688eba0029c71b3668662&chksm=fa80f1b6cdf778a0bbd12ce5e97507d697058d7bc070082a8ca828c9910c1379ead43c7b9a05&scene=21#wechat_redirect">HikariCP连接池监控指标实战</a><br><a href="https://segmentfault.com/a/1190000015558954">整合Druid连接池及监控</a><br><a href="https://www.cnblogs.com/whb11/p/11315463.html">数据库连接池对比</a><br><a href="https://www.jianshu.com/p/c26d1ed16bb4">合理的数据库连接数</a><br><strong><a href="https://www.cnblogs.com/caoshousong/p/10845396.html">数据库参数配置显示</a></strong></p><ul><li><p>show processlist;</p></li><li><p>show variables like ‘%max_connection%’; 查看最大连接数</p></li><li><p>set global max_connections=1000;  重新设置最大连接数</p></li><li><p>show variables like ‘thread_cache_size’;  当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)</p></li><li><p>show status like  ‘Threads%’;   show global status like <code>&#39;Thread%&#39;</code>;<br><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210316155408524.png" alt="image-20210316155408524"></p><p>Threads_connected ：这个数值指的是打开的连接数.</p><p>Threads_running ：这个数值指的是激活的连接数，这个数值一般远低于connected数值.</p><p>Threads_created：表示创建过的线程数，通过查看Threads_created就可以查看MySQL服务器的进程状态</p></li></ul><h2 id="Binlog同步"><a href="#Binlog同步" class="headerlink" title="Binlog同步"></a>Binlog同步</h2><p><a href="https://www.jianshu.com/p/c0a7850e8fe9">canal数据同步</a></p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/1939592-5a09f70e5cc0db63.png" alt="img" style="zoom:45%;"><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p><a href="https://juejin.cn/post/6872600073843736589">redis缓存</a><br><a href="https://juejin.cn/post/6931742052325523470">缓存与数据库双写不一致解决方案</a></p><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p><a href="https://juejin.cn/post/6900188956525068301">幂等方法</a><br><a href="https://juejin.cn/post/6870337534275256333">通用的幂等组件</a></p><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><p><a href="https://www.cnblogs.com/june0816/p/6474569.html">Logback异步日志</a></p><h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p><a href="https://juejin.cn/post/6894120291744612359">ELK实战</a></p><h2 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h2><p><a href="https://juejin.cn/post/6916450426774781966">灰度发布的探索与实践</a></p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p><a href="https://blog.csdn.net/andy_zhang2007/article/details/86680622">feign原理</a><br><a href="https://www.cnblogs.com/crazymakercircle/p/11832534.html">feign默认采用的长连接</a></p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p><a href="https://juejin.cn/post/6923333239335550983">限流的基本概念</a><br><a href="https://juejin.cn/post/6922809716804419591">令牌桶限流</a><br><a href="https://juejin.cn/post/6921299013769625607">分布式限流方案（gateway限流，redis+lua实现限流，nginx限流）</a><br><a href="https://juejin.cn/post/6932094513292771342">分布式限流</a><br><a href="https://juejin.cn/post/6870671578372423694">sentinel系列文章</a><br><a href>Hystrix</a></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p><a href="https://blog.csdn.net/fu_huo_1993/article/details/88350180">配置详解</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUzMzQ2MDIyMA==&mid=2247484653&idx=1&sn=7f098999680025413e4d2801de81b427&chksm=faa2e17ecdd56868a431e7a63b86ce74686343aff73b010b3fa3a35d48ba0915647aaa99bf18&scene=158#rd">Hystrix替代方案</a><br><a href="https://cloud.tencent.com/developer/article/1452039">hystrix、resilience4j与sentinel的区别以及选型对比</a><br><a href="https://www.jianshu.com/p/5531b66b777a">Resilience4j-轻量级熔断框架</a></p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p><a href="https://www.upyun.com/tech/article/501/Apache%20APISIX%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E6%9E%81%E8%87%B4%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90.html"><strong>APISIX特点</strong></a><br><a href="https://juejin.cn/post/6882952033712734216">API 网关选型及包含 BFF 的架构设计</a><br><a href="https://blog.csdn.net/kingwinstar/article/details/105752725">灰度发布</a></p><p>springcloud官方推荐使用loadbalancer来代替ribbon。因为ribbon是阻塞的，但从官方的loadbalancer的负载均衡算法来看，目前loadbalancer默认只支持轮询算法，要其他算法得自己扩展实现，而ribbon默认支持7种算法，用默认的算法基本上就可以满足我们的需求了。其次ribbon支持懒加载处理，超时以及重试与断路器hystrix集成等配置，loadbalancer目前就支持重试。所以如果正式环境要自己实现灰度发布，可以考虑对ribbon进行扩展。</p><h2 id="Spring-Cloud-Loadbalancer"><a href="#Spring-Cloud-Loadbalancer" class="headerlink" title="Spring-Cloud-Loadbalancer"></a>Spring-Cloud-Loadbalancer</h2><ul><li>使用响应式编程，官方推荐</li><li>目前只支持轮询一种负载均衡算法</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><a href="https://zhuanlan.zhihu.com/p/262660637">Ribbon原理</a></p><ul><li>服务列表（配置文件，注册中心发现）</li><li>动态更新服务列表（主动拉取和通知）</li><li>心跳检测</li><li>路由，ServerListFilter过滤路由</li><li>负载均衡(7种)</li></ul><h2 id="SkyWalking"><a href="#SkyWalking" class="headerlink" title="SkyWalking"></a>SkyWalking</h2><ul><li>UI（数据统计展示）</li><li>OAP(Observability Analysis Platform，采集数据，处理数据，分析数据。config/application.yml|alarm-settings-sample.yml可以配置)链路数据收集器，对agent传过来的数据进行整合分析处理并落入相关的数据存储中。storage模块配置：Skywalking的存储，时间更迭，sw已经开发迭代到了8.x版本，支持以ElasticSearch、ElasticSearch7、Mysql、TiDB、H2、influxdb作为存储介质进行数据存储。Receiver是Skywalking在6.x提出的新的概念，负责从被监控的系统中接受指标数据。用户完全可以参照OpenTracing规范来上传自定义的监控数据。Skywalking官方提供了service-mesh、istio、zipkin的相关能力。</li><li>Agent(配置文件，config/agent.config,可以配置显示sql参数，默认不显示；启动时可以根据配置文件，设置参数)使用Javaagent做字节码植入，无侵入式的收集，并通过HTTP或者gRPC方式发送数据到Skywalking Collector。</li></ul><h2 id="全局唯一-ID-生成算法"><a href="#全局唯一-ID-生成算法" class="headerlink" title="全局唯一 ID 生成算法"></a>全局唯一 ID 生成算法</h2><p><a href="https://juejin.cn/post/6846687584324681735">薄雾算法</a><br><a href="https://juejin.cn/post/6892959738670743565">分布式主键ID 生成方案</a></p><h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><p><a href="https://juejin.cn/post/6921975658490888205">简单介绍</a></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><a href="https://blog.csdn.net/weixin_41288743/article/details/103000406">架构设计思路</a><br><a href="https://www.cnblogs.com/wchukai/p/5653135.html">分布式系统的架构思路</a><br><a href="https://wetest.qq.com/lab/view/80.html">高性能服务器架构思路【不仅是思路】</a><br><a href="https://blog.csdn.net/yellowzf3/article/details/103590725">电商系统微服务架构实践与优化思路</a><br><a href="https://www.jianshu.com/p/d567ce4ade2e"></a><br><a href="https://www.jianshu.com/p/d3b1d4ad67a8">架构理论</a><br><a href="https://www.jianshu.com/p/f0133417bdf8">实现电商平台从业务到架构的治理体系</a><br><a href="https://juejin.cn/post/6844903957693726727">什么是中台</a></p><h2 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h2><p><a href="http://blog.yannxia.top/2018/06/26/java/spring/projectreactor/">ProjectReactor原理</a><br><a href="https://blog.csdn.net/john1337/article/details/101028908">参考</a><br><a href="https://ifeve.com/reactive%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E7%BC%96%E7%A8%8B-reactor/">实例</a><br><a href="https://blog.csdn.net/mmlz00/article/details/86249161"><strong>Stream, RxJava, Reactor之比较</strong></a><br><a href="https://blog.csdn.net/daniel7443/article/details/80761340">Spring Reactor 入门与实践</a><br><a href="https://zhuanlan.zhihu.com/p/95966853">Reactive Streams</a><br><a href="https://www.immuthex.com/posts/reactor-netty-reference-guide/contents/">Reactor Netty</a></p><p><code>Reactor Netty</code>为<code>HTTP</code>（包括Websocket），<code>TCP</code>和<code>UDP</code>提供了支持背压的网络引擎。<br>Mono 实现了 org.reactivestreams.Publisher 接口，代表0到1个元素的发布者（Publisher）。<br>Flux 同样实现了 org.reactivestreams.Publisher 接口，代表0到N个元素的发布者（Publisher）。</p><h2 id="Spring-Webflux"><a href="#Spring-Webflux" class="headerlink" title="Spring Webflux"></a>Spring Webflux</h2><p><a href="http://ddrv.cn/a/287053">介绍与使用</a><br>在Spring Webflux的函数路由中，<code>Mono&lt;ServerResponse&gt;</code>被用作返回类型，<code>Mono&lt;ResponseEntity&lt;MyPojo&gt;&gt;</code>也被用作返回类型。在@Controller中使用<code>Mono&lt;ResponseEntity&lt;MyPojo&gt;&gt;</code>，@RequestMapping（Get，Post-mappingetc…）作为返回类型。</p><p><code>org.springframework.http.ResponseEntity</code>来自原始的Spring Mvc Framework包，<code>org.springframework.web.reactive.function.server.ServerResponse</code>来自springReactive包。</p><p>reactive包有一个“兼容性”模式，允许您使用向后兼容的<code>@RestController</code>注释，它们通常会像以前一样返回<code>ResponseEntity</code>。</p><p>没有兼容性特性的Reactive包实现使用<code>Router</code>和<code>Handler</code>，通常返回<code>ServerResponse</code>。</p><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p><a href="http://www.54tianzhisheng.cn/2018/12/30/Flink-ElasticSearch-Sink/">flink详细资料</a></p><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><p><a href="https://blog.csdn.net/dtlscsl/article/details/94185614">HashedWheelTimer原理</a><br><a href="https://zhuanlan.zhihu.com/p/65835110">时间轮算法应用</a><br><a href="https://blog.csdn.net/lzhcoder/article/details/102575327">应用的详解</a><br><a href="https://www.cnblogs.com/eryuan/p/7955677.html">延时队列</a></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a href="https://juejin.cn/post/6890369482758471687">算法</a><br><a href="https://visualgo.net/zh/sorting?slide=1">算法动态网站</a><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）</a></p><h2 id="其它资料"><a href="#其它资料" class="headerlink" title="其它资料"></a>其它资料</h2><p><a href="https://github.com/xjjdog/bcmall">各种</a></p><p><a href="https://github.com/macrozheng/mall-learning?utm_source=gold_browser_extension">商城项目实战</a></p><p><a href="https://github.com/CyC2018/CS-Notes?utm_source=gold_browser_extension">题目</a></p><p><a href="https://blog.csdn.net/wangmx1993328/article/details/88598625">Jackson使用</a><br>Jackson 提供三种不同的方法来操作 JSON<br>1）<a href="https://www.yiibai.com/jackson/jackson_streaming_api.html">流式API</a> - 使用 Stream(流) 的方式对 Json 的每一个组成部分进行最细粒度的控制，JsonParser 读取数据，JsonGenerator 写入数据。<br>2）树模型 - 将 JSON 文件在内存里以树的形式表示，通过 JsonNode 处理单个Json节点，类似于 XML 的 DOM 解析器。(常用)<br>3）databind 模块 - ObjectMapper 读/写 JSON 是 POJO 序列化与反序列化 json 最方便的方式。（常用）<br><a href="https://blog.csdn.net/linyifan_/article/details/83060408">fastjson的值过滤器ValueFilter</a><br><a href="https://blog.csdn.net/tangjiean/article/details/51729371">okhttp连接池复用机制</a></p><h2 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h2><p><a href="https://www.cnblogs.com/DXDE443/p/10308059.html">从ftp取文件并http调用某接口上传此文件</a><br><a href="https://www.cnblogs.com/javaguide/p/11861749.html">5种bean映射对比</a></p><p><a href="https://www.cnblogs.com/liuyi13535496566/p/12634898.html">EasyExcel</a></p><p><a href="https://juejin.cn/post/6937092573429235720">实用工具</a></p><h2 id="博客转PDF"><a href="#博客转PDF" class="headerlink" title="博客转PDF"></a>博客转PDF</h2><p><a href="https://www.cnblogs.com/zqj-blog/p/10602702.html">pdfkit</a><br><a href="https://www.jianshu.com/p/421cc442f06c">GitBook 使用教程</a><br><a href="https://www.jianshu.com/p/0388d8bb49a7">Gitbook教程</a></p><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210319154428936.png" alt="image-20210319154428936"></p><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210425163338982.png" alt="image-20210425163338982"></p><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210425172859785.png" alt="image-20210425172859785"></p><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210426131334386.png" alt="image-20210426131334386"></p><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210426131344665.png" alt="image-20210426131344665"></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>唯一id生成方式</title>
      <link href="2021/03/11/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/"/>
      <url>2021/03/11/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="那么分布式ID需要满足那些条件"><a href="#那么分布式ID需要满足那些条件" class="headerlink" title="那么分布式ID需要满足那些条件"></a><strong>那么分布式ID需要满足那些条件</strong></h2><ul><li>全局唯一：必须保证ID是全局性唯一的，基本要求</li><li>高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈</li><li>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性</li><li>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单</li><li>趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>UUID</li><li>数据库自增ID</li><li>数据库多主模式</li><li>号段模式</li><li>Redis</li><li>雪花算法（SnowFlake）</li><li>滴滴出品（TinyID）</li><li>百度 （Uidgenerator）</li><li>美团（Leaf）</li></ul><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>生成足够简单，本地生成无网络消耗，具有唯一性</li></ul><p><strong>缺点：</strong></p><ul><li>无序的字符串，不具备趋势自增特性</li><li>没有具体的业务含义</li><li>长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 <code>UUID</code> 的无序性会导致数据位置频繁变动，严重影响性能。</li></ul><h3 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h3><p>建一张表，插入数据，通过增长id实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SEQUENCE_ID(<span class="keyword">value</span>)  <span class="keyword">VALUES</span> (<span class="string">&#x27;values&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>实现简单，ID单调自增，数值类型查询速度快</li></ul><p><strong>缺点：</strong></p><ul><li>DB单点存在宕机风险，无法扛住高并发场景</li><li>访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐</li></ul><h3 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h3><p>设置不同的步长</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>解决DB单点问题</li></ul><p><strong>缺点：</strong></p><ul><li><strong>必要时可能还需要停机修改</strong>，不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景</li></ul><h3 id="基于数据库的号段模式"><a href="#基于数据库的号段模式" class="headerlink" title="基于数据库的号段模式"></a>基于数据库的号段模式</h3><p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> id_generator (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  max_id <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;当前最大id&#x27;</span>,</span><br><span class="line">  step <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;号段的布长&#x27;</span>,</span><br><span class="line">  biz_type<span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;业务类型&#x27;</span>,</span><br><span class="line">  <span class="keyword">version</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;版本号&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">update</span> id_generator <span class="keyword">set</span> max_id = <span class="comment">#&#123;max_id+step&#125;, version = version + 1 where version = # &#123;version&#125; and biz_type = XXX</span></span><br></pre></td></tr></table></figure><p>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code></p><p>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</p><h3 id="基于Redis模式"><a href="#基于Redis模式" class="headerlink" title="基于Redis模式"></a><strong>基于Redis模式</strong></h3><p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p><ul><li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li><li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li></ul><h3 id="基于雪花算法（Snowflake）模式"><a href="#基于雪花算法（Snowflake）模式" class="headerlink" title="基于雪花算法（Snowflake）模式"></a><strong>基于雪花算法（Snowflake）模式</strong></h3><p><img src="/2021/03/11/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/v2-21c519f61a3c693c5c446aeb2af72880_720w.jpg" alt="img"></p><ul><li>1bit:一般是符号位，不做处理</li><li>41bit:用来记录时间戳，这里可以记录69年，如果设置好起始时间比如今年是2018年，那么可以用到2089年，到时候怎么办？要是这个系统能用69年，我相信这个系统早都重构了好多次了。</li><li>10bit:10bit用来记录机器ID，总共可以记录1024台机器，一般用前5位代表数据中心ID，后面5位是某个数据中心的机器ID</li><li>12bit:循环位，用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。</li></ul><p><strong>雪花算法问题：</strong></p><ul><li><strong>时间回拨问题</strong>：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现数据重复</li><li><strong>机器id分配及回收问题</strong>：目前机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果该机器宕机了，对应的workerId分配后的回收问题</li><li><strong>机器id上限</strong>：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。</li></ul><p><strong>解决方案</strong></p><ul><li><p>时间回拨问题：</p><ul><li>采用直接抛异常方式，打日志，通知RD时钟回滚。：这种很不友好，太粗暴</li><li>采用等待跟上次时间的一段范围：这种算是简单解决，可以接受，但是如果等待一段时间后再出现回拨，则抛异常，可接受，但是不算彻底解决。如果时间回拨时间较短，比如配置5ms以内，那么可以直接等待一定的时间，让机器的时间追上来。</li><li>利用扩展位，如将12位的循环位拆分出2位，可以作为扩展位。比如当这个时间回拨比较长的时候，不需要等待，直接在扩展位加1。2位的扩展位允许我们有3次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li></ul></li><li><p>机器id分配及回收：</p><ul><li>采用zookeeper的顺序节点分配：解决了分配，回收可采用zookeeper临时节点回收，但是临时节点不可靠，存在无故消失问题，因此也不可靠</li><li>采用DB中插入数据作为节点值：解决了分配，没有解决回收</li><li>使用ip，需要三位，0~255</li></ul></li><li><p>机器id上限</p><p>该问题在业内都没有处理，也就是说如果采用雪花算法，则必定会存在该问题，但是该问题也只有需要大量的业务机器共享的场景才会出现，这种情况，采用客户端双Buffer+DB这种非雪花算法的方案也未尝不可。</p></li></ul><h3 id="其它解决方案"><a href="#其它解决方案" class="headerlink" title="其它解决方案"></a><strong>其它解决方案</strong></h3><p>分布式ID生成服务，提供服务：<a href="https://blog.csdn.net/qq_45401061/article/details/108175058">Butterfly方案</a></p><h3 id="百度（uid-generator）"><a href="#百度（uid-generator）" class="headerlink" title="百度（uid-generator）"></a>百度（uid-generator）</h3><p><code>uid-generator</code>是由百度技术部开发，项目GitHub地址 <a href="https://github.com/baidu/uid-generator">https://github.com/baidu/uid-generator</a></p><p><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的<code>snowflake</code>算法不同在于，<code>uid-generator</code>支持自<code>定义时间戳</code>、<code>工作机器ID</code>和 <code>序列号</code> 等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略。</p><p><code>uid-generator</code>需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的<code>workId</code>数据由host，port组成。</p><p><strong>对于<code>uid-generator</code> ID组成结构</strong>：</p><p><code>workId</code>，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的<code>snowflake</code>不太一样，时间的单位是秒，而不是毫秒，<code>workId</code>也不一样，而且同一应用每次重启就会消费一个<code>workId</code>。</p><blockquote><p>参考文献<br><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</a></p></blockquote><h3 id="美团（Leaf）"><a href="#美团（Leaf）" class="headerlink" title="美团（Leaf）"></a>美团（Leaf）</h3><p><code>Leaf</code>由美团开发，github地址：<a href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a></p><p><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用。</p><h5 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h5><p>先导入源码 <a href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a> ，在建一张表<code>leaf_alloc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;leaf_alloc&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;leaf_alloc&#96; (</span><br><span class="line">  &#96;biz_tag&#96; varchar(128)  NOT NULL DEFAULT &#39;&#39; COMMENT &#39;业务key&#39;,</span><br><span class="line">  &#96;max_id&#96; bigint(20) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;当前已经分配了的最大id&#39;,</span><br><span class="line">  &#96;step&#96; int(11) NOT NULL COMMENT &#39;初始步长，也是动态调整的最小步长&#39;,</span><br><span class="line">  &#96;description&#96; varchar(256)  DEFAULT NULL COMMENT &#39;业务key的描述&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;数据库维护的更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;biz_tag&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leaf.name&#x3D;com.sankuai.leaf.opensource.test</span><br><span class="line">leaf.segment.enable&#x3D;true</span><br><span class="line">leaf.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;leaf_test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;characterSetResults&#x3D;utf8</span><br><span class="line">leaf.jdbc.username&#x3D;root</span><br><span class="line">leaf.jdbc.password&#x3D;root</span><br><span class="line"></span><br><span class="line">leaf.snowflake.enable&#x3D;false</span><br><span class="line">#leaf.snowflake.zk.address&#x3D;</span><br><span class="line">#leaf.snowflake.port&#x3D;</span><br></pre></td></tr></table></figure><p>启动<code>leaf-server</code> 模块的 <code>LeafServerApplication</code>项目就跑起来了</p><p>号段模式获取分布式自增ID的测试url ：http：//localhost：8080/api/segment/get/leaf-segment-test</p><p>监控号段模式：<a href="http://localhost:8080/cache">http://localhost:8080/cache</a></p><h5 id="snowflake模式"><a href="#snowflake模式" class="headerlink" title="snowflake模式"></a>snowflake模式</h5><p><code>Leaf</code>的snowflake模式依赖于<code>ZooKeeper</code>，不同于<code>原始snowflake</code>算法也主要是在<code>workId</code>的生成上，<code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序Id来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaf.snowflake.enable&#x3D;true</span><br><span class="line">leaf.snowflake.zk.address&#x3D;127.0.0.1</span><br><span class="line">leaf.snowflake.port&#x3D;2181</span><br></pre></td></tr></table></figure><p>snowflake模式获取分布式自增ID的测试url：<a href="http://localhost:8080/api/snowflake/get/test">http://localhost:8080/api/snowflake/get/test</a></p><h3 id="滴滴（Tinyid）"><a href="#滴滴（Tinyid）" class="headerlink" title="滴滴（Tinyid）"></a>滴滴（Tinyid）</h3><p><code>Tinyid</code>由滴滴开发，Github地址：<a href="https://github.com/didi/tinyid%E3%80%82">https://github.com/didi/tinyid。</a></p><p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p><img src="https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aN77sK4V1x5e5dSVZcibkzSRRKsAGqcpaauibVfY9iaOR5LFvzDPictNjHXmmdhr31153iaiaStvXIJEo2g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;"><p>在这里插入图片描述 <code>Tinyid</code>提供<code>http</code>和<code>tinyid-client</code>两种方式接入</p><h5 id="Http方式接入"><a href="#Http方式接入" class="headerlink" title="Http方式接入"></a>Http方式接入</h5><p>（1）导入Tinyid源码：</p><p>git clone <a href="https://github.com/didi/tinyid.git">https://github.com/didi/tinyid.git</a></p><p>（2）创建数据表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tiny_id_info` (</span><br><span class="line">  `id` bigint(<span class="number">20</span>) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line">  `biz_type` varchar(<span class="number">63</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;业务类型，唯一&#x27;</span>,</span><br><span class="line">  `begin_id` bigint(<span class="number">20</span>) NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#x27;</span>,</span><br><span class="line">  `max_id` bigint(<span class="number">20</span>) NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;当前最大id&#x27;</span>,</span><br><span class="line">  `step` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;步长&#x27;</span>,</span><br><span class="line">  `delta` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL DEFAULT <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;每次id增量&#x27;</span>,</span><br><span class="line">  `remainder` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;余数&#x27;</span>,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT <span class="string">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT <span class="string">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `version` bigint(<span class="number">20</span>) NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;版本号&#x27;</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span>,</span></span><br><span class="line"><span class="function">  UNIQUE KEY `uniq_biz_type` <span class="params">(`biz_type`)</span></span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8 COMMENT <span class="string">&#x27;id信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tiny_id_token` (</span><br><span class="line">  `id` <span class="keyword">int</span>(<span class="number">11</span>) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">&#x27;自增id&#x27;</span>,</span><br><span class="line">  `token` varchar(<span class="number">255</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;token&#x27;</span>,</span><br><span class="line">  `biz_type` varchar(<span class="number">63</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;此token可访问的业务类型标识&#x27;</span>,</span><br><span class="line">  `remark` varchar(<span class="number">255</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT <span class="string">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT <span class="string">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span></span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8 COMMENT <span class="string">&#x27;token信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100000</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;2018-07-21 23:52:58&#x27;</span>, <span class="string">&#x27;2018-07-22 23:19:27&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;test_odd&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;2018-07-21 23:52:58&#x27;</span>, <span class="string">&#x27;2018-07-23 00:39:24&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;0f673adf80504e2eaa552f5d791b644c&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:46&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:48&#x27;</span>);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;0f673adf80504e2eaa552f5d791b644c&#x27;</span>, <span class="string">&#x27;test_odd&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:46&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:48&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（3）配置数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">datasource.tinyid.names&#x3D;primary</span><br><span class="line">datasource.tinyid.primary.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">datasource.tinyid.primary.url&#x3D;jdbc:mysql:&#x2F;&#x2F;ip:port&#x2F;databaseName?autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8</span><br><span class="line">datasource.tinyid.primary.username&#x3D;root</span><br><span class="line">datasource.tinyid.primary.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>（4）启动<code>tinyid-server</code>后测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取分布式自增ID: http:&#x2F;&#x2F;localhost:9999&#x2F;tinyid&#x2F;id&#x2F;nextIdSimple?bizType&#x3D;test&amp;token&#x3D;0f673adf80504e2eaa552f5d791b644c&#39;</span><br><span class="line">返回结果: 3</span><br><span class="line"></span><br><span class="line">批量获取分布式自增ID:</span><br><span class="line">http:&#x2F;&#x2F;localhost:9999&#x2F;tinyid&#x2F;id&#x2F;nextIdSimple?bizType&#x3D;test&amp;token&#x3D;0f673adf80504e2eaa552f5d791b644c&amp;batchSize&#x3D;10&#39;</span><br><span class="line">返回结果:  4,5,6,7,8,9,10,11,12,13</span><br></pre></td></tr></table></figure><h5 id="Java客户端方式接入"><a href="#Java客户端方式接入" class="headerlink" title="Java客户端方式接入"></a>Java客户端方式接入</h5><p>重复Http方式的（2）（3）操作</p><p>引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.xiaoju.uemc.tinyid&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;tinyid-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;tinyid.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tinyid.server &#x3D;localhost:9999</span><br><span class="line">tinyid.token &#x3D;0f673adf80504e2eaa552f5d791b644c</span><br></pre></td></tr></table></figure><p><code>test</code> 、<code>tinyid.token</code>是在数据库表中预先插入的数据，<code>test</code> 是具体业务类型，<code>tinyid.token</code>表示可访问的业务类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取单个分布式自增ID</span><br><span class="line">Long id &#x3D;  TinyId . nextId( &quot; test &quot; );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 按需批量分布式自增ID</span><br><span class="line">List&lt; Long &gt; ids &#x3D;  TinyId . nextId( &quot; test &quot; , 10 );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grafana仪表盘模板</title>
      <link href="2021/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7grafana%E4%BB%AA%E8%A1%A8%E7%9B%98%E6%A8%A1%E6%9D%BF/"/>
      <url>2021/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7grafana%E4%BB%AA%E8%A1%A8%E7%9B%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>在官网<a href="https://grafana.com/grafana/dashboards%E4%B8%8A%E6%89%BE%E9%9C%80%E8%A6%81%E7%9A%84Grafana%E4%BB%AA%E8%A1%A8%E7%9B%98%E6%A8%A1%E6%9D%BF%EF%BC%8C%E6%89%BE%E5%88%B0id">https://grafana.com/grafana/dashboards上找需要的Grafana仪表盘模板，找到id</a></p><h2 id="配置仪表盘"><a href="#配置仪表盘" class="headerlink" title="配置仪表盘"></a>配置仪表盘</h2><p>在Grafana上配置模板id，配置prometheus的地址</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus简单demo</title>
      <link href="2021/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7Prometheus%E7%AE%80%E5%8D%95demo/"/>
      <url>2021/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7Prometheus%E7%AE%80%E5%8D%95demo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/liangcha007/article/details/86699013">https://blog.csdn.net/liangcha007/article/details/86699013</a></p><h2 id="4种常用Metrics-types（指标类型）"><a href="#4种常用Metrics-types（指标类型）" class="headerlink" title="4种常用Metrics types（指标类型）"></a>4种常用Metrics <strong>types</strong>（指标类型）</h2><h3 id="Counter（计数器）"><a href="#Counter（计数器）" class="headerlink" title="Counter（计数器）"></a>Counter<strong>（计数器）</strong></h3><blockquote><p>连续增加不会减少的计数器，可以用于记录只增不减的类型，例如：网站访问人数，系统运行时间等。</p><p>对于Counter类型的指标，只包含一个inc()的方法，就是用于计数器+1.</p><p>一般而言，Counter类型的metric指标在冥冥中我们使用_total结束，如http_requests_total.</p></blockquote><h3 id="Gauge（计量器）"><a href="#Gauge（计量器）" class="headerlink" title="Gauge（计量器）"></a>Gauge<strong>（计量器）</strong></h3><blockquote><p>可增可减的仪表盘，曲线图</p><p>对于这类可增可减的指标，用于反应应用的当前状态。</p><p>例如在监控主机时，主机当前空闲的内存大小，可用内存大小等等。</p><p>对于Gauge指标的对象则包含两个主要的方法inc()和dec()，用于增加和减少计数。</p></blockquote><h3 id="Histogram（直方图、柱状图）"><a href="#Histogram（直方图、柱状图）" class="headerlink" title="Histogram（直方图、柱状图）"></a>Histogram<strong>（直方图、柱状图）</strong></h3><blockquote><p>主要用来统计数据的分布情况，这是一种特殊的metrics数据类型，代表的是一种近似的百分比估算数值，统计所有离散的指标数据在各个取值区段内的次数。例如：我们想统计一段时间内http请求响应小于0.005秒、小于0.01秒、小于0.025秒的数据分布情况。那么使用Histogram采集每一次http请求的时间，同时设置bucket。</p><p>Histogram会自动创建3个指标，分别为：<br>一、事件发生总次数： basename_count:<br>#实际含义： 当前一共发生了2次http请求<br>io_namespace_http_requests_latency_seconds_histogram_count{path=”/“,method=”GET”,code=”200”,} 2.0<br>二、所有事件产生值的大小的总和： basename_sum<br>#实际含义： 发生的2次http请求总的响应时间为13.107670803000001 秒<br>io_namespace_http_requests_latency_seconds_histogram_sum{path=”/“,method=”GET”,code=”200”,} 13.107670803000001<br>三、事件产生的值分布在bucket中的次数： basename_bucket{le=”上包含”}</p><p>在总共2次请求当中。http请求响应时间 &lt;=0.005 秒 的请求次数为0</p><p>io_namespace_http_requests_latency_seconds_histogram_bucket{path=”/“,method=”GET”,code=”200”,le=”0.005”,} 0.0<br>在总共2次请求当中。http请求响应时间 &lt;=0.01 秒 的请求次数为0<br>io_namespace_http_requests_latency_seconds_histogram_bucket{path=”/“,method=”GET”,code=”200”,le=”0.01”,} 0.0<br>在总共2次请求当中。http请求响应时间 &lt;=0.025 秒 的请求次数为0<br>io_namespace_http_requests_latency_seconds_histogram_bucket{path=”/“,method=”GET”,code=”200”,le=”0.025”,} 0.0</p></blockquote><h3 id="Summary（摘要）"><a href="#Summary（摘要）" class="headerlink" title="Summary（摘要）"></a>Summary<strong>（摘要）</strong></h3><blockquote><p>Summary和Histogram非常相似，都可以统计事件发生的次数或者大小，以及其分布情况，他们都提供了对时间的计数_count以及值的汇总_sum，也都提供了可以计算统计样本分布情况的功能，不同之处在于Histogram可以通过histogram_quantile函数在服务器计算分位数。而Sumamry的分位数则是直接在客户端进行定义的。因此对于分位数的计算，Summary在通过PromQL进行查询的时候有更好的性能表现，而Histogram则会消耗更多的资源，但是相对于客户端而言Histogram消耗的资源就更少。用哪个都行，根据实际场景自由调整即可。</p></blockquote><h2 id="exporter"><a href="#exporter" class="headerlink" title="exporter"></a>exporter</h2><p>广义上向prometheus提供监控数据的程序都可以成为一个exporter的，一个exporter的实例称为target, prometheus通过轮训的方式定时从这些target中获取监控数据。exporter来源主要2个方面，一个是社区提供的，一种是用户自定义的。</p><p>官方和一些社区提供好多exproter, 我们可以直接拿过来采集我们的数据。 官方的exporter地址： <a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></p><h2 id="Blackbox-Exporter"><a href="#Blackbox-Exporter" class="headerlink" title="Blackbox Exporter"></a>Blackbox Exporter</h2><p>bloackbox exporter是prometheus社区提供的黑盒监控解决方案，运行用户通过HTTP、HTTPS、DNS、TCP以及ICMP的方式对网络进行探测。这里通过blackbox对我们的站点信息进行采集。</p><h3 id="blackbox的安装"><a href="#blackbox的安装" class="headerlink" title="blackbox的安装"></a>blackbox的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入下载目录</span></span><br><span class="line">[root@node00 ~]# cd /usr/src/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">[root@node00 src]# wget https://github.com/prometheus/blackbox_exporter/releases/download/v0.15.1/blackbox_exporter-0.15.1.linux-amd64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">[root@node00 src]#  tar xf blackbox_exporter-0.15.1.linux-amd64.tar.gz </span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署到特定位置</span></span><br><span class="line">[root@node00 src]# mv blackbox_exporter-0.15.1.linux-amd64 /usr/local/exporter/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">[root@node00 src]# cd /usr/local/exporter/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 软连接</span></span><br><span class="line">[root@node00 exporter]# ln -s blackbox_exporter-0.15.1.linux-amd64 blackbox_exporter</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入自启目录</span></span><br><span class="line">[root@node00 exporter]#  cd /usr/lib/systemd/system</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置blackbox的开机自启文件</span></span><br><span class="line">[root@node00 system]# cat blackbox_exporter.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=blackbox_exporter</span><br><span class="line">After=network.target </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=prometheus</span><br><span class="line">Group=prometheus</span><br><span class="line">WorkingDirectory=/usr/local/exporter/blackbox_exporter</span><br><span class="line">ExecStart=/usr/local/exporter/blackbox_exporter/blackbox_exporter</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">[root@node00 system]# systemctl restart blackbox_exporter</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">[root@node00 system]# systemctl status blackbox_exporter</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启</span></span><br><span class="line">[root@node00 system]# systemctl enable blackbox_exporter</span><br></pre></td></tr></table></figure><h3 id="配置prometheus采集数据"><a href="#配置prometheus采集数据" class="headerlink" title="配置prometheus采集数据"></a>配置prometheus采集数据</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;blackbox&quot;</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">/probe</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">module:</span> [<span class="string">http_2xx</span>]  <span class="comment"># Look for a HTTP 200 response.</span></span><br><span class="line">    <span class="attr">file_sd_configs:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">refresh_interval:</span> <span class="string">1m</span></span><br><span class="line">      <span class="attr">files:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/usr/local/prometheus/prometheus/conf/blackbox*.yml&quot;</span></span><br><span class="line">    <span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>]</span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">__param_target</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__param_target</span>]</span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">instance</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">      <span class="attr">replacement:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.10</span><span class="string">:9115</span>  <span class="comment"># Blackbox exporter.</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node00 prometheus]# cat conf/blackbox-dis.yml </span><br><span class="line">- targets:</span><br><span class="line">  - https://www.alibaba.com</span><br><span class="line">  - https://www.tencent.com</span><br><span class="line">  - https://www.baidu.com </span><br></pre></td></tr></table></figure><h3 id="grafana展示blackbox采集数据"><a href="#grafana展示blackbox采集数据" class="headerlink" title="grafana展示blackbox采集数据"></a>grafana展示blackbox采集数据</h3><p>重启prometheus查看数据, 可以在grafana导入dashboard id <code>9965</code> 可以看到如下数据。</p><h2 id="pushgateway使用"><a href="#pushgateway使用" class="headerlink" title="pushgateway使用"></a>pushgateway使用</h2><p>由于网络问题或者安全问题，可能我们的数据无法直接暴露出一个entrypoint 给prometheus采集。 这个时候可能就需要一个pushgateway来作为中间者完成中转工作。 prometheus还是采用pull方式来采集pushgateway的数据，我们的采集端通过push方式把数据push给pushgateway，来完成数据的上报。</p><p><a href="https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_67_prometheus_pushgateway.html">prometheus学习系列十五： Prometheus pushgateway的使用</a></p><h2 id="应用集成自定义exporter"><a href="#应用集成自定义exporter" class="headerlink" title="应用集成自定义exporter"></a>应用集成自定义exporter</h2><h3 id="1-pom-xml配置如下"><a href="#1-pom-xml配置如下" class="headerlink" title="1.pom.xml配置如下"></a>1.pom.xml配置如下</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.unicom<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>exporter-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>exporter-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--普罗米修斯依赖--&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_spring_boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_hotspot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_pushgateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--springboot--&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">​<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Application类注解"><a href="#2-Application类注解" class="headerlink" title="2.Application类注解"></a>2.Application类注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnablePrometheusEndpoint</span></span><br><span class="line"><span class="meta">@EnableSpringBootMetricsCollector</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExporterDemoApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ExporterDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加@EnableScheduling注解主要是添加了定时任务，用于动态模拟数据的变化，后面会看到应用的地方。</p><h3 id="3-CounterDemo"><a href="#3-CounterDemo" class="headerlink" title="3.CounterDemo"></a>3.CounterDemo</h3><p>定义一个Counter类型的metrics，一般而言，Counter类型的metrics指标在命名中我们使用_total结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  使用Counter.build()创建Counter类型的监控指标，并且通过name()方法定义监控指标的名称network_traffic_input</span></span><br><span class="line"><span class="comment">     * ，通过labelNames()定义该指标包含的标签。最后通过register()将该指标注册到Collector的defaultRegistry中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Counter counterDemo = Counter.build()</span><br><span class="line">        .name(<span class="string">&quot;counterChanger2&quot;</span>).labelNames(<span class="string">&quot;wy&quot;</span>,<span class="string">&quot;zxjr&quot;</span>,<span class="string">&quot;ocs&quot;</span>,<span class="string">&quot;xxjf&quot;</span>,<span class="string">&quot;unit&quot;</span>)</span><br><span class="line">        .help(<span class="string">&quot;Counter 实例&quot;</span>).register();</span><br><span class="line">    <span class="comment">//指标埋点，定时器会造成普罗米修斯与本地的数据时间戳不同步，尽量不要使用这种方式，实例中的定时器是为了数据演示</span></span><br><span class="line">    <span class="meta">@Scheduled(cron=&quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/changeCounter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">changeCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        counterDemo.labels(<span class="string">&quot;网元&quot;</span>,<span class="string">&quot;在线接入&quot;</span>,<span class="string">&quot;OCS&quot;</span>,<span class="string">&quot;消息计费&quot;</span>,<span class="string">&quot;seconds&quot;</span>).inc();<span class="comment">//指标值增加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里每5秒会自动执行changeCounter用于模拟数据的变化。</p><h3 id="4-GaugeDemo"><a href="#4-GaugeDemo" class="headerlink" title="4.GaugeDemo"></a>4.GaugeDemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GaugeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**指标注册</span></span><br><span class="line"><span class="comment">     * name设置指标名</span></span><br><span class="line"><span class="comment">     * labelNames设置各项指标名称</span></span><br><span class="line"><span class="comment">     * help设置指标描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Gauge gaugeDemo = Gauge.build()</span><br><span class="line">        .name(<span class="string">&quot;gaugeDemo&quot;</span>)</span><br><span class="line">        .labelNames(<span class="string">&quot;label1&quot;</span>,<span class="string">&quot;label2&quot;</span>,<span class="string">&quot;label3&quot;</span>,<span class="string">&quot;label4&quot;</span>,<span class="string">&quot;label5&quot;</span>)</span><br><span class="line">        .help(<span class="string">&quot;gauge 实例&quot;</span>).register();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指标埋点</span></span><br><span class="line">    <span class="meta">@Scheduled(cron=&quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/changeGauge&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">changeGauge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gaugeDemo.labels(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>).inc(); <span class="comment">//指标值加1</span></span><br><span class="line">        gaugeDemo.labels(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>).dec(); <span class="comment">//指标值减一</span></span><br><span class="line">        gaugeDemo.labels(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>).set(<span class="number">19.00</span>); <span class="comment">//指标值直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Gauge类型的metrics可以对数据进行增加、减小和直接赋值。这种类型在实际应用中比较多。</p><h3 id="5-HistogramDemo"><a href="#5-HistogramDemo" class="headerlink" title="5.HistogramDemo"></a>5.HistogramDemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HistogramDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册</span></span><br><span class="line"><span class="comment">     * 注册时buckets()设置区间值，如下设置了100、200、300三个区间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Histogram histogramDemo = Histogram.build()</span><br><span class="line">        .labelNames(<span class="string">&quot;label1&quot;</span>, <span class="string">&quot;label2&quot;</span>, <span class="string">&quot;label3&quot;</span>, <span class="string">&quot;label4&quot;</span>, <span class="string">&quot;label5&quot;</span>)</span><br><span class="line">        .name(<span class="string">&quot;histogramDemo&quot;</span>)</span><br><span class="line">        .buckets(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line">        .help(<span class="string">&quot;Histogram 实例&quot;</span>)</span><br><span class="line">        .register();</span><br><span class="line">    <span class="comment">//指标埋点</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeHistogram</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 本次执行的指标值</span></span><br><span class="line"><span class="comment">         * 如下设置为150，则每次执行，小于200区间以及小于300区间加1，小于100区间不变</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        histogramDemo.labels(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>).observe(<span class="number">150</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了三个区间，小于100，小于200，小于300，而changeHistogram中每次我们设置数据为150，所以最后画出来的曲线只有两条。</p><h3 id="6-SummaryDemo"><a href="#6-SummaryDemo" class="headerlink" title="6.SummaryDemo"></a>6.SummaryDemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SummaryDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Summary summaryDemo = Summary.build()</span><br><span class="line">        .quantile(<span class="number">0.5</span>, <span class="number">0.01</span>)   <span class="comment">// 添加50%分位数，允许有5%的误差,相当于求中位数</span></span><br><span class="line">        .quantile(<span class="number">0.9</span>, <span class="number">0.01</span>)   <span class="comment">// 添加90%分位数，允许有1%的误差</span></span><br><span class="line">        .name(<span class="string">&quot;summaryDemo&quot;</span>).labelNames(<span class="string">&quot;label1&quot;</span>,<span class="string">&quot;label2&quot;</span>,<span class="string">&quot;label3&quot;</span>,<span class="string">&quot;label4&quot;</span>,<span class="string">&quot;label5&quot;</span>)</span><br><span class="line">        .help(<span class="string">&quot;Summary 实例&quot;</span>).register();</span><br><span class="line">    <span class="comment">//指标埋点</span></span><br><span class="line">    <span class="meta">@Scheduled(cron=&quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">changeSummary</span><span class="params">()</span></span>&#123;</span><br><span class="line">        summaryDemo.labels(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>).observe(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在prometheus的Graph中通过查看summaryDemo、summaryDemo_count、summaryDemo_sum查看对应结果。</p><h3 id="7-关于pushgateway"><a href="#7-关于pushgateway" class="headerlink" title="7.关于pushgateway"></a>7.关于pushgateway</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrometheusConfig</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Counter counterDemo = Counter.build()</span><br><span class="line">        .name(<span class="string">&quot;push_way_counter&quot;</span>)</span><br><span class="line">        .labelNames(<span class="string">&quot;wy&quot;</span>,<span class="string">&quot;zxjr&quot;</span>,<span class="string">&quot;ocs&quot;</span>,<span class="string">&quot;xxjf&quot;</span>,<span class="string">&quot;unit&quot;</span>,<span class="string">&quot;instance&quot;</span>)</span><br><span class="line">        .help(<span class="string">&quot;Counter 实例&quot;</span>)</span><br><span class="line">        .register();</span><br><span class="line">    <span class="comment">//测试发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PushGateway prometheusPush = <span class="keyword">new</span> PushGateway(<span class="string">&quot;localhost:9091&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">                counterDemo.labels(<span class="string">&quot;网元&quot;</span>,<span class="string">&quot;在线接入&quot;</span>,<span class="string">&quot;OCS&quot;</span>,<span class="string">&quot;消息计费&quot;</span>,<span class="string">&quot;byte&quot;</span>,<span class="string">&quot;localhsot:9091&quot;</span>).inc();</span><br><span class="line">                prometheusPush.push(counterDemo,<span class="string">&quot;sp-getway&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里拿counter举一个简单的例子，其他三种度量也是一样的处理方式。</p><p>关于pushgateway中转数据，根据我自己实际的验证，我发现索然说数据每次都会先发送到pushgateway，但是prometheus去取的时候还是只取当前那一时间点的数据，并不会把历史的也拿过来。</p><h2 id="Prometheus-监控-Redis"><a href="#Prometheus-监控-Redis" class="headerlink" title="Prometheus 监控 Redis"></a><a href="https://didispace-wx.blog.csdn.net/article/details/104352114">Prometheus 监控 Redis</a></h2>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch总结</title>
      <link href="2021/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E6%80%BB%E7%BB%93/"/>
      <url>2021/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/huangfox/p/9460361.html">为什么要移除Type</a></p><p><a href="https://developer.51cto.com/art/201904/594615.htm">倒排索引</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">简单部署和使用</a></p><p><a href="https://baijiahao.baidu.com/s?id=1663609942544356335&wfr=spider&for=pc">集群角色分离</a></p><p><a href="https://blog.csdn.net/truelove12358/article/details/105577414">倒排索引与B+Tree对比</a></p><p> <a href="https://www.cnblogs.com/LBSer/p/4119841.html">FST（finite state transducers）</a></p><p><a href="https://elasticsearch.cn/article/6178#tip3">Elasticsearch中数据是如何存储的（Lucene）</a></p><p>Master Node：主节点<br>Master eligible nodes：合格节点<br>Data Node：数据节点<br>Coordinating Node：协调节点<br>Ingest Node：ingest节点<br>machine learning：机器学习节点</p><p><img src="/2021/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E6%80%BB%E7%BB%93/794174-20200508142929527-1342544356.png" alt="img"></p><p><img src="/2021/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E6%80%BB%E7%BB%93/794174-20200508142947572-369187416.png" alt="img"></p><ul><li>Master Node：主节点，该节点不和应用创建连接，每个节点都保存了集群状态，master节点不占用磁盘IO和CPU，内存使用量一般。</li><li>Master eligible nodes：合格节点，每个节点部署后不修改配置信息，默认就是一个 eligible 节点，该节点可以参加选主流程，成为Mastere节点。该节点也保存了集群节点的状态。eligible节点比Master节点更节省资源，因为它还未成为 Master 节点，只是有资格成功Master节点。</li><li>Data Node：数据节点，该节点和索引应用创建连接、接收索引请求，该节点真正存储数据，ES集群的性能取决于该节点的个数（每个节点最优配置的情况下），data节点会占用大量的CPU、IO和内存。</li><li>Coordinating Node：协调节点，该节点和检索应用创建连接、接受检索请求，但其本身不负责存储数据，可当负责均衡节点，该节点不占用io、cpu和内存。</li><li>Ingest Node：ingest 节点可以看作是数据前置处理转换的节点，支持 pipeline管道 设置，可以使用 ingest 对数据进行过滤、转换等操作，类似于 logstash 中 filter 的作用，功能相当强大。</li></ul><p><a href="https://mp.weixin.qq.com/s/wnOZl68GlEw34Ms9obtshw">Elasticsearch 架构原理</a></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制及配置实现</title>
      <link href="2021/02/26/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0/"/>
      <url>2021/02/26/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="MySql-主从复制及配置实现"><a href="#MySql-主从复制及配置实现" class="headerlink" title="MySql 主从复制及配置实现"></a><a href="https://segmentfault.com/a/1190000008942618">MySql 主从复制及配置实现</a></h2><p><img src="/2021/02/26/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0/1460000008942622" alt="MySQL主从复制原理及配置实现"></p><ul><li>从节点IO线程，发起请求读取主节点binlog中offset位置后的数据</li><li>主节点Dump线程，读取binlog中的数据，发送给从节点</li><li>从节点IO线程将数据写入Relay log中继日志中</li><li>从节点中SQL线程将Relay log 中的数据进行回放存入从库中</li></ul><h2 id="Binlog日志格式"><a href="#Binlog日志格式" class="headerlink" title="Binlog日志格式"></a>Binlog日志格式</h2><ul><li>Statement   真实的SQL语句</li><li>Row   存有before和after之后的数据</li><li>Mixed  DDL语句使用Statement格式，DML语句使用Row格式</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ul><li>同步复制：在主节点上写入的数据，在从服务器上都同步完了以后才会给客户端返回成功消息，相对来说比较安全，比较靠谱。但是返回信息的时间比较慢</li><li>异步复制：在主节点接收到客户端发送的数据就给客户端返回执行成功的消息。然后再开始再从上面同步，不太靠谱，因为如果我给你返回消息以后，但是我的主节点坏了，并没有在从节点上同步完成，数据就会丢失，就算给客户端返回成功消息，但是我执行是不成功的(mysql默认使用异步复制)</li><li>半同步复制：在接收到客户端发送的数据，主节点会将数据同步到至少一台从节点以后再给客户端发送执行成功的消息，这个以前是没有的，是谷歌贡献的一个插件才可以做，它相当于是同步和异步的一个中和的复制方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结</title>
      <link href="2021/02/26/%E6%80%BB%E7%BB%93/"/>
      <url>2021/02/26/%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul><li><p>存储引擎 </p><ul><li>show engines;</li><li>show variables like ‘%storage_engine%’;</li><li>show table status like “table_name” ; </li></ul></li><li><p>MyISAM和InnoDB区别</p></li><li><p>索引</p></li><li><p>事务</p><ul><li>四大特性</li><li>并发事务带来的问题：</li><li>隔离级别</li></ul></li><li><p>MVCC</p></li><li><p>查询缓存</p></li><li><p>锁机制</p></li><li><p>大表优化</p></li><li><p>数据库连接池</p></li><li><p>分库分表id处理</p></li><li><p>redolog</p></li><li><p>undolog</p></li><li><p>binlog</p></li><li><p>binlog同步中间件-阿里cancel</p></li><li><p>sql执行计划</p></li><li><p><em>页</em>(Page)是 Innodb 存储引擎用于管理数据的最小磁盘单位。常见的<em>页</em>类型有数据<em>页</em>、Undo <em>页</em>、系统<em>页</em>、事务数据<em>页</em>等</p></li><li><p><a href="https://segmentfault.com/a/1190000008545713">Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型：<code>数据页（B-Tree Node）</code>，<code>Undo页（Undo Log Page）</code>，<code>系统页（System Page）</code>，<code>事务数据页（Transaction System Page）</code>等；每个数据页的大小为<code>16kb</code>，每个Page使用一个32位（一位表示的就是0或1）的int值来表示，正好对应Innodb最大64TB的存储容量(16kb * 2^32=64tib)</a></p></li><li><p>预读取</p></li><li><p><a href="https://blog.csdn.net/luoyang_java/article/details/92781164">B+树存多少条数据</a></p></li><li><p><a href="https://www.cnblogs.com/MYSQLZOUQI/p/6991378.html?utm_source=itdadao&utm_medium=referral">预加载</a></p></li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul><li>IOC</li><li>Bean初始化流程（BeanDefinition,BeanDefinitionRegistry）</li><li>Bean范围Scope</li><li>Bean生命周期(BeanFactoryPostProcessor,BeanPostProcessor)</li><li>循环依赖(三级缓存)</li><li>AOP（jdk动态代理，cglib）</li><li>事务（失效，隔离级别，传播行为，默认回滚事务RuntimeException）</li><li>BeanFactory、ApplicationContext</li><li>BeanFactory、FactoryBean</li><li>设计模式</li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><ul><li>SpirngBootApplication注解<ul><li>Configuration</li><li>EnableAutoConfiguration</li><li>ComponentScan</li></ul></li><li>简化spring开发，约定大于配置，使用默认配置，解决依赖问题</li><li>内置容器（tomcat,jetty,undo）</li></ul><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li>Near Realtime 近实时：</li><li>角色：{master、data、协调者、Ingest节点、machine learning}</li><li>集群</li><li>ELK</li><li>概念：Index、Type、document</li><li>优化点：预热（自检热点数据）、冷热分离、SystemFile cache需要保证内存是数据的一半以上</li><li>倒排索引</li><li>segment : lucene内部的数据是由一个个segment组成的，写入lucene的数据并不直接落盘，而是先写在内存中，经过了refresh间隔，lucene才将该时间段写入的全部数据refresh成一个segment，segment多了之后会进行merge成更大的segment。lucene查询时会遍历每个segment完成。由于lucene* 写入的数据是在内存中完成，所以写入效率非常高。但是也存在丢失数据的风险，所以Elasticsearch基于此现象实现了translog，只有在segment数据落盘后，Elasticsearch才会删除对应的translog。</li><li></li></ul><h2 id="登录权限"><a href="#登录权限" class="headerlink" title="登录权限"></a>登录权限</h2><h2 id="Spring-Security-Oauth2-单点登录案例实现和执行流程剖析"><a href="#Spring-Security-Oauth2-单点登录案例实现和执行流程剖析" class="headerlink" title="Spring Security Oauth2 单点登录案例实现和执行流程剖析"></a><a href="https://www.cnblogs.com/xifengxiaoma/p/10043173.html">Spring Security Oauth2 单点登录案例实现和执行流程剖析</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql缓存池</title>
      <link href="2021/02/26/Mysql%E7%BC%93%E5%AD%98%E6%B1%A0/"/>
      <url>2021/02/26/Mysql%E7%BC%93%E5%AD%98%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>今天来聊一聊 Mysql 缓存池原理。</p><p>提纲附上，话不多说，直接干货。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0UlVBbYzdDQ1AcJDicwOVicSTFITUHRWnBpoPaM0miaibv8KFdzI24JSUGeA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面试官：同学，你能说说Mysql 缓存池吗？</p><p>狂聊君：啊，这么难吗，容我组织一下语言。（内心OS：这TM还不简单？我能给你扯半小时！）</p><p>面试官：可以，给你一分钟时间想一想吧。</p><h2 id="为什么要有缓存池？"><a href="#为什么要有缓存池？" class="headerlink" title="为什么要有缓存池？"></a>为什么要有缓存池？</h2><p>Mysql 的 innodb 存储引擎是基于磁盘存储的，并且是按照页的方式进行管理的。</p><p>在数据库系统中，CPU 速度与磁盘速度之间的差距是非常大的，为了最大可能的弥补之间的差距，提出了缓存池的概念。</p><p>所以缓存池，简单来说就是一块<strong>「内存区域」</strong>，通过内存的速度来弥补磁盘速度较慢，导致对数据库造成性能的影响。</p><h2 id="缓存池的基本原理"><a href="#缓存池的基本原理" class="headerlink" title="缓存池的基本原理"></a>缓存池的基本原理</h2><p><strong>「读操作」</strong></p><p>在数据库中进行读取页的操作，首先把从磁盘读到的页存放在缓存池中，下一次读取相同的页时，首先判断该页是不是在缓存池中。</p><p>若在，称该页在缓存池中被命中，则直接读取该页，否则，还是去读取磁盘上的页。</p><p><strong>「写操作」</strong></p><p>对于数据库中页的修改操作，首先修改在缓存池中的页，然后在以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘，而是通过 checkpoint 的机制把页刷新回磁盘。</p><p><strong>可以看到，无论是读操作还是写操纵，都是对缓存池进行操作，而不是直接对磁盘进行操纵。</strong></p><h2 id="缓存池结构"><a href="#缓存池结构" class="headerlink" title="缓存池结构"></a>缓存池结构</h2><p>Buffer Pool 是一片连续的内存空间，innodb 存储引擎是通过页的方式对这块内存进行管理的。</p><p>缓存池的结构如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0U7N0aFIbzkyjSnmeRiaibdRicvmf6B8ylOIXIdiazPLib0Vuo1f5KInOe3VQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>可以看到缓存池中包括数据页、索引页、插入缓存、自适应哈希索引、锁信息、数据字段。</p><p>其中数据页和索引页会用掉多数内存。</p><p><strong>「但是，innodb 是如何管理缓存池中的这么多页呢？」</strong></p><p>为了更好的管理这些缓存的页，innodb 为每一个缓存页都创建了一些所谓的控制信息，这些控制信息包括该页所属的：</p><ul><li>表空间编号(sapce id)</li><li>页号(page numeber)</li><li>页在 buffer Pool 的地址</li><li>一些锁信息以及 LSN 信息日志序列号</li><li>其他控制信息</li></ul><p>每个缓存页对应的控制信息占用的内存大小是相同的，我们把每个页对应的控制信息占用的一块内存称为一个<strong>「控制块」。</strong></p><p><strong>「控制块」</strong>和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 的后边。</p><p>Buffer Pool 对应的内存空间示意图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0Uq7lPibDTEeZnDGC2LibZrb14MDXlMGZ2zVtfwJ6SYvOMm1pypL9kYgXQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="缓存池参数设置"><a href="#缓存池参数设置" class="headerlink" title="缓存池参数设置"></a>缓存池参数设置</h2><ul><li>innodb_buffer_pool_size：缓存池的大小最多应设置为物理内存的 80%</li><li>innodb_buffer_pool_instance：设置有多少个缓存池，通常建议把缓存池个数设置为 CPU 的个数，多个缓存池可以减少数据库内部的资源竞争，增加数据库并发访问的能力</li><li>innodb_old_blocks_pct：老生代占整个 LRU 的链长比例，默认是 3：7</li><li>innodb_old_blocks_time：老生代停留时间窗口，单位是毫秒，默认是 1000，即同时满足“被访问”与“在老生代停留时间超过 1 秒”两个条件，才会被插入到新生代头部</li></ul><h2 id="缓存池管理"><a href="#缓存池管理" class="headerlink" title="缓存池管理"></a>缓存池管理</h2><p><strong>「管理缓存池依赖的链表结构」：</strong></p><h3 id="Free-链表"><a href="#Free-链表" class="headerlink" title="Free 链表"></a>Free 链表</h3><p>当启动 Mysql 服务器的时候，需要完成对 Buffer Pool 的初始化过程，即分配 Buffer Pool 的内存空间，把它划分为若干对控制块和缓存页，但是此时并没有真正的磁盘页被缓存到 Buffer Pool 中，之后随着程序的运行，会不断的有磁盘上的页被缓存到 Buffer Pool 中。</p><p>在使用过程中，为了记录哪些缓存页是可用的，我们把所有空闲的页包装成一个节点组成一个链表，这个链表可以称作为 Free 链表（空闲链表）。因为刚刚完成初始化的 Buffer Pool 中所有的缓存页都是空闲的，所以每一个缓存页都会被加入到 Free 链表中。</p><p>为了方便管理 Free 链表，特意为这个链表定义了一些<strong>「控制信息」</strong>，里面包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</p><p>另外会在每个 Free 链表的节点中都记录了某个<strong>「缓存页控制块」</strong>的地址，而每个<strong>「缓存页控制块」</strong>都记录着对应的<strong>「缓存页地址」</strong>，所以相当于每个 Free 链表节点都对应一个空闲的缓存页。</p><p>给大家画了个结构图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0UZH5zZQvdLAa3IhDasmjUE7AfDibmEWtR6aH0fjw1XFCtPLyafdjhTzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这图怎么样，这下能看的懂了吧！</p><h3 id="2、Lru-链表"><a href="#2、Lru-链表" class="headerlink" title="2、Lru 链表"></a>2、Lru 链表</h3><p>Lru 链表用来管理已经读取的页，当数据库刚启动时，Lru 链表是空的，此时页也都放在 Free 列表中，当需要读取数据时，会从 Free 链表中申请一个页，把从放入到磁盘读取的数据放入到申请的页中，这个页的集合叫做 Lru 链表。</p><h3 id="3、Flush-链表"><a href="#3、Flush-链表" class="headerlink" title="3、Flush 链表"></a>3、Flush 链表</h3><p>Flush 链表用来管理被修改的页，Buffer Pool 中被修改的页也被称之为<strong>「脏页」</strong>，脏页既存在于 Lru 链表中，也存在于 Flush 链表中，Flush 链表中存的是一个指向 Lru 链表中具体数据的指针。</p><p>因此只有 Lru 链表中的页第一次被修改时，对应的指针才会存入到 Flush 中，若之后再修改这个页，则是直接更新 Lru 链表中的页对应的数据。</p><p>这三者之间是这么个关系：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0UYZKoGqCJ4KGib4uJV2r9G25CnTwLTPic3SGYcJmM5QFJiapOuRshaRP3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>Buffer Pool 一个最主要的功能是<strong>「加速读」</strong>。加速读是当需要访问一个数据页面的时候，如果这个页面已经在缓存池中，那么就不再需要访问磁盘，直接从缓冲池中就能获取这个页面的内容。当我们需要访问某个页中的数据时，就会把该页加载到 Buffer Pool 中，如果该页已经在 Buffer Pool 中的话直接使用就可以了。</p><p><strong>问题：那么如何快速查找在 Buffer Pool 中的页呢？</strong></p><p>为了避免查询数据页时扫描 Lru，其实是根据表空间号 + 页号来定位一个页的，也就相当于表空间号 + 页号是一个 key，缓存页就是对应的 value。用表空间号 + 页号作为 key，缓存页作为 value 创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据表空间号 + 页号看看有没有对应的缓存页。</p><p>如果有，直接使用该缓存页就好。</p><p>如果没有，那就从 Free 链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free 链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的 Free 链表节点从链表中移除，表示该缓存页已经被使用了，并且把该页写入 Lru 链表。</p><p>在初始化的时候，Buffer pool 中所有的页都是空闲页，需要读数据时，就会从 Free 链表中申请页，但是物理内存不可能无限增大，数据库的数据却是在不停增大的，所以 Free 链表的页是会用完的。</p><p>因此需要考虑把已经缓存的页从 Buffer pool 中删除一部分，进而需要考虑如何删除及删除哪些已经缓存的页。假设一共访问了 n 次页，那么被访问的页在缓存中的次数除以 n 就是缓存命中率，缓存命中率越高，和磁盘的 IO 交互也就越少 。</p><p>为了提高缓存命中率，InnoDB 在传统 Lru 算法的基础上做了优化，解决了两个问题：1、预读失效 2、缓存池污染</p><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>Buffer pool 另一个主要的功能是<strong>「加速写」</strong>，即当需要修改一个页面的时候，先将这个页面在缓冲池中进行修改，记下相关的重做日志，这个页面的修改就算已经完成了。</p><p>被修改的页面真正刷新到磁盘，这个是后台刷新线程来完成的。前面页面更新是在缓存池中先进行的，那它就和磁盘上的页不一致了，这样的缓存页被称为脏页（dirty page）。</p><p><strong>问题：这些被修改的页面什么时候刷新到磁盘？以什么样的顺序刷新到磁盘？</strong></p><p>最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，不能立即把修改同步到磁盘上，而是在未来的某个时间点进行同步，由后台刷新线程依次刷新到磁盘，实现修改落地到磁盘。</p><p>但是如果不立即同步到磁盘的话，那之后再同步的时候如何判断 Buffer Pool 中哪些页是脏页，哪些页从来没被修改过呢？</p><p>InnoDB 并没有一次性把所有的缓存页都同步到磁盘上，InnoDB 创建一个存储脏页的链表，凡是在 Lru 链表中被修改过的页都需要加入这个链表中，因为这个链表中的页都是需要被刷新到磁盘上的，所以这个链表也叫 Flush 链表，链表的构造和 Free 链表一致。</p><p>这里的脏页修改指的此页被加载进 Buffer Pool 后第一次被修改，只有第一次被修改时才需要加入 Flush 链表，对于已经存在在 Flush 链表中的页，如果这个页被再次修改就不会再放到 Flush 链表。</p><p>需要注意，脏页数据实际还在 Lru 链表中，而 Flush 链表中的脏页记录只是通过指针指向 Lru 链表中的脏页。并且在 Flush 链表中的脏页是根据 oldest_lsn（这个值表示这个页第一次被更改时的 lsn 号，对应值 oldest_modification，每个页头部记录）进行排序刷新到磁盘的，值越小表示要最先被刷新，避免数据不一致。</p><p><a href="https://blog.csdn.net/suifeng629/article/details/93649148">预读失效和缓冲池污染</a> </p><p>BufferPool是引擎级别的缓存</p><p><a href="https://www.cnblogs.com/michael9/p/14135436.html">RC隔离级别，半一致性读，提高并发读</a><br><a href="https://www.cnblogs.com/michael9/p/14135436.html">互联网项目中使用RC隔离级别</a><br>    <em>在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！</em><br>    <em>在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</em><br>    <em>在RC隔离级别下，半一致性读(semi-consistent)特性增加了update、delete操作的并发性！</em></p><p><em>在RC级别下，不可重复读问题需要解决么？</em></p><p>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？</p><p><em>在RC级别下，主从复制用什么binlog格式？</em><br>OK,在该隔离级别下，用的binlog为row格式，是基于行的复制！Innodb的创始人也是建议binlog使用该格式！</p><p><a href="https://blog.csdn.net/SnailMann/article/details/94724197">RC、RR下MVCC</a></p><p>ibd文件结构由segment inode、extent和page组成。page是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。</p><p>MyISAM -&gt;.frm(描述表结构文件，字段长度等)、.MYD(数据信息文件，存储数据信息)、.MYI(索引信息文件)</p><p>Innodb -&gt;.frm(描述表结构文件，字段长度等) 、.idb(存储数据信息和索引信息)</p><p>Innodb的idb文件组成：由segment inode、extent和page组成。page是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。</p><p>page组成：page header（page number、prev page、next page） 、页尾 、行记录（Infimun+Supremum  user record）</p><p><a href="https://blog.csdn.net/weixin_38629422/article/details/105813338?spm=1001.2014.3001.5501">redo日志的刷盘策略</a><br><a href="https://www.jianshu.com/p/2b7fdad5fc0c">binlog/redolog/undolog详解</a></p><p>mysql发生崩溃恢复的过程中，会根据redo log日志，结合 binlog 记录来做事务回滚：</p><p>1、如果redo log 和 binlog都存在，逻辑上一致，那么提交事务；</p><p>2、如果redo log存在而binlog不存在，逻辑上不一致，那么回滚事务；</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql页的概念</title>
      <link href="2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://segmentfault.com/u/huaidiaodeya">坏掉的牙</a></p><p>出处：<a href="https://segmentfault.com/a/1190000008545713">mysql中InnoDB引擎中页的概念</a></p><p>Linux内存页默认大小是4K的，所以每个4K都有一个对应的page结构体进行管理。Linux有大页功能，比如2M，1G大页，但这里的大页并不是指Linux管理物理内存的基本单位，而是指MMU页表项所能描述的最大物理块空间，使用更大的页，是为了减少TLB miss造成查页表带来的性能开销。一个大页，也是由多个连续的物理页组成的，每个物理页也都有page结构体描述。</p><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p>Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型：<code>数据页（B-Tree Node）</code>，<code>Undo页（Undo Log Page）</code>，<code>系统页（System Page）</code>，<code>事务数据页（Transaction System Page）</code>等；每个数据页的大小为<code>16kb</code>，每个Page使用一个32位（一位表示的就是0或1）的int值来表示，正好对应Innodb最大64TB的存储容量(16kb * 2^32=64tib)。一个Page的基本结构如下：</p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1hx" alt="clipboard.png" style="zoom:67%;"><h2 id="头部数据"><a href="#头部数据" class="headerlink" title="头部数据"></a>头部数据</h2><p>每个page都有通用的头和尾，但是中部的内容根据page的类型不同而发生变化，头部的数据如下：</p><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/1.png" alt="clipboard.png"><br>page头部保存了两个指针，分别指向前一个Page和后一个Page，头部还有Page的类型信息和用来唯一标识Page的编号。根据这个指针分布可以想象到Page链接起来就是一个双向链表</p><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1hF" alt="clipboard.png"></p><h2 id="主体数据"><a href="#主体数据" class="headerlink" title="主体数据"></a>主体数据</h2><p>在Page的主体部分，主要关注数据和索引的存储，他们都位于<code>User Records</code>部分，User Records占据Page的大部分空间，User Records由一条条的Record组成，每条记录代表索引树上的一个节点（非叶子节点和叶子节点）；在一个单链表的内部，单链表的头尾由两条记录来表示，字符串形式的“ Infimum”代表开头，“Supremum”表示结尾；System Record 和 User Record是两个平行的段；<br>Innodb中存在四种不同的Record，分别是</p><ol><li>主键索引树非叶子节点</li><li>主键索引树叶子节点</li><li>辅助键索引树非叶子节点</li><li>辅助键索引树叶子节点</li></ol><p>这四种节点Record格式上有差异，但是内部都存储着Next指针指向下一个Record</p><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1hK" alt="clipboard.png"></p><h3 id="User-Record"><a href="#User-Record" class="headerlink" title="User Record"></a>User Record</h3><p>User Record在Page内以单链表的形式存在，最初数据是按照插入的先后顺序排列的，但是随着新数据的插入和旧数据的删除，数据物理顺序发生改变，但是他们依然保持着逻辑上的先后顺序</p><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1hN" alt="clipboard.png"></p><p>把User Record组织形式和若干Page组织起来，就得到了稍微完整的形式：</p><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1hP" alt="clipboard.png"></p><h4 id="如何定位一个Record："><a href="#如何定位一个Record：" class="headerlink" title="如何定位一个Record："></a>如何定位一个Record：</h4><ol><li>通过根节点开始遍历一个索引的B+树，通过各层非叶子节点达到底层的叶子节点的数据页（Page），这个Page内部存放的都是叶子节点</li><li>在Page内部从“Infimum”节点开始遍历单链表（遍历一般会被优化），如果找到键则返回。如果遍历到了“Supremum”，说明当前Page里没有合适的键，这时借助Page页内部的next page指针，跳转到下一个page继续从“Infmum”开始逐个查找</li></ol><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1hS" alt="clipboard.png"></p><h4 id="User-Record内部的数据"><a href="#User-Record内部的数据" class="headerlink" title="User Record内部的数据"></a>User Record内部的数据</h4><p>User Record内部存储了四种格式的数据：</p><ol><li>主索引树非叶子节点（绿色）<ul><li>子节点存储的主键里最小的值，这时B+树必须的，作用是在一个Page里定位到具体的记录的位置</li><li>最小的值所在的Page的编号，作用是定位到对应的Record所在的Page</li></ul></li><li>主索引树叶子节点（黄色）<ul><li>主键，B+树所必须的，也是数据行的一部分</li><li>除去主键以外的所有列，这时数据行的除去主键的其他所有列的集合</li></ul></li><li>辅助索引树非叶子节点（蓝色）<ul><li>子节点里存储的辅助键值里的最小值，这时B+Tree必须的，作用是在一个Page里定位到具体记录的位置</li></ul></li><li>辅助索引树叶子节点（红色）<ul><li>辅助索引键值，是B+树必须的</li><li>主键值，用来在主索引树里在做一次B+树检索来找到整条记录</li></ul></li></ol><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1hZ" alt="clipboard.png"></p><h1 id="整体的查找过程"><a href="#整体的查找过程" class="headerlink" title="整体的查找过程"></a>整体的查找过程</h1><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1h2" alt="clipboard.png"></p><h2 id="简介的树形查找示意图"><a href="#简介的树形查找示意图" class="headerlink" title="简介的树形查找示意图"></a>简介的树形查找示意图</h2><p><img src="/2021/02/26/mysql%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5/bVJ1hk" alt="clipboard.png"></p><p>Page和B+树之间并没有一一对应的关系，Page只是作为一个Record的保存容器，它存在的目的是便于对磁盘空间进行批量管理。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql使用RC隔离级别</title>
      <link href="2021/02/26/MySQL%E4%BD%BF%E7%94%A8RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>2021/02/26/MySQL%E4%BD%BF%E7%94%A8RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="【原创】互联网项目中mysql应该选什么事务隔离级别"><a href="#【原创】互联网项目中mysql应该选什么事务隔离级别" class="headerlink" title="【原创】互联网项目中mysql应该选什么事务隔离级别"></a><a href="https://www.cnblogs.com/rjzheng/p/10510174.html">【原创】互联网项目中mysql应该选什么事务隔离级别</a></h2><h2 id="MySQL-InnoDB-锁总结（二）-RC-加锁流程"><a href="#MySQL-InnoDB-锁总结（二）-RC-加锁流程" class="headerlink" title="MySQL InnoDB 锁总结（二）- RC 加锁流程"></a><a href="https://www.cnblogs.com/michael9/p/14135436.html">MySQL InnoDB 锁总结（二）- RC 加锁流程</a></h2><h2 id="为什么默认隔离级别是RR"><a href="#为什么默认隔离级别是RR" class="headerlink" title="为什么默认隔离级别是RR"></a>为什么默认隔离级别是RR</h2><ul><li>历史原因，binlog格式是statement，使用RC时，主从复制有bug，导致数据错误。实例时session1执行delete，session2执行insert</li><li>解决方案有二个。一个是使用RR隔离级别，通过next-key锁解决插入，锁住间隙；第二使用Row格式binlog日志</li><li>低版本没有Row格式，因此改为了RR为默认隔离级别</li></ul><h2 id="为什么互联网项目使用RC"><a href="#为什么互联网项目使用RC" class="headerlink" title="为什么互联网项目使用RC"></a>为什么互联网项目使用RC</h2><ul><li><em>在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！</em></li><li><em>在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</em></li><li><em>在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！</em></li></ul><h2 id="在RC级别下，不可重复读问题需要解决么？"><a href="#在RC级别下，不可重复读问题需要解决么？" class="headerlink" title="在RC级别下，不可重复读问题需要解决么？"></a>在RC级别下，不可重复读问题需要解决么？</h2><p>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？</p><h2 id="在RC级别下，主从复制用什么binlog格式？"><a href="#在RC级别下，主从复制用什么binlog格式？" class="headerlink" title="在RC级别下，主从复制用什么binlog格式？"></a>在RC级别下，主从复制用什么binlog格式？</h2><p>在该隔离级别下，用的binlog为row格式，是基于行的复制！Innodb的创始人也是建议binlog使用该格式！</p><h2 id="RC隔离级别"><a href="#RC隔离级别" class="headerlink" title="RC隔离级别"></a>RC隔离级别</h2><p><font color="red">RC 相较于 RR 在很大程度上调高了并发性，降低了死锁发生的概率，因而作为大多数高并发场景的首选。</font></p><ul><li>对于 <code>select  for update</code>, <code>UPDATE</code> 或者 <code>DELETE</code> 操作来说，<code>InnoDB</code> 仅仅会锁住更新或者删除的行。在 MySQL 根据 Where 条件，搜索后，不满足条件的行会被释放。这样做可以很好地降低死锁发生的概率，但仍然可以发生。</li><li>对于 <code>UPDATE</code> 操作来说，在 RC 级别下，如果一个行被锁上后，InooDB 会执行<font color="red">半一致性读</font>的操作，通过返回最近的 commit 版本，来判断当前锁定的行是否符合 WHERE 条件。如果不匹配，不会对该记录加锁，如果匹配，会再次读取该行进行加锁或者阻塞来等待锁定该行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册中心对比</title>
      <link href="2021/02/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/"/>
      <url>2021/02/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h3 id="consul、eureka、nacos对比"><a href="#consul、eureka、nacos对比" class="headerlink" title="consul、eureka、nacos对比"></a>consul、eureka、nacos对比</h3><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><ul><li>eureka 不支持</li><li>consul 支持 但用起来偏麻烦，不太符合springBoot框架的命名风格，支持动态刷新</li><li>nacos 支持 用起来简单，符合springBoot的命名风格，支持动态刷新</li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><ul><li>eureka<ul><li>应用内/外：直接集成到应用中，依赖于应用自身完成服务的注册与发现，</li><li>CAP原则：遵循AP（可用性+分离容忍）原则，有较强的可用性，服务注册快，但牺牲了一定的一致性。</li><li>版本迭代：目前已经不进行升级</li><li>集成支持：只支持SpringCloud集成</li><li>访问协议：HTTP</li><li>雪崩保护：支持雪崩保护</li><li>界面：英文界面，不符合国人习惯</li><li>上手：容易</li></ul></li><li>consul<ul><li>应用内/外：属于外部应用，侵入性小</li><li>CAP原则：遵循CP原则（一致性+分离容忍） 服务注册稍慢，由于其一致性导致了在Leader挂掉时重新选举期间真个consul不可用。</li><li>版本迭代：目前仍然进行版本迭代</li><li>集成支持：支持SpringCloud K8S集成</li><li>访问协议：HTTP/DNS</li><li>雪崩保护：不支持雪崩保护</li><li>界面：英文界面，不符合国人习惯</li><li>上手：复杂一点</li></ul></li><li>nacos<ul><li>应用内/外：属于外部应用，侵入性小</li><li>CAP原则：通知遵循CP原则（一致性+分离容忍） 和AP原则（可用性+分离容忍）</li><li>版本迭代：目前仍然进行版本迭代</li><li>集成支持：支持Dubbo 、SpringCloud、K8S集成</li><li>访问协议：HTTP/动态DNS/UDP</li><li>雪崩保护：支持雪崩保护</li><li>界面：中文界面，符合国人习惯</li><li>上手：极易，中文文档，案例，社区活跃</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> consul </tag>
            
            <tag> eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC调用理解</title>
      <link href="2021/02/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRPC%E8%B0%83%E7%94%A8%E7%90%86%E8%A7%A3/"/>
      <url>2021/02/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRPC%E8%B0%83%E7%94%A8%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>rpc只是一种概念，可以有很多种的实现方式，可以直接http来做，接触到很多公司后端服务之间的调用就是直接通过http来做的，这种实现的方式好处就太多了，简单，现成可用的库很多，缺点也很多，性能，系统伸缩性等都有比较明显的限制。</p><p>  更加成熟的分布式后端解决方案应该还是类似于阿里的那一套基于服务化的系统设计，一般情况下都有一个config中心，用于注册进程和服务的信息，进程之间直接建立连接发起rpc请求，对于业务层面，一般情况下都是提供比较简洁的同步接口，类似于如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service = config.get_service(<span class="string">&quot;fjs&quot;</span>)</span><br><span class="line">res = service.hello(<span class="string">&quot;你好&quot;</span>)<span class="number">12</span></span><br></pre></td></tr></table></figure><p>  通过这种同步的rpc方式，构建出可伸缩的后端系统。（个人觉得这里提供如上的一种简洁的同步的api接口是非常重要的，因为也接触过node.js的一些rpc方案，通过注册回调的方式来实现rpc来回，感觉这对上层写业务来说是一种灾难，这方面node.js确实感觉没有太好的方案，好像fib.js不错，java这方面做的应该是最好的，所以能够找到很多java的服务框架，python其实也可以有很好的实现，毕竟有greenlet这种协程方案。）</p><p>上面好像说了很多无关内容，主要是为了引入接下来的内容，要实现跨进程的通信，那么首先肯定要建立连接，这个时候就会有一些差异了：</p><blockquote><p>（1）对于每一次rpc请求，都单独建立一个tcp连接，请求完成之后关闭连接，每一个请求都需要独占一个tcp连接<br>（2）类似于（1）中实现，只不过对tcp连接做了缓存，类似于连接池的方案，每一次rpc请求都需要独占连接<br>（3）只建立一个连接，请求都共享这个连接，通过一些请求id来标示返回的数据应该属于哪一个请求。</p></blockquote><hr><p>对于上述三种实现，第一种最简单，但是也是可能问题最大的，例如如果进程大量的发起请求，那么将会有大量的tcp连接建立，关闭，开销会比较的大，而且还有可能会出端口耗尽的风险，毕竟tcp有TIME_WAIT这种状态。</p><p>对于第二种就稍微好了一些，但是要维护一个连接池，实现难度就稍大了点。</p><p>对于第三种，这种系统开销最小，但是需要实现请求id的分配和映射，同时还需要有对长连接的状态监测，实现起来难度也稍大。</p><hr><p>对于现在实际工业界的用法，第一种应该很少，相对来说第二种和第三种用的都还算比较的普遍，接下来是一些自己总结的比较实用的一些代码实现方案：</p><ul><li>专门抽出来一个连接管理器，每一次在发起rpc请求的时候，都需要在连接器中申请一个连接，连接管理器负责连接状态监测</li><li>每次在获取连接的时候，对于获取的连接，都应该做一次连接状态的监测，确保连接确实是正常的，常用的方法就是直接select.select来试一下</li><li>最好要根据rpc请求的一些状态，来主动的处理连接，例如出现了一些意料之外的异常，那么为了安全，最好应该将当前主动关闭</li><li>如果语言有上下文管理器，类似于python的with语句，那应该将其利用起来，通过上下文管理来捕获外部代码的一些异常，从而在一些特殊情况下主动关闭连接</li><li>对于第三种类型的长连接实现，最好要实现一个应用层的心跳，因为同一条连接上关联的请求太多，为了减小伤害面积，能够尽早发现异常连接状态越好，那么其实tcp的keepalive就应该够了，那么为啥要实现应用层的心跳呢？这里其实还有另外的考虑，tcp的保活定时器是系统层面上的东西，对于自己的代码其实并不能感知到，就算是对面的进程因为永久性的阻塞而无法服务了，其实保活定时器是无法处理这种情况的</li><li>客户端rpc的超时一定要有，另外服务端，如果是并发的，不管是线程还是协程，都一定要监控运行状态，防止永久性的阻塞造成内存泄露，设定一些阈值，在需要的时候直接终止正在执行的rpc请求</li><li>能用开源的io层实现就尽量用优秀的开源软件来实现，不要自己去写，首先自己写的不管是性能还是系统的鲁棒性估计都有问题，其次，实现的肯定会有各种问题</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日志之ELK简单使用</title>
      <link href="2021/02/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%97%A5%E5%BF%97ELK%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%97%A5%E5%BF%97ELK%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>ELK(Elasticsearch + Logstash + Kibana)-&gt;EFK由ElasticSearch、Fluentd和Kiabana三个开源工具组成<br><a href="https://www.jianshu.com/p/09cbd7fb369a">https://www.jianshu.com/p/09cbd7fb369a</a></p><p>业界是采用ELK(Elasticsearch + Logstash + Kibana)来管理日志。Logstash是一个具有实时渠道能力的数据收集引擎,但和fluentd相比，它在效能上表现略逊一筹，故而逐渐被fluentd取代，ELK也随之变成EFK。</p><h2 id="Beats是一组轻量级采集程序的统称"><a href="#Beats是一组轻量级采集程序的统称" class="headerlink" title="Beats是一组轻量级采集程序的统称"></a>Beats是一组轻量级采集程序的统称</h2><p>1） filebeat: 进行文件和目录采集，主要用于收集日志数据。<br>                1) 健壮性<br>                2) 智能调节传输速度，防止logstash、es 过载</p><p> 2） metricbeat: 进行指标采集，指标可以是系统的，也可以是众多中间件产品的，主要用于监控系统和软件的性能。</p><p>3） packetbeat: 通过网络抓包、协议分析，对一些请求响应式的系统通信进行监控和数据收集，可以收集到很多常规方式无法收集到的信息。</p><p>4） Winlogbeat: 专门针对 windows 的 event log 进行的数据采集。</p><p>5） Heartbeat: 系统间连通性检测，比如 icmp, tcp, http 等系统的连通性监控。</p><p>6） 可以通过 beats 生成器来生成自己的 beats</p><p>​<br>                                                    Elasticsearch</p><pre><code>                                                Logstash: 是一个灵活的数据传输和处理系统，在beats出来之前，还负责进行数据收集。                                                Logstash的任务，就是将各种各样的数据，经过配置转化规则，统一化存入Elasticsearch。                                                使用Ruby开发的Logstash在灵活性上，非常出色。不过性能一直是被诟病的问题。                                                由于Logstash在数据收集上并不出色，而且作为agent，性能并不达标。elastic发布了beats系列轻量级采集组件。                                                至此，elastic形成了一个完整的生态链和技术栈，成为大数据市场的佼佼者。</code></pre><p>​<br>                                                    Fluentd (客户端和服务端)</p><pre><code>                                                Kabana</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>其它</title>
      <link href="2021/02/07/%E5%85%B6%E5%AE%83/"/>
      <url>2021/02/07/%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<p>//redisson<br><dependency><br>    <groupId>org.redisson</groupId><br>    <artifactId>redisson-spring-boot-starter</artifactId><br>    <version>3.13.6</version><br></dependency></p><p>//rocketmq<br><dependency><br>    <groupId>org.apache.rocketmq</groupId><br>    <artifactId>rocketmq-spring-boot-starter</artifactId><br>    <version>2.1.1</version><br></dependency></p><p>//sentry 异常监控平台  Sentry来收集线上错误日志并进行告警、监控及任务分配处理<br><dependency><br>    <groupId>io.sentry</groupId><br>    <artifactId>sentry-spring-boot-starter</artifactId><br></dependency><br><dependency><br>    <groupId>io.sentry</groupId><br>    <artifactId>sentry-logback</artifactId><br></dependency></p><p>@EnableDubbo //使用下面的配置可以不用使用注解，springboot自动配置机制</p><dependency>  <groupId>org.apache.dubbo</groupId>  <artifactId>dubbo-spring-boot-starter</artifactId>  <version>2.7.7</version></dependency><p>@EnableNacosConfig  //使用下面的配置可以不用使用注解，springboot自动配置机制<br>//作用：可以将配置信息注入到environment对象中，方便存取，且可以使用@value注入属性，也可以使用nacos定义的注解注入属性。配置项查看相关的properties<br>//@NacosValue(value = “${alone88.name}”, autoRefreshed = true)<br><dependency><br>  <groupId>com.alibaba.boot</groupId><br>  <artifactId>nacos-config-spring-boot-starter</artifactId><br>  <version>0.2.7</version><br></dependency></p><p>nacos:<br>  config:<br>    server-addr: localhost:8848<br>    namespace: 65711e90-5040-467a-8d59-4c3b2050b9c4<br>    data-id: order-service<br>    bootstrap:<br>      enable: true<br>    type: yaml<br>    auto-refresh: true</p><p>//nacos配置中心定义的注解<br>@Configuration<br>@EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = “127.0.0.1:8848”))<br>@NacosPropertySource(dataId = “example”, autoRefreshed = true)<br>public class NacosConfiguration {</p><p>}</p><p>@NacosValue(value = “${useLocalCache:false}”, autoRefreshed = true)<br>private boolean useLocalCache;</p><p>@EnableNacosDiscovery //使用下面的配置可以不用使用注解，springboot自动配置机制<br>//作用：使用nacos进行服务注册和发现。处理@NacosInjected，注入服务。配置项查看相关的properties<br>//注册 ApplicationContextHolder.class,AnnotationNacosInjectedBeanPostProcessor.class NamingServiceBeanBuilder.class,NamingMaintainServiceBeanBuilder.class<br>//@NacosInjected: An annotation to inject {@link ConfigService} or {@link NamingService} instance into the target Bean.<br><dependency><br>  <groupId>com.alibaba.boot</groupId><br>  <artifactId>nacos-discovery-spring-boot-starter</artifactId><br>  <version>0.2.7</version><br></dependency></p><p>//nacos服务发现定义的注解<br>@Configuration<br>@EnableNacosDiscovery(globalProperties = @NacosProperties(serverAddr = “127.0.0.1:8848”))<br>public class NacosConfiguration {</p><p>}<br>@NacosInjected<br>private NamingService namingService;</p><p>//dubbo和nacos的springboot的starter包都依赖这个包，是一个基于spring的扩展基础包。<br><dependency><br>    <groupId>com.alibaba.spring</groupId><br>    <artifactId>spring-context-support</artifactId><br>    <version>[latest version]</version><br></dependency></p><p>spring cloud 原理是：通过spring-cloud-commons定义了一系列的的api，如服务注册、发现,负载均衡，断路器</p><p>cloud nacos NacosDiscoveryProperties中存放NamingService,实现了DiscoveryClient，实现了服务发现。</p><p>//spring-boot properties属性配置，正规配置就应该这样写<br>@ConfigurationProperties(DUBBO_PREFIX)<br>class DubboConfigurationProperties {<br>    @NestedConfigurationProperty<br>    private Config config = new Config();<br>}</p><p>@AutoConfigureAfter(DubboRelaxedBindingAutoConfiguration.class)<br>@EnableConfigurationProperties(DubboConfigurationProperties.class)<br>@Import(ServiceBeanIdConflictProcessor.class)<br>public class DubboAutoConfiguration {</p><p>}</p><p>dubbo-admin这边默认group都是dubbo<br>dubbo metadata的group是dubbo<br>dubbo registry的group是DEFAULT_GROUP<br>dubbo config-contener是dubbo/dubbo.properties</p><p>doSubscribe(url, listener, serviceNames);<br>notifySubscriber(url, listener, instances);<br>subscribeEventListener(serviceName, url, listener);</p><p> scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();<br>            scheduledExecutorService.scheduleAtFixedRate({}，30，30，TimeUnit.SECONDS）</p><h1 id="Dubbo-配置项"><a href="#Dubbo-配置项" class="headerlink" title="Dubbo 配置项"></a>Dubbo 配置项</h1><p>dubbo:</p><h1 id="Spring-Cloud-Alibaba-Dubbo-专属配置"><a href="#Spring-Cloud-Alibaba-Dubbo-专属配置" class="headerlink" title="Spring Cloud Alibaba Dubbo 专属配置"></a>Spring Cloud Alibaba Dubbo 专属配置</h1><p>  cloud:<br>    subscribed-services: ‘’ # 设置订阅的应用列表，默认为 * 订阅所有应用</p><h1 id="Dubbo-提供者的协议"><a href="#Dubbo-提供者的协议" class="headerlink" title="Dubbo 提供者的协议"></a>Dubbo 提供者的协议</h1><p>  protocol:<br>    name: dubbo<br>    port: -1</p><h1 id="Dubbo-提供服务的扫描基础包"><a href="#Dubbo-提供服务的扫描基础包" class="headerlink" title="Dubbo 提供服务的扫描基础包"></a>Dubbo 提供服务的扫描基础包</h1><p>  scan:<br>    base-packages: cn.iocoder.mall.tradeservice.rpc</p><h1 id="Dubbo-服务提供者的配置"><a href="#Dubbo-服务提供者的配置" class="headerlink" title="Dubbo 服务提供者的配置"></a>Dubbo 服务提供者的配置</h1><p>  provider:<br>    filter: -exception<br>    validation: true # 开启 Provider 参数校验<br>    version: 1.0.0 # 服务的版本号</p><h1 id="Dubbo-服务消费者的配置"><a href="#Dubbo-服务消费者的配置" class="headerlink" title="Dubbo 服务消费者的配置"></a>Dubbo 服务消费者的配置</h1><p>  consumer:<br>    ErrorCodeRpc:<br>      version: 1.0.0<br>    ProductSkuRpc:<br>      version: 1.0.0<br>    UserAddressRpc:<br>      version: 1.0.0<br>    PriceRpc:<br>      version: 1.0.0<br>    CouponCardRpc:<br>      version: 1.0.0<br>    PayTransactionRpc:<br>      version: 1.0.0</p><p>grant all on nacos.* to ‘nacos’@’%’ identified by ‘nacos’ with grant option;</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘nacos’@’%’ identified by ‘nacos’ WITH GRANT OPTION;</p><p>grant all privileges on <em>.</em> to ‘nacos’@’localhost’ ;</p><p>bean初始化：<br>doGetBean{}</p><h2 id="Object-sharedInstance-getSingleton-beanName-缓存"><a href="#Object-sharedInstance-getSingleton-beanName-缓存" class="headerlink" title="Object sharedInstance = getSingleton(beanName); //缓存"></a>Object sharedInstance = getSingleton(beanName); //缓存</h2><h2 id="getSingleton-String-beanName-ObjectFactory-lt-gt-singletonFactory-获取对象"><a href="#getSingleton-String-beanName-ObjectFactory-lt-gt-singletonFactory-获取对象" class="headerlink" title="getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) //获取对象"></a>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) //获取对象</h2><p>singletonsCurrentlyInCreation.add(beanName) //1.</p><p>调用ObjectFactory的createBean方法</p><p>二种情况<br>Object bean = resolveBeforeInstantiation(beanName, mbdToUse); 对象直接返回<br>Object beanInstance = doCreateBean(beanName, mbdToUse, args);<br>    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>        this.singletonFactories.put(beanName, singletonFactory); //三级<br>        this.earlySingletonObjects.remove(beanName); //二级<br>        this.registeredSingletons.add(beanName);</p><p>singletonsCurrentlyInCreation.remove(beanName) // 最后<br>this.singletonObjects.put(beanName, singletonObject);<br>this.singletonFactories.remove(beanName);<br>this.earlySingletonObjects.remove(beanName);</p><p>通过三级缓存生成二级缓存。</p><p>springboot 增加Filter<br>方案一：<br>1、 @WebFilter(urlPatterns = “/<em>“) public class MemberFilter implements Filter {}<br>2、 @ServletComponentScan(basePackages = {“com.example.controller.filter”})<br>方案二：<br>@Bean<br>public FilterRegistrationBean filterProxy() {<br>    FilterRegistrationBean registrationBean = new FilterRegistrationBean();<br>    DelegatingFilterProxy httpBasicFilter = new DelegatingFilterProxy();<br>    registrationBean.setFilter(httpBasicFilter);<br>    Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;();<br>    m.put(“targetBeanName”, “memberFilter”);<br>    m.put(“targetFilterLifecycle”, “true”);<br>    registrationBean.setInitParameters(m);<br>    List<String> urlPatterns = new ArrayList<String>();<br>    urlPatterns.add(“/</String></String></em>“);<br>    registrationBean.setUrlPatterns(urlPatterns);<br>    return registrationBean;<br>}</p><p>DelegatingFilterProxyRegistrationBean</p><p>springSecurityFilterChain</p><p>资源服务器<br>@EnableResourceServer -&gt; @Import(ResourceServerConfiguration.class) -&gt;ResourceServerConfiguration extends WebSecurityConfigurerAdapter 类上有@Configuration<br>@EnableResourceServer<br>public class ResourceServerConfig extends ResourceServerConfigurerAdapter{}</p><p>认证服务器逻辑实现<br>@EnableAuthorizationServer-&gt;@Import({AuthorizationServerEndpointsConfiguration.class, AuthorizationServerSecurityConfiguration.class})</p><p>AuthorizationServerEndpointsConfiguration-&gt;@Import(TokenKeyEndpointRegistrar.class)-&gt;注册TokenKeyEndpoint.class<br>AuthorizationServerSecurityConfiguration extends WebSecurityConfigurerAdapter(类上有@Configuration) -&gt;@Import({ ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class })</p><p>ClientDetailsServiceConfiguration -&gt; 配置ClientDetailsServiceConfiguration</p><p>@EnableAuthorizationServer<br>public class AuthorizationConfig extends AuthorizationServerConfigurerAdapter{}</p><p>@EnableOAuth2Client -》@Import(OAuth2ClientConfiguration.class)</p><p>spring-security-oauth2-autoconfigure.jar<br>@EnableOAuth2Sso -&gt;@EnableOAuth2Client  @Import({ OAuth2SsoDefaultConfiguration.class, OAuth2SsoCustomConfiguration.class,<br>    ResourceServerTokenServicesConfiguration.class })</p><p>security:<br>  oauth2:<br>    client:<br>      client-id: sso-server<br>      client-secret: deepblueai@2018<br>      user-authorization-uri: ${sso.auth.server}/oauth/authorize<br>      access-token-uri: ${sso.auth.server}/oauth/token<br>      scope: server<br>    resource:<br>      jwt:<br>        key-value: jwt:token:deepblue</p><p>spring bean注入扩展类<br>BeanDefinitionRegistryPostProcessor</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring的bean加载及生命周期</title>
      <link href="2021/02/07/spring%E7%9A%84bean%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2021/02/07/spring%E7%9A%84bean%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring容器启动"><a href="#Spring容器启动" class="headerlink" title="Spring容器启动"></a>Spring容器启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 会初始化一个BeanFactory,为默认的DefaultListableBeanFactory</span></span><br><span class="line">    <span class="comment">// 会初始化一个beanDefinition的读取器，同时向容器中注册了7个spring的后置处理器(包括BeanPostProcessor和BeanFactoryPostProcessor)</span></span><br><span class="line">    <span class="comment">// 会初始化一个扫描器，后面似乎并没有用到这个扫描器，在refresh()中使用的是重新new的一个扫描器。</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// 将配置类注册进BeanDefinitionMap中</span></span><br><span class="line">    <span class="comment">//将传入的配置类annotatedClasses解析成BeanDefinition(实际类型为AnnotatedGenericBeanDefinition)，然后放入到BeanDefinitionMap中，这样后面在ConfigurationClassPostProcessor中能解析annotatedClasses，例如demo中的AppConfig类，只有解析了AppConfig类，才能知道Spring要扫描哪些包(因为在AppConfig类中添加了@ComponentScan注解)，只有知道要扫描哪些包了，才能扫描出需要交给Spring管理的bean有哪些，这样才能利用Spring来创建bean。</span></span><br><span class="line">    register(annotatedClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring容器刷新"><a href="#spring容器刷新" class="headerlink" title="spring容器刷新"></a>spring容器刷新</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"> <span class="number">2</span>    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"> <span class="number">3</span>        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"> <span class="number">4</span>        <span class="comment">// 初始化属性配置文件、检验必须属性以及监听器</span></span><br><span class="line"> <span class="number">5</span>        prepareRefresh();</span><br><span class="line"> <span class="number">6</span>        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"> <span class="number">7</span>        <span class="comment">// 给beanFactory设置序列化id</span></span><br><span class="line"> <span class="number">8</span>        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"> <span class="number">9</span>        <span class="comment">// 向beanFactory中注册了两个BeanPostProcessor,以及三个和环境相关的bean</span></span><br><span class="line"><span class="number">10</span>        <span class="comment">// 这两个后置处理器为ApplicationContextAwareProcessor和ApplicationListenerDetector</span></span><br><span class="line"><span class="number">11</span>        <span class="comment">// 前一个后置处理是为实现了ApplicationContextAware接口的类，回调setApplicationContext()方法，</span></span><br><span class="line"><span class="number">12</span>        <span class="comment">// 后一个处理器时用来检测ApplicationListener类的，当某个Bean实现了ApplicationListener接口的bean被创建好后，会被加入到监听器列表中</span></span><br><span class="line"><span class="number">13</span>        prepareBeanFactory(beanFactory);</span><br><span class="line"><span class="number">14</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">15</span>            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="number">16</span>            <span class="comment">// 空方法，由子类实现</span></span><br><span class="line"><span class="number">17</span>            postProcessBeanFactory(beanFactory);</span><br><span class="line"><span class="number">18</span>            <span class="comment">// 执行所有的BeanFactoryPostProcessor，包括自定义的，以及spring内置的。默认情况下，容器中只有一个BeanFactoryPostProcessor,即：Spring内置的，ConfigurationClassPostProcessor(这个类很重要)</span></span><br><span class="line"><span class="number">19</span>            <span class="comment">// 会先执行实现了BeanDefinitionRegistryPostProcessor接口的类，然后执行BeanFactoryPostProcessor的类</span></span><br><span class="line"><span class="number">20</span>            <span class="comment">// ConfigurationClassPostProcessor类的postProcessBeanFactory()方法进行了@Configuration类的解析，@ComponentScan的扫描，以及@Import注解的处理</span></span><br><span class="line"><span class="number">21</span>            <span class="comment">// 经过这一步以后,会将所有交由spring管理的bean所对应的BeanDefinition放入到beanFactory的beanDefinitionMap中</span></span><br><span class="line"><span class="number">22</span>            <span class="comment">// 同时ConfigurationClassPostProcessor类的postProcessBeanFactory()方法执行完后，向容器中添加了一个后置处理器————ImportAwareBeanPostProcessor</span></span><br><span class="line"><span class="number">23</span>            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"><span class="number">24</span>            <span class="comment">// 注册所有的BeanPostProcessor，因为在方法里面调用了getBean()方法，所以在这一步，实际上已经将所有的BeanPostProcessor实例化了</span></span><br><span class="line"><span class="number">25</span>            <span class="comment">// 为什么要在这一步就将BeanPostProcessor实例化呢？因为后面要实例化bean，而BeanPostProcessor是用来干预bean的创建过程的，所以必须在bean实例化之前就实例化所有的BeanPostProcessor(包括开发人员自己定义的)</span></span><br><span class="line"><span class="number">26</span>            <span class="comment">// 最后再重新注册了ApplicationListenerDetector，这样做的目的是为了将ApplicationListenerDetector放入到后置处理器的最末端</span></span><br><span class="line"><span class="number">27</span>            registerBeanPostProcessors(beanFactory);</span><br><span class="line"><span class="number">28</span>            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="number">29</span>           <span class="comment">// 初始化MessageSource，用来做消息国际化。在一般项目中不会用到消息国际化</span></span><br><span class="line"><span class="number">30</span>            initMessageSource();</span><br><span class="line"><span class="number">31</span>            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="number">32</span>            <span class="comment">// 初始化事件广播器，如果容器中存在了名字为applicationEventMulticaster的广播器，则使用该广播器</span></span><br><span class="line"><span class="number">33</span>            <span class="comment">// 如果没有，则初始化一个SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="number">34</span>            <span class="comment">// 事件广播器的用途是，发布事件，并且为所发布的时间找到对应的事件监听器。</span></span><br><span class="line"><span class="number">35</span>            initApplicationEventMulticaster();</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">37</span>            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="number">38</span>            <span class="comment">// 执行其他的初始化操作，例如和SpringMVC整合时，需要初始化一些其他的bean，但是对于纯spring工程来说，onFresh方法是一个空方法</span></span><br><span class="line"><span class="number">39</span>            onRefresh();</span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">41</span>            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="number">42</span>            <span class="comment">// 这一步会将自定义的listener的bean名称放入到事件广播器中</span></span><br><span class="line"><span class="number">43</span>            <span class="comment">// 同时还会将早期的ApplicationEvent发布(对于单独的spring工程来说，在此时不会有任何ApplicationEvent发布，但是和springMVC整合时，springMVC会执行onRefresh()方法，在这里会发布事件)</span></span><br><span class="line"><span class="number">44</span>            registerListeners();</span><br><span class="line"><span class="number">45</span>            <span class="comment">// 实例化剩余的非懒加载的单例bean(注意：剩余、非懒加载、单例)</span></span><br><span class="line"><span class="number">46</span>            <span class="comment">// 为什么说是剩余呢？如果开发人员自定义了BeanPosrProcessor，而BeanPostProcessor在前面已经实例化了，所以在这里不会再实例化，因此这里使用剩余一词</span></span><br><span class="line"><span class="number">47</span>            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"><span class="number">48</span>            <span class="comment">// 结束refresh，主要干了一件事，就是发布一个事件ContextRefreshEvent，通知大家spring容器refresh结束了。</span></span><br><span class="line"><span class="number">49</span>            finishRefresh();</span><br><span class="line"><span class="number">50</span>        &#125;</span><br><span class="line"><span class="number">51</span>        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="number">52</span>            <span class="comment">// 出异常后销毁bean</span></span><br><span class="line"><span class="number">53</span>            destroyBeans();</span><br><span class="line"><span class="number">54</span>            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line"><span class="number">55</span>            cancelRefresh(ex);</span><br><span class="line"><span class="number">56</span>            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="number">57</span>            <span class="keyword">throw</span> ex;</span><br><span class="line"><span class="number">58</span>        &#125;</span><br><span class="line"><span class="number">59</span>        <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="number">60</span>           <span class="comment">// 在bean的实例化过程中，会缓存很多信息，例如bean的注解信息，但是当单例bean实例化完成后，这些缓存信息已经不会再使用了，所以可以释放这些内存资源了</span></span><br><span class="line"><span class="number">61</span>            resetCommonCaches();</span><br><span class="line"><span class="number">62</span>        &#125;</span><br><span class="line"><span class="number">63</span>    &#125;</span><br><span class="line"><span class="number">64</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.beanName先从map中获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">//2.判断beanName是否在singletonsCurrentlyInCreation中</span></span><br><span class="line"><span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"><span class="comment">//3.如果存在singletonsCurrentlyInCreation中，则从earlySingletonObjects中获取，</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//4. 如果为空，从singletonFactories中获取ObjectFactory，如果singletonFactory不为空，获取bean</span></span><br><span class="line"><span class="comment">// 存入earlySingletonObjects中，删除singletonFactories中的beanName</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/q6zs7xRjpcB4YxLw6w477w">Spring源码系列之容器启动流程</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Mjg2NjUzNw==&mid=2247483679&idx=1&sn=03a08c6844397a6d2610d89577eb8558&scene=21#wechat_redirect">看Bean的创建过程</a></p><p><a href="https://www.cnblogs.com/duanxz/p/3787884.html">spring加载及刷新容器流程</a></p><p><a href="https://blog.csdn.net/finalcola/article/details/81449140">spring创建bean流程</a></p><hr><h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法，再执行BeanFactoryPostProcessor的postProcessBeanFactory方法</p><h2 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a><font color="red">ConfigurationClassPostProcessor</font></h2><ul><li>(1) @Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？</li><li>(2) Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？</li><li>(3) Spring什么时候解析了@Import注解，如何解析的？</li><li>(4) Spring什么时候解析了@Bean注解？</li></ul><p><a href="https://blog.csdn.net/qq_34436819/article/details/100944204">ConfigurationClassPostProcessor详解</a></p><hr><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><h2 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h2><h2 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h2><h2 id="InstantiationAwareBeanPostProcessorAdapter"><a href="#InstantiationAwareBeanPostProcessorAdapter" class="headerlink" title="InstantiationAwareBeanPostProcessorAdapter"></a>InstantiationAwareBeanPostProcessorAdapter</h2><h2 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a><font color="red">AutowiredAnnotationBeanPostProcessor</font></h2><p>bean的后置处理器用来处理@Autowired的注入</p><h2 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a><font color="red">CommonAnnotationBeanPostProcessor</font></h2><p>用来处理如@Resource，@PostConstruct等符合JSR-250规范的注解</p><h2 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a><font color="red">RequiredAnnotationBeanPostProcessor</font></h2><h2 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a><font color="red">PersistenceAnnotationBeanPostProcessor</font></h2><p>用来支持JPA</p><h2 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a><font color="red">EventListenerMethodProcessor</font></h2><p>注册EventListenerMethodProcessor，用来处理方法上加了@EventListener注解的方法</p><h2 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a><font color="red">DefaultEventListenerFactory</font></h2><p>事件监听器的工厂</p><hr><h2 id="SmartInitializingSingleton"><a href="#SmartInitializingSingleton" class="headerlink" title="SmartInitializingSingleton"></a>SmartInitializingSingleton</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现SmartInitializingSingleton的接口后，当所有单例 bean 都初始化完成以后， Spring的IOC容器会回调该接口的afterSingletonsInstantiated()方法。主要应用场合就是在所有单例 bean 创建完成之后，可以在该回调中做一些事情。</p><hr><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><a href="https://blog.csdn.net/f641385712/article/details/88904983">Spring AOP详解</a></p><p><a href="https://blog.csdn.net/f641385712/article/details/89303088">SpringAOP引入增强</a></p><p><a href="https://blog.csdn.net/chuzunyuan9004/article/details/100984276">spring aop</a></p><h3 id="切面编程之spring的AOP和AspectJ的区别"><a href="#切面编程之spring的AOP和AspectJ的区别" class="headerlink" title="切面编程之spring的AOP和AspectJ的区别"></a>切面编程之spring的AOP和AspectJ的区别</h3><p>①选择spring的AOP还是AspectJ?<br>spring确实有自己的AOP。功能已经基本够用了，除非你的要在接口上动态代理或者方法拦截精确到getter和setter。这些都是写奇葩的需求，一般不使用。<br>②在使用AOP的时候，你是用xml还是注解的方式（@Aspect）？<br>1）如果使用xml方式，不需要任何额外的jar包。<br>2）如果使用@Aspect方式，你就可以在类上直接一个@Aspect就搞定，不用费事在xml里配了。但是这需要额外的jar包（ aspectjweaver.jar）。因为<font color="red">spring直接使用AspectJ的注解功能，注意只是使用了它 的注解功能而已。并不是核心功能 ！！！</font><br>注意到文档上还有一句很有意思的话：文档说到是选择spring AOP还是使用full aspectJ？<br>什么是full aspectJ？如果你使用”full aspectJ”。就是说你可以实现基于接口的动态代理，等强大的功能。而不仅仅是aspectj的注解功能 。<br>如果用full AspectJ。比如说Load-Time Weaving的方式 还 需要额外的jar包 spring-instrument.jar<br>当然，无论是使用spring aop还是 aspectj都需要aspectjweaver.jar spring-aop.jar这两个jar包</p><p>spring有自己的AOP实现与aspectj的实现不同比较麻烦，马士兵的教程所讲的是spring整合了aspectj的AOP马士兵没有将spring自己的aop，在视频的末尾他说一般情况用不到spring自己的AOP你可以仔细听听，spring在做声明式事物处理时就没有用aspectj嘛！springAOP是设计用于在应用服务器环境下实现AOP，切入点与方面均由普通Java对象实现，其中连接点模型与AspectJ相同，只是远不如AspectJ丰富。针对你的问题spring有两组AOP一组是spring本身的一组是整合AspectJ，就好比在国际上一个中国人说英语是因为大家都说英语（好比AspectJ），但中国人还有自己的语言中文（spring自己的AOP）</p><h3 id="AOP植入方式"><a href="#AOP植入方式" class="headerlink" title="AOP植入方式"></a>AOP植入方式</h3><p>AOP有三种植入切面的方法：其一是编译期织入，这要求使用特殊的Java编译器，AspectJ是其中的代表者；其二是类装载期织入，而这要求使用特殊的类装载器，AspectJ和AspectWerkz是其中的代表者；其三为动态代理织入，在运行期为目标类添加增强生成子类的方式，Spring AOP采用动态代理织入切面。<br>Spring AOP使用了两种代理机制，一种是基于JDK的动态代理，另一种是基于CGLib的动态代理，之所以需要两种代理机制，很大程度上是因为JDK本身只提供基于接口的代理，不支持类的代理。</p><h3 id="Aop实战"><a href="#Aop实战" class="headerlink" title="Aop实战"></a>Aop实战</h3><p><a href="https://blog.csdn.net/flyfeifei66/article/details/82784321">Spring提供了四种类型的Aop支持 </a></p><h3 id="AOP通知"><a href="#AOP通知" class="headerlink" title="AOP通知"></a>AOP通知</h3><p>前置通知：org.springframework.aop.MethodBeforeAdvice<br>后置通知：org.springframework.aop.AfterReturningAdvice<br>环绕通知：org.aopalliance.intercept.MethodInterceptor<br>异常通知：org.springframework.aop.ThrowsAdvice</p><p>[<a href="https://www.cnblogs.com/chaoesha/p/13037368.html">面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？</a></p><p><img src="/2021/02/07/spring%E7%9A%84bean%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20160113113029764" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性占位符工具类</span></span><br><span class="line">PropertyPlaceholderHelper</span><br><span class="line"><span class="comment">//资源工具类</span></span><br><span class="line">ResourceUtils</span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line">AnnotationAttributes extends LinkedHashMap&lt;String, Object&gt;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">ClassUtils</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">WebApplicationContextUtils</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">AnnotatedElementUtils</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">AnnotationUtils</span><br></pre></td></tr></table></figure><h2 id="使用-ControllerAdvice如何返回给前端对应错误码"><a href="#使用-ControllerAdvice如何返回给前端对应错误码" class="headerlink" title="使用@ControllerAdvice如何返回给前端对应错误码"></a>使用@ControllerAdvice如何返回给前端对应错误码</h2><p>@ControllerAdvice可以捕获spring应用下面未被捕获异常，下面是常见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">errorHandler</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">    ApiResultVo&lt;String&gt; resultVo = <span class="keyword">new</span> ApiResultVo&lt;&gt;();</span><br><span class="line">    resultVo.setErrorCode(<span class="number">500</span>);</span><br><span class="line">    resultVo.setErrorMsg(ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> JSON.toJSONString(resultVo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(value = MyException.class)</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">myExceptionHandler</span><span class="params">(MyException ex)</span> </span>&#123;</span><br><span class="line">    ApiResultVo&lt;String&gt; resultVo = <span class="keyword">new</span> ApiResultVo&lt;&gt;();</span><br><span class="line">    resultVo.setErrorCode(<span class="number">401</span>);</span><br><span class="line">    resultVo.setErrorMsg(ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> JSON.toJSONString(resultVo);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>我们在对应异常处理的上面加上<font color="red">ResponseStatus</font>注解就能将系统异常转换为对应的Http状态码，这部分工作由<font color="red">ResponseStatusExceptionResolver</font>这个类完成，下面是关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">doResolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">    ResponseStatus responseStatus = AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);</span><br><span class="line">    <span class="keyword">if</span> (responseStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> resolveResponseStatus(responseStatus, request, response, handler, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception resolveEx) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Handling of @ResponseStatus resulted in Exception&quot;</span>, resolveEx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ex.getCause() <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">        ex = (Exception) ex.getCause();</span><br><span class="line">        <span class="keyword">return</span> doResolveException(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">resolveResponseStatus</span><span class="params">(ResponseStatus responseStatus, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> statusCode = responseStatus.code().value();</span><br><span class="line">    String reason = responseStatus.reason();</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(reason)) &#123;</span><br><span class="line">        response.sendError(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        String resolvedReason = (<span class="keyword">this</span>.messageSource != <span class="keyword">null</span> ?</span><br><span class="line">                                 <span class="keyword">this</span>.messageSource.getMessage(reason, <span class="keyword">null</span>, reason, LocaleContextHolder.getLocale()) :</span><br><span class="line">                                 reason);</span><br><span class="line">        response.sendError(statusCode, resolvedReason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring学习笔记</title>
      <link href="2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="对象bean实例化"><a href="#对象bean实例化" class="headerlink" title="对象bean实例化"></a>对象bean实例化</h2><ul><li>构造函数对象实例化</li><li>静态工厂方法实例化</li><li>工厂方法实例化</li></ul><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><ul><li>带参构造函数对象实例化注入属性</li><li>set方法</li><li>注解注入</li><li>ref标签<br>普通属性注入</li><li>property标签</li><li>配置PropertyPlaceholderConfigurer</li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>标签配置depends-on</li><li>注解@DependsOn</li></ul><h2 id="延迟加载-阻止预初始化"><a href="#延迟加载-阻止预初始化" class="headerlink" title="延迟加载(阻止预初始化)"></a>延迟加载(阻止预初始化)</h2><ul><li>标签配置lazy-init=true</li><li>对容器层次default-lazy-init=true</li></ul><h2 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h2><p>如单例对象中需要注入原型对象，如果直接依赖注入，会导致注入的是单例对象，因为只会注入一次</p><ul><li>可以使用ApplicationContextAware,通过applicationContext属性获取bean，即使用getBean方法</li><li>标签配置lookup-method，指定方法name，指定使用的类。或者使用注解@Lookup。使用的是CGLIB库的方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果</li><li>标签配置replaced-method,需要继承MethodReplacer，也是使用的是CGLIB库的方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果</li></ul><h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><ul><li>sigleton</li><li>prototype</li><li>request</li><li>session</li><li>application</li><li>websockct</li></ul><p>后面四个，如果不使用springmvc则需要进行配置，Servlet2.5需要注册RequestContextListener或者ServletRequestListener或者RequestContextFilter。<br>都是绑定请求对象到服务请求的Thread上，才使得bean在之后的调用链上可见。Servlet3.0之后，这些都能够通过WebApplicationInitializer接口实现</p><h3 id="自定义scope"><a href="#自定义scope" class="headerlink" title="自定义scope"></a>自定义scope</h3><p>1、实现Scope接口，重写get和remove方法<br>2、配置CustomScopeConfurer</p><h2 id="自定义Bean的生命周期"><a href="#自定义Bean的生命周期" class="headerlink" title="自定义Bean的生命周期"></a>自定义Bean的生命周期</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行顺序为先注解-》接口实现-》自定义的方法</p><ul><li><p>InitializeingBean（afterPropertiesSet()） </p></li><li><p>@PostConstruct</p></li><li><p>DisposableBean（destroy()）</p></li><li><p>@PreDestroy</p></li><li><p>init-method</p></li><li><p>destroy-method</p></li></ul><p>Bean后置处理器<br>后置处理器包含二个方法，初始化之前的方法和初始化之后的方法</p><ul><li>接口==BeanPostProcessor==</li></ul><h3 id="生命周期接口"><a href="#生命周期接口" class="headerlink" title="生命周期接口"></a>生命周期接口</h3><p>接口==Lifecycle==，为任何有自己生命周期需求的对象定义了一些基本的方法（如停止和启动一些后台进程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>; <span class="comment">//开始</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口==LifecycleProcessor==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;  <span class="comment">//刷新</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;    <span class="comment">//关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类==DefaultLifecycleProcessor==会等到配置的时间超时再调用回调。默认每阶段的时间是30s，可以通过timeoutPerShutdownPhase修改超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultLifecycleProcessor</span> <span class="keyword">implements</span> <span class="title">LifecycleProcessor</span>, <span class="title">BeanFactoryAware</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动关闭顺序"><a href="#启动关闭顺序" class="headerlink" title="启动关闭顺序"></a>启动关闭顺序</h3><ul><li>==Phased==(getPhased) 定义了执行的顺序。Bean直接存在depends-on的关系，被依赖的一方要更早的启动，关闭的更早。然而有时候直接的依赖是未知的，而开发者仅仅知道哪一种类型更早的进行初始化，就可以实现Phased接口</li><li>接口==SmartLifecycle== extends Lifecycle,Phased(提供了isAutoStartup,stop(Runnable callback)方法)</li><li>当启动时，拥有最低phased的对象优先启动，当关闭时，相反。未实现Phased和SmartLifecycle接口的对象，phased默认值为0</li><li>SmartLifecycle 中的stop方法，回调函数，在关闭流程完成之后调用回调中的run()方法，可以做到异步关闭</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">        callback.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优雅关闭spring的ioc容器"><a href="#优雅关闭spring的ioc容器" class="headerlink" title="优雅关闭spring的ioc容器"></a>优雅关闭spring的ioc容器</h3><p>ConfigurableApplicationContext调用registerShutdownHook()；</p><h3 id="aware接口"><a href="#aware接口" class="headerlink" title="aware接口"></a>aware接口</h3><p>aware接口的方法回调发生在属性配置完成之后，初始化回调之前，后置处理器之前</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210119112030740-1612677917089.png" alt="image-20210119112030740"></p><h2 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h2><p>父子Bean，子Bean可以继承父Bean的元数据配置，父类可以是抽象类，使用abstract=”true”标识。</p><p>ChildBeanDefinition</p><h2 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h2><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>可以配置多个BeanPostProcessor，通过order属性控制执行顺序，实现Ordered接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>操作Bean的配置元数据，即读取配置元数据，bean实例化之前修改它，也是可以配置多个，通过order控制执行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>是Spring IoC容器实例化逻辑的可插拔点。如果开发者的初始化代码很复杂，相当于需要写很多的xml信息，可以使用java语言来表达。可以创建自己的FactoryBean，在类中编写复杂的初始化代码，然后将自定义的FactoryBean插入容器中。</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120100739444-1612677926892.png" alt="image-20210120100739444"></p><p>如果需要返回的是FactoryBean对象，则使用getBean(“&amp;myBean”)，如果获取FactoryBean生成的对象，则使用getBean(“myBean”)</p><h2 id="扩展点实战"><a href="#扩展点实战" class="headerlink" title="扩展点实战"></a>扩展点实战</h2><h3 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h3><p>底层是继承抽象类PlaceholderConfigurerSupport，抽象类继承抽象类PropertyResourceConfigurer，抽象类继承PropertiesLoaderSupport和实现了BeanFactoryPostProcessor接口，完成了读取配置文件，替换占位符${}。</p><p>以前在xml中配置jdbc.properties，或者在xml中使用&lt;conetext:property-placeholder location=”classpath:jdbc.properties”&gt;</p><h3 id="PropertyOverrideConfigurer"><a href="#PropertyOverrideConfigurer" class="headerlink" title="PropertyOverrideConfigurer"></a>PropertyOverrideConfigurer</h3><p>底层是继承抽象类PropertyResourceConfigurer,属性覆盖。</p><h2 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h2><ul><li>@Required</li><li>@Autowired</li><li>JSR-250注解支持：@Resource、@PostConstruct、@PreDestroy、@ManagedBean可以替代@Component</li><li>JSR-330注解支持：@Inject可以代替@Autowired、@Qualifier、@Named可以替代@Component、@Provider</li><li>@Primary,指定一个优先提供的特殊bean。当存在多个bean时，使用是未指定特定的bean，会使用注解标识的bean</li></ul><p>CommonAnnotationBeanPostProcessor不但能识别@Resource注解，而且能识别JSR-250生命周期注解</p><h2 id="类路径扫描及组件管理"><a href="#类路径扫描及组件管理" class="headerlink" title="类路径扫描及组件管理"></a>类路径扫描及组件管理</h2><p>通过扫描类路径的方式来隐式检测候选组件的方式。候选组件是匹配过滤条件的类库。</p><ul><li>@Configuration @Bean  @Import  @DependsOn @ImportSource</li><li>@Repository @Component @Service @Controller</li><li>元注解如@RestController</li><li>@ControllerAdvice</li><li>@ComponentScan</li></ul><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120111448978-1612677932522.png" alt="image-20210120111448978"></p><h2 id="基于java的容器配置"><a href="#基于java的容器配置" class="headerlink" title="基于java的容器配置"></a>基于java的容器配置</h2><h3 id="AnnotationConfigApplicationContext指定加载的配置类"><a href="#AnnotationConfigApplicationContext指定加载的配置类" class="headerlink" title="AnnotationConfigApplicationContext指定加载的配置类"></a>AnnotationConfigApplicationContext指定加载的配置类</h3><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120112308757-1612677934627.png" alt="image-20210120112308757"></p><h3 id="使用编程式构建容器"><a href="#使用编程式构建容器" class="headerlink" title="使用编程式构建容器"></a>使用编程式构建容器</h3><p>AnnotationConfigApplicationContext对象有注册bean的方法</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120112510068-1612677936569.png" alt="image-20210120112510068"></p><h3 id="使用scan开启组件扫描"><a href="#使用scan开启组件扫描" class="headerlink" title="使用scan开启组件扫描"></a>使用scan开启组件扫描</h3><p>@ComponentScan(basePackages=”com.hufei”)或在xml中配置&lt;context:component-scan base-package=”com.hufei”&gt;</p><p>或者在ctx中使用scan方法，需要refresh方法，刷新容器</p><h2 id="环境抽象"><a href="#环境抽象" class="headerlink" title="环境抽象"></a>环境抽象</h2><p>Environment是一个集成到容器中的特殊抽象，它针对应用的环境建立了profile和properties二个关键的概念。</p><p>@Profile(“dev”) 表示对应dev环境下，配置才会生效。可以通过指定配置文件spring.profiles.active属性指定环境，也可以通过ctx.getEnvironment().setActiveProfiles(“dev”)，再刷新容器。@Profile(“default”)如果未指定，则使用此默认。</p><p>@PropertySource将PropertySource增加到Spring的Environment中。@PropertySource(“classpath:app.properties”)。路径还可以使用占位符。@PropertySource(“classpath:/com/${my.placeholder:default/path}/app.properties”)</p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120114552069-1612677939086.png" alt="image-20210120114552069"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalMessageSource</span> <span class="keyword">extends</span> <span class="title">MessageSource</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingMessageSource</span> <span class="keyword">extends</span> <span class="title">MessageSourceSupport</span> <span class="keyword">implements</span> <span class="title">HierarchicalMessageSource</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMessageSource</span> <span class="keyword">extends</span> <span class="title">MessageSourceSupport</span> <span class="keyword">implements</span> <span class="title">HierarchicalMessageSource</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResourceBasedMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractMessageSource</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBundleMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractResourceBasedMessageSource</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReloadableResourceBundleMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractResourceBasedMessageSource</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractMessageSource</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="事件监听-观察者模式"><a href="#事件监听-观察者模式" class="headerlink" title="事件监听(观察者模式)"></a>事件监听(观察者模式)</h2><p>ApplicationEvent</p><p>ApplicationListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleApplicationEventMulticaster</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationEventMulticaster</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationEventMulticaster</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ApplicationEventMulticaster</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120160456974-1612677942764.png" alt="image-20210120160456974"></p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><ul><li>事件类A实现ApplicationEvent接口</li><li>发布事件类B，实现ApplicationEventPublisherAware接口，重写setApplicationEventPublisher方法，注入事件发布对象，发布事件</li><li>配置事件监听类C，实现ApplicationListener，重写onApplicationEvent方法</li></ul><h3 id="注解自定义事件"><a href="#注解自定义事件" class="headerlink" title="注解自定义事件"></a>注解自定义事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener(&#123;xxxEvent.class,xxxEvent.class&#125;)</span> <span class="comment">//事件监听</span></span><br><span class="line"><span class="meta">@Async</span> <span class="comment">//异步处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(xxEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120162529783-1612677945009.png" alt="image-20210120162529783"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120162546973-1612677946793.png" alt="image-20210120162546973"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120162618110-1612677948850.png" alt="image-20210120162618110"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用spring-aop</span></span><br><span class="line"><span class="comment">// 注册bean的名称为:org.springframework.aop.config.internalAutoProxyCreator</span></span><br><span class="line">InfrastructureAdvisorAutoProxyCreator.class</span><br><span class="line">APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用AspectJ</span></span><br><span class="line">AnnotationAwareAspectJAutoProxyCreator</span><br></pre></td></tr></table></figure><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><ul><li><p>Advice 通知                                          会被DefaultPointcutAdvisor包装</p></li><li><p>Interceptor extends Advice  拦截器     会被DefaultPointcutAdvisor包装   </p></li><li><p>MethodInterceptor extends Interceptor   方法拦截器     MethodInterceptor会被DefaultPointcutAdvisor包装</p></li><li><p>Advisor 增强器  Advice getAdvice();获取增强  </p></li><li><p>PointcutAdvisor extends Advisor   带切入点的增强器 public Pointcut getPointcut() ; 获取切入点</p></li><li><p>ProxyFactory extends ProxyCreatorSupport extends AdvisedSupport  extends ProxyConfig implements Advised</p></li><li><p>GlobalAdvisorAdapterRegistry有实例：DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry</p></li><li><p>MethodBeforeAdviceAdapter 、AfterReturningAdviceAdapter 、 ThrowsAdviceAdapter 继承AdvisorAdapter，会适配Advice</p></li><li><p>MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice</p></li><li><p>AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice</p></li><li><p>ThrowsAdviceInterceptor implements MethodInterceptor, AfterAdvice</p></li><li><p>ProxyFactoryBean   </p></li><li><p>AbstractAutoProxyCreator extends ProxyProcessorSupport extends ProxyConfig implements Ordered, BeanClassLoaderAware, AopInfrastructureBean</p></li><li><p>DefaultAopProxyFactory implements AopProxyFactory</p></li><li><p>JdkDynamicAopProxy implements AopProxy, InvocationHandler</p></li><li><p>ObjenesisCglibAopProxy</p></li><li><pre><code class="java">List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);//AdvisedSupport中     AdvisorChainFactory advisorChainFactory = new DefaultAdvisorChainFactory();this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);//通过这个类获取到MethodInterceptor实例返回的是封装的InterceptorAndDynamicMethodMatcher实例，存入ConcurrentHashMapAdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 引入增强</span><br><span class="line"></span><br><span class="line">Introduction可以在不改动目标类定义的情况下，为目标类增加新的属性和行为。**&#96;一个Java类，没有实现A接口，在不修改Java类的情况下，使其具备A接口的功能。&#96;**&lt;font color&#x3D;&#39;red&#39;&gt;只能应用于类级别的拦截&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">[AOP引入增强详解及AOP增强类](https:&#x2F;&#x2F;blog.csdn.net&#x2F;f641385712&#x2F;article&#x2F;details&#x2F;89303088)</span><br><span class="line"></span><br><span class="line">## 资源处理</span><br><span class="line"></span><br><span class="line">Java的标准java.net.URL类和各种URL前缀的标准处理程序并不足以满足所有对低级资源的访问。例如，没有标准化的URL实现可用于访问需要从类路径获取的资源，或相对于ServletContext的资源。Spring的Resource接口就是为了弥补不足。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public interface InputStreamSource &#123;</span><br><span class="line">InputStream getInputStream() throws IOException;</span><br><span class="line">&#125;</span><br><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line">    &#x2F;&#x2F;以下方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210122114124625-1612677954183.png" alt="image-20210122114124625"></p><h3 id="内置资源实现"><a href="#内置资源实现" class="headerlink" title="内置资源实现"></a>内置资源实现</h3><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210122114705114-1612677957074.png" alt="image-20210122114705114"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210122114724545-1612677958891.png" alt="image-20210122114724545"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210122114741609-1612677961146.png" alt="image-20210122114741609"></p><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext实现了ResourceLoader，通过ClassPathXmlApplicationContext获取的是ClassPathResource，通过FileSystemXmlApplicationContext获取的是FileSystemResource，对于WebApplicationContext，获取到的是ServletContextResource。</p><p>也可以指定获取的Resource对象</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125110027705-1612677962996.png" alt="image-20210125110027705"></p><h3 id="ResourceLoaderAware"><a href="#ResourceLoaderAware" class="headerlink" title="ResourceLoaderAware"></a>ResourceLoaderAware</h3><p>用于标识期望通过ResourceLoader接口提供的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="资源依赖"><a href="#资源依赖" class="headerlink" title="资源依赖"></a>资源依赖</h3><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125111409585-1612677965203.png" alt="image-20210125111409585"></p><h2 id="Bean验证"><a href="#Bean验证" class="headerlink" title="Bean验证"></a>Bean验证</h2><ul><li>支持Bean Validation 1.0 （JSR-303）</li><li>Bean Validation 1.1(JSR-349)</li><li>Spring Validation</li></ul><p>Spring应用程序可以选择全局启用Bean验证，并专门用于所有验证需求。应用程序还可以为每个DataBinder实例注册额外的Spring Validation实例，这对于插入验证逻辑而不使用注解的情况可能是有用的。</p><h3 id="Validator接口"><a href="#Validator接口" class="headerlink" title="Validator接口"></a>Validator接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"><span class="comment">//验证这个验证器是否支持所提供的类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">    <span class="comment">//验证给定的对象，并在验证出错误的情况下，将错误信息注册到给定的错误对象</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ValidationUtils.rejectIfEmpty(e,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;name empty&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h2><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125133527744-1612677968272.png" alt="image-20210125133527744"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpelExpressionParser</span><br><span class="line">SpelExpression</span><br></pre></td></tr></table></figure><h2 id="数据缓冲器和编解码器"><a href="#数据缓冲器和编解码器" class="headerlink" title="数据缓冲器和编解码器"></a>数据缓冲器和编解码器</h2><p>Spring数据缓冲器和编解码器用于处理网络传输过程中的数据解析。</p><h3 id="数据缓冲器"><a href="#数据缓冲器" class="headerlink" title="数据缓冲器"></a>数据缓冲器</h3><p>DataBuffer接口定义了一个字节缓冲区的抽象。引入的原因是Netty。Netty并不使用标准的java.nio.ByteBuffer，而是提供ByteBuf作为代替。Spring的DataBuffer是ByteBuf的一个简单的抽象，也可以在非Netty平台（Servlet3.1+）上使用。</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125150404283-1612677970417.png" alt="image-20210125150404283"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125150426114-1612677973730.png" alt="image-20210125150426114"></p><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125150645445-1612677976389.png" alt="image-20210125150645445"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125150653993-1612677977889.png" alt="image-20210125150653993"></p><p>springboot 自动装配（@EnableAutoConfiguration或@SpringBootApplication）</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控之自定义trace拦截</title>
      <link href="2021/02/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89trace%E6%8B%A6%E6%88%AA/"/>
      <url>2021/02/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89trace%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<p>想要跟踪请求，第一个想到的就是当请求来时生成一个traceId放在ThreadLocal里，然后打印时去取就行了。但在不改动原有输出语句的前提下自然需要日志框架的支持了，搜索的一番发现主流日志框架都提供了MDC功能。</p><p>MDC 介绍<br>MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。MDC 可以看成是一个与当前线程绑定的Map，可以往其中添加键值对。MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p><p>简而言之，MDC就是日志框架提供的一个InheritableThreadLocal，项目代码中可以将键值对放入其中，然后使用指定方式取出打印即可。</p><p>简单总结一下主要思路：</p><p>当请求来的时候，用Filter拦截，主要初始化请求的上下文，包括MDC，配置文件中打印MDC中的traceId和spanId。<br>微服务之间调用时，服务调用方需要传递当前的上线文，这个时候解析上下文，spanId自增。以下例子使用的是自定义映射上下文和MDC,只使用MDC就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTEXT_KEY = <span class="string">&quot;CONTEXT_KEY&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SPAN = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次请求唯一记录值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String traceId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一次请求的多次处理唯一标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String spanId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求ip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;ProjectContext&gt; LOCAL = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProjectContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProjectContext context = LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(context)) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> ProjectContext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nextSpan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(getContext())) &#123;</span><br><span class="line">            initContext();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(getContext().getSpanId())) &#123;</span><br><span class="line">            getContext().setSpanId(DEFAULT_SPAN);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的spanId</span></span><br><span class="line">        String span = getContext().getSpanId();</span><br><span class="line">        <span class="keyword">if</span> (span.endsWith(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            span = span.substring(<span class="number">0</span>, span.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到切割位置</span></span><br><span class="line">        <span class="keyword">int</span> p = span.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        String last = span.substring(p + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 最后需要自增的原数据</span></span><br><span class="line">        <span class="keyword">int</span> lastId = Integer.parseInt(last);</span><br><span class="line">        <span class="comment">// 完成自增并设置设置到spanId中</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            getContext().setSpanId(String.valueOf(lastId + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getContext().setSpanId(span.substring(<span class="number">0</span>, p) + (lastId + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 透传上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> contextString 被序列化的上下文字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fromString</span><span class="params">(String contextString)</span> </span>&#123;</span><br><span class="line">        ProjectContext context = GsonUtil.toBean(contextString, ProjectContext.class);</span><br><span class="line"></span><br><span class="line">        fromContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fromContext</span><span class="params">(ProjectContext context)</span> </span>&#123;</span><br><span class="line">        LOCAL.set(context);</span><br><span class="line">        nextSpan();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(ProjectContext context)</span> </span>&#123;</span><br><span class="line">        LOCAL.set(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initContext</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        initContext();</span><br><span class="line"></span><br><span class="line">        ProjectContext context = getContext();</span><br><span class="line"></span><br><span class="line">        context.setIp(ip);</span><br><span class="line"></span><br><span class="line">        setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProjectContext context = <span class="keyword">new</span> ProjectContext();</span><br><span class="line">        context.setTraceId(String.valueOf(genLogId()));</span><br><span class="line">        context.setSpanId(DEFAULT_SPAN);</span><br><span class="line"></span><br><span class="line">        setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">genLogId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(((System.currentTimeMillis() % <span class="number">86400000L</span>) + RANDOM.nextDouble()) * <span class="number">100000.0D</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GsonUtil.toJson(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;requestWrapperFilter&quot;, urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRACE_ID = <span class="string">&quot;trace&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPAN_ID = <span class="string">&quot;span&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化请求链路信息：唯一key，日志初始化，body包装防止获取日志打印时后续不能继续使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String contextString = ((HttpServletRequest) request).getHeader(ProjectContext.CONTEXT_KEY);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(contextString)) &#123;</span><br><span class="line">            ProjectContext.fromString(contextString);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无内容时，也自动初始化</span></span><br><span class="line">            ProjectContext.initContext();</span><br><span class="line">        &#125;</span><br><span class="line">        initLog();</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MDC.put(TRACE_ID, ProjectContext.getContext().getTraceId());</span><br><span class="line">        MDC.put(SPAN_ID, ProjectContext.getContext().getSpanId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProjectContext projectContext = ProjectContext.getContext();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(projectContext)) &#123;</span><br><span class="line">                requestTemplate.header(CONTEXT_KEY, projectContext.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过改变默认logging.pattern.level=%5p，增加需要打印的字段，例： logger.pattern.level=%5p [${traceId:-}],输出的日志中会输出traceId字段的值。</p>]]></content>
      
      
      <categories>
          
          <category> APM </category>
          
          <category> trace </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trace </tag>
            
            <tag> APM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控之Skywalking简单使用</title>
      <link href="2021/02/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>分布式应用，会存在各种问题。解决这些难题，除了要应用自己做一些监控埋点外，还可以有一些外围的系统进行主动探测和主动发现。SkyWalking 是观察性分析平台和应用性能管理系统。提供分布式追踪、服务格遥测分析、度量聚合和可视化一体化解决方案。</p><p>大概原理：针对各种不同客户端实现不同的指标采集，统一通过grpc/http发送到apm服务端，然后经过分析引擎后存储到es/h2/mysql等存储系统，最后由前端通过查询引擎进行展现。 </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">docker network create skywalking-net</span><br><span class="line"><span class="meta">#</span><span class="bash">OAP</span></span><br><span class="line">docker pull apache/skywalking-oap-server:8.3.0-es7</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># skywalking 单机</span></span></span><br><span class="line">docker run --name oap --network skywalking-net --restart always -p 11800:11800 -p 12800:12800 -d -e SW_STORAGE=elasticsearch7 -e SW_STORAGE_ES_CLUSTER_NODES=elasticsearch:9200 apache/skywalking-oap-server:latest-es7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># skywalking kubernetes</span></span></span><br><span class="line">https://github.com/apache/skywalking-kubernetes#deploy-skywalking-backend-to-kubernetes-cluster</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 集群版本</span></span></span><br><span class="line">https://github.com/SkyAPM/document-cn-translation-of-skywalking/blob/master/docs/zh/8.0.0/setup/backend/backend-cluster.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># skywalking操作文档</span></span></span><br><span class="line">https://github.com/SkyAPM/document-cn-translation-of-skywalking/blob/master/docs/zh/8.0.0/README.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># skywalking-ui</span></span></span><br><span class="line">docker run --name oap-ui -p8080:8080 --network skywalking-net --restart always -d -e SW_OAP_ADDRESS=oap:12800 apache/skywalking-ui</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 使用外置elasticsearch.yml，容器化elasticsearch时把它挂载进来</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##先把elasticsearch容器中的config/elasticsearch.yml拷贝可编辑的目录</span></span></span><br><span class="line">docker cp elasticsearch:/usr/share/elasticsearch/config/elasticsearch.yml /mydata/elasticsearch/elasticsearch.yml</span><br><span class="line">vim /mydata/elasticsearch/elasticsearch.yml</span><br><span class="line">docker run -p 9200:9200 -p 9300:9300 --name elasticsearch \</span><br><span class="line">  -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; \</span><br><span class="line">  -e &quot;discovery.type=single-node&quot; \</span><br><span class="line">  -e &quot;cluster.name=elasticsearch&quot; \</span><br><span class="line">  -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">  -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">  -v /mydata/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">  -d elasticsearch:7.9.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改内置/config/elasticsearch.yml文件</span></span></span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 表示当前elasticsearch单节点模式，非集群，不配置的话，本版本elasticsearch启动30秒后就挂掉了</span></span></span><br><span class="line">docker run --name elasticsearch  -p 9200:9200 -p 9300:9300 -d --network skywalking-net -e &quot;discovery.type=single-node&quot; elasticsearch:7.9.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#容器化镜像，注意--net skywalking-net代码看上面网络创建</span></span></span><br><span class="line">docker run -d --name kibana -e “I18N_LOCALE=zh-CN” --link=elasticsearch:elasticsearch --net skywalking-net -p 5601:5601 kibana:7.9.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># elasticsearch安装IK分词器</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入elasticsearch容器</span></span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#下载并安装ik分词器</span></span></span><br><span class="line">elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.9.1/elasticsearch-analysis-ik-7.9.1.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#退出容器</span></span></span><br><span class="line">exit</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#重启elasticsearch容器</span></span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><h2 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Environment variables</span></span><br><span class="line">SW_AGENT_COLLECTOR_BACKEND_SERVICES与skywalking.collector.backend_service含义相同。如SW_AGENT_COLLECTOR_BACKEND_SERVICES=localhost:11800</span><br><span class="line"></span><br><span class="line">SW_AGENT_NAME与skywalking.agent.service_name 含义相同。如SW_AGENT_NAME=order-service</span><br><span class="line"><span class="meta">#</span><span class="bash">VM options</span></span><br><span class="line">-javaagent:D:\资料\apache-skywalking-apm-es7-8.3.0\apache-skywalking-apm-bin-es7\agent\skywalking-agent.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Java Agent是插件化、可插拔的。Skywalking的插件分为三种：</p><ul><li>引导插件：在agent的 <code>bootstrap-plugins</code> 目录下</li><li>内置插件：在agent的 <code>plugins</code> 目录下</li><li>可选插件：在agent的 <code>optional-plugins</code> 目录下</li></ul><p>Java Agent只会启用 <code>plugins</code> 目录下的所有插件，<code>bootstrap-plugins</code> 目录以及 <code>optional-plugins</code> 目录下的插件不会启用。如需启用引导插件或可选插件，只需将JAR包移到 <code>plugins</code> 目录下，如需禁用某款插件，只需从 <code>plugins</code> 目录中移除即可。</p><h3 id="引导插件"><a href="#引导插件" class="headerlink" title="引导插件"></a>引导插件</h3><p>目前只有两款引导插件：</p><ul><li><code>apm-jdk-http-plugin</code> 用来是监测HttpURLConnection；</li><li><code>apm-jdk-threading-plugin</code> 用来监测Callable以及Runnable；</li></ul><p>有关引导插件的功能描述，可详见： <code>https://github.com/apache/skywalking/blob/v6.6.0/docs/en/setup/service-agent/java-agent/README.md#bootstrap-class-plugins</code> 。</p><h3 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h3><p>内置插件主要用来为业界主流的技术与框架提供支持。所支持的技术&amp;框架，详见 <code>https://github.com/apache/skywalking/blob/v6.6.0/docs/en/setup/service-agent/java-agent/Supported-list.md</code> 。</p><h3 id="可选插件"><a href="#可选插件" class="headerlink" title="可选插件"></a>可选插件</h3><p>关于可选插件的功能描述，可详见 <code>https://github.com/apache/skywalking/blob/v6.6.0/docs/en/setup/service-agent/java-agent/README.md</code> 。</p><h3 id="插件扩展"><a href="#插件扩展" class="headerlink" title="插件扩展"></a>插件扩展</h3><p>Skywalking生态还有一些插件扩展，例如Oracle、Resin插件等。这部分插件主要是由于许可证不兼容/限制，Skywalking无法将这部分插件直接打包到Skywalking安装包内，于是托管在这个地址： <code>https://github.com/SkyAPM/java-plugin-extensions</code> ，使用方式：</p><ul><li>前往 <code>https://github.com/SkyAPM/java-plugin-extensions/releases</code> ，下载插件JAR包</li><li>将JAR包挪到 <code>plugins</code> 目录即可启用。</li></ul><h3 id="插件实例"><a href="#插件实例" class="headerlink" title="插件实例"></a>插件实例</h3><p>忽略某些url不被追踪</p><ol><li><p>将apm-trace-ignore-plugin-8.0.1.jar 从optional-plugins 移动到 plugins 目录中</p></li><li><p>配置忽略url</p><p>方法一： 在 agent/config 目录下创建 apm-trace-ignore-plugin.config文件</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trace.ignore_path&#x3D;$&#123;SW_AGENT_TRACE_IGNORE_PATH:需要忽略的url&#125;</span><br><span class="line">eg：trace.ignore_path&#x3D;$&#123;SW_AGENT_TRACE_IGNORE_PATH:&#x2F;xxx&#x2F;**&#125;</span><br></pre></td></tr></table></figure><p>​    方法二： 直接使用环境变量 -Dskywalking.trace.ignore_path=需要忽略的url路径</p><h2 id="全局日志追踪-traceId-的使用"><a href="#全局日志追踪-traceId-的使用" class="headerlink" title="全局日志追踪 traceId 的使用"></a>全局日志追踪 traceId 的使用</h2><ol><li><p>依赖日志相关的jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.skywalking<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apm-toolkit-logback-1.x<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改logback配置信息</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- ConsoleAppender：把日志输出到控制台 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.mdc.TraceIdMDCPatternLogbackLayout&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      %clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; [%X&#123;tid&#125;] %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;</span><br><span class="line">          ]]&gt;<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE-LOG-ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE-LOG-ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;appender-ref ref=&quot;FILE-LOG-ASYNC&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="额外记录请求参数"><a href="#额外记录请求参数" class="headerlink" title="额外记录请求参数"></a>额外记录请求参数</h2><p>如果某个方法SkyWalking没有追踪，但是想追踪并输出一些额外的tag信息等。用此方法可以记录请求参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.skywalking<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apm-toolkit-trace<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码方式"><a href="#代码方式" class="headerlink" title="代码方式"></a>代码方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trace(operationName = &quot;requestWrapperFilter&quot;)</span> <span class="comment">//增加一个深度</span></span><br><span class="line">ActiveSpan.tag(<span class="string">&quot;request&quot;</span>, requestStr);  <span class="comment">//增加标签即页面上展示参数</span></span><br><span class="line">ActiveSpan.tag(<span class="string">&quot;response&quot;</span>, customHttpServletResponseWrapper.getContent()); <span class="comment">//增加标签显示返回值</span></span><br></pre></td></tr></table></figure><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trace(operationName = &quot;添加自定义的方法&quot;)</span></span><br><span class="line"><span class="meta">@Tags(&#123;</span></span><br><span class="line"><span class="meta">        @Tag(key = &quot;从方法参数中获取值&quot;, value = &quot;arg[0]&quot;), //key为tag的名称，value为内容</span></span><br><span class="line"><span class="meta">        @Tag(key = &quot;从返回值中获取值&quot;, value = &quot;returnedObj.name&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">trace</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;如果此方法没有被SkyWalking收集，但是又需要被收集到，可以加上@Trace注解&quot;</span>);</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;创建的名字&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步线程追踪"><a href="#异步线程追踪" class="headerlink" title="异步线程追踪"></a>异步线程追踪</h2><p>自定义线程</p><ul><li>使用注解：@TraceCrossThread</li><li>使用类：SupplierWrapper/RunnableWrapper。如new Thread(RunnableWrapper.of(() -&gt; log.info(“子线程的信息”))).start();</li></ul><p>spring async异步线程</p><ul><li>不需要额外处理，已经支持透传。</li></ul><h2 id="自定义显示服务实例"><a href="#自定义显示服务实例" class="headerlink" title="自定义显示服务实例"></a>自定义显示服务实例</h2><p>默认服务实例的名字是 uuid@hostname，这个在某些时候不一定好区分，因为我们希望自定义一个 instanceName 名字,使用<br>-Dskywalking.agent.instance_name=自定义的服务名</p><h2 id="和其它agent使用时候的处理"><a href="#和其它agent使用时候的处理" class="headerlink" title="和其它agent使用时候的处理"></a>和其它agent使用时候的处理</h2><p>当我们和其它的agent一起使用时，比如Arthas，其它的agent可能工作的不是那么好。添加参数: -Dskywalking.agent.is_cache_enhanced_class=true -Dskywalking.agent.class_cache_mode=MEMORY</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://blog.csdn.net/u010928589/article/details/106608864/">agent启动服务分析以及性能影响</a><br><a href="https://www.imooc.com/article/306199"><strong>手把手教你编写Skywalking插件</strong></a><br><a href="https://blog.csdn.net/snail_bi/article/details/102525736">skywalking-ui详解</a><br><a href="http://cmsblogs.com/?p=3549">源码解析系列文章</a><br><a href="https://zhuanlan.zhihu.com/p/125689524">SkyWalking-性能剖析</a><br><a href="https://blog.51cto.com/zero01/2463976">SkyWalking - 实现微服务监控告警</a><br><a href="https://www.jianshu.com/p/929af3d64f7f">全链路追踪技术选型：pinpoint vs skywalking</a><br><a href="https://www.jianshu.com/p/45cb1cd5a1be">APM分布式性能管理监控工具调研</a></p>]]></content>
      
      
      <categories>
          
          <category> APM </category>
          
          <category> trace </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trace </tag>
            
            <tag> APM </tag>
            
            <tag> SkyWalking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven详解</title>
      <link href="2021/02/05/maven%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/02/05/maven%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="scope属性"><a href="#scope属性" class="headerlink" title="scope属性"></a>scope属性</h2><ul><li><strong>compile</strong> <strong>（编译）</strong></li></ul><p>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath中可用，同时它们也会被打包。</p><ul><li><strong>provided</strong> <strong>（已提供）</strong></li></ul><p>provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。</p><ul><li><strong>runtime</strong> <strong>（运行时）</strong></li></ul><p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC<br>驱动实现。</p><ul><li><strong>test</strong> <strong>（测试）</strong></li></ul><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</p><ul><li><strong>system</strong> <strong>（系统）</strong></li></ul><p>system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构建应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个<strong>systemPath</strong>元素。注意该范围是不推荐使用的（建议尽量去从公共或定制的 Maven 仓库中引用依赖）。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;sun.jdk&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;tools&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.5.0&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;system&lt;&#x2F;scope&gt;</span><br><span class="line">      &lt;systemPath&gt;$&#123;java.home&#125;&#x2F;..&#x2F;lib&#x2F;tools.jar&lt;&#x2F;systemPath&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>import(导入)</strong></li></ul><p>import仅支持在<code>&lt;**dependencyManagement**&gt;</code>中的类型依赖项上。它表示要在指定的POM <code>&lt;**dependencyManagement**&gt;</code>部分中用有效的依赖关系列表替换的依赖关系。该scope类型的依赖项``实际上不会参与限制依赖项的可传递性。</p><h2 id="scope的依赖传递"><a href="#scope的依赖传递" class="headerlink" title="scope的依赖传递"></a>scope的依赖传递</h2><ul><li>当B对C的依赖的scope是<strong>test</strong>或者<strong>provided</strong>，则A不依赖C。</li><li>当B对C的依赖是scope是<strong>runtime</strong>或者<strong>compile</strong>，则A依赖C。且传递依赖的scope的<strong>规则：</strong>如果A对B的依赖是compile，那么A对C的依赖和B对C的依赖相同，否则和A对B的依赖保持一致。</li></ul><h2 id="optional属性"><a href="#optional属性" class="headerlink" title="optional属性"></a><strong>optional</strong>属性</h2><p><optional>true</optional>的作用是让依赖只被当前项目使用，而不会在模块间进行传递依赖。如b依赖c，而a依赖b。在b中设置了依赖c的属性<optional>true</optional>，此时a想要用c的类，需要a自己去依赖c，而且使用b中的类且类依赖c中的类，此时必须依赖c，否则报错。</p><h2 id="distributionManagement配置"><a href="#distributionManagement配置" class="headerlink" title="distributionManagement配置"></a>distributionManagement配置</h2><p>pom文件中，<distributionManagement>  标签的作用是指定mvn deploy的地址。</distributionManagement></p><p>maven会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情况下，直接编译打包时，maven会自动从镜像服务器上下载最新的快照版本。如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//最佳实践，本地上传到镜像服务器，生产上上传到正式版本库</span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.release.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">project.release.version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">project.release.version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>release<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">project.release.version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">project.release.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--定义snapshots库和releases库的nexus地址--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>  </span><br><span class="line">            http://172.17.103.59:8081/nexus/content/repositories/releases/  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>  </span><br><span class="line">            http://172.17.103.59:8081/nexus/content/repositories/snapshots/  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><p>需要在settings.xml文件中配置地址的用户名和密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="repositories配置"><a href="#repositories配置" class="headerlink" title="repositories配置"></a>repositories配置</h2><p>作用是指定jar的下载地址，即仓库地址。可以指定下载镜像版本和正式版本的仓库，在settings.xml中可以设置生效的配置，配置仓库的镜像地址，提高下载速度。如下<mirrorOf>*</mirrorOf>映射了所有的仓库的地址。先从镜像仓库下载，再到配置仓库下载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在settings.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Send all requests to the public group --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://nexus.xxx.com/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插件plugin"><a href="#插件plugin" class="headerlink" title="插件plugin"></a>插件plugin</h2><h3 id="dockerfile-maven-plugin"><a href="#dockerfile-maven-plugin" class="headerlink" title="dockerfile-maven-plugin"></a>dockerfile-maven-plugin</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>ip地址(push镜像的地址):5000/镜像name<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><strong>根目录下载创建Dockfile文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">MAINTAINER 作者信息</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;&#x2F;app.jar&quot;]</span><br><span class="line"># Add the service itself</span><br><span class="line">ADD target&#x2F;web-1.0-SNAPSHOT.jar &#x2F;app.jar</span><br></pre></td></tr></table></figure><p><strong>构建Docker镜像并发送到镜像仓库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package dockerfile:push</span><br></pre></td></tr></table></figure><h3 id="screw-maven-plugin"><a href="#screw-maven-plugin" class="headerlink" title="screw-maven-plugin"></a>screw-maven-plugin</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.smallbun.screw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>screw-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.smallbun.screw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>screw-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HikariCP --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql driver--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--username--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>magic_mirror<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--password--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>qAjTe#YHK8dev<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--driver--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">driverClassName</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">driverClassName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jdbc url--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcUrl</span>&gt;</span>jdbc:mysql://10.16.32.177:3306/magic_mirror_iot<span class="tag">&lt;/<span class="name">jdbcUrl</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生成文件类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileType</span>&gt;</span>WORD<span class="tag">&lt;/<span class="name">fileType</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打开文件输出目录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">openOutputDir</span>&gt;</span>false<span class="tag">&lt;/<span class="name">openOutputDir</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生成模板--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">produceType</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">produceType</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--文档名称 为空时:将采用[数据库名称-描述-版本号]作为文档名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileName</span>&gt;</span>sso<span class="tag">&lt;/<span class="name">fileName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>数据库文档生成<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>数据库文档<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>执行mvn命令生成数据库文档</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package screw:run</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos监控</title>
      <link href="2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/"/>
      <url>2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>Nacos 0.8.0版本完善了监控系统，支持通过暴露metrics数据接入第三方监控系统监控Nacos运行状态，目前支持prometheus、elastic search和influxdb，下面结合prometheus和grafana如何监控Nacos，官网<a href="http://monitor.nacos.io/">grafana监控页面</a>。与elastic search和influxdb结合可自己查找相关资料</p><h2 id="搭建Nacos集群暴露metrics数据"><a href="#搭建Nacos集群暴露metrics数据" class="headerlink" title="搭建Nacos集群暴露metrics数据"></a>搭建Nacos集群暴露metrics数据</h2><p>按照<a href="https://nacos.io/zh-cn/docs/deployment.html">部署文档</a>搭建好Nacos集群</p><p>配置application.properties文件，暴露metrics数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include&#x3D;*</span><br></pre></td></tr></table></figure><p>访问{ip}:8848/nacos/actuator/prometheus，看是否能访问到metrics数据</p><h2 id="搭建prometheus采集Nacos-metrics数据"><a href="#搭建prometheus采集Nacos-metrics数据" class="headerlink" title="搭建prometheus采集Nacos metrics数据"></a>搭建prometheus采集Nacos metrics数据</h2><p>下载你想安装的prometheus版本，地址为<a href="https://prometheus.io/download/">download prometheus</a></p><h3 id="linux-amp-mac"><a href="#linux-amp-mac" class="headerlink" title="linux &amp; mac"></a>linux &amp; mac</h3><p>解压prometheus压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xvfz prometheus-*.tar.gz</span><br><span class="line">cd prometheus-*</span><br></pre></td></tr></table></figure><p>修改配置文件prometheus.yml采集Nacos metrics数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metrics_path: &#39;&#x2F;nacos&#x2F;actuator&#x2F;prometheus&#39;</span><br><span class="line">static_configs:</span><br><span class="line">  - targets: [&#39;&#123;ip1&#125;:8848&#39;,&#39;&#123;ip2&#125;:8848&#39;,&#39;&#123;ip3&#125;:8848&#39;]</span><br></pre></td></tr></table></figure><p>启动prometheus服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;prometheus --config.file&#x3D;&quot;prometheus.yml&quot;</span><br></pre></td></tr></table></figure><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>下载对应的windows版本并解压</p><p>修改配置文件prometheus.yml采集Nacos metrics数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metrics_path: &#39;&#x2F;nacos&#x2F;actuator&#x2F;prometheus&#39;</span><br><span class="line">static_configs:</span><br><span class="line">  - targets: [&#39;&#123;ip1&#125;:8848&#39;,&#39;&#123;ip2&#125;:8848&#39;,&#39;&#123;ip3&#125;:8848&#39;]</span><br></pre></td></tr></table></figure><p>启动prometheus服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus.exe --config.file&#x3D;prometheus.yml</span><br></pre></td></tr></table></figure><p>通过访问http://{ip}:9090/graph可以看到prometheus的采集数据，在搜索栏搜索nacos_monitor可以搜索到Nacos数据说明采集数据成功 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1LThVCQvoK1RjSZFwXXciCFXa-2832-1576.png" alt="IMAGE"></p><h2 id="搭建grafana图形化展示metrics数据"><a href="#搭建grafana图形化展示metrics数据" class="headerlink" title="搭建grafana图形化展示metrics数据"></a>搭建grafana图形化展示metrics数据</h2><p>和prometheus在同一台机器上安装grafana，使用 yum 安装grafana</p><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install grafana</span><br><span class="line">brew services start grafana</span><br></pre></td></tr></table></figure><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;grafana-releases&#x2F;release&#x2F;grafana-5.2.4-1.x86_64.rpm</span><br><span class="line">sudo service grafana-server start</span><br></pre></td></tr></table></figure><h3 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h3><p>参考文档：<a href="http://docs.grafana.org/installation/windows/">http://docs.grafana.org/installation/windows/</a></p><p>访问grafana: http://{ip}:3000</p><p>配置prometheus数据源 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1bTafCOLaK1RjSZFxXXamPFXa-2832-1568.png" alt="IMAGE"></p><p>导入Nacos grafana监控<a href="https://github.com/nacos-group/nacos-template/blob/master/nacos-grafana.json">模版</a> <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1JadVCPDpK1RjSZFrXXa78VXa-2742-1338.png" alt="IMAGE"></p><p>Nacos监控分为三个模块:</p><ul><li>nacos monitor展示核心监控项 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1PMpUCQvoK1RjSZFDXXXY3pXa-2832-1584.png" alt="IMAGE"></li><li>nacos detail展示指标的变化曲线 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1ZBF4CNjaK1RjSZFAXXbdLFXa-2742-1480.png" alt="IMAGE"></li><li>nacos alert为告警项 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1ALlUCFzqK1RjSZFCXXbbxVXa-2742-1476.png" alt="IMAGE"></li></ul><h2 id="配置grafana告警"><a href="#配置grafana告警" class="headerlink" title="配置grafana告警"></a>配置grafana告警</h2><p>当Nacos运行出现问题时，需要grafana告警通知相关负责人。grafana支持多种告警方式，常用的有邮件，钉钉和webhook方式</p><h3 id="钉钉告警"><a href="#钉钉告警" class="headerlink" title="钉钉告警"></a>钉钉告警</h3><p>钉钉可以通过配置钉钉机器人 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1eJ0RCSzqK1RjSZFjXXblCFXa-2742-1482.png" alt="IMAGE"></p><p>配置钉钉通知url <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1ERtQCSzqK1RjSZFjXXblCFXa-2832-1578.png" alt="IMAGE"></p><p>测试告警项 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1KvXPCHPpK1RjSZFFXXa5PpXa-996-504.png" alt="IMAGE"></p><h3 id="邮件告警"><a href="#邮件告警" class="headerlink" title="邮件告警"></a>邮件告警</h3><p>修改defaults.ini配置文件，增加邮件告警</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#################################### SMTP &#x2F; Emailing ##########################</span><br><span class="line">[smtp]</span><br><span class="line">enabled &#x3D; true</span><br><span class="line">host &#x3D; smtp.126.com:25</span><br><span class="line">user &#x3D; xxxxxx</span><br><span class="line">password &#x3D; xxxxx</span><br><span class="line">;cert_file &#x3D;</span><br><span class="line">;key_file &#x3D;</span><br><span class="line">skip_verify &#x3D; true</span><br><span class="line">from_address &#x3D; xxxxxx@126.com</span><br><span class="line"></span><br><span class="line">[emails]</span><br><span class="line">;welcome_email_on_sign_up &#x3D; false</span><br></pre></td></tr></table></figure><p>配置通知邮箱 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB12qyhCNnaK1RjSZFtXXbC2VXa-2832-1576.png" alt="IMAGE"></p><h2 id="Nacos-metrics含义"><a href="#Nacos-metrics含义" class="headerlink" title="Nacos metrics含义"></a>Nacos metrics含义</h2><h3 id="jvm-metrics"><a href="#jvm-metrics" class="headerlink" title="jvm metrics"></a>jvm metrics</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>system_cpu_usage</td><td>CPU使用率</td></tr><tr><td>system_load_average_1m</td><td>load</td></tr><tr><td>jvm_memory_used_bytes</td><td>内存使用字节，包含各种内存区</td></tr><tr><td>jvm_memory_max_bytes</td><td>内存最大字节，包含各种内存区</td></tr><tr><td>jvm_gc_pause_seconds_count</td><td>gc次数，包含各种gc</td></tr><tr><td>jvm_gc_pause_seconds_sum</td><td>gc耗时，包含各种gc</td></tr><tr><td>jvm_threads_daemon</td><td>线程数</td></tr></tbody></table><h3 id="Nacos-监控指标"><a href="#Nacos-监控指标" class="headerlink" title="Nacos 监控指标"></a>Nacos 监控指标</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>http_server_requests_seconds_count</td><td>http请求次数，包括多种(url,方法,code)</td></tr><tr><td>http_server_requests_seconds_sum</td><td>http请求总耗时，包括多种(url,方法,code)</td></tr><tr><td>nacos_timer_seconds_sum</td><td>Nacos config水平通知耗时</td></tr><tr><td>nacos_timer_seconds_count</td><td>Nacos config水平通知次数</td></tr><tr><td>nacos_monitor{name=’longPolling’}</td><td>Nacos config长连接数</td></tr><tr><td>nacos_monitor{name=’configCount’}</td><td>Nacos config配置个数</td></tr><tr><td>nacos_monitor{name=’dumpTask’}</td><td>Nacos config配置落盘任务堆积数</td></tr><tr><td>nacos_monitor{name=’notifyTask’}</td><td>Nacos config配置水平通知任务堆积数</td></tr><tr><td>nacos_monitor{name=’getConfig’}</td><td>Nacos config读配置统计数</td></tr><tr><td>nacos_monitor{name=’publish’}</td><td>Nacos config写配置统计数</td></tr><tr><td>nacos_monitor{name=’ipCount’}</td><td>Nacos naming ip个数</td></tr><tr><td>nacos_monitor{name=’domCount’}</td><td>Nacos naming域名个数</td></tr><tr><td>nacos_monitor{name=’failedPush’}</td><td>Nacos naming推送失败数</td></tr><tr><td>nacos_monitor{name=’avgPushCost’}</td><td>Nacos naming平均推送耗时</td></tr><tr><td>nacos_monitor{name=’leaderStatus’}</td><td>Nacos naming角色状态</td></tr><tr><td>nacos_monitor{name=’maxPushCost’}</td><td>Nacos naming最大推送耗时</td></tr><tr><td>nacos_monitor{name=’mysqlhealthCheck’}</td><td>Nacos naming mysql健康检查次数</td></tr><tr><td>nacos_monitor{name=’httpHealthCheck’}</td><td>Nacos naming http健康检查次数</td></tr><tr><td>nacos_monitor{name=’tcpHealthCheck’}</td><td>Nacos naming tcp健康检查次数</td></tr></tbody></table><h3 id="nacos-异常指标"><a href="#nacos-异常指标" class="headerlink" title="nacos 异常指标"></a>nacos 异常指标</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>nacos_exception_total{name=’db’}</td><td>数据库异常</td></tr><tr><td>nacos_exception_total{name=’configNotify’}</td><td>Nacos config水平通知失败</td></tr><tr><td>nacos_exception_total{name=’unhealth’}</td><td>Nacos config server之间健康检查异常</td></tr><tr><td>nacos_exception_total{name=’disk’}</td><td>Nacos naming写磁盘异常</td></tr><tr><td>nacos_exception_total{name=’leaderSendBeatFailed’}</td><td>Nacos naming leader发送心跳异常</td></tr><tr><td>nacos_exception_total{name=’illegalArgument’}</td><td>请求参数不合法</td></tr><tr><td>nacos_exception_total{name=’nacos’}</td><td>Nacos请求响应内部错误异常（读写失败，没权限，参数错误）</td></tr></tbody></table><h3 id="client-metrics"><a href="#client-metrics" class="headerlink" title="client metrics"></a>client metrics</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>nacos_monitor{name=’subServiceCount’}</td><td>订阅的服务数</td></tr><tr><td>nacos_monitor{name=’pubServiceCount’}</td><td>发布的服务数</td></tr><tr><td>nacos_monitor{name=’configListenSize’}</td><td>监听的配置数</td></tr><tr><td>nacos_client_request_seconds_count</td><td>请求的次数，包括多种(url,方法,code)</td></tr><tr><td>nacos_client_request_seconds_sum</td><td>请求的总耗时，包括多种(url,方法,code)</td></tr></tbody></table><h2 id="Nacos-Sync监控"><a href="#Nacos-Sync监控" class="headerlink" title="Nacos-Sync监控"></a>Nacos-Sync监控</h2><p>随着Nacos 0.9版本发布，Nacos-Sync 0.3版本支持了metrics监控，能通过metrics数据观察Nacos-Sync服务的运行状态，提升了Nacos-Sync的在生产环境的监控能力。 整体的监控体系的搭建参考<a href="https://nacos.io/zh-cn/docs/monitor-guide.html">Nacos监控手册</a></p><h2 id="grafana监控Nacos-Sync"><a href="#grafana监控Nacos-Sync" class="headerlink" title="grafana监控Nacos-Sync"></a>grafana监控Nacos-Sync</h2><p>和Nacos监控一样，Nacos-Sync也提供了监控模版，导入监控<a href="https://github.com/nacos-group/nacos-template/blob/master/nacos-sync-grafana">模版</a></p><p>Nacos-Sync监控同样也分为三个模块:</p><ul><li>nacos-sync monitor展示核心监控项 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1GeNWKmzqK1RjSZFHXXb3CpXa-2834-1588.png" alt="monitor"></li><li>nacos-sync detail和alert展示监控曲线和告警 <img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E7%9B%91%E6%8E%A7/TB1kP8UKbvpK1RjSZPiXXbmwXXa-2834-1570.png" alt="detail"></li></ul><h2 id="Nacos-Sync-metrics含义"><a href="#Nacos-Sync-metrics含义" class="headerlink" title="Nacos-Sync metrics含义"></a>Nacos-Sync metrics含义</h2><p>Nacos-Sync的metrics分为jvm层和应用层</p><h3 id="jvm-metrics-1"><a href="#jvm-metrics-1" class="headerlink" title="jvm metrics"></a>jvm metrics</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>system_cpu_usage</td><td>CPU使用率</td></tr><tr><td>system_load_average_1m</td><td>load</td></tr><tr><td>jvm_memory_used_bytes</td><td>内存使用字节，包含各种内存区</td></tr><tr><td>jvm_memory_max_bytes</td><td>内存最大字节，包含各种内存区</td></tr><tr><td>jvm_gc_pause_seconds_count</td><td>gc次数，包含各种gc</td></tr><tr><td>jvm_gc_pause_seconds_sum</td><td>gc耗时，包含各种gc</td></tr><tr><td>jvm_threads_daemon</td><td>线程数</td></tr></tbody></table><h2 id="应用层-metrics"><a href="#应用层-metrics" class="headerlink" title="应用层 metrics"></a>应用层 metrics</h2><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>nacosSync_task_size</td><td>同步任务数</td></tr><tr><td>nacosSync_cluster_size</td><td>集群数</td></tr><tr><td>nacosSync_add_task_rt</td><td>同步任务执行耗时</td></tr><tr><td>nacosSync_delete_task_rt</td><td>删除任务耗时</td></tr><tr><td>nacosSync_dispatcher_task</td><td>从数据库中分发任务</td></tr><tr><td>nacosSync_sync_task_error</td><td>所有同步执行时的异常</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo-admin简单使用</title>
      <link href="2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bdubbo-admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bdubbo-admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="dubbo-admin"><a href="#dubbo-admin" class="headerlink" title="dubbo-admin"></a>dubbo-admin</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>配置中心：用于配置dubbo元数据中心和注册中心的配置信息</li><li>元数据中心：用于存放接口调用相关的信息，如方法名</li><li>注册中心 ：Dubbo 2.6版本所有数据都存在注册中心上，Dubbo 2.7版本分成了注册中心，配置中心，和元数据中心。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>重点类ConfigCenter，配置中心自动配置类，创建GovernanceConfiguration对象，初始化nacos的configService</li><li>如果配置了配置中心，则加载配置中心的配置，读取注册中心和元数据中心的配置，生成url</li><li>dubbo-admin前后端分离，admin-ui前端使用vue,dubbo-admin-server后端使用spring-boot</li><li>订阅（dubbo-admin，nacos订阅）更改map缓存的数据（服务提供者、消费者）</li></ol><h3 id="GROUP默认值"><a href="#GROUP默认值" class="headerlink" title="GROUP默认值"></a>GROUP默认值</h3><p>dubbo-admin这边默认group都是dubbo</p><h3 id="application-properties配置项说明"><a href="#application-properties配置项说明" class="headerlink" title="application.properties配置项说明"></a>application.properties配置项说明</h3><ul><li><p>admin.config-center</p><ul><li><p>推荐使用，配置中心地址，比如<code>admin.config-center=&quot;zookeeper://127.0.0.1:2181&quot;</code></p></li><li><p>需要在配置中心中，配置注册中心和元数据中心地址配置格式如下：</p></li><li><p>zookeeper</p><ul><li><p>path: <code>/dubbo/config/dubbo/dubbo.properties</code></p></li><li><p>content:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="meta">dubbo.metadata-report.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>admin.registry.address</p><ul><li>不推荐使用，老版本的配置中心地址，比如：<code>admin.registry.address=&quot;zookeeper://127.0.0.1:2181&quot;</code></li><li>如使用该配置，Dubbo Admin会将其作为注册中心和配置中心使用，元数据中心将无法使用，会影响服务测试等功能。</li></ul></li></ul><h2 id="dubbo-monitor-simple"><a href="#dubbo-monitor-simple" class="headerlink" title="dubbo-monitor-simple"></a>dubbo-monitor-simple</h2><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li>启动<code>com.alibaba.dubbo.monitor.simple.MonitorStarter#main</code></li><li>需要进行监控的服务，在xml中配置<code>&lt;dubbo:monitor protocol=&quot;registry&quot;/&gt;</code></li><li>打开监控页面<code>http://localhost:8080</code>可以看到服务调用相关的统计</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="dubbo-monitor-simple-1"><a href="#dubbo-monitor-simple-1" class="headerlink" title="dubbo-monitor-simple"></a>dubbo-monitor-simple</h5><ul><li>dubbo-monitor-simple启动的时候，发布服务:<code>com.alibaba.dubbo.monitor.MonitorService</code>(实现类：<code>com.alibaba.dubbo.monitor.simple.SimpleMonitorService</code>)，只实现了<code>collect</code>方法，将RPC调用过来的URL存到<code>queue</code>里面</li><li><code>com.alibaba.dubbo.monitor.simple.SimpleMonitorService</code>启动了两个线程，分别执行<code>write</code>和<code>draw</code>方法，<code>write</code>从<code>queue</code>里面取出URL进行统计分析，结果写文件，<code>draw</code>方法把这些结果画成折线图，存本地图片文件</li><li><code>com.alibaba.dubbo.monitor.simple.pages.ChartsPageHandler</code>和<code>com.alibaba.dubbo.monitor.simple.pages.StatisticsPageHandler</code>负责在页面上渲染展示这些数据</li></ul><h5 id="Dubbo应用"><a href="#Dubbo应用" class="headerlink" title="Dubbo应用"></a>Dubbo应用</h5><ul><li>Dubbo服务在配置了<code>&lt;dubbo:monitor protocol=&quot;registry&quot;/&gt;</code>标签后，调用经过<code>com.alibaba.dubbo.monitor.support.MonitorFilter</code>时，会进行结果收集操作。</li><li>最终在调用到<code>com.alibaba.dubbo.monitor.dubbo.DubboMonitor#collect</code>，该方法将调用过程中的统计信息存放在<code>statisticsMap</code>中。并且，有另一个线程定期(默认为60秒)调用dubbo-monitor-simple暴露的com.alibaba.dubbo.monitor.MonitorService服务，将这些信息发送给monitor。</li></ul><p>Dubbo-montitor-simple实现的过程借助了dubbo服务调用：Monitor端暴露服务，Dubbo应用通过配置去消费这些服务，消费的过程就是自身服务数据上报的过程。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo简单使用</title>
      <link href="2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bdubbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bdubbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="整体架构分层"><a href="#整体架构分层" class="headerlink" title="整体架构分层"></a>整体架构分层</h2><ul><li>第一层：service 层，接口层，给服务提供者和消费者来实现的</li><li>第二层：config 层，配置层，主要是对 dubbo 进行各种配置的</li><li>第三层：proxy 层，服务代理层，无论是 consumer 还是 provider，dubbo 都会给你生成代理，代理之间进行网络通信</li><li>第四层：registry 层，服务注册层，负责服务的注册与发现</li><li>第五层：cluster 层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li><li>第六层：monitor 层，监控层，对 rpc 接口的调用次数和调用时间进行监控</li><li>第七层：protocal 层，远程调用层，封装 rpc 调用</li><li>第八层：exchange 层，信息交换层，封装请求响应模式，同步转异步</li><li>第九层：transport 层，网络传输层，抽象 mina 和 netty 为统一接口</li><li>第十层：serialize 层，数据序列化层 </li></ul><p><img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bdubbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/4ec2d5628535e5ddc2c84b48ab2f0cebcc1b62ab.jpeg" alt="img"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bdubbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c75c10385343fbf2472e75616d97618464388f65.jpeg" alt="img"><br>dubbo工作原理要理解的方向：</p><ul><li>dubbo 工作原理：服务注册、注册中心、消费者、代理通信、负载均衡；</li><li>网络通信、序列化：dubbo 协议、长连接、NIO、hessian 序列化协议；</li><li>负载均衡策略、集群容错策略、动态代理策略</li></ul><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><ul><li>dubbo协议，基于 hessian2作为序列化协议，单一长连接，使用NIO，使用IO多路复用模型。适用多个消费者如100个，几个服务提供者的场景，建立100个连接就可以一直通信。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高。</li><li>rmi 协议，走Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。</li><li>hessian 协议，走hessian2序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。</li><li>http 协议，走 json 序列化。</li><li>webservice协议，走 SOAP 文本。</li><li>grpc协议，与grpc框架提供的接口通信</li><li>injvm协议：jvm进程通信</li><li>memcached：</li><li>Thrift：Thrift框架通信</li><li>redis：</li><li>rest：应该就是指的http协议。</li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Serialization: java、compactedjava、nativejava、fastjson、fst、hessian2、kryo、gson、avro 、protostuff、protobuf</p><p>其中默认hessian2。其中java、compactedjava、nativejava属于原生java的序列化。</p><p>hessian序列化，java二级制序列化，json序列化，protocol buffer序列化</p><h2 id="Dubbo服务负载均衡"><a href="#Dubbo服务负载均衡" class="headerlink" title="Dubbo服务负载均衡"></a>Dubbo服务负载均衡</h2><p>可以设置在消费者端，亦可设置在提供者端；可以设置在接口级别，亦可设置在方法级别。其限制的是流向，而非流量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;leastactive&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于权重随机算法的 RandomLoadBalance  默认路由</li><li>基于加权轮询算法的 RoundRobinLoadBalance</li><li>基于最少活跃调用数算法的 LeastActiveLoadBalance</li><li>基于 hash一致性的 ConsistentHashLoadBalance</li><li>最少响应时间加权算法的ShortestResponseLoadBalance</li></ul><h2 id="集群容错策略"><a href="#集群容错策略" class="headerlink" title="集群容错策略"></a>集群容错策略</h2><ul><li><p>failover cluster 失败自动切换，自动重试其他机器，<strong>默认</strong>就是这个，常见于读操作。（失败重试其它机器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;findFoo&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>failfast cluster 一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）</p></li><li><p>failsafe cluster 出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>failback cluster 失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。</p></li><li><p>forking cluster <strong>并行调用</strong>多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源，可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</p></li><li><p>broadcacst cluster 逐个调用所有的 provider。任何一个 provider 出错则报错（从<code>2.1.0</code> 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p></li></ul><h2 id="Dubbo动态代理"><a href="#Dubbo动态代理" class="headerlink" title="Dubbo动态代理"></a>Dubbo动态代理</h2><p>默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。</p><h2 id="Dubbo的SPI机制"><a href="#Dubbo的SPI机制" class="headerlink" title="Dubbo的SPI机制"></a>Dubbo的SPI机制</h2><p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。 SPI的作用就是为这些被扩展的API寻找服务实现。</p><p>需要在resources目录下新建META-INF/services目录，并且在这个目录下新建一个与上述接口的全限定名一致的文件，在这个文件中写入接口的实现类的全限定名：ServiceLoader<UploadCDN> uploadCDN = ServiceLoader.load(UploadCDN.class);</UploadCDN></p><p>java的spi机制有着如下的弊端：</p><ul><li>只能遍历所有的实现，并全部实例化。</li><li>配置文件中只是简单的列出了所有的扩展实现，而没有给他们命名。导致在程序中很难去准确的引用它们。</li><li>扩展如果依赖其他的扩展，做不到自动注入和装配。</li><li>扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持。</li></ul><p>dubbo的spi有如下几个概念：<br>  （1）<strong>扩展点</strong>：一个接口。<br>  （2）<strong>扩展</strong>：扩展（接口）的实现。<br>  （3）<strong>扩展自适应实例：</strong>其实就是一个Extension的代理，它实现了扩展点接口。在调用扩展点的接口方法时，会根据实际的参数来决定要使用哪个扩展。dubbo会根据接口中的参数，自动地决定选择哪个实现。<br>  （4）**@SPI**:该注解作用于扩展点的接口上，表明该接口是一个扩展点。<br>  （5）**@Adaptive：**@Adaptive注解用在扩展接口的方法上。表示该方法是一个自适应方法。Dubbo在为扩展点生成自适应实例时，如果方法有@Adaptive注解，会为该方法生成对应的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure><p><code>@SPI(&quot;dubbo&quot;)</code> 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 <code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</code>。</p><p>如果想要动态替换掉默认的实现类，需要使用 <code>@Adaptive</code> 接口，Protocol 接口中，有两个方法加了 <code>@Adaptive</code> 注解，就是说那俩接口会被代理实现。</p><p> Protocol 接口搞了俩 <code>@Adaptive</code> 注解标注了方法，在运行的时候会针对 Protocol 生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据 url 中的 protocol 来获取那个 key，默认是 dubbo，你也可以自己指定，你如果指定了别的 key，那么就会获取别的实现类的实例了。</p><p>/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol目录下文件内容为：定义自己的扩展类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo&#x3D;com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line">http&#x3D;com.alibaba.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class="line">hessian&#x3D;com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol</span><br></pre></td></tr></table></figure><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>1）多个服务之间可能由于服务没有启动或者网络不通，调用中会出现远程调用失败;<br>2) 服务请求过大，需要停止部分服务以保证核心业务的正常运行；<br>可以使用Dubbo的服务降级来实现，即在服务宕掉或者并发数太高导致的RpcException异常时，进行友好的处理或者提示，而不是内部报错导致系统不可用。</p><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a><strong>解决方法：</strong></h5><p>dubbo提供了mock配置，可以很好的实现dubbo服务降级。</p><h5 id="mock配置方式"><a href="#mock配置方式" class="headerlink" title="mock配置方式"></a>mock配置方式</h5><ul><li>服务返回固定值：配置了mock参数之后，假设在调用服务的时候，远程服务没有启动，或者各种网络异常了，那远程服务会把这个mock配置的值返回，也就是会返回123456…通过这种方式就可以避免了因为服务调用不了而出现异常错误而带来的程序不可用(起码是有值返回的，然后可以根据值进行业务逻辑处理判断等等)。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;xxxService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.x..service.xxxxService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;return 123456...&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>服务返回true：配置了mock参数之后，假设在调用服务的时候，远程服务没有启动，或者各种网络异常了，那远程服务会去寻找自定义的mock业务处理类进行业务处理。需要配置自定义的mock业务处理类进行业务处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;xxxService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.x..service.xxxxService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务类上增加Mock，实现服务，重写方法，返回降级之后的返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxxServiceMock</span> <span class="keyword">implements</span> <span class="title">xxxxService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getXXXX</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this is exception 自定义....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>管理界面手动配置：</p></li></ul><p><img src="/2021/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bdubbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/20180831152853913" alt="img"></p><p><strong>屏蔽：force.mock</strong> （即：屏蔽请求，直接返回某个值，如上面的字符串，*mock=”return 123456…”*）;</p><p><strong>容错：fail.mock</strong> （即：允许请求，在请求失败的时候，再返回某个值，如：*mock=”fail:return 123456…”*）;</p><h2 id="失败重试和超时重试"><a href="#失败重试和超时重试" class="headerlink" title="失败重试和超时重试"></a>失败重试和超时重试</h2><p>失败重试，就是 consumer 调用 provider 要是失败了，比如抛异常了，此时应该是可以重试的，或者调用超时也可以重试。配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">check</span>=<span class="string">&quot;true&quot;</span> <span class="attr">async</span>=<span class="string">&quot;false&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>timeout</code>：一般设置为 <code>200ms</code>，我们认为不能超过 <code>200ms</code> 还没返回。</li><li><code>retries</code>：设置 retries，一般是在读请求的时候，比如你要查询个数据，你可以设置个 retries，如果第一次没读到，报错，重试指定的次数，尝试再次读取。</li></ul><h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><ul><li>标签路由TagRouter：以Provider应用为粒度配置路由规则。</li><li>条件路由ConditionRouter：支持以服务或Consumer应用为粒度配置路由规则。</li><li>脚本路由ScriptRouter：</li></ul><h3 id="标签路由"><a href="#标签路由" class="headerlink" title="标签路由"></a>标签路由</h3><p>标签路由通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。</p><p>标签主要是指对Provider端应用实例的分组，目前有两种方式可以完成实例分组，分别是动态规则打标和静态规则打标，其中动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。</p><p>请求标签的作用域为每一次 invocation，使用 attachment 来传递请求标签，注意保存在 attachment 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，我们只需要在起始调用时，通过一行代码的设置，达到标签的持续传递。</p><h5 id="降级约定"><a href="#降级约定" class="headerlink" title="降级约定"></a>降级约定</h5><blockquote><p>consumer携带request.tag=tag1 时优先选择 标记了tag=tag1 的 provider。若集群中不存在与请求标记对应的服务，默认将降级请求 tag为空的provider；如果要改变这种默认行为，即找不到匹配tag1的provider返回异常，需设置request.tag.force=true。</p></blockquote><blockquote><p>comsumer侧request.tag未设置时，只会匹配tag为空的provider。即使集群中存在可用的服务，若tag不匹配也就无法调用，这与约定1不同，携带标签的请求可以降级访问到无标签的服务，但不携带标签/携带其他种类标签的请求永远无法访问到其他标签的服务。</p></blockquote><h5 id="标签路由的坑"><a href="#标签路由的坑" class="headerlink" title="标签路由的坑"></a>标签路由的坑</h5><p>dubbo的consumer侧的Filter对象ConsumerContextFilter每次请求后都会清空Attachments，导致再次发起请求就无法找到tag，所以需要在整个生命周期内保存tag。一般通过线程的ThreadLocal进行实现。</p><h5 id="标签路由的实现"><a href="#标签路由的实现" class="headerlink" title="标签路由的实现"></a>标签路由的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 实现逻辑为：</span></span><br><span class="line"><span class="comment"> * 1. 对于 Consumer 方，在调用 Provider 时，&#123;<span class="doctag">@link</span> DubboConsumerRouterTagClusterInterceptor&#125; 会将 &#123;<span class="doctag">@link</span> DubboRouterTagContextHolder&#125; 中的 Tag 通过 Dubbo 隐式传参。</span></span><br><span class="line"><span class="comment"> *      同时，Dubbo 自带 &#123;<span class="doctag">@link</span> TagRouter&#125;，会根据该参数，会选择符合该 Tag 的 Provider。</span></span><br><span class="line"><span class="comment"> * 2. 对于 Provider 方，在通过 Dubbo 隐式传参获得到 Tag 时，会设置到 &#123;<span class="doctag">@link</span> DubboRouterTagContextHolder&#125; 中。</span></span><br><span class="line"><span class="comment"> *      这样，在 Provider 作为 Consumer 角色时，调用其它 Provider 时，可以继续实现标签路由的功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Activate(group = &#123;CommonConstants.PROVIDER, CommonConstants.CONSUMER&#125;, order = -1000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProviderRouterTagFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="comment">// 从 Dubbo 隐式传参获得 Dubbo Tag</span></span><br><span class="line">        String dubboTag = invocation.getAttachment(CommonConstants.TAG_KEY);</span><br><span class="line">        <span class="keyword">boolean</span> hasDubboTag = StringUtils.hasText(dubboTag);</span><br><span class="line">        <span class="keyword">if</span> (hasDubboTag) &#123;</span><br><span class="line">            invocation.setAttachment(CommonConstants.TAG_KEY, dubboTag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理</span></span><br><span class="line">            <span class="keyword">if</span> (hasDubboTag) &#123;</span><br><span class="line">                DubboRouterTagContextHolder.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件路由"><a href="#条件路由" class="headerlink" title="条件路由"></a>条件路由</h3><p>[服务消费者匹配条件] =&gt; [服务提供者匹配条件]  如 host = 10.20.153.10 =&gt; host = 10.20.153.11</p><h5 id="向注册中心写入路由规则：-通常由监控中心或治理中心的页面完成"><a href="#向注册中心写入路由规则：-通常由监控中心或治理中心的页面完成" class="headerlink" title="向注册中心写入路由规则：(通常由监控中心或治理中心的页面完成)"></a>向注册中心写入路由规则：(通常由监控中心或治理中心的页面完成)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">&quot;condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=&quot;</span> + URL.encode(<span class="string">&quot;http://10.20.160.198/wiki/display/dubbo/host = 10.20.153.10 =&gt; host = 10.20.153.11&quot;</span>) + <span class="string">&quot;));</span></span><br></pre></td></tr></table></figure><ul><li>condition:// 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填。</li><li>0.0.0.0 表示对所有IP地址生效，如果只想对某个IP的生效，请填入具体IP，必填。</li><li>com.foo.BarService 表示只对指定服务生效，必填。</li><li>category=routers 表示该数据为动态配置类型，必填。</li><li>dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。</li><li>enabled=true 覆盖规则是否生效，可不填，缺省生效。</li><li>force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为flase。</li><li>runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。 如果用了参数路由，必须设为true，需要注意设置会影响调用的性能，可不填，缺省为flase。</li><li>priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为0。</li><li>rule=URL.encode(“host = 10.20.153.10 =&gt; host = 10.20.153.11”) 表示路由规则的内容，必填。</li></ul><h4 id="条件路由规则"><a href="#条件路由规则" class="headerlink" title="条件路由规则"></a>条件路由规则</h4><p>基于条件表达式的路由规则，如：<code>host = 10.20.153.10 =&gt; host = 10.20.153.11</code></p><p>规则：</p><ul><li>“=&gt;”之前的为消费者匹配条件，所有参数和消费者的URL进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。</li><li>“=&gt;”之后为提供者地址列表的过滤条件，所有参数和提供者的URL进行对比，消费者最终只拿到过滤后的地址列表。</li><li>如果匹配条件为空，表示对所有消费方应用，如：=&gt; host != 10.20.153.11</li><li>如果过滤条件为空，表示禁止访问，如：host = 10.20.153.10 =&gt;</li></ul><p>表达式：</p><ul><li>参数支持：<ul><li>服务调用信息，如：method, argument 等 (暂不支持参数路由)</li><li>URL本身的字段，如：protocol, host, port 等</li><li>以及URL上的所有参数，如：application, organization 等</li></ul></li><li>条件支持：<ul><li>等号 <code>=</code> 表示”匹配”，如：host = 10.20.153.10</li><li>不等号 <code>!=</code> 表示”不匹配”，如：host != 10.20.153.10</li></ul></li><li>值支持：<ul><li>以逗号 <code>,</code> 分隔多个值，如：host != 10.20.153.10,10.20.153.11</li><li>以星号 <code>*</code> 结尾，表示通配，如：host != 10.20.*</li><li>以美元符 <code>$</code> 开头，表示引用消费者参数，如：host = $host</li></ul></li></ul><p>示例：</p><ol><li><p>排除预发布机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; host !&#x3D; 172.22.3.91</span><br></pre></td></tr></table></figure></li><li><p>白名单： 注意：一个服务只能有一条白名单规则，否则两条规则交叉，就都被筛选掉了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host !&#x3D; 10.20.153.10,10.20.153.11 &#x3D;&gt;</span><br></pre></td></tr></table></figure></li><li><p>黑名单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host &#x3D; 10.20.153.10,10.20.153.11 &#x3D;&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务寄宿在应用上，只暴露一部分的机器，防止整个集群挂掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; host &#x3D; 172.22.3.1*,172.22.3.2*</span><br></pre></td></tr></table></figure></li><li><p>为重要应用提供额外的机器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application !&#x3D; kylin &#x3D;&gt; host !&#x3D; 172.22.3.95,172.22.3.96</span><br></pre></td></tr></table></figure></li><li><p>读写分离：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method &#x3D; find*,list*,get*,is* &#x3D;&gt; host &#x3D; 172.22.3.94,172.22.3.95,172.22.3.96</span><br><span class="line">method !&#x3D; find*,list*,get*,is* &#x3D;&gt; host &#x3D; 172.22.3.97,172.22.3.98</span><br></pre></td></tr></table></figure></li><li><p>前后台分离：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application &#x3D; bops &#x3D;&gt; host &#x3D; 172.22.3.91,172.22.3.92,172.22.3.93</span><br><span class="line">application !&#x3D; bops &#x3D;&gt; host &#x3D; 172.22.3.94,172.22.3.95,172.22.3.96</span><br></pre></td></tr></table></figure></li><li><p>隔离不同机房网段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host !&#x3D; 172.22.3.* &#x3D;&gt; host !&#x3D; 172.22.3.*</span><br></pre></td></tr></table></figure></li><li><p>提供者与消费者部署在同集群内，本机只访问本机的服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; host &#x3D; $host</span><br></pre></td></tr></table></figure></li></ol><h5 id="admin上配置条件路由"><a href="#admin上配置条件路由" class="headerlink" title="admin上配置条件路由"></a>admin上配置条件路由</h5><h3 id="脚本路由"><a href="#脚本路由" class="headerlink" title="脚本路由"></a>脚本路由</h3><p>支持JDK脚本引擎的所有脚本，比如：javascript, jruby, groovy 等，通过 type=javascript 参数设置脚本类型，缺省为javascript。</p><p>脚本没有沙箱约束，可执行任意代码，存在后门风险。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(&quot;script:&#x2F;&#x2F;0.0.0.0&#x2F;com.foo.BarService?category&#x3D;routers&amp;dynamic&#x3D;false&amp;rule&#x3D;&quot; + URL.encode(&quot;function route(invokers) &#123; ... &#125; (invokers)&quot;);</span><br><span class="line"></span><br><span class="line">function route(invokers) &#123;</span><br><span class="line">    var result &#x3D; new java.util.ArrayList(invokers.size());</span><br><span class="line">    for (i &#x3D; 0; i &lt; invokers.size(); i ++) &#123;</span><br><span class="line">        if (&quot;http:&#x2F;&#x2F;10.20.160.198&#x2F;wiki&#x2F;display&#x2F;dubbo&#x2F;10.20.153.10&quot;.equals(invokers.get(i).getUrl().getHost())) &#123;</span><br><span class="line">            result.add(invokers.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125; (invokers); &#x2F;&#x2F; 表示立即执行方法</span><br></pre></td></tr></table></figure><h2 id="Dubbo服务限流"><a href="#Dubbo服务限流" class="headerlink" title="Dubbo服务限流"></a>Dubbo服务限流</h2><p>为了防止某个消费者的QPS或是所有消费者的QPS总和突然飙升而导致的重要服务的失效，系统可以对访问流量进行控制，这种对集群的保护措施称为服务限流。<br>Dubbo中能够实现服务限流的方式较多，可以划分为两类：<strong>直接限流</strong>与<strong>间接限流</strong></p><ul><li><p>直接限流：通过对连接数量直接进行限制来达到限流的目的。（官方方案汇总）</p><ul><li><p>服务提供者executes：指定并发执行数量</p></li><li><p>服务提供者accepts，协议级全局范围:指定连接数量</p></li><li><p>二端可以配置actives：长连接，最多可以处理或提交的请求个数。短连接，可以同时处理或提交的短连接数量。</p></li><li><p>二端可以配置connections：长连接，限定连接的个数。短连接，可以同时处理或提交的短连接数量。</p></li><li><p>会使connectons与actives联用，让connections限制长连接个数，让actives限制一个长连接中可以处理的请求个数。联用前提：使用默认的Dubbo服务暴露协议</p></li></ul></li><li><p>间接限流：通过一些非连接数量设置来达到限制流量的目的。</p><ul><li><p>延迟连接 – 仅消费者端，lazy=”true”，不能设置为方法级别，仅作用于Dubbo服务暴露协议。将长连接的建立推迟到消费者真正调用提供者时</p></li><li><p>粘连连接 – 仅消费者，sticky=”true”，使客户端尽量向同一个提供者发起调用，只要启用了粘连连接，其就会自动启用延迟连接</p></li></ul></li></ul><h3 id="executes直接限流–-仅提供者端"><a href="#executes直接限流–-仅提供者端" class="headerlink" title="executes直接限流– 仅提供者端"></a>executes直接限流– 仅提供者端</h3><p>该属性仅能设置在提供者端。可以设置为接口级别，也可以设置为方法级别。限制的是服务（方法）并发执行数量。一旦超出指定的数目直接报错 其实是指在服务端的并行度【需要注意这些都是指的是在单台服务上而不是整个服务集群】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 类级别，服务器端并发执行（或占用线程池线程数）不能超过 10 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">executes</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方法级别，服务器端并发执行（或占用线程池线程数）不能超过 10 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">executes</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="accepts限流-–-仅提供者端"><a href="#accepts限流-–-仅提供者端" class="headerlink" title="accepts限流 – 仅提供者端"></a>accepts限流 – 仅提供者端</h3><p>该属性仅可设置在提供者端的<a href="dubbo:provider/">dubbo:provider/</a>与<a href="dubbo:protocol/">dubbo:protocol/</a>。用于对指定协议的连接数量进行限制。拦截器类为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--限制当前提供者在使用dubbo协议时最多可以接受10个消费者链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">accepts</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> <span class="attr">accepts</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="tps限流-仅服务端"><a href="#tps限流-仅服务端" class="headerlink" title="tps限流-仅服务端"></a>tps限流-仅服务端</h3><p>该属性仅可以配置在服务端，拦截器类为TpsLimitFilter。获取tps允许调用次数和tps.interval请求间隔。使用AtomicInteger表示允许调用的次数 每次调用减少1次当结果小于0之后返回不允许调用</p><h3 id="actives限流-–-两端"><a href="#actives限流-–-两端" class="headerlink" title="actives限流 – 两端"></a>actives限流 – 两端</h3><p>该限流方式与前两种不同的是，其可以设置在提供者端，也可以设置在消费者端。可以设置为接口级别，也可以设置为方法级别。拦截器类为ActiveLimitFilter。很明显当超过了指定的active值之后该请求将等待前面的请求完成【何时结束呢？依赖于该方法的timeout 如果没有设置timeout的话可能就是多个请求一直被阻塞然后等待随机唤醒吧……】。因此要搭配timeout一起使用噢！</p><h5 id="提供者端限流"><a href="#提供者端限流" class="headerlink" title="提供者端限流"></a><strong>提供者端限流</strong></h5><p>根据消费者与提供者间建立的连接类型的不同，其意义也不同</p><ul><li>长连接：表示当前长连接最多可以处理的请求个数。与长连接的数量没有关系</li><li>短连接：表示当前服务可以同时处理的短连接数量</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--类级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">actives</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方法级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">actives</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>消费者端限流</strong></p><p>根据消费者与提供者间建立的连接类型的不同，其意义也不同：</p><ul><li>长连接：表示当前消费者所发出的长连接中最多可以提交的请求个数。与长连接的数量没有关系。</li><li>短连接：表示当前消费者可以提交的短连接数量</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--类级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">actives</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方法级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">actives</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="connections限流"><a href="#connections限流" class="headerlink" title="connections限流"></a>connections限流</h3><p>可以设置在提供者端，也可以设置在消费者端。限定连接的个数。对于短连接，该属性效果与actives相同。但对于长连接，其限制的是长连接的个数。一般情况下，会使connectons与actives联用，让connections限制长连接个数，让actives限制一个长连接中可以处理的请求个数。联用前提：使用默认的Dubbo服务暴露协议</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="间接限流-延迟连接-–-仅消费者端"><a href="#间接限流-延迟连接-–-仅消费者端" class="headerlink" title="间接限流 延迟连接 – 仅消费者端"></a>间接限流 <strong>延迟连接 – 仅消费者端</strong></h3><p>仅可设置在消费者端，且不能设置为方法级别。仅作用于Dubbo服务暴露协议。将长连接的建立推迟到消费者真正调用提供者时。<br>可以减少长连接的数量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前消费者对接口中的每个方法发出链接采用延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span>  <span class="attr">lazy</span>=<span class="string">&quot;true&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.dubbo.service.UserService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">lazy</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:consumer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="间接限流-粘连连接-–-仅消费者"><a href="#间接限流-粘连连接-–-仅消费者" class="headerlink" title="间接限流 粘连连接 – 仅消费者"></a>间接限流 <strong>粘连连接 – 仅消费者</strong></h3><p>仅能设置在消费者端，其可以设置为接口级别，也可以设置为方法级别。仅作用于Dubbo服务暴露协议。其会使客户端尽量向同一个提供者发起调用，除非该提供者挂了，其会连接另一台。只要启用了粘连连接，其就会自动启用延迟连接其限制的是流向，而非流量</p><h2 id="端口监控"><a href="#端口监控" class="headerlink" title="端口监控"></a>端口监控</h2><p>netstat -an |grep 18220 | wc -l</p><p>netstat -an |grep 18220</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>连接个数：单连接<br>连接方式：长连接</p><p>传输协议：TCP<br>传输方式：NIO 异步传输</p>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logstash简单使用</title>
      <link href="2021/01/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%97%A5%E5%BF%97Logstash%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/01/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%97%A5%E5%BF%97Logstash%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="使用mysql作为input"><a href="#使用mysql作为input" class="headerlink" title="使用mysql作为input"></a>使用mysql作为input</h2><blockquote><p>下载logstash</p></blockquote><p><a href="https://www.elastic.co/cn/downloads/logstash">logstash官网</a></p><blockquote><p>解压文件，并在其根目录下创建<code>mysqletc</code>文件夹（名称随意），在<code>mysqletc</code>文件夹下创建<code>mysql.conf</code>（名称随意）</p></blockquote><p>在<code>mysql.conf</code>配置文件中写入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  jdbc &#123;</span><br><span class="line">    # 数据库连接语句</span><br><span class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/springboot_es?characterEncoding=UTF8&quot;</span><br><span class="line">    jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">    jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">    # mysql-connection驱动的绝对路径</span><br><span class="line">    jdbc_driver_library =&gt; &quot;/develop/software/logstash-6.6.2/mysqletc/mysql-connector-java-5.1.47.jar&quot;</span><br><span class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">    jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">    # SQL查询语句，用于将查询到的数据导入到ElasticSearch</span><br><span class="line">    statement =&gt; &quot;select id,title,content from tb_article&quot;</span><br><span class="line">    # 定时任务，各自表示：分 时 天 月 年 。全部为 * 默认每分钟执行</span><br><span class="line">    schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">    # 索引名称</span><br><span class="line">    index =&gt; &quot;aritcleindex&quot;</span><br><span class="line">    # 自增ID编号</span><br><span class="line">    document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">    # 文档名称</span><br><span class="line">    document_type =&gt; &quot;article&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    # JSON格式输出</span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成，找一个<code>mysql-connection.jar</code>包拷贝到<code>/mysqletc/</code>根目录下，并修改配置文件中的<code>jdbc_driver_library</code>路径地址。</p><blockquote><p>创建数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> springboot_es <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> utf8;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`tb_article`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_article`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;文章标题&#x27;</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;文章内容&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tb_article`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;测试&#x27;</span>, <span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tb_article`</span> <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;测试啊&#x27;</span>, <span class="string">&#x27;测试啊&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>在终端中切换到<code>logstash</code>根目录下</p></blockquote><p>执行<code>logstash -f ../mysqletc/mysql.conf</code>：</p><p>并且查询语句会每分钟执行一次。</p>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Logstash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料汇总</title>
      <link href="2021/01/04/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
      <url>2021/01/04/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000021340649">https://segmentfault.com/a/1190000021340649</a></p><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p><a href="https://github.com/spring-projects/spring-boot">spring-boot</a>推荐指数：★Star44.1K</p><p>推荐语：从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。具有如下特性：创建独立的Spring应用程序、嵌入的Tomcat，无需部署WAR文件、简化Maven配置、自动配置Spring、提供生产就绪型功能，如指标，健康检查和外部配置、绝对没有代码生成和对XML没有要求配置。</p><p><a href="https://developer.aliyun.com/special/tech-java">Java 开发手册</a>    推荐指数：★★★★★</p><p>推荐语：这部手册始于阿里内部规约，在全球 Java 开发者共同努力下，已成为业界普遍遵循的开发规范，内容涵盖编程规约、异常日志、单元测试、安全规约、MySQL 数据库、工程规约、设计规约共七大维度。</p><p><a href="https://github.com/Snailclimb/JavaGuide">Java学习+面试指南-JavaGuide</a>  推荐指数：★Star64.7K</p><p>推荐语：【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。</p><p><a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a>     推荐指数：★Star53.6K</p><p>推荐语：史上最全的用Java实现的设计模式。</p><p><a href="https://github.com/xingshaocheng/architect-awesome">architect-awesome</a>     推荐指数：★Star40.2K</p><p>推荐语：史上最全的后端架构师技术图谱。</p><p><a href="https://github.com/doocs/advanced-java">后端同学进阶必看的advanced-java</a>     推荐指数：★Star35.3K</p><p>推荐语：本系列知识出自中华石杉，可以作为互联网 Java 工程师进阶知识完全扫盲。学习本系列知识之前，如果你完全没接触过 MQ、ES、Redis、Dubbo、Hystrix 等，那么我建议你可以先在网上搜一下每一块知识的快速入门，跟着入门 Demo 玩一下，然后再开始每一块知识的学习，这样效果更好。</p><p><a href="https://github.com/akullpp/awesome-java">akullpp发起维护的Java资源列表-awesome</a>   推荐指数：23.2K</p><p>推荐语：awesome项目是github的一个神奇项目，awesome-java 就是akullpp发起维护的Java资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等</p><p><a href="https://github.com/seata/seata">基于Java的开源分布式事务解决方案-Seata</a>    推荐指数：★Star13.1K</p><p>推荐语：Seata是一种易于使用，高性能，基于Java的开源分布式事务解决方案，旨在实现简单并快速的事务提交与回滚。</p><p><a href="https://github.com/macrozheng/mall">基于SpringBoot+MyBatis实现-mall电商系统</a>     推荐指数：★Star26.4K</p><p>推荐语：mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。</p><p><a href="https://github.com/qiurunze123/miaosha">基于MQ、SpringBoot、Redis、Dubbo的秒杀系统</a>   推荐指数：★Star11.6K</p><p>推荐语：该项目是对高并发大流量如何进行秒杀架构，而做的一个系统整理，如果你完全没接触过 MQ、SpringBoot、Redis、Dubbo、ZK 、Maven,lua等，那么我建议你可以先在网上搜一下每一块知识的快速入门</p><p><a href="https://github.com/apache/flink">数据分析开源系统-Apache Flink</a>   推荐指数：★Star11.4K</p><p>推荐语：Apache Flink 声明式的数据分析开源系统，结合了分布式 MapReduce 类平台的高效，灵活的编程和扩展性。同时在并行数据库发现查询优化方案。</p><p><a href="https://github.com/wuyouzhuguli/SpringAll">SpringAll</a>   推荐指数：★Star11.4K</p><p>推荐语：包括了Spring Boot，Spring Boot＆Shiro，Spring Cloud，Spring Boot＆Spring Security＆Spring Security OAuth2等系列教程。</p><p><a href="https://github.com/crossoverJie/cim">一款面向开发者的 IM(即时通讯)系统-CIM(CROSS-IM)</a>   推荐指数：★Star4.4K</p><p>推荐语：CIM(CROSS-IM) 一款面向开发者的 IM(即时通讯)系统；同时提供了一些组件帮助开发者构建一款属于自己可水平扩展的 IM 。借助 CIM 你可以实现以下需求：IM 即时通讯系统、适用于 APP 的消息推送中间件、IOT 海量连接场景中的消息透传中间件。</p><p><a href="https://github.com/alibaba/arthas">阿里巴巴Java诊断工具Arthas</a>    推荐指数：★Star18.5K</p><p>推荐语：Arthas旨在帮助开发人员解决Java应用程序的生产问题，无需修改代码或重新启动服务器。有了Arthas，你就可以在不重新启动JVM或需要额外的代码更改的情况下实时地对问题进行故障排除。</p><p><a href="https://github.com/eugenp/tutorials">基于Spring Framework（和Spring Security）的教程</a>    推荐指数：★Star18.5K</p><p>推荐语：该项目是一系列小而专注的教程，每个教程都涵盖一个明确的开发领域。大多数教程项目都专注于Spring Framework（和Spring Security）。以下技术是重点：core Java，Jackson，HttpClient，Guava。</p><p><a href="https://github.com/lenve/vhr">基于SpringBoot+Vue开发的人力资源管理系统-vhr</a>   推荐指数：★Star12.3K</p><p>推荐语：一个前后端分离的人力资源管理系统，采用SpringBoot+Vue开发。这个项目的权限管理模块已经开发完成，其他模块还在开发当中。可以管理角色和资源的关系，管理用户和角色的关系。</p><p><a href="https://github.com/hollischuang/toBeTopJavaer">To Be Top Javaer - Java工程师成神之路</a>   推荐指数：★Star9.9K</p><p>推荐语：Java工程师成神之路。总结的很好，直接理解学习就完了。</p><p><a href="https://github.com/kdn251/interviews">软件工程技术面试个人指南-interviews</a>     推荐指数：★Star40.8K</p><p>推荐语：软件工程技术面试个人指南。可以这里找到针对很多面试问题的视频解决方案以及详细说明。</p><p><a href="https://github.com/zhangdaiscott/jeecg-boot">基于代码生成器的JAVA快速开发平台-jeecg-boot</a>    推荐指数：★Star8.5K</p><p>推荐语：一款基于代码生成器的JAVA快速开发平台！全新架构前后端分离：SpringBoot 2.x，Ant Design&amp;Vue，Mybatis，Shiro，JWT。强大的代码生成器让前后端代码一键生成，无需写任何代码，绝对是全栈开发的福音！</p><p><a href="https://github.com/forezp/SpringCloudLearning">史上最简单的Spring Cloud教程源码</a>     推荐指数：★Star11.5K</p><p>推荐语：@方志朋“史上最简单的SpringCloud教程”系列，包括Spring Cloud阿里巴巴教程、格林威治版本、芬奇利版本、源码篇、进阶篇、d版本、番外篇等</p><p><a href="https://github.com/alibaba/fastjson">阿里巴巴 的开源项目-fastjson</a>     推荐指数：★Star20.2K</p><p>推荐语：@阿里巴巴 的开源项目，Fastjson是一个Java库，可用于将Java对象转换为其JSON表示，还可用于将JSON字符串转换为等效的Java对象。</p><p><a href="https://github.com/alibaba/nacos">阿里巴巴 的开源项目-nacos</a>    推荐指数：★Star9.7K</p><p>推荐语：@阿里巴巴 的开源项目，<a href="https://link.zhihu.com/?target=http://nacos.io/">Nacos</a>是一个易于使用的平台，专为动态服务发现，配置和服务管理而设计。它可以帮助使用者轻松构建云本机应用程序和微服务平台。</p><p><a href="https://github.com/spring-projects/spring-framework">spring-framework</a>    推荐指数：★Star34.1K</p><p>推荐语：与<a href="https://link.zhihu.com/?target=https://github.com/spring-projects/spring-boot">spring-boot</a>同样是非常值得学习的项目。</p><p><a href="https://github.com/alibaba/p3c">阿里巴巴 p3c项目</a>    推荐指数：★Star19.5K</p><p>推荐语：是@阿里巴巴 p3c项目组进行研发。根据《阿里巴巴Java开发规范》转化而成的自动化插件，并且实现了部分自动编程。</p><p><a href="https://github.com/apache/dubbo">基于Java的高性能开源RPC框架-dubbo</a>   推荐指数：★Star30.4K</p><p>推荐语：Apache Dubbo是一个基于Java的高性能开源RPC框架。</p><p><a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a>    推荐指数：★Star53.5K</p><p>推荐语：设计模式是程序员在设计应用程序或系统时可用于解决常见问题的最佳形式化实践。重用设计模式有助于防止导致重大问题的细微问题，并且还可以提高熟悉模式的编码人员和架构师的代码可读性。</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba">spring-cloud-alibaba</a>    推荐指数：★Star10.8K</p><p>推荐语：由@阿里巴巴 维护的项目，它为分布式应用程序开发提供一站式解决方案，包含开发分布式应用程序所需的所有组件，使用者可以轻松地使用Spring Cloud开发应用程序。</p><p><a href="https://github.com/eugenp/tutorials">Spring 教程-tutorials</a>   推荐指数：★Star18.5K</p><p>推荐语：每个教程都涵盖Java生态系统中单一且定义明确的开发领域。当然，它们的重点是Spring Framework - Spring，Spring Boot和Spring Security。</p><p><a href="https://github.com/dianping/cat">服务端项目基础组件-cat</a>    推荐指数：★Star12.3K</p><p>推荐语：作为服务端项目基础组件，cat提供了 Java, C/C++, Node.js, Python, Go 等多语言客户端，已经在美团点评的基础架构中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等，消息队列，配置系统等）深度集成，为美团点评各业务线提供系统丰富的性能指标、健康状况、实时告警等。</p><p><a href="https://github.com/TheAlgorithms/Java">算法-Java</a>    推荐指数：★Star20.4K</p><p>推荐语：适合用Java编程的算法学习者。</p><p><a href="https://github.com/google/guava">Google Java核心库</a>    推荐指数：★Star35.1K</p><p>推荐语：包括新的集合类型（例如多图和多集），不可变集合，图形库以及用于并发，I / O，哈希，基元，字符串等的实用程序！</p><p><a href="https://github.com/giantray/stackoverflow-java-top-qa">StackOverflow Java Top100问题（翻译）</a> 推荐指数：★Star4.9K</p><p>推荐语：对阅读本项目的人来说：1.巩固基础。top100问题都是比较重要、基础的问题；而且也都是so上很多人优化和投票的，很靠谱。2.快速学习知识。相对英文原文，本项目的翻译有两个优点：（1）是中文母语，能更好理解；（2）翻译时会对原文做精简，多个答案做整合，阅读起来更有效率。</p><p><a href="https://github.com/AobingJava/JavaFamily">JavaFamily </a>     推荐指数：★Star3.8K</p><p>推荐语：【互联网一线大厂面试+学习指南】进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识。</p><p><a href="https://github.com/brianway/java-learning">java-learning</a>     推荐指数：★Star3.3K</p><p>推荐语：作者的Java学习笔记。笔记内容主要是对一些基础特性和编程细节进行总结整理，适合了解Java基础语法，想进一步深入学习的人。含博客讲解和二进制实例，采用maven构建，分模块学习，涉及反射，代理，多线程，IO，集合类等核心知识。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql之分区及分库分表</title>
      <link href="2020/12/24/mysql%E4%B9%8B%E5%88%86%E5%8C%BA%E5%8F%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>2020/12/24/mysql%E4%B9%8B%E5%88%86%E5%8C%BA%E5%8F%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是表分区"><a href="#什么是表分区" class="headerlink" title="什么是表分区"></a><strong>什么是表分区</strong></h2><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p><h2 id="表分区与分表的区别"><a href="#表分区与分表的区别" class="headerlink" title="表分区与分表的区别"></a><strong>表分区与分表的区别</strong></h2><p><strong>分表</strong>：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。</p><p><strong>分表与分区的区别在于</strong>：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p><h2 id="表分区有什么好处"><a href="#表分区有什么好处" class="headerlink" title="表分区有什么好处"></a><strong>表分区有什么好处</strong></h2><p>1、<strong>存储更多数据</strong>。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据</p><p>2、<strong>优化查询</strong>。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</p><p>3、<strong>分区表更容易维护</strong>。例如：想批量删除大量数据可以清除整个分区。</p><p>4、<strong>避免某些特殊的瓶颈</strong>，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</p><h2 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a><strong>分区表的限制因素</strong></h2><ol><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ol><h2 id="如何判断当前MySQL是否支持分区"><a href="#如何判断当前MySQL是否支持分区" class="headerlink" title="如何判断当前MySQL是否支持分区"></a><strong>如何判断当前MySQL是否支持分区</strong></h2><p>命令：show variables like ‘%partition%’ 运行结果:  have_partintioning 的值为YES，表示支持分区。</p><h2 id="MySQL支持的分区类型有哪些"><a href="#MySQL支持的分区类型有哪些" class="headerlink" title="MySQL支持的分区类型有哪些"></a><strong>MySQL支持的分区类型有哪些</strong></h2><ol><li><strong>RANGE分区</strong>： 这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li><strong>LIST分区</strong>： 这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li><strong>HASH分区</strong> ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li><strong>KEY分区</strong> ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ol><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><ul><li>表字段拆分</li><li>业务拆分</li></ul><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>分表-》分库</p><h2 id="水平拆分实例"><a href="#水平拆分实例" class="headerlink" title="水平拆分实例"></a>水平拆分实例</h2><p>当业务规模达到一定规模之后，像淘宝日订单量在5000万单以上，美团3000万单以上。数据库面对海量的数据压力，分库分表就是必须进行的操作了。而分库分表之后一些常规的查询可能都会产生问题，最常见的就是比如分页查询的问题。一般我们把分表的字段称作shardingkey，比如订单表按照用户ID作为shardingkey，那么如果查询条件中不带用户ID查询怎么做分页？又比如更多的多维度的查询都没有shardingkey又怎么查询？</p><h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><p>一般我们数据库的主键都是自增的，那么分表之后主键冲突的问题就是一个无法避免的问题，最简单的办法就是以一个唯一的业务字段作为唯一的主键，比如订单表的订单号肯定是全局唯一的。</p><p>常见的分布式生成唯一ID的方式很多，最常见的雪花算法Snowflake、滴滴Tinyid、美团Leaf。以雪花算法举例来说，一毫秒可以生成4194304多个ID。</p><p>第一位不使用，默认都是0，41位时间戳精确到毫秒，可以容纳69年的时间，10位工作机器ID高5位是数据中心ID，低5位是节点ID，12位序列号每个节点每毫秒累加，累计可以达到2^12 4096个ID。</p><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>第一步，分表后要怎么保证订单号的唯一搞定了，现在考虑下分表的问题。首先根据自身的业务量和增量来考虑分表的大小。</p><p>举个例子，现在我们日单量是10万单，预估一年后可以达到日100万单，根据业务属性，一般我们就支持查询半年内的订单，超过半年的订单需要做归档处理。</p><p>那么以日订单100万半年的数量级来看，不分表的话我们订单量将达到100万X180=1.8亿，以这个数据量级部分表的话肯定单表是扛不住的，就算你能扛RT的时间你也根本无法接受吧。根据经验单表几百万的数量对于数据库是没什么压力的，那么只要分256张表就足够了，1.8亿/256≈70万，如果为了保险起见，也可以分到512张表。那么考虑一下，如果业务量再增长10倍达到1000万单每天，分表1024就是比较合适的选择。</p><p>通过分表加上超过半年的数据归档之后，单表70万的数据就足以应对大部分场景了。接下来对订单号hash，然后对256取模的就可以落到具体的哪张表了。</p><p><img src="/2020/12/24/mysql%E4%B9%8B%E5%88%86%E5%8C%BA%E5%8F%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/%E5%88%86%E8%A1%A8.jpg" alt="img"></p><p>那么，因为唯一主键都是以订单号作为依据，以前你写的那些根据主键ID做查询的就不能用了，这就涉及到了历史一些查询功能的修改。不过这都不是事儿对吧，都改成以订单号来查就行了。这都不是问题，问题在我们的标题说的点上。</p><h3 id="C端查询"><a href="#C端查询" class="headerlink" title="C端查询"></a>C端查询</h3><p>说了半天，总算到了正题了，那么分表之后查询和分页查询的问题怎么解决？</p><p>首先说带shardingkey的查询，比如就通过订单号查询，不管你分页还是怎么样都是能直接定位到具体的表来查询的，显然查询是不会有什么问题的。</p><p>如果不是shardingkey的话，上面举例说的以订单号作为shardingkey的话，像APP、小程序这种一般都是通过用户ID查询，那这时候我们通过订单号做的sharding怎么办？很多公司订单表直接用用户ID做shardingkey，那么很简单，直接查就完了。那么订单号怎么办，一个很简单的办法就是在订单号上带上用户ID的属性。举个很简单的例子，原本41位的时间戳你觉得用不完，用户ID是10位的，订单号的生成规则带上用户ID，落具体表的时候根据订单号中10位用户ID hash取模，这样无论根据订单号还是用户ID查询效果都是一样的。</p><p>当然，这种方式只是举例，具体的订单号生成的规则，多少位，包含哪些因素根据自己的业务和实现机制来决定。</p><p>好，那么无论你是订单号还是用户ID作为shardingkey，按照以上的两种方式都可以解决问题了。那么还有一个问题就是如果既不是订单号又不是用户ID查询怎么办？最直观的例子就是来自商户端或者后台的查询，商户端都是以商户或者说卖家的ID作为查询条件来查的，后台的查询条件可能就更复杂了，像我碰到的有些后台查询条件能有几十个，这怎么查？？？别急，接下来分开说B端和后台的复杂查询。</p><p>现实中真正的流量大头都是来自于用户端C端，所以本质上解决了用户端的问题，这个问题就解了大半，剩下来自商户卖家端B端、后台支持运营业务的查询流量并不会很大，这个问题就好解。</p><h3 id="其他端查询"><a href="#其他端查询" class="headerlink" title="其他端查询"></a>其他端查询</h3><p>针对B端的非shardingkey的查询有两个办法解决。</p><p>双写，双写就是下单的数据落两份，C端和B端的各自保存一份，C端用你可以用单号、用户ID做shardingkey都行，B端就用商家卖家的ID作为shardingkey就好了。有些同学会说了，你双写不影响性能吗？因为对于B端来说轻微的延迟是可以接受的，所以可以采取异步的方式去落B端订单。你想想你去淘宝买个东西下单了，卖家稍微延迟个一两秒收到这个订单的消息有什么关系吗？你点个外卖商户晚一两秒收到这个订单有什么太大影响吗？</p><p><img src="/2020/12/24/mysql%E4%B9%8B%E5%88%86%E5%8C%BA%E5%8F%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/%E5%8F%8C%E5%86%99.jpg" alt="img"></p><p>这是一个解决方案，另外一个方案就是走离线数仓或者ES查询，订单数据落库之后，不管你通过binlog还是MQ消息的都形式，把数据同步到数仓或者ES，他们支持的数量级对于这种查询条件来说就很简单了。同样这种方式肯定是稍微有延迟的，但是这种可控范围的延迟是可以接受的。</p><p>而针对管理后台的查询，比如运营、业务、产品需要看数据，他们天然需要复杂的查询条件，同样走ES或者数仓都可以做得到。如果不用这个方案，又要不带shardingkey的分页查询，兄弟，这就只能扫全表查询聚合数据，然后手动做分页了，但是这样查出来的结果是有限制的。</p><p>比如你256个片，查询的时候循环扫描所有的分片，每个片取20条数据，最后聚合数据手工分页，那必然是不可能查到全量的数据的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分库分表后的查询问题，对于有经验的同学来说其实这个问题都知道，但是我相信其实大部分同学做的业务可能都没来到这个数量级，分库分表可能都停留在概念阶段，面试被问到后就手足无措了，因为没有经验不知道怎么办。</p><p>分库分表首先是基于现有的业务量和未来的增量做出判断，比如拼多多这种日单量5000万的，半年数据得有百亿级别了，那都得分到4096张表了对吧，但是实际的操作是一样的，对于你们的业务分4096那就没有必要了，根据业务做出合理的选择。</p><p>对于基于shardingkey的查询我们可以很简单的解决，对于非shardingkey的查询可以通过落双份数据和数仓、ES的方案来解决，当然，如果分表后数据量很小的话，建好索引，扫全表查询其实也不是什么问题。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql之锁</title>
      <link href="2020/12/24/mysql%E4%B9%8B%E9%94%81/"/>
      <url>2020/12/24/mysql%E4%B9%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>锁定整个表，表级别的共享锁和排他锁。如 <code>LOCK TABLES ... WRITE/READ</code> 等命令，实现的就是表级锁。</p><p>在 InnoDB 中是支持多粒度的锁共存的，比如表锁和行锁。而 Intention Locks - 意向锁，就是表级锁。和行级锁一样，意向锁分为 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_intention_shared_lock">intention shared lock</a> (<code>IS</code>) 和 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_intention_exclusive_lock">intention exclusive lock</a> (<code>IX</code>) . 但有趣的是，IS 和 IX 之间并不互斥，也就是说可以同时给不同的事务加上 IS 和 IX. 兼容性如下：<br><img src="/2020/12/24/mysql%E4%B9%8B%E9%94%81/1861307-20200308182522643-1705968057.png" alt="img"></p><p>这里的X锁和S锁和行锁没关系，指的是表级别的共享锁和排它锁。</p><h3 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h3><p>意向锁的目的就是表明有事务正在或者将要锁住某个表中的行。</p><p>想象这样一个场景，我们使用 <code>select * from t where id=0 for update;</code> 将 id=0 这行加上了写锁。假设同时，一个新的事务想要发起 <code>LOCK TABLES ... WRITE</code> 锁表的操作，这时如果没有意向锁的话，就需要去一行行检测是否所在表中的某行是否存在写锁，从而引发冲突，效率太低。相反有意向锁的话，在发起 <code>lock in share mode</code> 或者 <code>for update</code> 前就会自动加上意向锁，这样检测起来就方便多了。</p><p>在实际中，手动锁表的情况并不常见，所以意向锁并不常用。特别是之后 MySQL 引入了 <a href="https://www.cnblogs.com/michael9/p/12167434.html#_label1_2">MDL 锁</a>，解决了 DML 和 DDL 冲突的问题，意向锁就更不被提起来了。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>共享锁和排他锁，就是我们常说的读锁和写锁。<strong>共享锁和排他锁是标准的实现行级别的锁。</strong>Innodb支持行级锁。每一个索引对应一颗 B+ 树，这里的行锁锁的就是 B+ 中的索引记录。之前提到的共享锁和排他锁，就是将锁加在这里。</p><p>当给 select 语句应用 <code>lock in share mode</code> 或者 <code>for update</code>，或者更新、删除某条记录时，加的都是行级别的锁。</p><ul><li>RR隔离级别下条件字段不是索引，则会锁表；是索引则锁行。</li><li>RC隔离级别下， <code>lock in share mode</code> 或者 <code>for update</code>，会先全表扫描，先加锁，符合查询条件的数据则加锁，不符合查询条件的数据释放锁；update或者delete时，使用半一致性读，提高 RC 并发，如果一个行被锁上后，通过返回最近的 commit 版本，来判断当前锁定的行是否符合 WHERE 条件。如果不匹配，不会对该记录加锁，如果匹配，会再次读取该行进行加锁或者阻塞来等待锁定该行。<font color="red">半一致性读仅发生在 RC 或者开启 innodb_locks_unsafe_for_binlog 的情况下。</font></li></ul><h3 id="读锁和写锁"><a href="#读锁和写锁" class="headerlink" title="读锁和写锁"></a>读锁和写锁</h3><p>有些情况下为了保证数据逻辑的一致性，需要对SELECT的操作加锁。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、  SELECT …… FOR UPDATE</span><br><span class="line">2、  SELECT …… LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure><p>其中，SELECT …… FOR UPDATE对读取的记录加一个锁，其他事务不能对已锁定的行加任何锁。而SELECT …… LOCK IN SHARE MODE也是对读取的记录加一个锁。 </p><p>但是如果有另一个一致性非锁定读的操作来读取该行那么数据是不会阻塞的，读取的是改行的快照版本(也就是指改行之前的数据版本,也就会出现脏读，所以也称为非锁定读，因为不需要等待被访问行的锁的释放。非锁定读的方式极大提高了数据库的并发性。在InnoDB存储引擎中，这是默认的读取方式)   </p><p>SELECT …… FOR UPDATE和SELECT …… LOCK IN SHARE MODE必须在一个事务中，当一个事务提交了，锁就释放了。因此在使用这两个SELECT锁定语句时，必须开启事务。</p><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>Gap Locks, 间隙锁锁住的是索引记录间的空隙，是为了解决<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">幻读问题</a>被引入的。有一点需要注意，间隙锁和间隙锁本身之间并不冲突，仅仅和插入这个操作发生冲突</p><h2 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next_Key  Lock"></a>Next_Key  Lock</h2><p>行锁+间隙锁，<a href="https://www.cnblogs.com/michael9/p/12358631.html#_label2">是行锁（Record）和间隙锁的并集</a><br>如下测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`keyname`</span> (<span class="string">`age`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">335</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=gbk</span><br><span class="line">+<span class="comment">-----+------+-------+</span></span><br><span class="line">| <span class="keyword">id</span>  | age  | <span class="keyword">name</span>  |</span><br><span class="line">+<span class="comment">-----+------+-------+</span></span><br><span class="line">| <span class="number">302</span> |    <span class="number">3</span> | xxx   |</span><br><span class="line">| <span class="number">303</span> |    <span class="number">6</span> | xxx22 |</span><br><span class="line">| <span class="number">304</span> |    <span class="number">9</span> | <span class="literal">NULL</span>  |</span><br><span class="line">| <span class="number">330</span> |    <span class="number">9</span> | <span class="number">2222</span>  |</span><br><span class="line">| <span class="number">331</span> |   <span class="number">19</span> | <span class="number">2222</span>  |</span><br><span class="line">+<span class="comment">-----+------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="更新和插入（带间隙锁）"><a href="#更新和插入（带间隙锁）" class="headerlink" title="更新和插入（带间隙锁）"></a>更新和插入（带间隙锁）</h3><p>当事务为快照读时，不会有幻读现象，当为当前读时，通过间隙锁+行锁（next-key lock）解决幻读</p><table><thead><tr><th>事务一</th><th>事务二</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>update test set name=’xxxx’ where age=7;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>insert into test(age,name) values(8,’xxxx’);    //堵塞插入</td></tr><tr><td>commit；</td><td>此时执行</td></tr><tr><td></td><td>commit；</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-----+------+-------+</span></span><br><span class="line">| id  | age  | name  |</span><br><span class="line">+<span class="comment">-----+------+-------+</span></span><br><span class="line">| 302 |    3 | xxx   |</span><br><span class="line">| 303 |    6 | xxx22 |</span><br><span class="line">| 304 |    9 | NULL  |</span><br><span class="line">| 330 |    9 | 2222  |</span><br><span class="line">| 331 |   19 | 2222  |</span><br><span class="line">| 332 |    8 | xxxx  |</span><br><span class="line">+<span class="comment">-----+------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="插入和更新（不带间隙锁-锁索引行）"><a href="#插入和更新（不带间隙锁-锁索引行）" class="headerlink" title="插入和更新（不带间隙锁,锁索引行）"></a>插入和更新（不带间隙锁,锁索引行）</h3><p>先插入，再用另一个事务更新数据，此时如果使用更新条件为插入字段，会堵塞；否则正常更新</p><h3 id="插入和插入（不带锁）"><a href="#插入和插入（不带锁）" class="headerlink" title="插入和插入（不带锁）"></a>插入和插入（不带锁）</h3><p>二个事务，可以正常插入，不会堵塞，不会开启间隙锁和行锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(age,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;xooxx&#x27;</span>);  <span class="comment">#二个sql都可以插入成功，id自增</span></span><br></pre></td></tr></table></figure><h3 id="插入和删除（行锁）"><a href="#插入和删除（行锁）" class="headerlink" title="插入和删除（行锁）"></a>插入和删除（行锁）</h3><h3 id="删除和插入（带间隙锁）"><a href="#删除和插入（带间隙锁）" class="headerlink" title="删除和插入（带间隙锁）"></a>删除和插入（带间隙锁）</h3><p>先删除再插入，会使用间隙锁</p><h3 id="删除和更新（行锁）"><a href="#删除和更新（行锁）" class="headerlink" title="删除和更新（行锁）"></a>删除和更新（行锁）</h3><p>二个事务，锁存在锁行，行不存在不加锁</p><h3 id="删除和删除（行锁）"><a href="#删除和删除（行锁）" class="headerlink" title="删除和删除（行锁）"></a>删除和删除（行锁）</h3><p>二个事务，锁存在锁行，行不存在不加锁</p><h3 id="更新和更新（行锁）"><a href="#更新和更新（行锁）" class="headerlink" title="更新和更新（行锁）"></a>更新和更新（行锁）</h3><p>二个事务，锁存在锁行，行不存在不加锁</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>删除和更新（推论共享锁和排它锁也是一样），之后再插入，会使用间隙锁+行锁（next-key lock）。</li><li>插入和插入，不带锁。</li><li>其它都是行锁</li></ul><h3 id="间隙锁范围"><a href="#间隙锁范围" class="headerlink" title="间隙锁范围"></a>间隙锁范围</h3><p>前开后闭，如（6，10] 不包含前数6包含后数10</p><h2 id="加锁的基本原则（RR隔离级别下）"><a href="#加锁的基本原则（RR隔离级别下）" class="headerlink" title="加锁的基本原则（RR隔离级别下）"></a>加锁的基本原则（RR隔离级别下）</h2><ol><li>原则1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li><li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p><strong>行锁和间隙锁都是由 next-key 锁满足一定后条件后转换的，加锁的默认单位是 next-key.</strong></p><p><strong>加锁其实是在索引上，并且只加在访问到的记录上，如果想要在 lock in share mode 下避免数据被更新，需要引入覆盖索引不能包含的字段。</strong>假设将 Session A 的语句改成 <code>select id from t where c=5 for update;</code>, for update 表示可能当前事务要更新数据，所以也会给满足的条件的主键索引加锁。</p><p><strong>对于非唯一索引，考虑加锁范围时要考虑到主键 Id 的情况。</strong></p><p><strong>间隙锁仅仅对插入操作本身互斥</strong>，不同事务之间的间隙锁并不互斥。</p><h2 id="打开-InnoDB-锁日志"><a href="#打开-InnoDB-锁日志" class="headerlink" title="打开 InnoDB 锁日志"></a>打开 InnoDB 锁日志</h2><p>打开 InnoDB 的锁日志，在遇到一些奇葩的现象时，会帮助我们确定锁范围。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;innodb_status_output&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output=<span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;innodb_status_output&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output_locks=<span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%tx_isolation%&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\G;</span><br></pre></td></tr></table></figure><p>打开 SQL 记录，用于分析 transcation</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&quot;general_log%&quot;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log = <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure><p>分析死锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br></pre></td></tr></table></figure><h2 id="MySQL-InnoDB-锁总结（二）-RC-加锁流程"><a href="#MySQL-InnoDB-锁总结（二）-RC-加锁流程" class="headerlink" title="MySQL InnoDB 锁总结（二）- RC 加锁流程"></a><a href="https://www.cnblogs.com/michael9/p/14135436.html">MySQL InnoDB 锁总结（二）- RC 加锁流程</a></h2><h2 id="关于-InnoDB-锁的超全总结"><a href="#关于-InnoDB-锁的超全总结" class="headerlink" title="关于 InnoDB 锁的超全总结"></a><a href="https://www.cnblogs.com/michael9/p/12443975.html">关于 InnoDB 锁的超全总结</a></h2><h2 id="幻读在-InnoDB-中是被如何解决的？"><a href="#幻读在-InnoDB-中是被如何解决的？" class="headerlink" title="幻读在 InnoDB 中是被如何解决的？"></a><a href="https://www.cnblogs.com/michael9/p/12358631.html">幻读在 InnoDB 中是被如何解决的？</a></h2><h2 id="8点几版本performance-schema-data-locks理解"><a href="#8点几版本performance-schema-data-locks理解" class="headerlink" title="8点几版本performance_schema.data_locks理解"></a><a href="https://www.jb51.net/article/214306.htm">8点几版本performance_schema.data_locks理解</a></h2><h2 id="mysql中QPS、TPS、系统吞吐量"><a href="#mysql中QPS、TPS、系统吞吐量" class="headerlink" title="mysql中QPS、TPS、系统吞吐量"></a><a href="https://blog.csdn.net/yxl_num/article/details/107952577">mysql中QPS、TPS、系统吞吐量</a></h2>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql之MVCC及快照读和当前读</title>
      <link href="2020/12/24/mysql%E4%B9%8BMVCC%E5%8F%8A%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB/"/>
      <url>2020/12/24/mysql%E4%B9%8BMVCC%E5%8F%8A%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>1、什么是锁？</p><p>一种保护机制，在多线程的情况下，保证操作数据的正确性与一致性</p><p>2、锁有哪些分类？</p><p>悲观锁、乐观锁、独占锁、共享锁、公平锁、非公平锁、分布式锁、自旋锁</p><p>3、谈谈悲观锁乐观锁：<br>指的是看待并发同步的角度，一般结合数据库将，以MySQL为例，悲观锁主要是表锁，行锁和间隙锁，叶锁，读锁，因为这些锁在被触发时会引起线程阻塞，所以叫悲观锁；而乐观锁其实在MySQL中本身不存在，但是MySQL提供了MVCC的机制，支持乐观锁机制</p><p>4、什么是MVCC？</p><p>只有在InnoDB引擎下存在，MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，所说的乐观锁只在事务级别未提交锁和已提交锁时才会生效</p><p>5、具体MVCC机制有什么？</p><p>多版本并发控制，保证数据操作在多线程过程中，保证事务隔离的机制，可以降低锁竞争的压力，保证较高的并发量。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题</p><p>6、在多个事务操作同一条数据的并发过程中，谁先成功?</p><p>mysql判断，先提交的先成功</p><p>7、谈谈事务。</p><p>事务常说一系列操作作为一个整体要么都成功要么都失败，主要特性acid，事务的的实现主要依赖两个log redo-log,undo-log,每次事务都会记录数据修改前的数据undo-log，修改后的数据放入redo-log,提出成功则使用redo-log 更新到磁盘，失败则使用undo-log将数据恢复到事务之前的数据</p><p>8、再谈谈独占锁、共享锁：</p><p>独占锁即是持有锁的线程只有一个，共享锁则可以有多个线程</p><p>9、共享的意义在于？</p><p>共享锁是为了提高程序的效率，举个例子：数据的操作有读写之分，对于写的操作加锁，保证数据正确性，而对于读的操作如果不加锁，在写读操作同时进行时，读的数据有可能不是最新数据，如果对读操作加独占锁，面对读多写少的程序肯定效率很低，所有就出现了共享锁，对于读的的操作就使用共享的概念，但是对于写的操作则是互斥的，保证了读写的数据操作都一致</p><h2 id="一丶什么是MVCC？"><a href="#一丶什么是MVCC？" class="headerlink" title="一丶什么是MVCC？"></a>一丶什么是MVCC？</h2><p>　　MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。当然，这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。具体见下面介绍。</p><h2 id="二丶MVCC的实现机制"><a href="#二丶MVCC的实现机制" class="headerlink" title="二丶MVCC的实现机制"></a>二丶MVCC的实现机制</h2><p>　　InnoDB在每行数据都增加两个隐藏字段，一个记录创建的版本号，一个记录删除的版本号。</p><p>　　在多版本并发控制中，为了保证数据操作在多线程过程中，保证事务隔离的机制，降低锁竞争的压力，保证较高的并发量。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。</p><h2 id="三丶MVCC下的CRUD"><a href="#三丶MVCC下的CRUD" class="headerlink" title="三丶MVCC下的CRUD"></a>三丶MVCC下的CRUD</h2><p><strong>SELECT：</strong><br>　　当隔离级别是REPEATABLE READ时select操作，InnoDB必须每行数据来保证它符合两个条件：<br>　　1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。<br>　　2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。<br>符合这两个条件的行可能会被当作查询结果而返回。</p><p><strong>INSERT：</strong></p><p>　　InnoDB为这个新行记录当前的系统版本号。<br><strong>DELETE：</strong></p><p>　　InnoDB将当前的系统版本号设置为这一行的删除ID。<br><strong>UPDATE：</strong></p><p>　　InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。</p><p>　　这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。<br>　　MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。</p><h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a><strong>四种隔离级别</strong></h2><ol><li>**Serializable (串行化)**：可避免脏读、不可重复读、幻读的发生。</li><li>**Repeatable read (可重复读)**：可避免脏读、不可重复读的发生。</li><li>**Read committed (读已提交)**：可避免脏读的发生。</li><li>**Read uncommitted (读未提交)**：最低级别，任何情况都无法保证。</li></ol><h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a><strong>快照读</strong></h2><p><strong>快照读</strong>是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</p><p>　　<strong>读已提交：</strong>一个事务内操作一条数据，可以查询到另一个已提交事务操作同一条数据的最新值。（Oracle 默认隔离级别）</p><p>　　<strong>可重复读：</strong>每个事务只关注自己事务开始查询到的数据值，无论事务查询同一条数据多少次，该数据改了多少次，都只查询到事务开始之前的数据值。（MySQL 默认隔离级别）</p><p>　　而所谓 <strong>MVCC 并发版本控制</strong>，是靠 readView (事务视图) 来实现的。多个 readView 组成 undo log（回滚日志）。</p><p>　　每一个 sql 查询某条数据时，都是查询最新 readView 的该条数据的值。</p><p>　　<strong>ReadView：</strong>（查询同一条数据，因为 readView 也是针对同一条数据生成的视图）</p><p>　　<strong>读已提交：</strong>是事务中的每个 sql 语句生成一个 readView。那就是一个事务内多条 sql 语句，会生成多个 readView。而每条 sql 执行时，都是查询最新 readView 的值。</p><p>　　假如事务 A 有2个查询 sql 语句，在第一个查询 sql 生成一个 readView（事务视图 id = n），事务 B 对该数据做了操作，那么就会生成新的 readView（事务视图 id = n + 1），第二个查询 sql 语句获取该条数据时，就会去 readView（事务视图 id = n + 1）查询数据。</p><p>　　<strong>可重复读：</strong>是在事务开始的时候生成一个 readView。所以一个事务内的多条查询 sql ，查询同一条数据时，读取到的 readView 都是同一个，那么查询某条数据的值，也是同一个值。</p><p>　　例如事务A开始查询主键 id = 1 的行数据的列 age = 10，不管其他事务是否对该 age 做改变，当前事务的多条查询 sql 语句，查询 age 的值一直都是 age = 10。</p><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a><strong>当前读</strong></h2><p><strong>当前读</strong>是基于 临键锁（行锁 + 间歇锁）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。</p><p>　　<strong>当前读：</strong></p><p>　　更新数据时，都是先读后写，而这个读，就是当前读。读取数据时，读取该条数据的已经提交的最新的事务，生成的 readView。</p><p>　　例如事务 A 有2个 sql 语句，事务开始时生成 readView（id = n），第一个 sql 操作一条数据时读当前的 readView（id = n） 。此时开始事务B生成 readView（id = n + 1），并且对该条数据做了操作（非简单 select 操作）。事务A的第2个 sql 语句<strong>当前读</strong>该数据时，就会读取该数据的最新事务视图 readView (id =n + 1) 的值。</p><p>　　而假如事务A的第二个 sql 语句操作数据时，事务B还未提交（非简单 select 操作），那么该条数据此时被事务B的<strong>写锁</strong>锁住。事务A的第二个 sql 语句操作数据（非简单 select 操作），那么也要获取该条数据的锁。而此时锁被事务B持有，事务A就会阻塞，等待事务B释放锁。</p><h2 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h2><p>read view 主要是用来做可见性判断的, 比较普遍的解释便是”本事务不可见的当前其他活跃事务”</p><ul><li>在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;</li><li>在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view);</li></ul><h2 id="MySQL-InnoDB-MVCC多版本并发控制"><a href="#MySQL-InnoDB-MVCC多版本并发控制" class="headerlink" title="MySQL-InnoDB-MVCC多版本并发控制"></a><a href="https://segmentfault.com/a/1190000012650596">MySQL-InnoDB-MVCC多版本并发控制</a></h2><h2 id="正确的理解MySQL的MVCC及实现原理"><a href="#正确的理解MySQL的MVCC及实现原理" class="headerlink" title="正确的理解MySQL的MVCC及实现原理"></a><a href="https://blog.csdn.net/SnailMann/article/details/94724197">正确的理解MySQL的MVCC及实现原理</a></h2><h2 id="数据库性能调优的方向"><a href="#数据库性能调优的方向" class="headerlink" title="数据库性能调优的方向"></a>数据库性能调优的方向</h2><img src="/2020/12/24/mysql%E4%B9%8BMVCC%E5%8F%8A%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB/image-20210622142838320.png" alt="image-20210622142838320" style="zoom:67%;">通常来讲我们会依照下面的顺序来进行分析：- 硬件能力- 系统规模- 数据库内部因素- 软件环境<p>这4个的顺序可以有所调整或者交换，但是对于系统的性能优化一定要从全局出发。切勿一来就深入到某一个SQL语句的优化，因为可能你花费大量的时间把一个SQL从20s 优化到1s，但是整个系统的卡慢仍然存在。</p><p>最后才是</p><ul><li>业务模型及架构</li><li>代码设计</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之并发与并行</title>
      <link href="2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"/>
      <url>2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是并发、并行？"><a href="#什么是并发、并行？" class="headerlink" title="什么是并发、并行？"></a>什么是并发、并行？</h3><p>这里引用Java8实战中的一张图片来加以说明</p><p><img src="/2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwrv49sw0j30fq07iwf8.jpg" alt="image.png"></p><p>可能从上图简单来看，并发是单处理器核心多任务的交替执行，并行是多任务多处理器核心的同时执行，由于这个问题并没有被盖棺定论规范化，导致可能不同的人有不同的理解，我也并不能给出一个严格意义上准确的定义，但是我综合他人的观点给出的自己的定义如下，<strong>并行是并发的一种表现形式</strong>，并发只强调两个任务的生命周期存在交集，即对用上面的任务1开始到结束的过程中，如果任务2也开始了，那么我们就认为任务1和任务2是并发的。但是今天想梳理的并不是严格意义上的区分这两个关联紧密的概念，而是讨论这两者能够给我们的程序带来什么？</p><p><strong>并发</strong>更加侧重于<strong>压榨单个CPU的性能，降低任务平均时延</strong>，对于一串任务（task1，task2，task3…）高并发并不能加快这些任务总体完成的时间，甚至由于线程切换还会延长任务总体完成的时间，所以它并不是以提高整体响应速率为目的的，而并行它使得多个任务（任务之间不相干，简化讨论，避免多核之间的一致性要求）可以在多个处理器核中得到真正的同时处理，而这个时候对于一系列的不相干任务来说，利用并行计算，就能大大缩短整体的响应时间</p><h3 id="单线程并发能够提高任务的总体处理速度嘛？"><a href="#单线程并发能够提高任务的总体处理速度嘛？" class="headerlink" title="单线程并发能够提高任务的总体处理速度嘛？"></a>单线程并发能够提高任务的总体处理速度嘛？</h3><p>答案是显然的，<strong>不能</strong>，而且由于线程切换带来的资源开销，单线程并发还会延长<strong>整个</strong>任务的处理时间？</p><h3 id="单线程并发还有必要嘛？"><a href="#单线程并发还有必要嘛？" class="headerlink" title="单线程并发还有必要嘛？"></a>单线程并发还有必要嘛？</h3><p>有必要，而且非常有必要，首先我们假定有四个任务1，2，3，4如下，每个任务的执行耗时1个单位时间，如果按照单线程串行的执行方式，它应该是这样的</p><p><img src="/2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwuv5cv87j30f409wmxa.jpg" alt="image.png"></p><p>对于task1来说，它还能接收，毕竟执行1个单位时间它就拿到了它想要的结果，但是对于后面的task来说就不满意了，特别是task4来说，执行task4的耗时为1个单位时间，但是它需要等4个单位时间才能拿到结果，如果在多线程情况下，它是如何的呢？假设每个task都另起了一个线程，且不考虑操作系统任务调度耗时等等，现在的处理情况是这样的</p><p><img src="/2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwv7rlnk4j30od0a7dg5.jpg" alt="image.png"></p><p>假如理想状况下，每个任务被切割得足够小，那么最终每个任务几乎是同时开始同时结束，那么每个task的用时就是总耗时的平均值也就是2.5，这下task4总算开心了，它不用等那么久了。</p><p>但是实际问题中，不可能把任务无限切分，操作系统的线程调度也是耗时操作，那么上面的结论就不一定那么可靠了，甚至可能每个时间都超过3了，那还不如串行呢，至少task1和task2爽了，那为什么还需要并发呢？</p><p>因为实际状况下，每个任务的执行速度也不可能完全相等，每个任务执行的速度有快有慢，我们现在假设task1执行用时需要1000个单位时间，如果在串行情况下，task1后面的所有任务都会被task1所拖累，需要等待的时间为1000加，而此时的并发执行策略中，虽然由于系统调度等等开销，task2，3，4仍然可以以一个与之前速度相差无几的时间响应，task1带来的恶劣影响也单单只影响到了自己。我们上面的策略也就类似于tomcat对于请求的处理策略，针对每个请求都另起一个线程（processor）来处理。</p><h3 id="tomcat都这么厉害了，自己的代码中还有必要多线程嘛？"><a href="#tomcat都这么厉害了，自己的代码中还有必要多线程嘛？" class="headerlink" title="tomcat都这么厉害了，自己的代码中还有必要多线程嘛？"></a>tomcat都这么厉害了，自己的代码中还有必要多线程嘛？</h3><p><strong>有必要</strong>，通常一个大任务是由多个小任务组合而成，如果按照<strong>CPU密集型和I/O密集型</strong>来划分任务类型的话，对于CPU密集型任务来说，无论我们再怎么多线程疯狂操作也好，在单核处理器中，最终都还是依靠单核来做运算，多线程的线程切换开销无疑延长了整个任务的处理时间，但是在I/O密集型任务情况下（包括磁盘IO，网络IO），假设你发起了10个不同的RPC调用，无疑多线程的方式能够让你同时发起多个请求，多个请求同时等待响应，否则你就只能按照串行的方式，每个请求都需要等一个时延，然后再处理下一个请求，这样的等待无疑延长了总体响应时间，降低CPU利用率。其实这样的并发就包含了并行，因为你发起的远程调用是远方的多个处理器去帮你处理的，我们所做的只不过是利用并发在一个请求傻等着的过程中又发起了另一个请求罢了</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行的好处是显而易见的，多个处理器干活肯定是快于一个人干活的，对于上面讨论的情况，如果在多核心的处理器下，并发之后可能整个处理过程就是并行的，小的任务可以在多个处理器核心中同时运行，在这里也不太过多讨论并发安全的问题，主要讨论如何高效并行</p><p>在tomcat中想要并行很简单，你并发就好，如果你有多个处理器核心它自然会并行执行，可能并不太需要我们对整个处理过程进行并行处理，关注更多的是不同请求之间的并行，但是在一些场景下，可能就需要我们关注整个任务本身的并行，这时候并行就不那么容易，假设你要计算1-1000000000的和，你当然可以选择并发执行，自己分割每个处理器计算多少到多少的和，然后自行汇总结果，就像下面的代码一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentVsParallel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//串行</span></span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> time1=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000000000L</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;串行计算结果为：&quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;串行耗时：&quot;</span>+(System.currentTimeMillis()-time1));</span><br><span class="line">        <span class="keyword">long</span> time2= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> res = concurrentCal(<span class="number">10000000000L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结果为：&quot;</span>+res);</span><br><span class="line">        System.out.println(<span class="string">&quot;并行耗时为：&quot;</span>+(System.currentTimeMillis()-time2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">concurrentCal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//4等分来处理</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">long</span> quarter=n/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> allSum=<span class="number">0</span>;</span><br><span class="line">        Future[] parts = <span class="keyword">new</span> Future[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4L</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp=i;</span><br><span class="line">            Future&lt;Long&gt; partSum = executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> j = temp * quarter + <span class="number">1</span>; j &lt;= (temp + <span class="number">1</span>) * quarter; j++) &#123;</span><br><span class="line">                    sum += j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;);</span><br><span class="line">            parts[i]=partSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.length; i++) &#123;</span><br><span class="line">            allSum+=(<span class="keyword">long</span>)parts[i].get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串行计算结果为：-5340232216128654848</span><br><span class="line">串行耗时：4617</span><br><span class="line">计算结果为：-5340232216128654848</span><br><span class="line">并行耗时为：1847</span><br></pre></td></tr></table></figure><p>上述的代码能够实现我们既定的目标，但是存在着<strong>可读性和可拓展性</strong>的问题，性能也存在着问题，如果需要对(2-n)求和呢，很简单，给我们的代码加入一个start即可，但是如果需要对（2-n）中所有的偶数求和呢？岂不是又需要改代码，更加严重的问题是任务规模的划分是定下来的，导致任务划分的粒度有的时候并不够，当然你也可以再添加一个参数设置任务规模的划分，但是上述这些操作都会导致代码的膨胀和难以维护，利用java8的Stream可以做如下简单实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time3=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> res = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">10000000000L</span>).parallel().sum();</span><br><span class="line">System.out.println(<span class="string">&quot;stream计算结果为：&quot;</span>+res);</span><br><span class="line">System.out.println(<span class="string">&quot;stream耗时为：&quot;</span>+(System.currentTimeMillis()-time3));</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串行计算结果为：-5340232216128654848</span><br><span class="line">串行耗时：4631</span><br><span class="line">stream计算结果为：-5340232216128654848</span><br><span class="line">stream耗时为：3605</span><br></pre></td></tr></table></figure><p>虽然这里的耗时可能比不过我们直接手动划分，并发的方式去进行计算，但是这里的代码可读性以及可拓展性是非常好的，如果你想过滤掉所有的奇数，加一个filter就好。诚然这个结果也受限于我仅仅只有四核的垃圾笔记本，无论如何，通过Stream的方式，Java的并行计算也变得简单！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Java8实战》</p><p><a href="https://www.zhihu.com/question/37396742">https://www.zhihu.com/question/37396742</a></p><p><a href="https://www.zhihu.com/question/33515481">https://www.zhihu.com/question/33515481</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 并发与并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis之缓存更新</title>
      <link href="2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/"/>
      <url>2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h2><p>更新缓存的时候涉及两个问题：</p><ul><li>删除（del）还是 修改（set）？</li><li>先操作数据库，还是 先操作缓存？</li></ul><p>组合起来就有四种情况：</p><p><font color="red">第一种情况：先删除缓存，后更新数据库</font></p><p>如果删除缓存失败，则后面的操作都不会执行，没问题；</p><p>如果删除缓存成功，更新数据库失败，则缓存与数据库不一致，但这种不一致会马上被修正，因而不影响，因为下一次请求缓存的时候发现缓存中没有，会从数据库重新加载；但是，又有一个问题出现了，在旧的缓存被删除后，新的缓存未写入之前，这段时间内如果有读操作，那么旧的值会被重新加载到缓存，这就相当于没更新缓存；</p><p><font color="red">第二种情况：先更新缓存，后更新数据库</font></p><p>同样，如果更新缓存成功，更新数据库失败，则出现缓存与数据库不一致，<strong>数据不一致就是问题</strong></p><p><font color="red">第三种情况：先更新数据库，后删除缓存</font></p><p>如果更新数据库成功，删除缓存失败，则出现缓存与数据库不一致，<strong>数据不一致就是问题</strong></p><p><font color="red">第四种情况：先更新数据库，后更新缓存</font></p><p>跟第三种情况一样</p><h2 id="单主更新缓存"><a href="#单主更新缓存" class="headerlink" title="单主更新缓存"></a>单主更新缓存</h2><p>虽然，看上去好像都有问题，但是，<strong>任何脱离实际业务的设计都是耍流氓</strong></p><p>既然我们把Redis当缓存，那么所有数据都要以数据库为准，像上面第二种情况（缓存中有的数据在数据库中没有）是不能容忍的，而对于第一种情况，可以采取双删的策略（删除缓存 –&gt; 更新数据库 –&gt; 再删除缓存），后面两种情况，可以用定时任务进行补偿，有些场景下我们是可以接受不一致的情况的。</p><p>不过，话又说回来，直接删除缓存当然是最简单的，它相当于延迟加载（第一次使用的时候发现没有才会去从数据库加载），这样可能导致第一次请求会比较慢；而采用修改缓存的方式，相当于预先加载。</p><p>在实际使用的时候，可以采用这两种方式：</p><ol><li>先删除缓存，再更新数据库，最后再删一次</li><li>先更新数据库，然后向MQ发一条消息，由专门的缓存服务去更新数据</li></ol><p><strong>上面说的是只有一个数据库实例的情况</strong>，而实际生产过程中肯定是一主多从的</p><h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><p>延时双删的方案的思路是，为了避免更新数据库的时候，其他线程从缓存中读取不到数据，就在更新完数据库之后，再sleep一段时间，然后再次删除缓存。</p><p>sleep的时间要对业务读写缓存的时间做出评估，sleep时间大于读写缓存的时间即可。</p><p>流程如下：</p><ol><li>线程1删除缓存，然后去更新数据库</li><li>线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存</li><li>线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除</li><li>如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值</li></ol><p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E6%9B%B4%E6%96%B0redis.png" alt="图片"></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。</p><p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98.png"></p><p>这个解决方案其实问题更多。</p><ol><li>引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦</li><li>就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的</li></ol><h3 id="进阶版消息队列"><a href="#进阶版消息队列" class="headerlink" title="进阶版消息队列"></a>进阶版消息队列</h3><p>为了解决缓存一致性的问题单独引入一个消息队列，太复杂了。</p><p>其实，一般大公司本身都会有监听binlog消息的消息队列存在，主要是为了做一些核对的工作。</p><p>这样，我们可以借助监听binlog的消息队列来做删除缓存的操作。这样做的好处是，不用你自己引入，侵入到你的业务代码中，中间件帮你做了解耦，同时，中间件的这个东西本身就保证了高可用。</p><p>当然，这样消息延迟的问题依然存在，但是相比单纯引入消息队列的做法更好一点。</p><p>而且，如果并发不是特别高的话，这种做法的实时性和一致性都还算可以接受的。</p><p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/binlog%E7%9B%91%E5%90%AC%E6%9B%B4%E6%96%B0redis.png" alt="图片"></p><h3 id="设置缓存过期时间-不建议"><a href="#设置缓存过期时间-不建议" class="headerlink" title="设置缓存过期时间(不建议)"></a>设置缓存过期时间(不建议)</h3><p>每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。</p><p>如果对于一致性要求不是很高的情况，可以采用这种方案。</p><p>这个方案还会有另外一个问题，就是如果数据更新的特别频繁，不一致性的问题就很大了。</p><p>在实际生产中，我们有一些活动的缓存数据是使用这种方式处理的。</p><p>因为活动并不频繁发生改变，而且对于活动来说，短暂的不一致性并不会有什么大的问题。</p><h2 id="主从更新缓存"><a href="#主从更新缓存" class="headerlink" title="主从更新缓存"></a>主从更新缓存</h2><p>按照<strong>写主读从</strong>，缓存加载数据的时候应该从从库中读，而本来主从同步就有延迟，于是读从库很有可能读到的是旧数据</p><p>为了解决这种问题，可以考虑以下几种方案：</p><p><font color="red">第一种：强制缓存读主数据库</font></p><p>这样一来，就不必考虑主从同步的问题了，可行（PS：跟微信公众号开发的时候获取Token一样）</p><p><font color="red">第二种：选择性地读主数据库</font></p><p>之所以强制读主库，是因为再主从同步完成之前从库中的数据还是旧的，当主从同步完成后再读从库就没什么问题了，那么如果在主从同步的这段时间内如果没有请求读这个KEY就没有问题，如果这段时间内有请求读取这个KEY，那么在同步完成后要删除这个KEY</p><p>如何判断在主从同步这段时间内有没有请求读取这个KEY呢？</p><p>在更新数据库的时候，往缓存中设置一个KEY，格式是：缓存KEY+业务数据ID，其生存时间是主从延时时间</p><p>比如，假设主从同步延时是3秒，而有业务缓存KEY是hash类型的，更新的这条数据的ID是213，那么在更新数据库后要立即设置 set USER_213_KV 1 3</p><p>在读的时候，首先判断缓存中有没有这样一个KEY，如果有则从主库中重新加载数据到缓存，没有，则直接从从库中加载数据到缓存</p><p><font color="red">第三种：订阅从库的binlog</font></p><p>可以通过工具（比如，canal）订阅从库的binlog，这是比较准确的，从库数据有更新，则立即更新缓存<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p><h2 id="为什么是删除，而不是更新缓存？"><a href="#为什么是删除，而不是更新缓存？" class="headerlink" title="为什么是删除，而不是更新缓存？"></a>为什么是删除，而不是更新缓存？</h2><p>我们以<strong>先更新数据库，再删除缓存</strong>来举例。</p><p>如果是更新的话，那就是<strong>先更新数据库，再更新缓存</strong>。</p><p>举个例子：如果数据库1小时内更新了1000次，那么缓存也要更新1000次，但是这个缓存可能在1小时内只被读取了1次，那么这1000次的更新有必要吗？</p><p>反过来，如果是删除的话，就算数据库更新了1000次，那么也只是做了1次缓存删除，只有当缓存真正被读取的时候才去数据库加载。</p><h2 id="补充1：缓存穿透"><a href="#补充1：缓存穿透" class="headerlink" title="补充1：缓存穿透"></a>补充1：缓存穿透</h2><p><font color="red">缓存穿透</font></p><p>缓存穿透，指的是查询一个数据库中不存在的数据。这样的话，每次都会查询数据库，相当于缓存就没有用了。</p><ul><li>针对这种情况，可以缓存空值，并设置一个较短的生存时间，比如60秒。</li><li>使用布隆过滤器，存在的时候保存；有一个错误率，并且不能删除，可以使用带计数器的布隆过滤器。</li></ul><p><font color="red">缓存雪崩</font></p><p>缓存雪崩，指的是大量缓存在一段时间内集体失效。这样的话，短时间内大量请求会直接打到数据库。</p><p>针对这种情况，可以在缓存的生存时间后面再加上一个随机数，这样的话就不至于同一时刻集体过期。实际上，因为大量缓存失效意味着这些缓存在同一时刻被设置的，而这种情况不多见。</p><p><font color="red">缓存击穿</font></p><p>缓存击穿，指的是单个缓存在被高并发访问时失效了导致请求全部打到数据库。</p><p>针对这种情况，在加载缓存的时候要加分布式锁。</p><h2 id="补充2：Redis客户端工具Medis"><a href="#补充2：Redis客户端工具Medis" class="headerlink" title="补充2：Redis客户端工具Medis"></a>补充2：Redis客户端工具Medis</h2><p><a href="https://github.com/luin/medis">https://github.com/luin/medis</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;luin&#x2F;medis.git</span><br><span class="line">cd medis</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/874963-20190422192347253-2059999245.png" alt="img"></p><p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/874963-20190422192359546-1385109275.png" alt="img"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/cjsblog/p/10752245.html">https://www.cnblogs.com/cjsblog/p/10752245.html</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247488185&idx=1&sn=f07ee035bc8c276e4d72b4ffb9627e1e&chksm=c2b25a44f5c5d3523985e4161e42ae0d1b4c8273915760d3ec53afbbd5fe0066178d5ade1673&scene=132#wechat_redirect">缓存一致性问题怎么解决</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis之数据结构</title>
      <link href="2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="redis单点吞吐量"><a href="#redis单点吞吐量" class="headerlink" title="redis单点吞吐量"></a><strong>redis单点吞吐量</strong></h2><p>单点TPS达到8万/秒，QPS达到10万/秒。</p><h2 id="redis的5中存储类型"><a href="#redis的5中存储类型" class="headerlink" title="redis的5中存储类型"></a><strong>redis的5中存储类型</strong></h2><p>string、list、set、map（hash）、stored-set</p><h2 id="redis的string类型"><a href="#redis的string类型" class="headerlink" title="redis的string类型"></a><strong>redis的string类型</strong></h2><ol><li>能表达3中类型：字符串、整数和浮点数。根据场景相互间自动转型，并且根据需要选取底层的承载方式</li><li><font color="red">value内部以int、sds作为结构存储</font>。int存放整型数据，sds存放字节/字符串和浮点型数据</li><li>sds内部结构： <ol><li>用buf数组存储字符串的内容，但数组的长度会大于所存储内容的长度。会有一格专门存放”\0”（C标准库）作为结尾，还有预留多几个空的（即free区域），当append字符串的长度小于free区域，则sds不会重新申请内存，直接使用free区域</li><li>扩容：当对字符串的操作完成后预期的串长度小于1M时，扩容后的buf数组大小=预期长度*2+1；若大于1M，则buf总是会预留出1M的free空间</li><li>value对象通常具有两个内存部分：redisObject部分和redisObject的ptr指向的sds部分。创建value对象时，通常需要为redisObject和sds申请两次内存。单对于短小的字符串，可以把两者连续存放，所以可以一次性把两者的内存一起申请了</li></ol></li><li>使用场景<ol><li>分布式锁｛setnx +lua脚本 | set key value  [EX seconds] [PX milliseconds] [NX|XX] ｝</li><li>计数器|自增id｛incr key increment | DECRBY key decrement｝</li><li>Token {set key value}</li><li>幂等</li></ol></li></ol><h2 id="redis的list类型"><a href="#redis的list类型" class="headerlink" title="redis的list类型"></a><strong>redis的list类型</strong></h2><ol><li><font color="red">list类型的value对象内部以linkedlist或ziplist承载</font>。当list的元素个数和单个元素的长度较小时，redis会采用ziplist实现以减少内存占用，否则采用linkedlist结构</li><li>linkedlist内部实现是双向链表。在list中定义了头尾元素指针和列表的长度，是的pop/push操作、llen操作的复杂度为O(1)。由于是链表，lindex类的操作复杂度仍然是O(N)</li><li>ziplist的内部结构 <ol><li>所有内容被放置在连续的内存中。其中zlbytes表示ziplist的总长度，zltail指向最末元素，zllen表示元素个数，entry表示元素自身内容，zlend作为ziplist定界符</li><li>rpush、rpop、llen，复杂度为O(1);lpush/pop操作由于涉及全列表元素的移动，复杂度为O(N)</li></ol></li><li>使用场景<ol><li>消息流｛LPUSH | RPUSH key value | LRANGE key start stop｝</li><li>堵塞队列｛ BLPOP |  BRPOP key1 [key2 ] timeout ｝</li></ol></li></ol><h2 id="redis的map类型"><a href="#redis的map类型" class="headerlink" title="redis的map类型"></a><strong>redis的map类型</strong></h2><ol><li>map又叫hash。map内部的key和value不能再嵌套map了，只能是string类型：整形、浮点型和字符串</li><li><font color="red">map主要由hashtable和ziplist两种承载方式实现</font>，对于数据量较小的map，采用ziplist实现</li><li>hashtable内部结构 <ol><li>主要分为三层，自底向上分别是dictEntry、dictht、dict</li><li>dictEntry：管理一个key-value对，同时保留同一个桶中相邻元素的指针，一次维护哈希桶的内部连</li><li>dictht：维护哈希表的所有桶链</li><li>dict：当dictht需要扩容/缩容时，用于管理dictht的迁移</li><li>哈希表的核心结构是dictht，它的table字段维护着hash桶，它是一个数组，每个元素指向桶的第一个元素（dictEntry）</li><li>set值的流程：先通过MurmurHash算法求出key的hash值，再对桶的个数取模，得到key对应的桶，再进入桶中，遍历全部entry，判定是否已有相同的key，如果没有，则将新key对应的键值对插入到桶头，并且更新dictht的used数量，used表示hash表中已经存了多少元素。由于每次插入都要遍历hash桶中的全部entry，所以当桶中entry很多时，性能会线性下降</li><li>扩容：通过负载因子判定是否需要增加桶数。负载因子=哈希表中已有元素/哈希桶数的比值。有两个阈值，小于1一定不扩容；大于5一定扩容。扩容时新的桶数目是现有桶的2n倍</li><li>缩容：负载因子的阈值是0.1</li><li>扩/缩容通过新建哈希表的方式实现。即扩容时，会并存两个哈希表，一个是源表，一个是目标表。通过将源表的桶逐步迁移到目标表，以数据迁移的方式实现扩容，迁移完成后目标表覆盖源表。迁移过程中，首先访问源表，如果发现key对应的源表桶已完成迁移，则重新访问目标表，否则在源表中操作</li><li>redis是单线程处理请求，迁移和访问的请求在相同线程内进行，所以不会存在并发性问题</li></ol></li><li>ziplist内部结构 <ol><li>和list的ziplist实现类似。不同的是，map对应的ziplist的entry个数总是2的整数倍，奇数存放key，偶数存放value</li><li>ziplist实现下，由哈希遍历变成了链表的顺序遍历，复杂度变成O(N)</li></ol></li><li>使用场景<ol><li>对象存储，对象字段修改</li><li>可重入锁</li><li>购物车{HINCRBY key field increment}</li><li>幂等</li></ol></li></ol><h2 id="redis的set类型"><a href="#redis的set类型" class="headerlink" title="redis的set类型"></a><strong>redis的set类型</strong></h2><ol><li><font color="red">set以intset或hashtable来存储</font>。hashtable中的value永远为null，当set中只包含整数型的元素时，则采用intset</li><li>intset的内部结构 <ol><li>核心元素是一个字节数组，从小到大有序存放着set的元素</li><li>由于元素有序排列，所以set的获取操作采用二分查找方式实现，复杂度O(log(N))。进行插入时，首先通过二分查找得到本次插入的位置，再对元素进行扩容，再将预计插入位置之后的所有元素向右移动一个位置，最后插入元素，插入复杂度为O(N)。删除类似</li></ol></li><li>使用场景<ol><li>关注和粉丝 点赞收藏 {SREM key member1 [member2] | SADD}</li><li>好友推荐（集合操作）{SINTERSTORE destination key1 [key2] | SDIFFSTORE destination key1 [key2] }</li><li>抽奖（可以随机选择集合里的多个元素{SRANDMEMBER key [count] }，选择并删除一个元素spop key）</li></ol></li></ol><h2 id="redis的sorted-set类型"><a href="#redis的sorted-set类型" class="headerlink" title="redis的sorted-set类型"></a><strong>redis的sorted-set类型</strong></h2><ol><li><p>类似map是一个key-value对，但是有序的。value是一个浮点数，称为score，内部是按照score从小到大排序</p></li><li><p><font color="red">内部结构以ziplist或skiplist来实现</font></p><ol><li>ziplist 编码的 Zset 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。ziplist 内的集合元素按 score 从小到大排序，其实质是一个双向链表。<img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1637947-20200108102944037-1942746276.png" alt="img"></li><li><a href="https://www.cnblogs.com/wuyizuokan/p/11108417.html">skiplist原理</a><img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1236645-20190629233343522-1807329534.png"></li></ol></li><li><p>使用场景</p><ol><li>排行榜、活跃文章（对score进行累加）</li><li>信息流（社交类如微博）</li><li>限流里的滑动窗口</li><li>延时队列（没有 ack 机制，当消费失败的情况下队列如何处理，topic 模式，广播模式如何搞）</li><li>排行榜 {ZINCRBY key increment member }  月排行榜{ZINTERSTORE destination numkeys key [key …] }</li></ol></li></ol><h2 id="位图BitSet"><a href="#位图BitSet" class="headerlink" title="位图BitSet"></a>位图BitSet</h2><p>使用场景</p><ol><li>布隆过滤器 {Setbit key offset  1|0    |   Getbit key offset}</li><li>签到（用户id自增）{BITOP AND destkey key [key …] }</li><li>活跃用户统计（用户id自增）{BITOP OR destkey key [key …] }</li></ol><h2 id="redis中key和value的存储大小限制"><a href="#redis中key和value的存储大小限制" class="headerlink" title="redis中key和value的存储大小限制"></a>redis中key和value的存储大小限制</h2><p>String类型：一个String类型的value最大可以存储512M</p><p>List类型：list的元素个数最多为2^32-1个，也就是4294967295个。</p><p>Set类型：元素个数最多为2^32-1个，也就是4294967295个。</p><p>Hash类型：键值对个数最多为2^32-1个，也就是4294967295个。</p><p>Sorted set类型：跟Set类型相似。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis之进阶</title>
      <link href="2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/"/>
      <url>2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="redis客户端与服务器的交互模式"><a href="#redis客户端与服务器的交互模式" class="headerlink" title="redis客户端与服务器的交互模式"></a><strong>redis客户端与服务器的交互模式</strong></h2><ol><li>串行的请求/响应模式 <ol><li>每一次请求的发送都依赖于上一次请求的相应结果完全接收，同一个连接的每秒吞吐量低</li><li>redis对单个请求的处理时间通常比局域网的延迟小一个数量级，所以串行模式下，单链接的大部分时间都处于网络等待</li></ol></li><li>双工的请求/相应模式(pipeline) <ol><li>适用于批量的独立写入操作。即可将请求数据批量发送到服务器，再批量地从服务器连接的字节流中一次读取每个响应数据，减少了网络延迟，所以单连接吞吐量较串行会提高一个数量级</li></ol></li><li>原子化的批量请求/响应模式（事务） <ol><li>客户端通过和redis服务器两阶段的交互做到批量命令原子执行的事务效果：入队操作（即服务器端先将客户端发送过来的连接对象暂存在请求队列中）和执行阶段（依次执行请求队列中的所有请求）</li><li>一个连接的请求在执行批量请求的过程中，不会执行其他客户端的请求</li><li>redis的事务不是一致的，没有回滚机制。如果中途失败，则返回错误信息，但已经成功执行的命令不会回滚</li><li>事务里面有可能会带有读操作作为条件，由于批量请求只会先入队列，再批量一起执行，所以一般读操作不会跟批量写请求一起执行，这时候就有可能会导致批量写之前和之后读到的数据不一致，这种可以通过乐观锁的可串行化来解决，redis通过watch机制实现乐观锁。具体实现过程看下一题</li></ol></li><li>发布/订阅模式 <ol><li>发布端和订阅者通过channel关联</li><li>channel的订阅关系，维护在reids实例级别，独立于redisDB的key-value体系。所有的channel都由一个map维护，键是channel的名字，value是它所有订阅者client的指针链表</li></ol></li><li>脚本化的批量执行（脚本模式）</li></ol><h2 id="redis通过watch机制实现乐观锁流程"><a href="#redis通过watch机制实现乐观锁流程" class="headerlink" title="redis通过watch机制实现乐观锁流程"></a><strong>redis通过watch机制实现乐观锁流程</strong></h2><ol><li>将本次事务涉及的所有key注册为观察模式</li><li>执行只读操作</li><li>根据只读操作的结果组装写操作命令并发送到服务器端入队</li><li>发送原子化的批量执行命令EXEC试图执行连接的请求队列中的命令</li><li>如果前面注册为观察模式的key中有一个货多个，在EXEC之前被修改过，则EXEC将直接失败，拒绝执行；否则顺序执行请求队列中的所有请求</li><li>redis没有原生的悲观锁或者快照实现，但可通过乐观锁绕过。一旦两次读到的操作不一样，watch机制触发，拒绝了后续的EXEC执行</li></ol><h2 id="redis的网络协议"><a href="#redis的网络协议" class="headerlink" title="redis的网络协议"></a><strong>redis的网络协议</strong></h2><p>redis协议位于TCP层之上，即客户端和redis实例保持双工的连接，交互的都是序列化后的协议数据</p><h2 id="redis处理命令的主要逻辑"><a href="#redis处理命令的主要逻辑" class="headerlink" title="redis处理命令的主要逻辑"></a><strong>redis处理命令的主要逻辑</strong></h2><ol><li>redis服务器对命令的处理都是单线程的，但是I/O层面却面向多个客户端并发地提供服务，并发到内部单线程的转化通过多路复用框架来实现</li><li>首先从多路复用框架（epoll、evport、kqueue）中select出已经ready的文件描述符（fileDescriptor）</li><li>ready的标准是已有数据到达内核（kernel）、已准备好写入数据</li><li>对于上一步已经ready的fd，redis会分别对每个fd上已ready的事件进行处理，处理完相同fd上的所有事件后，再处理下一个ready的fd。有3中事件类型 <ol><li>acceptTcpHandler：连接请求事件</li><li>readQueryFromClient：客户端的请求命令事件</li><li>sendReplyToClient：将暂存的执行结果写回客户端</li></ol></li><li>对来自客户端的命令执行结束后，接下来处理定时任务（TimeEvent）</li><li>aeApiPoll的等待时间取决于定时任务处理（TimeEvent）逻辑</li><li>本次主循环完毕，进入下一次主循环的beforeSleep逻辑，后者负责处理数据过期、增量持久化的文件写入等任务</li></ol><h2 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a><strong><a href="https://baijiahao.baidu.com/s?id=1654694618189745916&wfr=spider&for=pc">Redis的持久化机制</a></strong></h2><ol><li>redis主要提供了两种持久化机制：RDB和AOF；</li><li>RDB <ol><li>默认开启，会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，redis启动时再恢复到内存中。</li><li>redis会单独创建fork()一个子进程，将当前父进程的数据的内存地址复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</li><li>需要注意的是，每次快照持久化都会将主进程的数据库数据内存地址复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I/O操作，严重影响性能，并且最后一次持久化后的数据可能会丢失；</li><li>save 900 1 表示900 秒内如果至少有 1 个 key 的值变化，则保存</li><li>save 300 10表示300 秒内如果至少有 10 个 key 的值变化，则保存</li><li>save 60 10000表示60 秒内如果至少有 10000 个 key 的值变化，则保存</li><li><strong>rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li><li><strong>rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li><li><strong>dbfilename ：</strong>设置快照的文件名，默认是 dump.rdb</li><li><strong>dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名</li><li>命令行触发可以使用save或bgsave<img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/1.png" alt="img" style="zoom:67%;"></li></ol></li><li>AOF <ol><li>以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件，redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB也会执行。</li><li>主要有两种方式触发：有写操作就写、每秒定时写（也会丢数据）。</li><li>因为AOF采用追加的方式，所以文件会越来越大，针对这个问题，新增了重写机制，就是当日志文件大到一定程度的时候，会fork出子进程来遍历进程内存中的数据，每条记录对应一条set语句，写到临时文件中，然后再替换到旧的日志文件（类似rdb的操作方式）。默认触发是当aof文件大小是上次重写后大小的一倍且文件大于64M时触发；</li></ol></li><li>当两种方式同时开启时，数据恢复redis会优先选择AOF恢复。一般情况下，只要使用默认开启的RDB即可，因为相对于AOF，RDB便于进行数据库备份，并且恢复数据集的速度也要快很多。</li><li>开启持久化缓存机制，对性能会有一定的影响，特别是当设置的内存满了的时候，更是下降到几百reqs/s。所以如果只是用来做缓存的话，可以关掉持久化。</li></ol><h2 id="redis内存分析的设计思路"><a href="#redis内存分析的设计思路" class="headerlink" title="redis内存分析的设计思路"></a><strong>redis内存分析的设计思路</strong></h2><ol><li>主要有3种方式可以实现 <ol><li>keys命令：获取到所有的key，再根据key获取所有的内容。缺点是如果key数量特别多，则会导致redis卡住影响业务</li><li>aof：通过aof文件获取到所有数据。缺点是有一些redis实例写入频繁，不适合开启aof，并且文件可能特别大，传输、解析效率差</li><li>rdb：使用bgsave获取rdb文件，然后解析。缺点是bgsave在fork子进程时有可能会卡住主进程。当对于其他两种，在低峰期在从节点做bgsave获取rdb文件，相对安全可靠。</li></ol></li><li>设计思路:<ol><li>在访问低峰期时根据redis获取rdb文件</li><li>解析rdb文件根据相对应的数据结构及内容，估算内容消耗等</li><li>统计并生成报表</li></ol></li><li>开源框架：<a href="https://github.com/xueqiu/rdr">https://github.com/xueqiu/rdr</a></li></ol><h2 id="redis内存估算"><a href="#redis内存估算" class="headerlink" title="redis内存估算"></a><strong>redis内存估算</strong></h2><ol><li>基础的数据类型：sds、dict、intset、zipmap、adlist、quicklist、skiplist</li><li>举例：以key为hello，value为world，类型是string，它的内存使用： <ol><li>一个dictEntry的消耗（有2个指针，一个int64的内存消耗），RedisDB就是一个大dict，每对kv都是其中的一个entry；</li><li>一个robj的消耗（有1指针，一个int，以及几个使用位域的字段共消耗4字节），robj是为了在同一个dict内能够存储不同类型的value，而使用的一个通用的数据结构，全名是RedisObject；</li><li>存储key的sds消耗（存储header以及字符串长度+1的空间，header长度根据字符串长度不同也会有所不同），sds是Redis中存储字符串使用的数据结构；</li><li>存储过期时间消耗（也是存储为一个dictEntry，时间戳为int64）；</li><li>存储value的sds消耗，根据数据结构不同而不同；</li><li>前四项基本是存储任何一个key都需要消耗的，最后一项根据value的数据结构不同而不同；</li></ol></li></ol><h2 id="redis-主从模式"><a href="#redis-主从模式" class="headerlink" title="redis 主从模式"></a><strong>redis 主从模式</strong></h2><p>同步主节点的数据，可以做读写分离，缺点是主从模式下，主节点挂了之后，从节点没办法自动成功主节点，需要人工设置为主节点。</p><h2 id="redis-sentinel（redis哨兵）"><a href="#redis-sentinel（redis哨兵）" class="headerlink" title="redis sentinel（redis哨兵）"></a><strong>redis sentinel（redis哨兵）</strong></h2><p>保证集群的高可用。作用故障发现，故障转移，通知。</p><p>自动故障转移就是当主节点不能正常工作时，Sentinel会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。</p><p>工作原理就是，当Master宕机的时候，Sentinel会选举出新的Master，并根据Sentinel中<code>client-reconfig-script</code>脚本配置的内容，去动态修改VIP(虚拟IP)，将VIP(虚拟IP)指向新的Master。我们的客户端就连向指定的VIP即可！故障发生后的转移情况，可以理解为下图</p><img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/725429-20190210232919215-1911685532.jpg" style="zoom:67%;"><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷:"></a>缺陷:</h3><p>(1)主从切换的过程中会丢数据<br>(2)Redis只能单点写，不能水平扩容</p><p><strong>实现原理：</strong><br>三个定时监控任务<br>1）每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。<br>2）每隔2秒，每个Sentinel节点会向Redis数据节点的<strong>sentinel</strong>:hello频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。<br>3）每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。</p><p><strong>主观下线</strong><br>因为每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。<br><strong>客观下线</strong><br>当Sentinel主观下线的节点是主节点时，该Sentinel节点会向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，那么意味着大部分的Sentinel节点都对这个主节点的下线做了同意的判定，于是该Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定。</quorum></p><p><strong>领导者Sentinel节点选举</strong><br>Raft算法：假设s1(sentinel-1)最先完成客观下线，它会向其余Sentinel节点发送命令，请求成为领导者；收到命令的Sentinel节点如果没有同意过其他Sentinel节点的请求，那么就会同意s1的请求，否则拒绝；如果s1发现自己的票数已经大于等于某个值，那么它将成为领导者。</p><p><strong>故障转移</strong><br>1）领导者Sentinel节点在从节点列表中选出一个节点作为新的主节点<br>2）上一步的选取规则是与主节点复制相似度最高的从节点<br>3）领导者Sentinel节点让剩余的从节点成为新的主节点的从节点<br>4）Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</p><h2 id="redis集群（redis-cluster）"><a href="#redis集群（redis-cluster）" class="headerlink" title="redis集群（redis cluster）"></a><strong>redis集群（redis cluster）</strong></h2><ol><li><p>redis3以后，节点之间提供了完整的sharding（分片）、replication（主备感知能力）、failover（故障转移）的特性</p></li><li><p>配置一致性：每个节点（Node）内部都保存了集群的配置信息，存储在clusterState中，通过引入自增的epoch变量来使得集群配置在各个节点间保持一致</p></li><li><p>sharding数据分片 </p><ol><li>将所有数据划分为16384个分片（slot），每个节点会对应一部分slot，每个key都会根据分布算法映射到16384个slot中的一个，分布算法为slotId=crc16(key)%16384</li><li>当一个client访问的key不在对应节点的slots中，redis会返回给client一个moved命令，告知其正确的路由信息从而重新发起请求。client会根据每次请求来缓存本地的路由缓存信息，以便下次请求直接能够路由到正确的节点</li><li>分片迁移：分片迁移的触发和过程控制由外部系统完成，redis只提供迁移过程中需要的原语支持。主要包含两种：一种是节点迁移状态设置，即迁移前标记源、目标节点；另一种是key迁移的原子化命令</li></ol></li><li><p>failover故障转移 </p><ol><li>故障发现：节点间两两通过TCP保持连接，周期性进行PING、PONG交互，若对方的PONG相应超时未收到，则将其置为PFAIL状态，并传播给其他节点</li><li>故障确认：当集群中有一半以上的节点对某一个PFAIL状态进行了确认，则将起改为FAIL状态，确认其故障</li><li>slave选举：当有一个master挂掉了，则其slave重新竞选出一个新的master。主要根据各个slave最后一次同步master信息的时间，越新表示slave的数据越新，竞选的优先级越高，就更有可能选中。竞选成功之后将消息传播给其他节点。</li></ol></li><li><p>从节点选举<br> ①每个从节点，都根据自己对master复制数据的offset，来设置一个选举时间，offset越大的从节点，选举时间越靠前，优先进行选举。</p><p>②所有的master node开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node(N/2 + 1)都投票给了某个从节点，那么选举通过，那个从节点可以切换成master node。</p><p>③从节点执行主备切换，从节点切换为主节点。</p></li><li><p>主从同步</p><p><strong>2.8版本之后 同步操作PSYNC。自行判断 是全量同步 还是 增量同步 效率比较高**</strong>2.8版本之后 同步操作PSYNC。自行判断 是全量同步 还是 增量同步 效率比较高**</p><p><strong>部分重同步功能由下面几个部分构成：</strong><br><font color="red">主服务器的复制偏移量和从服务器的复制偏移量</font>：当主服务器在向从服务器进行命令同步时，主服务器和从服务器会各自记录一个复制偏移量，当主从服务器的数据库状态一致时这两个复制偏移量是相同的，如果这两个偏移量不一致说明当前主从服务器的状态不一致<br><font color="red">主服务器的复制积压缓冲区</font>：复制积压缓冲区是一个固定大小的FIFO队列，当队列已满时会弹出最早插入的数据，在主服务器进行命令传播时会同时把命令放到缓冲区中，缓冲区包含两部分数据，偏移量和字节。在进行复制时从服务器会将偏移量上报到主服务器，主服务检查当前偏移量是否还存在缓冲区中，如果存在进行部分重同步，如果不存在进行完整重同步。因为这个积压缓冲区是一个固定大小的队列，所以当从服务器长时间断线时，从服务器的复制偏移量很可能已不再缓冲区中，这时候只能进行完整重同步<br><font color="red">服务器的运行ID</font>：初次同步时主服务器会把ID发给从服务器，从服务器保存主服务器ID，当断线重连后，会把之前保存的主服务器ID上报给主服务器，主服务器检查从服务器之前复制的主服务器ID是否和自己的ID相同，如果相同，执行部分重同步，如果不同说明从服务器之前记录的状态不是当前主服务器，这时候需要执行完整重同步<br><strong>PSYNC命令实现</strong></p><p>1）初始复制或者之前执行过SLAVEOF no one命令，执行完整重同步：发送PSYNC ? -1命令到主服务器<br>2）如果从服务器已经复制过某个主服务器，在开始新复制时向主服务器发送PSYNC <runid> <offset>命令，runid是上次复制的主服务器id，offset是从服务器的复制偏移量<br>3）主服务器会根据这个两个参数来决定做哪种同步，判断服务器id是否和本机相同，复制偏移量是否在缓冲区中，主服务器有三种回复：</offset></runid></p><p>回复+FULLRESYNC <runid> <offset>执行完整重同步，从服务器把offset当做初始复制偏移量<br>回复+CONTINUE，表示执行部分重同步，从服务器等待主服务器发送缺少的数据<br>回复-ERR，表示主服务器版本低于2.8，不支持PSYNC命令</offset></runid></p><p><strong>增量同步</strong><br>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p><p><strong>Redis主从同步策略</strong><br>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。<br><strong>注意点</strong><br>如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</p><p><strong>无磁盘复制</strong></p><p>在内存中生成RDB文件内容，默认是使用RDB磁盘文件复制，可以通过配置文件修改</p></li><li><p>集群不可用的情况： </p><ol><li>集群中任意master挂掉，且当前master没有slave。</li><li>集群中超过半数以上master挂掉。</li></ol></li><li><p>一致性协议交互</p><ol><li>使用Gossip协议，节点间进行信息交换，信息包含消息头和消息体。</li><li>消息体无外乎是一些节点标识啊，IP啊，端口号啊，发送时间，会携带一定数量的其他节点信息用于交换，约为集群总节点数量的1/10，至少携带3个节点的信息。消息体大小是10个节点的状态信息约1kb。<font color="red">节点数量越多，消息体内容越大。</font></li><li>消息头主要包含字段为type表示消息类型，区分meet，ping，pong，pfail，fail类型消息，字段为myslots的char数组，长度为16383/8，一个bitmap,每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点的。myslots大小为2kb</li></ol></li><li><p><em>定期的频率</em></p><ol><li>每秒会随机选取5个节点，找出最久没有通信的节点发送ping消息</li><li>每100毫秒(1秒10次)都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout/2 则立刻发送ping消息</li><li>每秒单节点发出ping消息数量为 <code>数量=1+10*num（node.pong_received&gt;cluster_node_timeout/2）</code></li></ol></li><li><p>使用16384个槽（slot）的原因</p><p>(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。</p><p>如上所述，在消息头中，最占空间的是<code>myslots[CLUSTER_SLOTS/8]</code>。 当槽位为65536时，这块的大小是: <code>65536÷8÷1024=8kb</code> 因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。</p><p>(2)redis的集群主节点数量基本不可能超过1000个。</p><p>如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</p><p>(3)槽位越小，节点少的情况下，压缩比高</p><p>Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p></li></ol><h2 id="普通哈希算法和一致性哈希算法对比"><a href="#普通哈希算法和一致性哈希算法对比" class="headerlink" title="普通哈希算法和一致性哈希算法对比"></a><strong>普通哈希算法和一致性哈希算法对比</strong></h2><ol><li>普通哈希：也称硬哈希，采用简单取模的方式，将机器进行散列，这在cache环境不变的情况下能取得让人满意的结果，但是当cache环境动态变化时，这种静态取模的方式显然就不满足单调性的要求（当增加或减少一台机子时，几乎所有的存储内容都要被重新散列到别的缓冲区中）。</li><li>一致性哈希：将机器节点和key值都按照一样的hash算法映射到一个0~2^32 的圆环上。当有一个写入缓存的请求到来时，计算Key值k对应的哈希值Hash(k)，如果该值正好对应之前某个机器节点的Hash值，则直接写入该机器节点，如果没有对应的机器节点，则顺时针查找下一个节点，进行写入，如果超过2^32还没找到对应节点，则从0开始查找（因为是环状结构）。为了更可能的满足平衡性，可以引入虚拟节点，即一个实体节点映射到多个虚拟节点。</li><li>参考：<a href="http://blog.huanghao.me/?p=14">http://blog.huanghao.me/?p=14</a></li></ol><h2 id="缓存雪崩，缓存穿透，缓存并发（缓存击穿），缓存预热，缓存算法"><a href="#缓存雪崩，缓存穿透，缓存并发（缓存击穿），缓存预热，缓存算法" class="headerlink" title="缓存雪崩，缓存穿透，缓存并发（缓存击穿），缓存预热，缓存算法"></a><strong>缓存雪崩，缓存穿透，缓存并发（缓存击穿），缓存预热，缓存算法</strong></h2><ol><li>缓存雪崩：可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。解决思路： <ol><li>加锁计数（即限制并发的数量，可以用semphore）或者起一定数量的队列来避免缓存失效时大量请求并发到数据库。但这种方式会降低吞吐量。</li><li>分析用户行为，然后失效时间均匀分布。或者在失效时间的基础上再加1~5分钟的随机数。</li><li>如果是某台缓存服务器宕机，则考虑做主备。</li></ol></li><li>缓存穿透：指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库中查询。解决思路： <ol><li>如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。</li><li>可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。</li></ol></li><li>缓存并发：如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。解决思路： <ol><li>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</li></ol></li><li>缓存预热：目的就是在系统上线前，将数据加载到缓存中。解决思路： <ol><li>数据量不大的话，在系统启动的时候直接加载。</li><li>自己写个简单的缓存预热程序。</li></ol></li><li>缓存算法： <ol><li>FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。</li><li>LFU算法：Least Frequently Used，最不经常使用算法。</li><li>LRU算法：Least Recently Used，近期最少使用算法。</li><li>LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的。</li></ol></li></ol><h2 id="用redis实现分布式锁"><a href="#用redis实现分布式锁" class="headerlink" title="用redis实现分布式锁"></a><strong>用redis实现分布式锁</strong></h2><ol><li><p>主要使用的命令： </p><ol><li>setnx key val。当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</li><li>expire key timeout。为key设置一个超时时间，单位为second，超过这个时间锁会自  动释放，避免死锁。</li><li>delete key。删除锁</li></ol></li><li><p>实现思想： </p><ol><li>使用setnx加锁，如果返回1，则说明加锁成功，并设置超时时间，避免系统挂了，锁没法释放。在finally中delete删除锁释放。</li><li>如果需要设置超时等待时间，则可以加个while循环，在获取不到锁的情况下，进行循环获取锁，超时了则退出。</li></ol></li><li><p>redis3.0以上版本支持set命令，原子性操作，可以跟过期时间，不用使用脚本的方式进行</p></li><li><p>问题点是：</p><ol><li>单点问题：当主挂了之后，设置的数据还未同步到从节点，导致其它线程加锁成功</li><li>续期问题：过期时间到之后但是业务还没有处理完成，此时需要续期，续租。可以使用守护线程进行续期</li><li>使用Redisson的红锁，使用Hash结构，实现了可重入锁，解决单节点问题，并使用watch dog（）解决续期</li></ol></li></ol><h2 id="Redis的缓存淘汰策略LRU与LFU"><a href="#Redis的缓存淘汰策略LRU与LFU" class="headerlink" title="Redis的缓存淘汰策略LRU与LFU"></a><a href="https://www.jianshu.com/p/c8aeb3eee6bc">Redis的缓存淘汰策略LRU与LFU</a></h2><h2 id="Redis内存不足的缓存淘汰策略"><a href="#Redis内存不足的缓存淘汰策略" class="headerlink" title="Redis内存不足的缓存淘汰策略"></a>Redis内存不足的缓存淘汰策略</h2><ul><li>noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键</li><li>volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键</li><li>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</li><li>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</li><li>allkeys-random：加入键的时候如果过限，从所有key随机删除</li><li>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</li><li>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</li><li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li></ul><h2 id="Redis缓存淘汰策略"><a href="#Redis缓存淘汰策略" class="headerlink" title="Redis缓存淘汰策略"></a>Redis缓存淘汰策略</h2><p>在Redis内存使用超过一定值的时候（一般这个值可以配置）使用的淘汰策略；</p><h2 id="Redis键的过期删除策略"><a href="#Redis键的过期删除策略" class="headerlink" title="Redis键的过期删除策略"></a>Redis键的过期删除策略</h2><p>通过定期删除+惰性删除两者结合的方式进行内存淘汰的。</p><ul><li>惰性删除：当某个key被设置了过期时间之后，客户端每次对该key的访问（读写）都会事先检测该key是否过期，如果过期就直接删除；</li><li>但有一些键只访问一次，因此需要主动删除，默认情况下redis每秒检测10次，检测的对象是所有设置了过期时间的键集合，每次从这个集合中随机检测20个键查看他们是否过期，如果过期就直接删除，如果删除后还有超过25%的集合中的键已经过期，那么继续检测过期集合中的20个随机键进行删除。这样可以保证过期键最大只占所有设置了过期时间键的25%。</li></ul><h2 id="Redis中LRU的实现"><a href="#Redis中LRU的实现" class="headerlink" title="Redis中LRU的实现"></a>Redis中LRU的实现</h2><p>Redis维护了一个24位全局时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。每个key内部也维护了一个24位的时钟，当新增key对象的时候会把系统的时钟赋值到这个内部对象时钟。比如我现在要进行LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰，这里值得注意的是全局时钟只有24位，按秒为单位来表示才能存储194天，所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。</p><p>Redis中的LRU与常规的LRU实现并不相同，常规LRU会准确的淘汰掉队头的元素，但是Redis的LRU并不维护队列，只是根据配置的策略要么从所有的key中随机选择N个（N可以配置）要么从所有的设置了过期时间的key中选出N个键，然后再从这N个键中选出最久没有使用的一个key进行淘汰。</p><h2 id="Redis中LFU的实现"><a href="#Redis中LFU的实现" class="headerlink" title="Redis中LFU的实现"></a>Redis中LFU的实现</h2><p>LFU是在Redis4.0后出现的，LRU的最近最少使用实际上并不精确，考虑下面的情况，如果在|处删除，那么A距离的时间最久，但实际上A的使用频率要比B频繁，所以合理的淘汰策略应该是淘汰B。LFU就是为应对这种情况而生的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A~~A~~A~~A~~A~~A~~A~~A~~A~~A~~~|</span><br><span class="line">B~~~~~B~~~~~B~~~~~B~~~~~~~~~~~B|</span><br></pre></td></tr></table></figure><p>LFU把原来的key对象的内部时钟的24位分成两部分，前16位还代表时钟，后8位代表一个计数器。16位的情况下如果还按照秒为单位就会导致不够用，所以一般这里以时钟为单位。而后8位表示当前key对象的访问频率，8位只能代表255，但是redis并没有采用线性上升的方式，而是通过一个复杂的公式，通过配置两个参数来调整数据的递增速度。如果一个key经过几分钟没有被命中，那么后8位的值是需要递减几分钟。最后，redis会对内部时钟最小的key进行淘汰（最小表示最不频繁使用），注意这个过程也是根据策略随机选择键。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lfu-<span class="built_in">log</span>-factor <span class="number">10</span></span><br><span class="line">lfu-decay-time <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><p>使用多个 Redis 从服务器处理读查询时可能会遇到的最棘手的问题，就是主服务器临时下线或者永久下线。每当有从服务器尝试与主服务器建立连接的时候，主服务器就会为从服务器创建一个快照，如果在快照创建完毕之前，有多个从服务器都尝试与主服务器进行连接，那么这些从服务器将接收到同一个快照。从效率的角度来看，这种做法非常好，因为它可以避免创建多个快照。但是，<strong>同时向多个从服务器发送快照的多个副本，可能会将主服务器可用的大部分带宽消耗殆尽</strong>。使主服务器的延迟变高，甚至导致主服务器已经建立了连接的从服务器断开。</p><p><font color="red">解决从服务器重同步（resync）问题的其中一个方法</font>，就是<strong>减少主服务器需要传送给从服务器的数据数量，这可以通过构建树状复制中间层来完成</strong>。</p><p><img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/1760830-d430d0dc2cf82058"><br>从服务器树非常有用，在对不同数据中心（data center）进行复制的时候，这种从服务器树甚至是必需的：通过缓慢的广域网（WAN）连接进行重同步是一件相当耗费资源的工作，这种工作应该交给位于中间层的从服务器去做，而不必劳烦最顶层的主服务器。但是另一方面，构建从服务器树也会带来复杂的网络拓扑结构（topology），这增加了手动和自动处理故障转移的难度。</p><p><font color="red">解决从服务器重同步问题的<strong>另一个方法就是对网络连接进行压缩</strong></font>，从而减少需要传送的数据量。一些 Redis 用户就发现使用带压缩的 SSH 隧道（tunnel）进行连接可以明显地降低带宽占用，比如某个公司就曾经使用这种方法，将复制单个从服务器所需的带宽从原来的 21Mbit 降低为 1.8Mbit（<a href="http://mng.bz/2ivv%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E8%AF%BB%E8%80%85%E4%B9%9F%E6%89%93%E7%AE%97%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%9D%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%B7%E8%AE%B0%E5%BE%97%E4%BD%BF%E7%94%A8">http://mng.bz/2ivv）。如果读者也打算使用这个方法的话，那么请记得使用</a> SSH 提供的选项来让 SSH 连接在断线后自动重连。</p><h2 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a><strong>Redis Sentinel</strong></h2><p>Redis Sentinel 可以配合 Redis 的复制功能使用，并对下线的主服务器进行故障转移。Sentinel 会监视一系列主服务器以及这些主服务器的从服务器，通过向主服务器发送<em>PUBLISH</em>命令和SUBSCRIBE命令，并向主服务器和从服务器发送<em>PING</em>命令，各个 Sentinel 进程可以自主识别可用的从服务器和其他 Sentinel。</p><p>当主服务器失效的时候，监视这个主服务器的所有 Sentinel 就会基于彼此共有的信息选出一个 Sentinel，并从现有的从服务器当中选出一个新的主服务器。当被选中的从服务器转换成主服务器之后，那个被选中的 Sentinel 就会让剩余的其他从服务器去复制这个新的主服务器（在默认设置下，Sentinel 会一个接一个地迁移从服务器，但这个数量可以通过配置选项进行修改）。</p><p>一般来说，使用 Redis Sentinel 的目的就是为了向主服务器属下的从服务器提供自动故障转移服务。此外，Redis Sentinel 还提供了可选的故障转移通知功能，这个功能可以通过调用用户提供的脚本来执行配置更新等操作。</p><h3 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h3><p>• 性能指标：Performance</p><p>•内存指标: Memory</p><p>•基本活动指标：Basic activity</p><p>•持久性指标: Persistence</p><p>•错误指标：Error</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>问题1:懂Redis事务么？<br><code>正常版</code>：Redis事务是一些列redis命令的集合,blabla…<br><code>高调版</code>: 我们在生产上采用的是Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效的。其次，Redis事务不支持回滚操作，简直是鸡肋！所以基本不用！</p><p>问题2:Redis的多数据库机制，了解多少？<br><code>正常版</code>：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，单机下的redis可以支持16个数据库（db0 ~ db15）<br><code>高调版</code>: 在Redis Cluster集群架构下只有一个数据库空间，即db0。因此，我们没有使用Redis的多数据库功能！</p><p>问题3:Redis集群机制中，你觉得有什么不足的地方吗？<br><code>正常版</code>: 不知道<br><code>高调版</code>: 假设我有一个key，对应的value是Hash类型的。如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上！还有就是做批量操作比较麻烦！</p><p>问题4:懂Redis的批量操作么？<br><code>正常版</code>: 懂一点。比如mset、mget操作等，blabla<br><code>高调版</code>: 我们在生产上采用的是Redis Cluster集群架构，不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通的。</p><p>问题5:那在Redis集群模式下，如何进行批量操作？</p><p>如果执行的key数量比较少，就不用mget了，就用串行get操作。如果真的需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。简单来说语法如下</p><blockquote><p><strong>对于key为{foo}.student1、{foo}.student2，{foo}student3，这类key一定是在同一个redis节点上。因为key中“{}”之间的字符串就是当前key的hash tags， 只有key中{ }中的部分才被用来做hash，因此计算出来的redis节点一定是同一个!</strong></p></blockquote><p><code>ps</code>:如果你用的是Proxy分片集群架构，例如Codis这种，会将mget/mset的多个key拆分成多个命令发往不同得redis实例，这里不多说。我推荐答的还是redis cluster。</p><p>问题6:你们有对Redis做读写分离么？<br><code>正常版</code>:没有做，至于原因额。。。额。。。额。。没办法了，硬着头皮扯~<br><code>高调版</code>:不做读写分离。我们用的是Redis Cluster的架构，是属于分片集群的架构。而redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</p><p><img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/image-20210721103502584.png" alt="image-20210721103502584"></p><p><a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>使用过程中经常会有各种大key的情况， 比如：</p><ul><li>单个简单的key存储的value很大</li><li>hash， set，zset，list 中存储过多的元素（以万为单位） 由于redis是单线程运行的，如果一次操作的value很大会对整个redis的响应时间造成负面影响，所以，业务上能拆则拆，下面举几个典型的分拆方案。 1. 单个简单的key存储的value很大 1.1 改对象需要每次都整存整取 可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；    </li></ul><h4 id="1-2-该对象每次只需要存取部分数据"><a href="#1-2-该对象每次只需要存取部分数据" class="headerlink" title="1.2 该对象每次只需要存取部分数据"></a>1.2 该对象每次只需要存取部分数据</h4><p>可以像第一种做法一样，分拆成几个key-value，  也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性    </p><h3 id="2-hash、set、zset、list-中存储过多的元素"><a href="#2-hash、set、zset、list-中存储过多的元素" class="headerlink" title="2. hash、set、zset、list 中存储过多的元素"></a>2. hash、set、zset、list 中存储过多的元素</h3><p>类似于场景一种的第一个做法，可以将这些元素分拆。</p><p>以hash为例，原先的正常存取流程是  hget(hashKey, field) ; hset(hashKey, field, value) 现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newHashKey  =  hashKey + (*hash*(field) % <span class="number">10000</span>）;   </span><br><span class="line">hset (newHashKey, field, value) ;  </span><br><span class="line">hget(newHashKey, field)</span><br></pre></td></tr></table></figure><p>set, zset, list 也可以类似上述做法.</p><p>但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT之简单使用</title>
      <link href="2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MQTT-Java-客户端库"><a href="#MQTT-Java-客户端库" class="headerlink" title="MQTT Java 客户端库"></a>MQTT Java 客户端库</h1><p><a href="https://www.eclipse.org/paho/clients/java/">Eclipse Paho Java Client (opens new window)</a>是用 Java 编写的 MQTT 客户端库（MQTT Java Client），可用于 JVM 或其他 Java 兼容平台（例如Android）。</p><p>Eclipse Paho Java Client 提供了MqttAsyncClient 和 MqttClient 异步和同步 API。</p><h2 id="通过-Maven-安装-Paho-Java"><a href="#通过-Maven-安装-Paho-Java" class="headerlink" title="通过 Maven 安装 Paho Java"></a>通过 Maven 安装 Paho Java</h2><p>通过包管理工具 Maven 可以方便地安装 Paho Java 客户端库，截止目前最新版本安装如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.paho<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.paho.client.mqttv3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Paho-Java-使用示例"><a href="#Paho-Java-使用示例" class="headerlink" title="Paho Java 使用示例"></a>Paho Java 使用示例</h2><p>Java 体系中 Paho Java 是比较稳定、广泛应用的 MQTT 客户端库，本示例包含 Java 语言的 Paho Java 连接 EMQ X Broker，并进行消息收发完整代码：</p><p><strong>App.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.emqx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttClient;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttConnectOptions;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttException;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String subTopic = <span class="string">&quot;testtopic/#&quot;</span>;</span><br><span class="line">        String pubTopic = <span class="string">&quot;testtopic/1&quot;</span>;</span><br><span class="line">        String content = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> qos = <span class="number">2</span>;</span><br><span class="line">        String broker = <span class="string">&quot;tcp://broker.emqx.io:1883&quot;</span>;</span><br><span class="line">        String clientId = <span class="string">&quot;emqx_test&quot;</span>;</span><br><span class="line">        MemoryPersistence persistence = <span class="keyword">new</span> MemoryPersistence();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MqttClient client = <span class="keyword">new</span> MqttClient(broker, clientId, persistence);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MQTT 连接选项</span></span><br><span class="line">            MqttConnectOptions connOpts = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">            connOpts.setUserName(<span class="string">&quot;emqx_test&quot;</span>);</span><br><span class="line">            connOpts.setPassword(<span class="string">&quot;emqx_test_password&quot;</span>.toCharArray());</span><br><span class="line">            <span class="comment">// 保留会话</span></span><br><span class="line">            connOpts.setCleanSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置回调</span></span><br><span class="line">            client.setCallback(<span class="keyword">new</span> PushCallback());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Connecting to broker: &quot;</span> + broker);</span><br><span class="line">            client.connect(connOpts);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Connected&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Publishing message: &quot;</span> + content);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 订阅</span></span><br><span class="line">            client.subscribe(subTopic);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息发布所需参数</span></span><br><span class="line">            MqttMessage message = <span class="keyword">new</span> MqttMessage(content.getBytes());</span><br><span class="line">            message.setQos(qos);</span><br><span class="line">            client.publish(pubTopic, message);</span><br><span class="line">            System.out.println(<span class="string">&quot;Message published&quot;</span>);</span><br><span class="line"></span><br><span class="line">            client.disconnect();</span><br><span class="line">            System.out.println(<span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">            client.close();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MqttException me) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;reason &quot;</span> + me.getReasonCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;msg &quot;</span> + me.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;loc &quot;</span> + me.getLocalizedMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;cause &quot;</span> + me.getCause());</span><br><span class="line">            System.out.println(<span class="string">&quot;excep &quot;</span> + me);</span><br><span class="line">            me.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回调消息处理类 OnMessageCallback.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.emqx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttCallback;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnMessageCallback</span> <span class="keyword">implements</span> <span class="title">MqttCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionLost</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 连接丢失后，一般在这里面进行重连</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开，可以做重连&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageArrived</span><span class="params">(String topic, MqttMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// subscribe后得到的消息会执行到这里面</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息主题:&quot;</span> + topic);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息Qos:&quot;</span> + message.getQos());</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息内容:&quot;</span> + <span class="keyword">new</span> String(message.getPayload()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliveryComplete</span><span class="params">(IMqttDeliveryToken token)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;deliveryComplete---------&quot;</span> + token.isComplete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Paho-Java-MQTT-5-0-支持"><a href="#Paho-Java-MQTT-5-0-支持" class="headerlink" title="Paho Java MQTT 5.0 支持"></a>Paho Java MQTT 5.0 支持</h2><p>目前 Paho Java 还在适配 MQTT 5.0，尚未全面支持。</p><h2 id="离线数据"><a href="#离线数据" class="headerlink" title="离线数据"></a>离线数据</h2><p>满足以下条件：</p><ul><li>发布和订阅客户端的clientId必须一样，必须自己设置。如果不设置，emqtt服务端会自动产生一个唯一的id。</li><li>发布和订阅客户端setCleanSession(false);不清除session</li><li>客户端的QoS &gt;= 1</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> EMQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT之Qos详解</title>
      <link href="2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://www.zhihu.com/people/zero-50-79">程序锅</a><br>出处：<a href="https://zhuanlan.zhihu.com/p/80203905">https://zhuanlan.zhihu.com/p/80203905</a></p><h2 id="1-MQTT中的QoS等级"><a href="#1-MQTT中的QoS等级" class="headerlink" title="1. MQTT中的QoS等级"></a>1. MQTT中的QoS等级</h2><p>MQTT设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次QoS（Quality of Service）：</p><ul><li>QoS0，At most once，至多一次；</li><li>QoS1，At least once，至少一次；</li><li>QoS2，Exactly once，确保只有一次。</li></ul><p>QoS 是消息的发送方（Sender）和接受方（Receiver）之间达成的一个协议：</p><ul><li>QoS0 代表，Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了；</li><li>QoS1 代表，Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息；</li><li>QoS2 代表，Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。</li></ul><blockquote><p>注意：<br>QoS是Sender和Receiver之间的协议，而不是Publisher和Subscriber之间的协议。换句话说，Publisher发布了一条QoS1的消息，只能保证Broker能至少收到一次这个消息；而对于Subscriber能否至少收到一次这个消息，还要取决于Subscriber在Subscibe的时候和Broker协商的QoS等级。</p></blockquote><h3 id="1-1-QoS0"><a href="#1-1-QoS0" class="headerlink" title="1.1. QoS0"></a>1.1. QoS0</h3><p>QoS0等级下，Sender和Receiver之间一次消息的传递流程如下：</p><p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-c707d4103db77637e352e20f445f728c_r.jpg" alt="preview"></p><p>Sender向Receiver发送一个包含消息数据的PUBLISH包，然后不管结果如何，丢掉已发送的PUBLISH包，一条消息的发送完成。</p><h3 id="1-2-QoS1"><a href="#1-2-QoS1" class="headerlink" title="1.2. QoS1"></a>1.2. QoS1</h3><p>QoS1要保证消息至少到达一次，所以有一个应答的机制。Sender和Receiver的一次消息的传递流程如下：</p><p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-600d6162bdb9e17430437ce58bfcda8f_720w.jpg" alt="img"></p><ol><li>Sender向Receiver发送一个带有数据的PUBLISH包，并在本地保存这个PUBLISH包；</li><li>Receiver收到PUBLISH包以后，向Sender发送一个PUBACK数据包，PUBACK数据包没有消息体（Payload），在可变头中有一个包标识（Packet Identifier），和它收到的PUBLISH包中的Packet Identifier一致。</li><li>Sender收到PUBACK之后，根据PUBACK包中的Packet Identifier找到本地保存的PUBLISH包，然后丢弃掉，一次消息的发送完成。</li></ol><p>但是消息传递流程中可能会出现问题：</p><ul><li>如果Sender在一段时间内没有收到PUBLISH包对应的PUBACK，它将该PUBLISH包的DUP标识设为1（代表是重新发送的PUBLISH包），然后重新发送该PUBLISH包。</li><li>Receiver可能会重复收到消息，需自行去重。</li></ul><h3 id="1-3-QoS2"><a href="#1-3-QoS2" class="headerlink" title="1.3. QoS2"></a>1.3. QoS2</h3><p>相比QoS0和QoS1,QoS2不仅要确保Receiver能收到Sender发送的消息，还需要确保消息不重复。它的重传和应答机制就要复杂一些，同时开销也是最大的。QoS2下，一次消息的传递流程如下所示：</p><p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-f9be4b4af808507942cad20984b1d0d8_720w.jpg" alt="img"></p><ol><li>Sender发送QoS为2的PUBLISH数据包，数据包 Packet Identifier 为 P，并在本地保存该PUBLISH包；</li><li>Receiver收到PUBLISH数据包后，<strong>在本地保存PUBLISH包的Packet Identifier P</strong>，并回复Sender一个PUBREC数据包，PUBREC数据包可变头中的Packet Identifier为P，没有消息体（Payload）；</li><li>当Sender收到PUBREC，它就可以安全的丢弃掉初始Packet Identifier为P的PUBLISH数据包。同时保存该PUBREC数据包，并回复Receiver一个PUBREL数据包，PUBREL数据包可变头中的Packet Identifier为P，没有消息体；</li><li>当Receiver收到PUBREL数据包，它可以丢掉保存的PUBLISH包的Packet Identifier P，并回复Sender一个可变头中 Packet Identifier 为 P，没有消息体（Payload）的PUBCOMP数据包；</li><li>当Sender收到PUBCOMP包，那么认为传输已完成，则丢掉对应的PUBREC数据包；</li></ol><p>上面是一次完整无误的传输过程，然而传输过程中可能会出现以下情况：</p><ul><li>情况1：Sender发送PUBLISH数据包给Receiver的时候，发送失败；</li><li>情况2：Sender已经成功发送PUBLISH数据包给Receiver了，但是Receiver发送PUBREC数据包失败；</li><li>情况3：Sender已经成功收到了PUBREC数据包，但是PUBREL数据包发送失败；</li><li>情况4：Receiver已经收到了PUBREL数据包，但是发送PUBCOMP数据包时发送失败</li></ul><p>针对上述的问题，较为详细的处理方法如下：</p><ul><li>不管是情况1还是情况2，因为Sender在一定时间内没有收到PUBREC，那么它会把PUBLISH包的DUP标识设为1，重新发送该PUBLISH数据包；</li><li>不管是情况3还是情况4，因为Sender在一定时间内没有收到PUBCOMP包，那么它会重新发送PUBREL数据包；</li><li>针对情况2，Receiver可能会收到多个重复的PUBLISH包，更加完善的处理如下：<br>Receiver在收到PUBLISH数据包之后，马上回复一个PUBREC数据包。并会在本地保存PUBLISH包的Packet Identifier P，不管之后因为重传多少次这个Packet Identifier 为P的数据包，Receiver都认为是重复的，丢弃。同时Receiver接收到QoS为2的PUBLISH数据包后，<strong>并不马上投递给上层，</strong>而是在本地做持久化，将消息保存起来（这里需要是持久化而不是保存在内存）。</li><li>针对情况4，更加完善的处理如下：<br>Receiver收到PUBREL数据包后，正式将消息递交给上层应用层，投递之后销毁Packet Identifier P，并发送PUBCOMP数据包，销毁之前的持久化消息。之后不管接收到多少个PUBREL数据包，因为没有Packet Identifier P，直接回复PUBCOMP数据包即可。</li></ul><h2 id="2-QoS降级"><a href="#2-QoS降级" class="headerlink" title="2. QoS降级"></a>2. QoS降级</h2><p>在 MQTT 协议中，从 Broker 到 Subscriber 这段消息传递的实际 QoS 等于：Publisher 发布消息时指定的 QoS 等级和 Subscriber 在订阅时与 Broker 协商的 QoS 等级，这两个 QoS 等级中的最小那一个。</p><blockquote><p><strong>Actual Subscribe QoS = MIN(Publish QoS, Subscribe QoS)</strong></p></blockquote><p>如下面代码所示：</p><p>该subscriber订阅消息时指定的QoS为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当代理响应订阅请求时被调用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_subscribe</span>(<span class="params">client, userdata, mid, granted_qos</span>):</span></span><br><span class="line">    print(<span class="string">&quot;granted_qos:&quot;</span>, granted_qos)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当收到关于客户订阅的主题的消息时调用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">client, userdata, message</span>):</span></span><br><span class="line">    print(<span class="string">&quot;message qos&quot;</span>, message.qos)</span><br><span class="line">    print(<span class="string">&quot;message topic&quot;</span>, message.topic)</span><br><span class="line">    print(<span class="string">&quot;message payload&quot;</span>, message.payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span></span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span> :</span><br><span class="line">        print(<span class="string">&quot;subscribing&quot;</span>)</span><br><span class="line">        client.subscribe(<span class="string">&quot;test&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;connection failed &quot;</span>, rc)</span><br><span class="line"></span><br><span class="line">mqtt_client = mqtt.Client(client_id=<span class="string">&quot;demo_mqtt_sub&quot;</span>, clean_session=<span class="literal">False</span>)</span><br><span class="line">mqtt_client.on_connect = on_connect</span><br><span class="line">mqtt_client.on_subscribe = on_subscribe</span><br><span class="line">mqtt_client.on_message = on_message</span><br><span class="line"></span><br><span class="line">mqtt_client.connect(<span class="string">&quot;192.168.10.239&quot;</span>, <span class="number">1883</span>)</span><br><span class="line">mqtt_client.loop_forever()</span><br></pre></td></tr></table></figure><p>运行上述代码输出的结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscribing</span><br><span class="line">granted_qos: (1,)</span><br></pre></td></tr></table></figure><p>之后运行下面的publisher代码，指定发送的PUBLISH数据包的QoS等级为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span></span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span>:</span><br><span class="line">        client.publish(<span class="string">&quot;test&quot;</span>, payload=<span class="string">&quot;hello world&quot;</span>, qos=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;connection failed &quot;</span>, rc)</span><br><span class="line"></span><br><span class="line">mqtt_client = mqtt.Client(client_id=<span class="string">&quot;demo_mqtt_pub&quot;</span>, clean_session=<span class="literal">False</span>)</span><br><span class="line">mqtt_client.on_connect = on_connect</span><br><span class="line"></span><br><span class="line">mqtt_client.connect(<span class="string">&quot;192.168.10.239&quot;</span>, <span class="number">1883</span>)</span><br><span class="line">mqtt_client.loop_forever()</span><br></pre></td></tr></table></figure><p>结果上面运行subscriber代码的终端输出如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message qos 0</span><br><span class="line">message topic <span class="built_in">test</span></span><br><span class="line">message payload b<span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><p>上述的结果表示，订阅者收到的消息的qos等级为0。同样如果修改subscriber中的订阅主题的QoS等级为0，publisher中发布的PUBLISH包的QoS为1，那么输出结果同上。</p><h2 id="3-QoS和会话"><a href="#3-QoS和会话" class="headerlink" title="3. QoS和会话"></a>3. QoS和会话</h2><p>如果 Client 想接收离线消息，必须使用持久化的会话（Clean Session = 0）连接到 Broker，这样 Broker 才会存储 Client 在离线期间没有确认接收的 QoS 大于 等于1 的消息。</p><blockquote><p>在发送QoS为1或2的情况，Broker（此时为Sender）会将发送的PUBLISH数据包保存到本地，直到收到一系列回复的数据包，然而Client（此时为Receiver）在离线期间无法回复相应的数据包，所以会一直存储。</p></blockquote><h2 id="4-QoS等级使用建议"><a href="#4-QoS等级使用建议" class="headerlink" title="4. QoS等级使用建议"></a>4. QoS等级使用建议</h2><p><strong>在以下情况下你可以选择 QoS0</strong>：</p><ul><li>Client 和 Broker 之间的网络连接非常稳定，例如一个通过有线网络连接到 Broker 的测试用 Client；</li><li>可以接受丢失部分消息，比如你有一个传感器以非常短的间隔发布状态数据，所以丢一些也可以接受；</li><li>你不需要离线消息。</li></ul><p><strong>在以下情况下你应该选择 QoS1：</strong></p><ul><li>你需要接收所有的消息，而且你的应用可以接受并处理重复的消息；</li><li>你无法接受 QoS2 带来的额外开销，QoS1 发送消息的速度比 QoS2 快很多。</li></ul><p><strong>在以下情况下你应该选择 QoS2：</strong></p><ul><li>你的应用必须接收到所有的消息，而且你的应用在重复的消息下无法正常工作，同时你也能接受 QoS2 带来的额外开销。</li></ul><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a><strong>本文参考</strong></h2><ol><li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/zerooffdate/article/details/78950907">MQTT协议QoS2 准确一次送达的实现</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> EMQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql之索引</title>
      <link href="2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
      <url>2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL索引方法"><a href="#MySQL索引方法" class="headerlink" title="MySQL索引方法"></a>MySQL索引方法</h2><ul><li>Hash （对于指定值查询很快，能直接定位，但是范围查询无效）</li><li>B+树 （提升查询效率）</li></ul><h2 id="B-树索引和哈希索引的区别"><a href="#B-树索引和哈希索引的区别" class="headerlink" title="B+树索引和哈希索引的区别"></a><strong>B+树索引和哈希索引的区别</strong></h2><p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</p><p><img src="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/1.jpeg" alt="img"></p><p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的，如下图所示：</p><p><img src="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/2.jpeg" alt="img"></p><h2 id="哈希索引的优缺点"><a href="#哈希索引的优缺点" class="headerlink" title="哈希索引的优缺点"></a>哈希索引的优缺点</h2><p><strong>等值查询，</strong>哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p><p><strong>缺点</strong></p><ol><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li></ol><h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a><strong>B树和B+树的区别</strong></h2><p>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</p><p><img src="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/3.jpeg" alt="img"></p><p>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接</p><p>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p><p><img src="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/4.jpeg" alt="img"></p><h2 id="B-比B树更适合实际应用中操作系统的文件索引和数据库索引"><a href="#B-比B树更适合实际应用中操作系统的文件索引和数据库索引" class="headerlink" title="B+比B树更适合实际应用中操作系统的文件索引和数据库索引"></a><strong>B+比B树更适合实际应用中操作系统的文件索引和数据库索引</strong></h2><p>1、B+的磁盘读写代价更低。</p><p>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</p><p>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+tree的查询效率更加稳定。</p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><ul><li>聚簇索引（clustered index ）</li><li>非聚簇索引（secondary index）</li></ul><p>​    InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p><p>​    MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p><p>InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。并且和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ul><li>最左匹配原则</li><li>like使用，&gt; &lt;使用  都会让组合索引后面的字段不走索引</li><li>回表查询，覆盖索引</li><li>减少关联sql查询</li></ul><h2 id="Explain执行计划"><a href="#Explain执行计划" class="headerlink" title="Explain执行计划"></a>Explain执行计划</h2><p>id：SQL执行的顺利的标识,SQL从大到小的执行,先执行的语句编号大。</p><p>type：system &gt;const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt;unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p><strong>好的sql查询至少达到range级别，最好能达到ref</strong></p><p>依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL。</p><p>除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引。</p><p>system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p><p>const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描。</p><p>eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref。</p><p>ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p><p>fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引。</p><p>ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p><p>unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值。</p><p>index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p><p>range：索引范围扫描，常见于使用&gt;,&lt;,is null,between,in ,like等运算符的查询中。</p><p>index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能都不如range。</p><p>index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p><p>key， possible_keys,</p><p>rows: 大致估算出找到所需的记录所需要读取的行数</p><p>Extra:  Using filesort （排序时无法使用到索引时，就会出现这个。常见于orderby和group by语句中。）</p><p>​             Using temporary（表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。）</p><p>​            usingindex：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql之存储引擎</title>
      <link href="2020/12/22/mysql%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>2020/12/22/mysql%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>MySQL 有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</span><br></pre></td></tr></table></figure><p>MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎：</p><ul><li><p><strong>MyISAM</strong>管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。</p></li><li><p><strong>MEMORY</strong>存储引擎提供”内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中。</p><p>注释：MEMORY存储引擎正式地被确定为HEAP引擎。</p></li><li><p><strong>InnoDB</strong>和BDB存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎。</p></li><li><p><strong>EXAMPLE</strong>存储引擎是一个”存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。</p></li><li><p><strong>NDB Cluster</strong>是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows。</p></li><li><p><strong>ARCHIVE</strong>存储引擎被用来无索引地，非常小地覆盖存储的大量数据。</p></li><li><p><strong>CSV</strong>存储引擎把数据以逗号分隔的格式存储在文本文件中。</p></li><li><p><strong>BLACKHOLE</strong>存储引擎接受但不存储数据，并且检索总是返回一个空集。</p></li><li><p><strong>FEDERATED</strong>存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动器或客户端连接方法连接到另外的数据源。</p></li></ul><h2 id="比较常用的是-MyISAM-和-InnoBD"><a href="#比较常用的是-MyISAM-和-InnoBD" class="headerlink" title="比较常用的是 MyISAM 和 InnoBD"></a>比较常用的是 MyISAM 和 InnoBD</h2><table><thead><tr><th></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td><strong>构成上的区别：</strong></td><td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。  <br>     .frm文件存储表定义。   <br>     数据文件的扩展名为.MYD (MYData)。    <br>     索引文件的扩展名是.MYI (MYIndex)。</td><td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td></tr><tr><td><strong>事务处理上方面:</strong></td><td>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持</td><td>InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能</td></tr><tr><td><strong>SELECT  UPDATE,INSERT，Delete操作</strong></td><td>如果执行大量的SELECT，MyISAM是更好的选择</td><td><strong>1.**如果你的数据执行大量的</strong>INSERT<strong>或</strong>UPDATE<strong>，出于性能方面的考虑，应该使用InnoDB表   **2.DELETE  FROM table</strong>时，InnoDB不会重新建立表，而是一行一行的删除。   <strong>3.LOAD  TABLE FROM MASTER</strong>操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用</td></tr><tr><td><strong>对AUTO_INCREMENT的操作</strong></td><td>每表一个AUTO_INCREMEN列的内部处理。   <strong>MyISAM为INSERT和UPDATE操作自动更新这一列</strong>。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。   AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置   对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引   更好和更快的auto_increment处理</td><td>如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。   自动增长计数器仅被存储在主内存中，而不是存在磁盘上   关于该计算器的算法实现，请参考   <strong>AUTO_INCREMENT列在InnoDB里如何工作</strong></td></tr><tr><td><strong>表的具体行数</strong></td><td>select count(<em>) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(</em>)语句包含  where条件时，两种表的操作是一样的</td><td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行</td></tr><tr><td><strong>锁</strong></td><td>表锁</td><td>提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in   SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%”</td></tr></tbody></table><h2 id="MySQL-存储引擎-MyISAM-与-InnoDB-如何选择？"><a href="#MySQL-存储引擎-MyISAM-与-InnoDB-如何选择？" class="headerlink" title="MySQL 存储引擎 MyISAM 与 InnoDB 如何选择？"></a>MySQL 存储引擎 MyISAM 与 InnoDB 如何选择？</h2><p>虽然 MySQL 里的存储引擎不只是 MyISAM 与 InnoDB 这两个，但常用的就是它俩了。可能有站长并未注意过 MySQL 的存储引擎，其实存储引擎也是数据库设计里的一大重要点，那么博客系统应该使用哪种存储引擎呢？</p><p>下面我们分别来看两种存储引擎的区别。</p><ul><li>一、InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</li><li>二、MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</li><li>三、InnoDB支持外键，MyISAM不支持</li><li>四、MyISAM是默认引擎，InnoDB需要指定</li><li>五、InnoDB不支持FULLTEXT类型的索引</li><li>六、InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表</li><li>七、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引</li><li>八、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表</li><li>九、InnoDB支持行锁（某些情况下还是锁整表，如 <strong>update table set a=1 where user like ‘%lee%’</strong></li><li>索引区别</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT之基础</title>
      <link href="2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
      <url>2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>出处：<a href="https://www.runoob.com/w3cnote/mqtt-intro.html">MQTT 入门介绍</a></p><h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p><p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/mqtt-fidge-2.svg" alt="img"></p><hr><h2 id="二、设计规范"><a href="#二、设计规范" class="headerlink" title="二、设计规范"></a>二、设计规范</h2><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p><ul><li>（1）精简，不添加可有可无的功能；</li><li>（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</li><li>（3）允许用户动态创建主题，零运维成本；</li><li>（4）把传输量降到最低以提高传输效率；</li><li>（5）把低带宽、高延迟、不稳定的网络等因素考虑在内；</li><li>（6）支持连续的会话控制；</li><li>（7）理解客户端计算能力可能很低；</li><li>（8）提供服务质量管理；</li><li>（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li></ul><hr><h2 id="三、主要特性"><a href="#三、主要特性" class="headerlink" title="三、主要特性"></a>三、主要特性</h2><p>MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p><ul><li><p>（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</p><p>这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</p></li><li><p>（2）对负载内容屏蔽的消息传输。</p></li><li><p>（3）使用TCP/IP提供网络连接。</p><p>主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</p></li><li><p>（4）有三种消息发布服务质量：</p><p>“至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p><p>“至少一次”，确保消息到达，但消息重复可能会发生。</p><p>“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</p></li><li><p>（5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。</p><p>这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</p></li><li><p>（6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。</p><p>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</p><p>Testament：遗嘱机制，功能类似于Last Will。</p></li></ul><hr><h2 id="四、MQTT协议原理"><a href="#四、MQTT协议原理" class="headerlink" title="四、MQTT协议原理"></a>四、MQTT协议原理</h2><h3 id="4-1-MQTT协议实现方式"><a href="#4-1-MQTT协议实现方式" class="headerlink" title="4.1 MQTT协议实现方式"></a>4.1 MQTT协议实现方式</h3><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p><p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p><ul><li>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li><li>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li></ul><h3 id="4-2-网络传输与应用消息"><a href="#4-2-网络传输与应用消息" class="headerlink" title="4.2 网络传输与应用消息"></a>4.2 网络传输与应用消息</h3><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p><p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p><h3 id="4-3-MQTT客户端"><a href="#4-3-MQTT客户端" class="headerlink" title="4.3 MQTT客户端"></a>4.3 MQTT客户端</h3><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p><ul><li>（1）发布其他客户端可能会订阅的信息；</li><li>（2）订阅其它客户端发布的消息；</li><li>（3）退订或删除应用程序的消息；</li><li>（4）断开与服务器连接。</li></ul><h3 id="4-4-MQTT服务器"><a href="#4-4-MQTT服务器" class="headerlink" title="4.4 MQTT服务器"></a>4.4 MQTT服务器</h3><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p><ul><li>（1）接受来自客户的网络连接；</li><li>（2）接受客户发布的应用信息；</li><li>（3）处理来自客户端的订阅和退订请求；</li><li>（4）向订阅的客户转发应用程序消息。</li></ul><h3 id="4-5-MQTT协议中的订阅、主题、会话"><a href="#4-5-MQTT协议中的订阅、主题、会话" class="headerlink" title="4.5 MQTT协议中的订阅、主题、会话"></a>4.5 MQTT协议中的订阅、主题、会话</h3><p><strong>一、订阅（Subscription）</strong></p><p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p><p><strong>二、会话（Session）</strong></p><p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p><p><strong>三、主题名（Topic Name）</strong></p><p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p><p><strong>四、主题筛选器（Topic Filter）</strong></p><p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p><p><strong>五、负载（Payload）</strong></p><p>消息订阅者所具体接收的内容。</p><h3 id="4-6-MQTT协议中的方法"><a href="#4-6-MQTT协议中的方法" class="headerlink" title="4.6 MQTT协议中的方法"></a>4.6 MQTT协议中的方法</h3><p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p><ul><li>（1）Connect。等待与服务器建立连接。</li><li>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li><li>（3）Subscribe。等待完成订阅。</li><li>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li><li>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li></ul><hr><h2 id="五、MQTT协议数据包结构"><a href="#五、MQTT协议数据包结构" class="headerlink" title="五、MQTT协议数据包结构"></a>五、MQTT协议数据包结构</h2><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p><ul><li>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</li><li>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</li><li>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</li></ul><h3 id="5-1-MQTT固定头"><a href="#5-1-MQTT固定头" class="headerlink" title="5.1 MQTT固定头"></a>5.1 MQTT固定头</h3><p>固定头存在于所有MQTT数据包中，其结构如下：</p><p><strong>5.1.1 MQTT数据包类型</strong></p><p>位置：Byte 1中bits 7-4。</p><p>相于一个4位的无符号值，类型、取值及描述如下：</p><p><strong>5.1.2 标识位</strong></p><p>位置：Byte 1中bits 3-0。</p><p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p><p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p><p>（2）QoS：发布消息的服务质量，即：保证消息传递的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ø00：最多一次，即：&lt;&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø01：至少一次，即：&gt;&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø10：一次，即：&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø11：预留</span><br></pre></td></tr></table></figure><p>（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。 5.1.3 剩余长度（Remaining Length）</p><p>地址：Byte 2。</p><p>固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0</p><h3 id="5-2-MQTT可变头"><a href="#5-2-MQTT可变头" class="headerlink" title="5.2 MQTT可变头"></a>5.2 MQTT可变头</h3><p>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p><p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p><h3 id="5-3-Payload消息体"><a href="#5-3-Payload消息体" class="headerlink" title="5.3 Payload消息体"></a>5.3 Payload消息体</h3><p>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：</p><ul><li>（1）CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</li><li>（2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</li><li>（3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</li><li>（4）UNSUBSCRIBE，消息体内容是要订阅的主题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> EMQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之Seata简单使用</title>
      <link href="2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>作者：程序员内点事<br>链接：<a href="https://juejin.cn/post/6899645923024355336">https://juejin.cn/post/6899645923024355336</a></p><h2 id="分布式事务由来"><a href="#分布式事务由来" class="headerlink" title="分布式事务由来"></a>分布式事务由来</h2><p>当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1ec31a8cda8745c9bf7793b7bd092616~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="分库分表、SOA"><a href="#分库分表、SOA" class="headerlink" title="分库分表、SOA"></a>分库分表、SOA</h3><p>可随着业务量的不断增长，单体架构渐渐扛不住巨大的流量，此时就需要对数据库、表做 <code>分库分表</code>处理，将应用 <code>SOA</code> 服务化拆分。也就产生了订单中心、用户中心、库存中心等，由此带来的问题就是业务间相互隔离，每个业务都维护着自己的数据库，数据的交换只能进行 <code>RPC</code> 调用。</p><p>当用户再次下单时，需同时对订单库 <code>order</code>、库存库 <code>storage</code>、用户库 <code>account</code> 进行操作，可此时我们只能保证自己本地的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7d920f9dedcf454faa0b9313bd17df43~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="Seata-优势"><a href="#Seata-优势" class="headerlink" title="Seata 优势"></a>Seata 优势</h2><p>实现分布式事务的方案比较多，常见的比如基于 <code>XA</code> 协议的 <code>2PC</code>、<code>3PC</code>，基于业务层的 <code>TCC</code>，还有应用消息队列 + 消息表实现的最终一致性方案，还有今天要说的 <code>Seata</code> 中间件，下边看看各个方案的优缺点。</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a><code>2PC</code></h3><p>基于 XA 协议实现的分布式事务，XA 协议中分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如 Oracle、MYSQL 这些数据库都实现了 XA 接口，而事务管理器则作为一个全局的调度者。</p><p>两阶段提交（<code>2PC</code>），对业务侵⼊很小，它最⼤的优势就是对使⽤⽅透明，用户可以像使⽤本地事务⼀样使⽤基于 XA 协议的分布式事务，能够严格保障事务 ACID 特性。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5d98e869a3d14c9da4ff308899222309~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可 <code>2PC</code>的缺点也是显而易见，它是一个强一致性的同步阻塞协议，事务执⾏过程中需要将所需资源全部锁定，也就是俗称的 <code>刚性事务</code>。所以它比较适⽤于执⾏时间确定的短事务，整体性能比较差。</p><p>一旦事务协调者宕机或者发生网络抖动，会让参与者一直处于锁定资源的状态或者只有一部分参与者提交成功，导致数据的不一致。因此，在⾼并发性能⾄上的场景中，基于 XA 协议的分布式事务并不是最佳选择。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/a34f0af5f47a4ea686dae570643a019e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a><code>3PC</code></h3><p>三段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一种改进版本 ，为解决两阶段提交协议的阻塞问题，上边提到两段提交，当协调者崩溃时，参与者不能做出最后的选择，就会一直保持阻塞锁定资源。</p><p><code>2PC</code> 中只有协调者有超时机制，<code>3PC</code> 在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。而且在第一阶段和第二阶段中又插入了一个准备阶段（如下图，看着有点啰嗦），保证了在最后提交阶段之前各参与节点的状态是一致的。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/08a0d09a1f684ac89d058ed599c5cb93~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>虽然 <code>3PC</code> 用超时机制，解决了协调者故障后参与者的阻塞问题，但与此同时却多了一次网络通信，性能上反而变得更差，也不太推荐。</p><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>所谓的 <code>TCC</code> 编程模式，也是两阶段提交的一个变种，不同的是 <code>TCC</code> 为在业务层编写代码实现的两阶段提交。<code>TCC</code> 分别指 <code>Try</code>、<code>Confirm</code>、<code>Cancel</code> ，一个业务操作要对应的写这三个方法。必须引入一款 TCC 分布式事务框架，比如国内开源的 ByteTCC、himly、tcc-transaction。否则的话，感知各个阶段的执行情况以及推进执行下一个阶段的这些事情，不太可能自己手写实现，太复杂了。</p><p>以下单扣库存为例，<code>Try</code> 阶段去占库存，<code>Confirm</code> 阶段则实际扣库存，如果库存扣减失败 <code>Cancel</code> 阶段进行回滚，释放库存。</p><p>TCC 不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则 <code>Cancel</code> 来进行回滚补偿，这也就是常说的补偿性事务。</p><p>原本一个方法，现在却需要三个方法来支持，可以看到 TCC 对业务的侵入性很强，而且这种模式并不能很好地被复用，会导致开发量激增。还要考虑到网络波动等原因，为保证请求一定送达都会有重试机制，所以考虑到接口的幂等性。</p><h3 id="消息事务（最终一致性）"><a href="#消息事务（最终一致性）" class="headerlink" title="消息事务（最终一致性）"></a>消息事务（最终一致性）</h3><p>消息事务其实就是基于消息中间件的两阶段提交，将本地事务和发消息放在同一个事务里，保证本地操作和发送消息同时成功。 下单扣库存原理图：</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/55a8781c22844f1794a3edaadac37765~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>订单系统向 <code>MQ</code> 发送一条预备扣减库存消息，<code>MQ</code> 保存预备消息并返回成功 <code>ACK</code></li><li>接收到预备消息执行成功 <code>ACK</code>，订单系统执行本地下单操作，为防止消息发送成功而本地事务失败，订单系统会实现 <code>MQ</code> 的回调接口，其内不断的检查本地事务是否执行成功，如果失败则 <code>rollback</code> 回滚预备消息；成功则对消息进行最终 <code>commit</code> 提交。</li><li>库存系统消费扣减库存消息，执行本地事务，如果扣减失败，消息会重新投，一旦超出重试次数，则本地表持久化失败消息，并启动定时任务做补偿。</li></ul><p>基于消息中间件的两阶段提交方案，通常用在高并发场景下使用，牺牲数据的强一致性换取性能的大幅提升，不过实现这种方式的成本和复杂度是比较高的，还要看实际业务情况。</p><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p><code>Seata</code> 也是从两段提交演变而来的一种分布式事务解决方案，提供了 <code>AT</code>、<code>TCC</code>、<code>SAGA</code> 和 <code>XA</code> 等事务模式，这里重点介绍 <code>AT</code>模式。</p><p>既然 <code>Seata</code> 是两段提交，那我们看看它在每个阶段都做了点啥？下边我们还以下单扣库存、扣余额举例。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/f84a66ad84ea4db0bb3970d4a430a8df~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>先介绍 <code>Seata</code> 分布式事务的几种角色：</p><ul><li><code>Transaction Coordinator(TC)</code>:  全局事务协调者，用来协调全局事务和各个分支事务（不同服务）的状态， 驱动全局事务和各个分支事务的回滚或提交。</li><li><code>Transaction Manager(TM) </code>:  事务管理者，业务层中用来开启/提交/回滚一个整体事务（在调用服务的方法中用注解开启事务）。</li><li><code>Resource Manager(RM)</code>:  资源管理者，一般指业务数据库代表了一个分支事务（<code>Branch Transaction</code>），管理分支事务与 <code>TC</code> 进行协调注册分支事务并且汇报分支事务的状态，驱动分支事务的提交或回滚。</li></ul><blockquote><p>Seata 实现分布式事务，设计了一个关键角色 <code>UNDO_LOG</code> （回滚日志记录表），我们在每个应用分布式事务的业务库中创建这张表，这个表的核心作用就是，将业务数据在更新前后的数据镜像组织成回滚日志，备份在 <code>UNDO_LOG</code> 表中，以便业务异常能随时回滚。</p></blockquote><h3 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h3><p>比如：下边我们更新 <code>user</code> 表的 <code>name</code> 字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;小富最帅&#x27;</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;程序员内点事&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>首先 Seata 的 <code>JDBC</code> 数据源代理通过对业务 SQL 解析，提取 SQL 的元数据，也就是得到 SQL 的类型（<code>UPDATE</code>），表（<code>user</code>），条件（<code>where name = &#39;程序员内点事&#39;</code>）等相关的信息。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c78f6b5488ac4602acd18e3c9a978d5b~tplv-k3u1fbpfcp-zoom-1.image" alt="第一个阶段的流程图"></p><p>先查询数据前镜像，根据解析得到的条件信息，生成查询语句，定位一条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;程序员内点事&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c195e1ddd8fb4621a9b8ea35077f35ec~tplv-k3u1fbpfcp-zoom-1.image" alt="数据前镜像"></p><p>紧接着执行业务 SQL，根据前镜像数据主键查询出后镜像数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1b4c7bad77e9441a89e47f530ef505cb~tplv-k3u1fbpfcp-zoom-1.image" alt="数据后镜像"></p><p>把业务数据在更新前后的数据镜像组织成回滚日志，将业务数据的更新和回滚日志在同一个本地事务中提交，分别插入到业务表和 <code>UNDO_LOG</code> 表中。</p><p>回滚记录数据格式如下：包括 <code>afterImage</code> 前镜像、<code>beforeImage</code> 后镜像、 <code>branchId</code> 分支事务ID、<code>xid</code> 全局事务ID</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;branchId&quot;</span>:<span class="number">641789253</span>,</span><br><span class="line">    <span class="attr">&quot;xid&quot;</span>:<span class="string">&quot;xid:xxx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;undoItems&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;afterImage&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;rows&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;fields&quot;</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>:<span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>:<span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;tableName&quot;</span>:<span class="string">&quot;product&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;beforeImage&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;rows&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;fields&quot;</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>:<span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>:<span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;tableName&quot;</span>:<span class="string">&quot;product&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;sqlType&quot;</span>:<span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以保证，任何提交的业务数据的更新一定有相应的回滚日志。</p><blockquote><p>在本地事务提交前，各分支事务需向 <code>全局事务协调者</code> TC 注册分支 ( <code>Branch Id</code>) ，为要修改的记录申请 <strong>全局锁</strong> ，要为这条数据加锁，利用 <code>SELECT FOR UPDATE</code> 语句。而如果一直拿不到锁那就需要回滚本地事务。TM 开启事务后会生成全局唯一的 <code>XID</code>，会在各个调用的服务间进行传递。</p></blockquote><p>有了这样的机制，本地事务分支（<code>Branch Transaction</code>）便可以在全局事务的第一阶段提交，并马上释放本地事务锁定的资源。相比于传统的 <code>XA</code> 事务在第二阶段释放资源，<code>Seata</code> 降低了锁范围提高效率，即使第二阶段发生异常需要回滚，也可以快速 从<code>UNDO_LOG</code> 表中找到对应回滚数据并反解析成 SQL 来达到回滚补偿。</p><p>最后本地事务提交，业务数据的更新和前面生成的 UNDO LOG 数据一并提交，并将本地事务提交的结果上报给全局事务协调者 TC。</p><h3 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h3><p>第二阶段是根据各分支的决议做提交或回滚：</p><p>如果决议是全局提交，此时各分支事务已提交并成功，这时 <code>全局事务协调者（TC）</code> 会向分支发送第二阶段的请求。收到 TC 的分支提交请求，该请求会被放入一个异步任务队列中，并马上返回提交成功结果给 TC。异步队列中会异步和批量地根据 <code>Branch ID</code> 查找并删除相应 <code>UNDO LOG</code> 回滚记录。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/592fc4836e8a4f9a9c4c1de690ba166d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>如果决议是全局回滚，过程比全局提交麻烦一点，<code>RM</code> 服务方收到 <code>TC</code> 全局协调者发来的回滚请求，通过 <code>XID</code> 和 <code>Branch ID</code> 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。</p><blockquote><p>注意：这里删除回滚日志记录操作，一定是在本地业务事务执行之后</p></blockquote><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1c40b2c8a80b45acae157850f58cac79~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>上边说了几种分布式事务各自的优缺点，下边实践一下分布式事务中间 Seata 感受一下。</p><h2 id="Seata-实践"><a href="#Seata-实践" class="headerlink" title="Seata 实践"></a>Seata 实践</h2><p>Seata 是一个需独立部署的中间件，所以先搭 Seata Server，这里以最新的 <code>seata-server-1.4.0</code> 版本为例，下载地址：<code>https://seata.io/en-us/blog/download.html</code></p><p>解压后的文件我们只需要关心 <code>\seata\conf</code> 目录下的 <code>file.conf</code> 和  <code>registry.conf</code> 文件。</p><h3 id="Seata-Server"><a href="#Seata-Server" class="headerlink" title="Seata Server"></a>Seata Server</h3><h3 id="file-conf"><a href="#file-conf" class="headerlink" title="file.conf"></a>file.conf</h3><p><code>file.conf</code> 文件用于配置持久化事务日志的模式，目前提供 <code>file</code>、<code>db</code>、<code>redis</code> 三种方式。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/136f615cd12e4e21a0c8ac8c41f6f2a2~tplv-k3u1fbpfcp-zoom-1.image" alt="file.conf 文件配置"></p><p><strong>注意</strong>：在选择 <code>db</code> 方式后，需要在对应数据库创建 <code>globalTable</code>（持久化全局事务）、<code>branchTable</code>（持久化各提交分支的事务）、 <code>lockTable</code>（持久化各分支锁定资源事务）三张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="comment">-- 持久化全局事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`xid`</span>                       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>            <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`status`</span>                    <span class="built_in">TINYINT</span>      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`application_id`</span>            <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_name`</span>          <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    <span class="string">`timeout`</span>                   <span class="built_in">INT</span>,</span><br><span class="line">    <span class="string">`begin_time`</span>                <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`application_data`</span>          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>                DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>              DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="comment">-- 持久化各提交分支的事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`branch_id`</span>         <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>               <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>    <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`resource_id`</span>       <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`branch_type`</span>       <span class="built_in">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="string">`status`</span>            <span class="built_in">TINYINT</span>,</span><br><span class="line">    <span class="string">`client_id`</span>         <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    <span class="string">`application_data`</span>  <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>        DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="string">`gmt_modified`</span>      DATETIME(<span class="number">6</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="comment">-- 持久化每个分支锁表事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`row_key`</span>        <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>            <span class="built_in">VARCHAR</span>(<span class="number">96</span>),</span><br><span class="line">    <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>      <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`resource_id`</span>    <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`table_name`</span>     <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`pk`</span>             <span class="built_in">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>     DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>   DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_key`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_branch_id`</span> (<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br></pre></td></tr></table></figure><h3 id="registry-conf"><a href="#registry-conf" class="headerlink" title="registry.conf"></a>registry.conf</h3><p><code>registry.conf</code> 文件设置 注册中心 和 配置中心：</p><p>目前注册中心支持 <code>nacos</code> 、<code>eureka</code>、<code>redis</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code>、<code>sofa</code> 七种，这里我使用的 <code>eureka</code>作为注册中心 ； 配置中心支持 <code>nacos</code> 、<code>apollo</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code> 五种方式。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/2119d406e05e42268ac3536fa64866dc~tplv-k3u1fbpfcp-zoom-1.image" alt="registry.conf 文件配置"></p><p>配置完以后在 <code>\seata\bin</code> 目录下启动 <code>seata-server</code> 即可，到这 <code>Seata</code> 的服务端就搭建好了。</p><h3 id="Seata-Client"><a href="#Seata-Client" class="headerlink" title="Seata Client"></a>Seata Client</h3><p><code>Seata Server</code> 环境搭建完，接下来我们新建三个服务 <code>order-server</code>（下单服务）、<code>storage-server</code>（扣减库存服务）、<code>account-server</code>（账户金额服务），分别服务注册到 <code>eureka</code>。</p><p>每个服务的大体核心配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">storage-server</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">alibaba:</span></span><br><span class="line">            <span class="attr">seata:</span></span><br><span class="line">                <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://47.93.6.1:3306/seat-storage</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka 注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">serviceUrl:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="number">47.93</span><span class="number">.6</span><span class="number">.5</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>业务大致流程：用户发起下单请求，本地 order 订单服务创建订单记录，并通过 <code>RPC</code> 远程调用 <code>storage</code> 扣减库存服务和 <code>account</code> 扣账户余额服务，只有三个服务同时执行成功，才是一个完整的下单流程。如果某个服执行失败，则其他服务全部回滚。</p><p>Seata 对业务代码的侵入性非常小，代码中使用只需用 <code>@GlobalTransactional</code> 注解开启一个全局事务即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@GlobalTransactional(name = &quot;create-order&quot;, rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String xid = RootContext.getXID();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;交易开始&quot;</span>);</span><br><span class="line">    <span class="comment">//本地方法</span></span><br><span class="line">    orderDao.create(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程方法 扣减库存</span></span><br><span class="line">    storageApi.decrease(order.getProductId(), order.getCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程方法 扣减账户余额</span></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;扣减账户开始order中&quot;</span>);</span><br><span class="line">    accountApi.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;扣减账户结束order中&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;交易结束&quot;</span>);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;全局事务 xid： &#123;&#125;&quot;</span>, xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前边说过 Seata AT 模式实现分布式事务，必须在相关的业务库中创建 <code>undo_log</code> 表来存数据回滚日志，表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`undo_log`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span>            <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;increment id&#x27;</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>     <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`xid`</span>           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`context`</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    <span class="string">`rollback_info`</span> LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    <span class="string">`log_status`</span>    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    <span class="string">`log_created`</span>   DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    <span class="string">`log_modified`</span>  DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>, <span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> =<span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>到这环境搭建的工作就完事了，完整案例会在后边贴出 <code>GitHub</code> 地址，就不在这占用篇幅了。</p></blockquote><h2 id="测试-Seata"><a href="#测试-Seata" class="headerlink" title="测试 Seata"></a>测试 Seata</h2><p>项目中的服务调用过程如下图：</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/40a44673f4c84450b2a29154accf7b1c~tplv-k3u1fbpfcp-zoom-1.image" alt="服务调用过程"></p><p>启动各个服务后，我们直接请求下单接口看看效果，只要 <code>order</code> 订单表创建记录成功，<code>storage</code> 库存表 <code>used</code> 字段数量递增、<code>account</code> 余额表 <code>used</code> 字段数量递增则表示下单流程成功。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d091e25fac5346dc92d1875df942e6de~tplv-k3u1fbpfcp-zoom-1.image" alt="原始数据"></p><p>请求后正向流程是没问题的，数据和预想的一样</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/9048853aec764d86a116473450270347~tplv-k3u1fbpfcp-zoom-1.image" alt="下单数据"></p><p>而且发现 <code>TM</code> 事务管理者 <code>order-server</code> 服务的控制台也打印出了两阶段提交的日志</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d13de839fd2a4db2af5f5e535d13e41a~tplv-k3u1fbpfcp-zoom-1.image" alt="控制台两次提交"></p><p>那么再看看如果其中一个服务异常，会不会正常回滚呢？在 <code>account-server</code> 服务中模拟超时异常，看能否实现全局事务回滚。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d5d73832fae544828d2bc33d67cd160b~tplv-k3u1fbpfcp-zoom-1.image" alt="全局事务回滚"></p><p>发现数据全没执行成功，说明全局事务回滚也成功了</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7307262d393244f890211618ec315630~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>那看一下 <code>undo_log</code> 回滚记录表的变化情况，由于 <code>Seata</code> 删除回滚日志的速度很快，所以要想在表中看见回滚日志，必须要在某一个服务上打断点才看的更明显。</p><p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/6b06cf8edcfe4bd997e57206b578a3e0~tplv-k3u1fbpfcp-zoom-1.image" alt="回滚记录"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上边简单介绍了 <code>2PC</code>、<code>3PC</code>、<code>TCC</code>、<code>MQ</code>、<code>Seata</code> 这五种分布式事务解决方案，还详细的实践了 <code>Seata</code> 中间件。但不管我们选哪一种方案，在项目中应用都要谨慎再谨慎，除特定的数据强一致性场景外，能不用尽量就不要用，因为无论它们性能如何优越，一旦项目套上分布式事务，整体效率会几倍的下降，在高并发情况下弊端尤为明显。</p><blockquote><p>本案例 github 地址：<a href="https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-seata-transaction">https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-seata-transaction</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper之简单使用</title>
      <link href="2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BZookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BZookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、初识-zookeeper"><a href="#一、初识-zookeeper" class="headerlink" title="一、初识 zookeeper"></a>一、初识 zookeeper</h2><p><code>Zookeeper</code> 它作为<code>Hadoop</code>项目中的一个开源子项目，是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务。</p><h3 id="1、zookeeper数据模型"><a href="#1、zookeeper数据模型" class="headerlink" title="1、zookeeper数据模型"></a>1、zookeeper数据模型</h3><p><code>zookeeper</code> 维护了一个类似文件系统的数据结构，每个子目录（/微信、/微信/公众号）都被称作为 <code>znode</code> 即节点。和文件系统一样，我们可以很轻松的对 <code>znode</code> 节点进行增加、删除等操作，而且还可以在一个<code>znode</code>下增加、删除<code>子znode</code>，区别在于文件系统的是，<code>znode</code>可以存储数据（严格说是必须存放数据，默认是个空字符）。</p><p>由于<code>zookeeper</code>是目录节点结构，在获取和创建节点时，必须要以<code>“/”</code> 开头，否则在获取节点时会报错 <code>Path must start with / character</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">13</span>] get test</span><br><span class="line">Command failed: java.lang.IllegalArgumentException: Path must start <span class="keyword">with</span> / character</span><br></pre></td></tr></table></figure><p>根节点名必须为<code>“/XXX”</code>，创建子节点时必须要带上根节点目录<code>“/XXX/CCC”</code>、<code>“/XXX/AAA”</code>。</p><p>例如：想要获取下图 <code>程序员内点事</code> 节点必须拼接完整的路径 <code>get /微信/公众号/程序员内点事</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /微信/公众号/程序员内点事</span><br></pre></td></tr></table></figure><p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BZookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/ee94371033334df0adaa31ccc7933ef4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><code>znode</code>被用来存储 <code>byte级</code> 或 <code>kb级</code> 的数据，可存储的最大数据量是<code>1MB</code>（<strong>请注意</strong>：一个节点的数据量不仅包含它自身存储数据，它的所有子节点的名字也要折算成Byte数计入，因此<code>znode</code>的子节点数也不是无限的）虽然可以手动的修改节点存储量大小，但一般情况下并不推荐这样做。</p><h3 id="2、znode节点属性"><a href="#2、znode节点属性" class="headerlink" title="2、znode节点属性"></a>2、znode节点属性</h3><p>一个<code>znode</code>节点不仅可以存储数据，还有一些其他特别的属性。接下来我们创建一个<code>/test</code>节点分析一下它各个属性的含义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] get /<span class="built_in">test</span></span><br><span class="line">456</span><br><span class="line">cZxid = 0x59ac //</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59ad</span><br><span class="line">mtime = Mon Mar 30 15:22:25 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 0  </span><br></pre></td></tr></table></figure><table><thead><tr><th>节点属性</th><th>注解</th></tr></thead><tbody><tr><td>cZxid</td><td>该数据节点被创建时的事务Id</td></tr><tr><td>mZxid</td><td>该数据节点被修改时最新的事物Id</td></tr><tr><td>pZxid</td><td>当前节点的父级节点事务Id</td></tr><tr><td>ctime</td><td>该数据节点创建时间</td></tr><tr><td>mtime</td><td>该数据节点最后修改时间</td></tr><tr><td>dataVersion</td><td>当前节点版本号（每修改一次值+1递增）</td></tr><tr><td>cversion</td><td>子节点版本号（子节点修改次数，每修改一次值+1递增）</td></tr><tr><td>aclVersion</td><td>当前节点acl版本号（节点被修改acl权限，每修改一次值+1递增）</td></tr><tr><td>ephemeralOwner</td><td>临时节点标示，当前节点如果是临时节点，则存储的创建者的会话id（sessionId），如果不是，那么值=0</td></tr><tr><td>dataLength</td><td>当前节点所存储的数据长度</td></tr><tr><td>numChildren</td><td>当前节点下子节点的个数</td></tr></tbody></table><p>我们看到一个<code>znode</code>节点的属性比较多，但比较主要的属性还是<code>zxid</code>、<code>version</code>、<code>acl</code> 这三个。</p><hr><p><strong>Zxid：</strong></p><p><code>znode</code>节点状态改变会导致该节点收到一个<code>zxid</code>格式的时间戳，这个时间戳是全局有序的，znode节点的建立或者更新都会产生一个新的。如果<code>zxid1</code>的值 &lt; <code>zxid2</code>的值，那么说明<code>zxid2</code>发生的改变在<code>zxid1</code>之后。每个znode节点都有3个<code>zxid</code>属性，<code>cZxid</code>（节点创建时间）、<code>mZxid</code>（该节点修改时间，与子节点无关）、<code>pZxid</code>（该节点或者该节点的子节点的最后一次创建或者修改时间，孙子节点无关）。</p><p><code>zxid</code>属性主要应用于<code>zookeeper</code>的集群，这个后边介绍集群时详细说。</p><p><strong>Version：</strong></p><p><code>znode</code>属性中一共有三个版本号<code>dataversion</code>（数据版本号）、<code>cversion</code>（子节点版本号）、<code>aclversion</code>（节点所拥有的ACL权限版本号）。</p><p><code>znode</code>中的数据可以有多个版本，如果某一个节点下存有多个数据版本，那么查询这个节点数据就需要带上版本号。每当我们对<code>znode</code>节点数据修改后，该节点的<code>dataversion</code>版本号会递增。当客户端请求该<code>znode</code>节点时，会同时返回节点数据和版本号。另外当<code>dataversion</code>为 <code>-1</code>的时候可以忽略版本进行操作。对一个节点设置权限时<code>aclVersion</code>版本号会递增，下边会详细说ACL权限控制。</p><p>验证一下，我们修改<code>/test</code>节点的数据看看<code>dataVersion </code>有什么变化，发现<code>dataVersion </code>属性变成了 3，版本号递增了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] <span class="built_in">set</span> /<span class="built_in">test</span> 8888</span><br><span class="line">cZxid = 0x59ac</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59b6</span><br><span class="line">mtime = Mon Mar 30 16:58:08 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h3 id="3、znode的类型"><a href="#3、znode的类型" class="headerlink" title="3、znode的类型"></a>3、znode的类型</h3><p><code>zookeeper</code> 有四种类型的<code>znode</code>，在用客户端 <code>client</code> 创建节点的时候需要指定类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.create(<span class="string">&quot;/公众号/程序员内点事&quot;</span>, <span class="string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br></pre></td></tr></table></figure><ul><li><code>PERSISTENT</code>-持久化目录节点 ：client创建节点后，与zookeeper断开连接该节点将被持久化，当client再次连接后节点依旧存在。</li><li><code>PERSISTENT_SEQUENTIAL</code>-持久化顺序节点 ：client创建节点后，与zookeeper断开连接该节点将被持久化，再次连接节点还存在，zookeeper会给该节点名称进行顺序编号，例如：/lock/0000000001、/lock/0000000002、/lock/0000000003。</li><li><code>EPHEMERAL</code>-临时目录节点 ： client与zookeeper断开连接后，该节点即会被删除</li><li><code>EPHEMERAL_SEQUENTIAL</code>-临时顺序节点 ： client与zookeeper断开连接后，该节点被删除，会给该节点名称进行顺序编号，例如：/lock/0000000001、/lock/0000000002、/lock/0000000003。</li></ul><h2 id="二、节点的ACL权限控制"><a href="#二、节点的ACL权限控制" class="headerlink" title="二、节点的ACL权限控制"></a>二、节点的ACL权限控制</h2><p><code>ACL</code>：即 <code>Access Control List</code> (节点的权限控制)，通过<code>ACL</code>机制来解决<code>znode</code>节点的访问权限问题，要注意的是<code>zookeeper</code>对权限的控制是基于<code>znode</code>级别的，也就说节点之间的权限不具有继承性，即子节点不继承父节点的权限。</p><p><code>zookeeper</code>中设置ACL权限的格式由<code>&lt;schema&gt;:&lt;id&gt;:&lt;acl&gt;</code>三段组成。</p><p><strong>schema</strong> ：表示授权的方式</p><ul><li><code>world</code>：表示任何人都可以访问</li><li><code>auth</code>：只有认证的用户可以访问</li><li><code>digest</code>：使用username  ：password用户密码生成MD5哈希值作为认证ID</li><li><code>host/ip</code>：使用客户端主机IP地址来进行认证</li></ul><p><strong>id</strong>： 权限的作用域，用来标识身份，依赖于schema选择哪种方式。</p><p><strong>acl</strong>：给一个节点赋予哪些权限，节点的权限有create,、delete、write、read、admin 统称 <code>cdwra</code>。</p><h3 id="1、world：表示任何人都可以访问"><a href="#1、world：表示任何人都可以访问" class="headerlink" title="1、world：表示任何人都可以访问"></a>1、<code>world</code>：表示任何人都可以访问</h3><p>我们用 <code>getAcl</code> 命令来看一下，没有设置过权限的<code>znode</code>节点，默认情况下的权限情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] getAcl /<span class="built_in">test</span></span><br><span class="line"><span class="string">&#x27;world,&#x27;</span>anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure><p>看到没有设置ACL属性的节点，默认schema 使用的是<code>world</code>，作用域是<code>anyone</code>，节点权限是<code>cdwra</code>，也就是说任何人都可以访问。</p><p>那我们如果要给一个schema 为非<code>world</code>的节点设置<code>world</code>权限咋搞？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl /<span class="built_in">test</span> world:anyone:crdwa</span><br></pre></td></tr></table></figure><h3 id="2、auth：只有认证的用户可以访问"><a href="#2、auth：只有认证的用户可以访问" class="headerlink" title="2、auth：只有认证的用户可以访问"></a>2、<code>auth</code>：只有认证的用户可以访问</h3><p>schema 用<code>auth</code>授权表示只有认证后的用户才可以访问，那么首先就需要添加认证用户，添加完以后需要对认证的用户设置ACL权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addauth digest <span class="built_in">test</span>:password(明文)</span><br></pre></td></tr></table></figure><p>需要注意的是设置认证用户时的密码是明文的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] addauth digest user:user //用户名：密码</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] setAcl /<span class="built_in">test</span> auth:user:crdwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] getAcl /<span class="built_in">test</span></span><br><span class="line"><span class="string">&#x27;digest,&#x27;</span>user:ben+k/3JomjGj4mfd4fYsfM6p0A=</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure><p>实际上我们这样设置以后，就是将这个节点开放给所有认证的用户，<code>setAcl /test auth:user:crdwa</code> 相当于<code>setAcl /test auth::crdwa</code>。</p><h3 id="3、digest：用户名-密码的验证方式"><a href="#3、digest：用户名-密码的验证方式" class="headerlink" title="3、digest：用户名:密码的验证方式"></a>3、<code>digest</code>：用户名:密码的验证方式</h3><p>用户名:密码方式授权是针对单个特定用户，这种方式是不需要先添加认证用户的。</p><p>如果在代码中使用zookeeper客户端设置ACL，那么密码是明文的，但若是zk.cli等客户端操作就需要将密码进行<code>sha1</code>及<code>base64</code>处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setAcl &lt;path&gt; digest:&lt;user&gt;:&lt;password(密文)&gt;:&lt;acl&gt;</span><br><span class="line"></span><br><span class="line">setAcl /<span class="built_in">test</span> digest:user:jalRr+knv/6L2uXdenC93dEDNuE=:crdwa</span><br></pre></td></tr></table></figure><p>那么密码如何加密嘞？有以下几种方式：</p><p>通过<code>shell</code>命令加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure><p>使用<code>zookeeper</code>自带的类库<code>org.apache.zookeeper.server.auth.DigestAuthenticationProvider</code>生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -cp /zookeeper-3.4.13/zookeeper-3.4.13.jar:/zookeeper-3.4.13/lib/slf4j-api-1.7.25.jar \</span><br><span class="line">  org.apache.zookeeper.server.auth.DigestAuthenticationProvider \</span><br><span class="line">  root:root</span><br><span class="line">root:root-&gt;root:qiTlqPLK7XM2ht3HMn02qRpkKIE=</span><br></pre></td></tr></table></figure><h3 id="4、host-ip：使用客户端主机IP地址来进行认证"><a href="#4、host-ip：使用客户端主机IP地址来进行认证" class="headerlink" title="4、host/ip：使用客户端主机IP地址来进行认证"></a>4、<code>host/ip</code>：使用客户端主机IP地址来进行认证</h3><p>这种方式就比较好理解了，通过对特定的IP地址，也可以是一个IP段进行授权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] setAcl /test0000000014 ip:127.0.0.1:crdwa</span><br><span class="line">cZxid = 0x59ac</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59b6</span><br><span class="line">mtime = Mon Mar 30 16:58:08 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 3 // 这个版本一直在增加</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h2 id="三、zookeeper的灵魂-watcher"><a href="#三、zookeeper的灵魂-watcher" class="headerlink" title="三、zookeeper的灵魂 watcher"></a>三、zookeeper的灵魂 watcher</h2><p>我们在开头就说过：<code>zookeeper</code>可以为<code>dubbo</code>提供服务的注册与发现，作为注册中心，但你有想过<code>zookeeper</code>为啥能够实现服务的注册与发现吗？这就不得不说一下<code>zookeeper</code>的灵魂 <code>Watcher</code>（监听者）。</p><h3 id="1、watcher是个啥？"><a href="#1、watcher是个啥？" class="headerlink" title="1、watcher是个啥？"></a>1、watcher是个啥？</h3><p><code>watcher</code> 是<code>zooKeeper</code>中一个非常核心功能 ，客户端<code>watcher</code> 可以监控节点的数据变化以及它子节点的变化，一旦这些状态发生变化，zooKeeper服务端就会通知所有在这个节点上设置过<code>watcher</code>的客户端 ，从而每个客户端都很快感知，它所监听的节点状态发生变化，而做出对应的逻辑处理。</p><p>简单的介绍了一下<code>watcher</code> ，那么我们来分析一下，<code>zookeeper</code>是如何实现服务的注册与发现。 <code>zookeeper</code>的服务注册与发现，主要应用的是<code>zookeeper</code>的<code>znode</code>节点数据模型和<code>watcher</code>机制，大致的流程如下：</p><p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BZookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/2a10d2a2b39a4cedbcd430dc2a2394a4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><ul><li><strong>服务注册：</strong> 服务提供者（<code>Provider</code>）启动时，会向<code>zookeeper服务端</code>注册服务信息，也就是创建一个节点，例如：用户注册服务<code>com.xxx.user.register</code>，并在节点上存储服务的相关数据（如服务提供者的ip地址、端口等）。</li><li><strong>服务发现：</strong> 服务消费者（<code>Consumer</code>）启动时，根据自身配置的依赖服务信息，向<code>zookeeper服务端</code>获取注册的服务信息并设置<code>watch监听</code>，获取到注册的服务信息之后，将服务提供者的信息缓存在本地，并进行服务的调用。</li><li><strong>服务通知：</strong> 一旦服务提供者因某种原因宕机不再提供服务之后，客户端与<code>zookeeper</code>服务端断开连接，<code>zookeeper</code>服务端上服务提供者对应服务节点会被删除（例如：用户注册服务<code>com.xxx.user.register</code>），随后<code>zookeeper</code>服务端会异步向所有消费用户注册服务<code>com.xxx.user.register</code>，且设置了<code>watch监听</code>的服务消费者发出节点被删除的通知，消费者根据收到的通知拉取最新服务列表，更新本地缓存的服务列表。</li></ul><p>上边的过程就是<code>zookeeper</code>可以实现服务注册与发现的大致原理。</p><h3 id="2、watcher类型"><a href="#2、watcher类型" class="headerlink" title="2、watcher类型"></a>2、watcher类型</h3><p><code>znode</code>节点可以设置两类<code>watch</code>，一种是<code>DataWatches</code>，基于znode节点的数据变更从而触发 <code>watch</code> 事件，触发条件<code>getData()</code>、<code>exists()</code>、<code>setData()</code>、 <code>create()</code>。</p><p>另一种是<code>Child Watches</code>，基于znode的孩子节点发生变更触发的watch事件，触发条件 <code>getChildren()</code>、 <code>create()</code>。</p><p>而在调用 <code>delete()</code> 方法删除znode时，则会同时触发<code>Data Watches</code>和<code>Child Watches</code>，如果被删除的节点还有父节点，则父节点会触发一个<code>Child Watches</code>。</p><h3 id="3、watcher特性"><a href="#3、watcher特性" class="headerlink" title="3、watcher特性"></a>3、watcher特性</h3><p><code>watch</code>对节点的监听事件是一次性的！客户端在指定的节点设置了监听<code>watch</code>，一旦该节点数据发生变更通知一次客户端后，客户端对该节点的监听事件就失效了。</p><p>如果还要继续监听这个节点，就需要我们在客户端的监听回调中，再次对节点的监听<code>watch</code>事件设置为<code>True</code>。否则客户端只能接收到一次该节点的变更通知。</p><h2 id="四、zookeeper能实现哪些功能"><a href="#四、zookeeper能实现哪些功能" class="headerlink" title="四、zookeeper能实现哪些功能"></a>四、zookeeper能实现哪些功能</h2><p>服务的注册与发现功能只是zookeeper的冰山一角，它还能实现诸如分布式锁、队列、配置中心等一系列功能，接下来我们只分析一下原理，具体的实现大家上网查一下资料还是比较全的。</p><h3 id="1、分布式锁"><a href="#1、分布式锁" class="headerlink" title="1、分布式锁"></a>1、分布式锁</h3><p><code>zookeeper</code>基于<code>watcher</code>机制和<code>znode</code>的有序节点，天生就是一个分布式锁的坯子。首先创建一个<code>/test/lock</code>父节点作为一把锁，尽量是持久节点（PERSISTENT类型），每个尝试获取这把锁的客户端，在<code>/test/lock</code>父节点下创建临时顺序子节点。</p><p>由于序号的递增性，我们规定序号最小的节点即获得锁。例如：客户端来获取锁，在<code>/test/lock</code>节点下创建节点为<code>/test/lock/seq-00000001</code>，它是最小的所以它优先拿到了锁，其它节点等待通知再次获取锁。<code>/test/lock/seq-00000001</code>执行完自己的逻辑后删除节点释放锁。</p><p><strong>那么节点<code>/test/lock/seq-00000002</code>想要获取锁等谁的通知呢？</strong></p><p>这里我们让<code>/test/lock/seq-00000002</code>节点监听<code>/test/lock/seq-00000001</code>节点，一旦<code>/test/lock/seq-00000001</code>节点删除，则通知<code>/test/lock/seq-00000002</code>节点，让它再次判断自己是不是最小的节点，是则拿到锁，不是继续等通知。</p><p>以此类推<code>/test/lock/seq-00000003</code>节点监听<code>/test/lock/seq-00000002</code>节点，总是让后一个节点监听前一个节点，不用让所有节点都监听最小的节点，避免设置不必要的监听，以免造成大量无效的通知，形成“羊群效应”。</p><p><code>zookeeper</code>分布式锁和<code>redis</code>分布式锁相比，因为大量的创建、删除节点性能上比较差，并不是很推荐。 <img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BZookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7d20302015de4629acd6d633bf0f5253~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2、分布式队列"><a href="#2、分布式队列" class="headerlink" title="2、分布式队列"></a>2、分布式队列</h3><p>zookeeper实现分布式队列也很简单，应用znode的有序节点天然的“先进先出”，后创建的节点总是最大的，出队总是拿序号最小的节点即可。</p><h3 id="3、配置管理"><a href="#3、配置管理" class="headerlink" title="3、配置管理"></a>3、配置管理</h3><p>现在有很多开源项目都在使用Zookeeper来维护配置，像消息队列Kafka中，就使用Zookeeper来维护broker的信息；dubbo中管理服务的配置信息。原理也是基于<code>watcher</code>机制，例如：创建一个<code>/config</code>节点存放一些配置，客户端监听这个节点，一点修改<code>/config</code>节点的配置信息，通知各个客户端数据变更重新拉取配置信息。</p><h3 id="4、命名服务"><a href="#4、命名服务" class="headerlink" title="4、命名服务"></a>4、命名服务</h3><p><code>zookeeper</code>的命名服务：也就是我们常说的服务注册与发现，主要是根据指定名字来获取资源或服务的地址，服务提供者等信息，利用其<code>znode</code>节点的特点和<code>watcher</code>机制，将其作为动态注册和获取服务信息的配置中心，统一管理服务名称和其对应的服务器列表信息，我们能够近乎实时地感知到后端服务器的状态(上线、下线、宕机)。</p><h3 id="5、集群选举"><a href="#5、集群选举" class="headerlink" title="5、集群选举"></a>5、集群选举</h3><h2 id="五、基本操作"><a href="#五、基本操作" class="headerlink" title="五、基本操作"></a>五、基本操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ul><li>create /blog “blog” 创建普通节点</li><li>create -e /blog-temp “temp” 创建临时节点</li><li>create -s /blog-sequence “sequence” 创建序列节点</li><li>create -s  -e /blog-ts “ts” 创建带序号的临时节点</li></ul><h3 id="节点监听"><a href="#节点监听" class="headerlink" title="节点监听"></a>节点监听</h3><ul><li>get /servers watch   节点的值变化监听</li><li>ls /servers watch 节点的子节点变化监听（增、删）</li><li>stat -w /path 监听节点属性的变化</li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul><li>delete /blog  删除节点（不能删除带有子节点的节点）</li><li>rmr /sanguo  递归删除节点（可以删除带有子节点的节点）</li></ul><h3 id="显示配额"><a href="#显示配额" class="headerlink" title="显示配额"></a>显示配额</h3><ul><li>listquota /zookeeper  返回值count=2,bytes=-1 节点个数限额为2，长度无限额</li></ul><h3 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h3><ul><li>stat /blog-temp</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid &#x3D; 0x70000012e  引起这个znode创建的zxid，创建节点的事务的zxid（ZooKeeper Transaction Id），每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生</span><br><span class="line">ctime &#x3D; Mon Oct 12 06:08:52 UTC 2020 znode被创建的时间戳(从1970年开始)</span><br><span class="line">mZxid &#x3D; 0x70000012e znode最后更新的zxid</span><br><span class="line">mtime &#x3D; Mon Oct 12 06:08:52 UTC 2020 znode最后修改的时间戳(从1970年开始)</span><br><span class="line">pZxid &#x3D; 0x70000012e  znode最后更新的子节点zxid</span><br><span class="line">cversion &#x3D; 0 znode子节点变化号，znode子节点修改次数</span><br><span class="line">dataVersion &#x3D; 0 znode数据变化号</span><br><span class="line">aclVersion &#x3D; 0 znode访问控制列表的变化号</span><br><span class="line">ephemeralOwner &#x3D; 0x0 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0</span><br><span class="line">dataLength &#x3D; 4 znode的数据长度</span><br><span class="line">numChildren &#x3D; 0 znode子节点数量</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>  分布式消息同步和协调机制</li><li>  服务器节点动态上下线</li><li>  统一配置管理</li><li>  负载均衡</li><li>  集群管理</li><li>  。。。。。。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>  zookeeper的数据模型的结构和unix文件系统很相似，整体上看是一颗目录树，每一个节点称为ZNode（每个节点不但有目录名称，还必须要有值，类似于键值对）。<br>  zookeeper集群自身维护了一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为”znode”，每一个znode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。</p><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><ul><li>  短暂（ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除。</li><li>  持久（persistent）：客户端和服务器端断开连接后，创建的节点不删除。</li><li>  持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号，顺序编号有小到大。</li><li>  临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号，顺序编号有小到大。</li></ul><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><h2 id="zab原子广播协议"><a href="#zab原子广播协议" class="headerlink" title="zab原子广播协议"></a>zab原子广播协议</h2><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><h2 id="失败恢复"><a href="#失败恢复" class="headerlink" title="失败恢复"></a>失败恢复</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://juejin.cn/post/6906694879380766727">zookeeper 基础</a></p><p><a href="https://blog.csdn.net/weixin_39381833/article/details/108145990">原子广播协议</a></p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java泛型之Type</title>
      <link href="2020/12/22/java%E6%B3%9B%E5%9E%8B%E4%B9%8BType/"/>
      <url>2020/12/22/java%E6%B3%9B%E5%9E%8B%E4%B9%8BType/</url>
      
        <content type="html"><![CDATA[<h2 id="Class（原始类型、基本数据类型-）"><a href="#Class（原始类型、基本数据类型-）" class="headerlink" title="Class（原始类型、基本数据类型 ）"></a>Class（原始类型、基本数据类型 ）</h2><p>Type的直接实现子类</p><h2 id="ParameterizedType（泛型参数化类型）"><a href="#ParameterizedType（泛型参数化类型）" class="headerlink" title="ParameterizedType（泛型参数化类型）"></a>ParameterizedType（泛型参数化类型）</h2><p>参数化的类型，比如Collection&lt;?&gt;,实现类是<strong>ParameterizedTypeImpl</strong></p><p>public Type[] getActualTypeArguments() ;   返回实际的Type()。</p><h2 id="GenericArrayType（泛型数组类型）"><a href="#GenericArrayType（泛型数组类型）" class="headerlink" title="GenericArrayType（泛型数组类型）"></a>GenericArrayType（泛型数组类型）</h2><p>元素类型是参数化类型或者类型变量的数组类型,实现类<strong>GenericArrayTypeImpl</strong></p><p>public Type getGenericComponentType()；获取泛型数组类型</p><h2 id="TypeVariable（泛型类型变量）"><a href="#TypeVariable（泛型类型变量）" class="headerlink" title="TypeVariable（泛型类型变量）"></a>TypeVariable（泛型类型变量）</h2><p>各种类型变量的公共父接口，实现类是<strong>TypeVariableImpl</strong></p><p>public D getGenericDeclaration()；</p><h2 id="WildcardType（泛型通配符类型）"><a href="#WildcardType（泛型通配符类型）" class="headerlink" title="WildcardType（泛型通配符类型）"></a>WildcardType（泛型通配符类型）</h2><p>一种通配符类型表达式，比如?, ? extends Number, ? super Integer，实现类：<strong>WildcardTypeImpl</strong></p><p>Type[] getUpperBounds();  获取通配符表达式对象的泛型限定的上边界的类型</p><p>Type[] getLowerBounds(); 下边界类型</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> E <span class="title">methodIV</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;ArrayList&gt; al1,  //al1的类型是ArrayList，返回类型是ParameterizedType</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;E&gt; al2,          //al2的类型是E，返回类型是TypeVariable</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;String&gt; al3,     //al3的类型是String，返回类型是Class</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;? extends Number&gt; al4,   //al4的类型是? extends Number，返回类型是WildcardType</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;E[]&gt; al5)</span></span>&#123;&#125;)     <span class="comment">//al5的类型是E[]，返回类型是GenericArrayType</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型出现之前的类型"><a href="#泛型出现之前的类型" class="headerlink" title="泛型出现之前的类型"></a>泛型出现之前的类型</h3><p>没有泛型的时候，只有所谓的原始类型。此时，所有的原始类型都通过字节码文件类Class类进行抽象。Class类的一个具体对象就代表一个指定的原始类型。</p><h3 id="泛型出现之后的类型"><a href="#泛型出现之后的类型" class="headerlink" title="泛型出现之后的类型"></a>泛型出现之后的类型</h3><p>泛型出现之后，扩充了数据类型。从只有原始类型扩充了参数化类型、类型变量类型、泛型限定的的参数化类型 (含通配符+通配符限定表达式)、泛型数组类型。</p><h3 id="与泛型有关的类型不能和原始类型统一到Class的原因"><a href="#与泛型有关的类型不能和原始类型统一到Class的原因" class="headerlink" title="与泛型有关的类型不能和原始类型统一到Class的原因"></a>与泛型有关的类型不能和原始类型统一到Class的原因</h3><p>[1]. 【产生泛型擦除的原因】<br>本来新产生的类型+原始类型都应该统一成各自的字节码文件类型对象。但是由于泛型不是最初Java中的成分。如果真的加入了泛型，涉及到JVM指令集的修改，这是非常致命的。<br>[2]. 【Java中如何引入泛型】<br>为了使用泛型的优势又不真正引入泛型，Java采用泛型擦除的机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部擦除。<br>[3]. 【Class不能表达与泛型有关的类型】<br>因此，与泛型有关的参数化类型、类型变量类型、泛型限定的的参数化类型 (含通配符+通配符限定表达式)、泛型数组类型这些类型全部被打回原形，在字节码文件中全部都是泛型被擦除后的原始类型，并不存在和自身类型一致的字节码文件。所以和泛型相关的新扩充进来的类型不能被统一到Class类中。<br>(4). 与泛型有关的类型在Java中的表示<br>为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了ParameterizedType，GenericArrayType，TypeVariable 和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。<br>(5). Type的引入：统一与泛型有关的类型和原始类型Class</p><h3 id="引入Type的原因"><a href="#引入Type的原因" class="headerlink" title="引入Type的原因"></a>引入Type的原因</h3><p>为了程序的扩展性，最终引入了Type接口作为Class，ParameterizedType，GenericArrayType，TypeVariable和WildcardType这几种类型的总的父接口。这样实现了Type类型参数接受以上五种子类的实参或者返回值类型就是Type类型的参数。</p><h3 id="Type接口中没有方法的原因"><a href="#Type接口中没有方法的原因" class="headerlink" title="Type接口中没有方法的原因"></a>Type接口中没有方法的原因</h3><p>从上面看到，Type的出现仅仅起到了通过多态来达到程序扩展性提高的作用，没有其他的作用。因此Type接口的源码中没有任何方法。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规则引擎介绍</title>
      <link href="2020/12/21/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/12/21/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Drools"><a href="#Drools" class="headerlink" title="Drools"></a>Drools</h2><p>Drools 是用 Java 语言编写的开放源码规则引擎，使用 Rete 算法对所编写的规则求值。Drools 允许使用声明方式表达业务逻辑。可以使用非 XML 的本地语言编写规则，从而便于学习和理解。并且，还可以将 Java 代码直接嵌入到规则文件中，这令 Drools 的学习更加吸引人。</p><p>Drools 还具有其他优点：</p><ul><li>非常活跃的社区支持</li><li>易用</li><li>快速的执行速度</li><li>在 Java 开发人员中流行</li><li>与 Java Rule Engine API（JSR 94）兼容</li></ul><h2 id="QLExpress"><a href="#QLExpress" class="headerlink" title="QLExpress"></a>QLExpress</h2><p>由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。</p><p>QLExpress脚本引擎被广泛应用在阿里的电商业务场景，具有以下的一些特性:</p><ul><li>1、线程安全，引擎运算过程中的产生的临时变量都是threadlocal类型。</li><li>2、高效执行，比较耗时的脚本编译过程可以缓存在本地机器，运行时的临时变量创建采用了缓冲池的技术，和groovy性能相当。</li><li>3、弱类型脚本语言，和groovy，javascript语法类似，虽然比强类型脚本语言要慢一些，但是使业务的灵活度大大增强。</li><li>4、安全控制,可以通过设置相关运行参数，预防死循环、高危系统api调用等情况。</li><li>5、代码精简，依赖最小，250k的jar包适合所有java的运行环境，在android系统的低端pos机也得到广泛运用。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://gitee.com/cuibo119/QLExpress">QLExpress基本语法</a></p><p><a href="https://developer.aliyun.com/article/621206">QLExpress功能清单</a></p><h2 id="Drools中文网"><a href="#Drools中文网" class="headerlink" title="Drools中文网"></a><a href="http://www.drools.org.cn/">Drools中文网</a></h2>]]></content>
      
      
      <categories>
          
          <category> 规则引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p6spy之简单使用</title>
      <link href="2020/12/21/SQL%E7%9B%91%E6%8E%A7%E4%B9%8Bp6spy%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/21/SQL%E7%9B%91%E6%8E%A7%E4%B9%8Bp6spy%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="p6spy作用"><a href="#p6spy作用" class="headerlink" title="p6spy作用"></a>p6spy作用</h2><p>将所有执行的sql打出日志，放在一个文件下。</p><p>p6spy将应用的数据源给劫持了，应用操作数据库其实在调用p6spy的数据源，p6spy劫持到需要执行的sql或者hql之类的语句之后，他自己去调用一个realDatasource，再去操作数据库</p><p>p6spy 可以输出日志到文件中、控制台、或者传递给 Log4j，而且还能配搭 SQL Profiler 或 IronTrackSQL 图形化监控 SQL 语句，监测到哪些语句的执行是耗时的，逐个优化。</p><h2 id="p6spy的配置"><a href="#p6spy的配置" class="headerlink" title="p6spy的配置"></a>p6spy的配置</h2><ul><li><p>p6spy.jar放入应用的classpath下</p></li><li><p>修改连接池或者连接配置的jdbc的驱动为p6spy所提供的驱动，com.p6spy.engine.spy.P6SpyDriver</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在单独的Hibernate的应用中，数据库驱动配置在hibernate.cfg.xml里面,所以我需要配置文件中的connection.driver_class属性从oracle.jdbc.driver.OracleDriver改为com.p6spy.engine.spy.P6SpyDriver其他的用户名密码等等配置信息全部不用修改.在web程序中，配置的连接池部分，也只需要修改jdbc-driver的配置即可。</span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>&gt;</span>com.p6spy.engine.spy.P6SpyDriver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>&gt;</span>jdbc:oracle:thin:@localhost:1521:orcl<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.username&quot;</span>&gt;</span>scott<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.password&quot;</span>&gt;</span>tiger<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.pool_size&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span>&gt;</span>org.hibernate.dialect.Oracle9Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;current_session_context_class&quot;</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.provider_class&quot;</span>&gt;</span>org.hibernate.cache.NoCacheProvider<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hbm2ddl.auto&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.jdbc.batch_size&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 spy.properties 并将其放到classpath下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment"># MODULES                                                       #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Modules provide the P6Spy functionality.  If a module, such   #</span></span><br><span class="line"><span class="comment"># as module_log is commented out, that functionality will not   #</span></span><br><span class="line"><span class="comment"># be available.  If it is not commented out (if it is active),  #</span></span><br><span class="line"><span class="comment"># the functionality will be active.                             #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Values set in Modules cannot be reloaded using the            #</span></span><br><span class="line"><span class="comment"># reloadproperties variable.  Once they are loaded, they remain #</span></span><br><span class="line"><span class="comment"># in memory until the application is restarted.                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment">#第一：module.log的属性必须配置，如果不配置，P6SPY将不起任何作用，典型配置：</span></span><br><span class="line"><span class="meta">module.log</span>=<span class="string">com.p6spy.engine.logging.P6LogFactory</span></span><br><span class="line"><span class="comment">#module.outage=com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment"># REALDRIVER(s)                                                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># In your application server configuration file you replace the #</span></span><br><span class="line"><span class="comment"># &quot;real driver&quot; name with com.p6spy.engine.P6SpyDriver. This is #</span></span><br><span class="line"><span class="comment"># where you put the name of your real driver P6Spy can find and #</span></span><br><span class="line"><span class="comment"># register your real driver to do the database work.            #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># If your application uses several drivers specify them in      #</span></span><br><span class="line"><span class="comment"># realdriver2, realdriver3\.  See the documentation for more     #</span></span><br><span class="line"><span class="comment"># details.                                                      #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Values set in REALDRIVER(s) cannot be reloaded using the      #</span></span><br><span class="line"><span class="comment"># reloadproperties variable.  Once they are loaded, they remain #</span></span><br><span class="line"><span class="comment"># in memory until the application is restarted.                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二：数据库驱动配置，你懂的，不多说了</span></span><br><span class="line"><span class="comment"># oracle driver</span></span><br><span class="line"><span class="comment"># realdriver=oracle.jdbc.driver.OracleDriver</span></span><br><span class="line"><span class="comment"># mysql Connector/J driver</span></span><br><span class="line"><span class="comment"># realdriver=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># informix driver</span></span><br><span class="line"><span class="comment"># realdriver=com.informix.jdbc.IfxDriver</span></span><br><span class="line"><span class="comment"># ibm db2 driver</span></span><br><span class="line"><span class="comment"># realdriver=COM.ibm.db2.jdbc.net.DB2Driver</span></span><br><span class="line"><span class="comment"># the mysql open source driver</span></span><br><span class="line"><span class="attr">realdriver</span>=<span class="string">org.gjt.mm.mysql.Driver</span></span><br><span class="line"><span class="comment">#specifies another driver to use</span></span><br><span class="line"><span class="attr">realdriver2</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#specifies a third driver to use</span></span><br><span class="line"><span class="attr">realdriver3</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第三：appender配置，一般分为三种</span></span><br><span class="line"><span class="comment">#specifies the appender to use for logging</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.logging.appender.Log4jLogger</span></span><br><span class="line"><span class="comment">#控制台</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.logging.appender.StdoutLogger</span></span><br><span class="line"><span class="attr">appender</span>=<span class="string">com.p6spy.engine.logging.appender.FileLogger</span></span><br><span class="line"><span class="comment"># name of logfile to use, note Windows users should make sure to use forward slashes in their pathname (e:/test/spy.log) (used for file logger only)</span></span><br><span class="line"><span class="comment">#日志文件存放路径及文件名</span></span><br><span class="line"><span class="attr">logfile</span>     = <span class="string">spy.log</span></span><br><span class="line"><span class="comment"># append to  the p6spy log file.  if this is set to false the</span></span><br><span class="line"><span class="comment"># log file is truncated every time.  (file logger only)</span></span><br><span class="line"><span class="attr">append</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#The following are for log4j logging only</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT.layout.ConversionPattern</span>=<span class="string">p6spy - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.p6spy</span>=<span class="string">INFO,STDOUT</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> p6spy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p6spy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之异常处理</title>
      <link href="2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><ul><li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><h2 id="异常类图"><a href="#异常类图" class="headerlink" title="异常类图"></a>异常类图</h2><p><img src="/2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201221175446673.png" alt="image-20201221175446673"></p><h2 id="Java-的非检查性异常"><a href="#Java-的非检查性异常" class="headerlink" title="Java 的非检查性异常"></a>Java 的非检查性异常</h2><table><thead><tr><th align="left"><strong>异常</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">ArithmeticException</td><td align="left">当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td align="left">ArrayIndexOutOfBoundsException</td><td align="left">用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td align="left">ArrayStoreException</td><td align="left">试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td align="left">ClassCastException</td><td align="left">当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td align="left">IllegalArgumentException</td><td align="left">抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td align="left">IllegalMonitorStateException</td><td align="left">抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td align="left">IllegalStateException</td><td align="left">在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td align="left">IllegalThreadStateException</td><td align="left">线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td align="left">IndexOutOfBoundsException</td><td align="left">指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td align="left">NegativeArraySizeException</td><td align="left">如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td align="left">NullPointerException</td><td align="left">当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</td></tr><tr><td align="left">NumberFormatException</td><td align="left">当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td align="left">SecurityException</td><td align="left">由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td align="left">StringIndexOutOfBoundsException</td><td align="left">此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td align="left">UnsupportedOperationException</td><td align="left">当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><h2 id="检查性异常类"><a href="#检查性异常类" class="headerlink" title="检查性异常类"></a>检查性异常类</h2><table><thead><tr><th align="left"><strong>异常</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">ClassNotFoundException</td><td align="left">应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td align="left">CloneNotSupportedException</td><td align="left">当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</td></tr><tr><td align="left">IllegalAccessException</td><td align="left">拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td align="left">InstantiationException</td><td align="left">当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td align="left">InterruptedException</td><td align="left">一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td align="left">NoSuchFieldException</td><td align="left">请求的变量不存在</td></tr><tr><td align="left">NoSuchMethodException</td><td align="left">请求的方法不存在</td></tr></tbody></table><h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><strong>public String getMessage()</strong></td><td align="left">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td></tr><tr><td align="left"><strong>public Throwable getCause()</strong></td><td align="left">返回一个Throwable 对象代表异常原因。</td></tr><tr><td align="left"><strong>public String toString()</strong></td><td align="left">使用getMessage()的结果返回类的串级名字。</td></tr><tr><td align="left"><strong>public void printStackTrace()</strong></td><td align="left">打印toString()结果和栈层次到System.err，即错误输出流。</td></tr><tr><td align="left"><strong>public StackTraceElement [] getStackTrace()</strong></td><td align="left">返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td></tr><tr><td align="left"><strong>public Throwable fillInStackTrace()</strong></td><td align="left">用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td></tr></tbody></table><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos之gRPC调用</title>
      <link href="2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8BgRPC%E8%B0%83%E7%94%A8/"/>
      <url>2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8BgRPC%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>acos 规划准备基于 gRPC 来替换现有的通信场景(Http + UDP)，以下是重点需要和社区讨论的项。请大家积极踊跃发表自己的看法。</p><h2 id="Nacos-能够替换成长连接的两大前提"><a href="#Nacos-能够替换成长连接的两大前提" class="headerlink" title="Nacos 能够替换成长连接的两大前提"></a>Nacos 能够替换成长连接的两大前提</h2><ul><li><p>通信模型的匹配</p><table><thead><tr><th align="center">现有的通信场景</th><th align="center">新的通讯场景</th></tr></thead><tbody><tr><td align="center">Http 服务接口 服务接口 Request/Response</td><td align="center">gRPC Request/Response</td></tr><tr><td align="center">配置推送 Http Long Polling</td><td align="center">gRPC Request/Stream</td></tr><tr><td align="center">UDP 服务推送 Request/Response</td><td align="center">gRPC Request/Stream</td></tr><tr><td align="center">支持ssl 通讯</td><td align="center">支持ssl 通讯</td></tr></tbody></table></li><li><p>通信的数据格式能够匹配</p><p>基于 gRPC 的业务层俩进程之间是需要协调好一致的通信数据格式 ，然后在 proto 文件里面来描述。为了能够服务好多场景下的通信模型数据格式的一致性，就像 Http 的通信数据格式一样，不 care 上层业务通信的数据具体表现形式，只 care 通信时数据格式的表现能力。以下关注两方面来阐述基于 gRPC 之后的数据格式长啥样。</p><ol><li><p>Request 数据格式</p><table><thead><tr><th align="center">通信数据格式字段</th><th align="center">数据类型</th><th align="center">必要性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">RequestId</td><td align="center">string</td><td align="center">必要</td><td align="center">标识当前的一次请求，方便于后续问题的排查</td></tr><tr><td align="center">Action</td><td align="center">string</td><td align="center">必要</td><td align="center">标识当前请求的具体行为，<strong>对标 Http 中的 URI 。</strong></td></tr><tr><td align="center">Headers</td><td align="center">map&lt;string,string&gt;</td><td align="center">必要</td><td align="center">动态可伸缩的消息头，<strong>对标 http 请求中的 header 。</strong></td></tr><tr><td align="center">Source</td><td align="center">string</td><td align="center">可选</td><td align="center">标明消息的发送源，是哪一个节点发送的消息。</td></tr><tr><td align="center">Params</td><td align="center">map&lt;string,string&gt; l 可选</td><td align="center">动态可伸缩的参数传递，<strong>对标 http 请求中的 参数传递。</strong></td><td align="center"></td></tr><tr><td align="center">Method</td><td align="center">string</td><td align="center">可选</td><td align="center">请求的 Method，<strong>对标 http 请求中的 method。</strong></td></tr><tr><td align="center">Payload</td><td align="center">byte[]</td><td align="center">必要</td><td align="center">请求的消息内容体，<strong>对标 http 请求中的 请求内容体。</strong></td></tr></tbody></table></li><li><p>Response 数据格式</p><table><thead><tr><th align="center">通信数据格式字段</th><th align="center">数据类型</th><th align="center">必要性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ReponseId</td><td align="center">string</td><td align="center">必要</td><td align="center">标识当前的一次 response，方便于后续问题的排查 。通常他的值是来源于 request id，标识当前这个 response 是针对那次 请求进行响应的。</td></tr><tr><td align="center">Source</td><td align="center">string</td><td align="center">可选</td><td align="center">标明消息的Response源，是哪一个节点响应的消息。</td></tr><tr><td align="center">Action</td><td align="center">string</td><td align="center">必要</td><td align="center">标识当前 Response 是对哪个 Action 进行响应的。</td></tr><tr><td align="center">Headers</td><td align="center">map&lt;string,string&gt;</td><td align="center">必要</td><td align="center">动态可伸缩的消息头，<strong>对标 http 请求中的 header 。</strong></td></tr><tr><td align="center">Response Code</td><td align="center">int l 必要</td><td align="center">响应状态码，对标 http 响应中的响应码 。</td><td align="center"></td></tr><tr><td align="center">Response Payload</td><td align="center">byte[]</td><td align="center">必要</td><td align="center">响应的消息内容体，<strong>对标 http 响应中的内容体。</strong></td></tr></tbody></table></li></ol></li></ul><h2 id="协议协商-通信的基础"><a href="#协议协商-通信的基础" class="headerlink" title="协议协商-通信的基础"></a>协议协商-通信的基础</h2><p>长连接支持的过程中必然会出现客户端/服务端，服务端/服务端 版本支持的通信协议不一致的情况。比如说，此时客户端支持 Http，但是服务端升级到新版本，既支持 Http,有支持 gRPC。这个时候客户端服务端通信要协商好一致的通信协议。面对客户端/服务端通信协议不一致的场景，主要采取<strong>通信协议降级</strong>的处理方式。通信协议降级处理主要分为两种：<strong>服务端通信协议降级处理</strong> 和 <strong>客户端通信协议降级处理</strong>。</p><ul><li><p>场景一：服务端版本高(既支持 Http+ UDP,有支持 gRPC),客户端版本低(支持 Http + UDP)。那这个时候经过客户端和服务端协议协商后，达成一致的通信协议是 Http + UDP。那么此时服务端对此客户端支持的通信协议就采用 Http +UDP，相对于新的通信协议，就降级了，这就是<strong>服务端通信协议降级处理。</strong></p><p><strong>注意:</strong> 服务端的通信协议降级处理是针对多个客户端而言的。因为有的客户端连接过来的是新版本，这个时候就没有服务端的通信协议降级处理，直接采用新的通信协议 gRPC 来处理；但是有的客户端连接过来的是低版本，那么这个时候就需要单独对这个客户端进行服务端通信协议降级处理了。</p></li><li><p>场景二：客户端版本高了(既支持 Http+ UDP,有支持 gRPC),服务端版本低(支持 Http + UDP)。那这个时候经过客户端和服务端协议协商后，达成一致的通信协议是 Http + UDP。那么此时客户端通信协议就采用 Http +UDP，相对于新的通信协议，就降级了，这就是<strong>客户端通信协议降级处理。</strong></p></li></ul><h2 id="服务端推送-Naming-Config-的支持"><a href="#服务端推送-Naming-Config-的支持" class="headerlink" title="服务端推送(Naming+Config)的支持"></a>服务端推送(Naming+Config)的支持</h2><ul><li>服务端推送-Naming(注册中心)</li><li>服务端推送-Config(配置中心)</li></ul><h2 id="Http-接口的改造"><a href="#Http-接口的改造" class="headerlink" title="Http 接口的改造"></a>Http 接口的改造</h2><p>Http 接口的改造，主要内容含两部分，分别是请求接口的数据和响应内容的处理。</p><ul><li><p>Http/gRPC 请求 通信数据格式的映射</p><table><thead><tr><th align="center">Http 请求</th><th align="center">gRPC 请求</th></tr></thead><tbody><tr><td align="center">URL</td><td align="center">Action</td></tr><tr><td align="center">Headers</td><td align="center">Headers</td></tr><tr><td align="center">Params</td><td align="center">Params</td></tr><tr><td align="center">Body</td><td align="center">Payload</td></tr><tr><td align="center">/</td><td align="center">其他字段按需指定</td></tr></tbody></table></li><li><p>Http/gRPC 响应 通信数据格式的映射</p><table><thead><tr><th align="center">Http 响应</th><th align="center">gRPC 响应</th></tr></thead><tbody><tr><td align="center">Response Code</td><td align="center">Response Code</td></tr><tr><td align="center">Response Body</td><td align="center">Response Payload</td></tr><tr><td align="center">Response Headers</td><td align="center">Response Headers</td></tr><tr><td align="center">/</td><td align="center">其他字段按需指定</td></tr></tbody></table><p>也就是说改为 gRPC 长连接之后，原先设置 Http 请求/响应所携带的相关数据都有具体的协议格式来于此对应，与此同时，在此基础上还丰富了原有的通信协议(例如 RequestId，Source 等)。在不失扩展性的同时，还降低了切换时数据通信改造和学习的成本。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> nacos </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos之注册中心原理解析</title>
      <link href="2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>注册和撤销服务，使用NamingProxy进行Http调用，使用jdk自带的Http协议API</li><li>查询服务，使用HostReactor类借助NamingProxy进行服务查询，重点是使用PushReceiver类创建UDP长连接，更新服务</li><li>subscribe/unsubscribe,使用EventDispatcher类addListener方法添加监听，重点是使用PushReceiver类创建UDP长连接，更新服务</li><li>都是使用定时任务线程池ScheduledExecutorService进行多线程处理</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="string">&quot;serverAddr&quot;</span>, System.getProperty(<span class="string">&quot;serverAddr&quot;</span>));</span><br><span class="line">properties.setProperty(<span class="string">&quot;namespace&quot;</span>, System.getProperty(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line"></span><br><span class="line">NamingService naming = NamingFactory.createNamingService(properties);</span><br><span class="line"></span><br><span class="line">naming.registerInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;11.11.11.11&quot;</span>, <span class="number">8888</span>, <span class="string">&quot;TEST1&quot;</span>);</span><br><span class="line">naming.registerInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;2.2.2.2&quot;</span>, <span class="number">9999</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">System.out.println(naming.getAllInstances(<span class="string">&quot;nacos.test.3&quot;</span>));</span><br><span class="line">naming.deregisterInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;2.2.2.2&quot;</span>, <span class="number">9999</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">System.out.println(naming.getAllInstances(<span class="string">&quot;nacos.test.3&quot;</span>));</span><br><span class="line"></span><br><span class="line">naming.subscribe(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        System.out.println(((NamingEvent)event).getServiceName());</span><br><span class="line">        System.out.println(((NamingEvent)event).getInstances());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="NamingService"><a href="#NamingService" class="headerlink" title="NamingService"></a>NamingService</h2><p>NamingService是Nacos对外提供给使用者的接口，其实现类为com.alibaba.nacos.client.naming.NacosNamingService，归纳起来，NamingService提供了以下方法：</p><ul><li>registerInstance：注册实例。</li><li>deregisterInstance：注销实例。</li><li>getAllInstances：获取某一服务的所有实例。</li><li>selectInstances：获取某一服务健康或不健康的实例。</li><li>selectOneHealthyInstance：根据权重选择一个健康的实例。</li><li>getServerStatus：检测服务端健康状态。</li><li>subscribe：注册对某个服务的监听。</li><li>unsubscribe：注销对某个服务的监听。</li><li>getSubscribeServices：获取被监听的服务。</li><li>getServicesOfServer：获取命名空间（namespace)下的所有服务名。</li></ul><h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/baa968b2dce6422703ca528e5550ca19" alt="core-class" style="zoom: 50%;"><h2 id="NacosNamingService"><a href="#NacosNamingService" class="headerlink" title="NacosNamingService"></a>NacosNamingService</h2><p>NacosNamingService是NamingService接口的实现类。实现了上面提到的那些方法。此外，NacosNamingService还起到了初始化其他核心类的作用，因为对外提供的方法都是委托给其他核心类处理的。按顺序将依次初始化EventDispatcher、NamingProxy、BeatReactor、HostReactor。从NacosNamingService的构造函数我们也可以了解到，可以进行一些参数的自定义，可参考<a href="https://nacos.io/zh-cn/docs/concepts.html">官方文档</a></p><h2 id="EventDispatcher"><a href="#EventDispatcher" class="headerlink" title="EventDispatcher"></a>EventDispatcher</h2><p>EventDispatcher与其他事件分发的组件没什么不同，用于处理subscribe、unsubscribe等等与服务监听相关的方法，并分发NamingEvent到各Listener。成员变量ConcurrentMap&lt;String, List<EventListener>&gt; observerMap保存了注册的Listener，key为{服务名}@@{集群名}，value为各个EventListener的列表。EventDispatcher会启动<strong>1</strong>个名为com.alibaba.nacos.naming.client.listener的线程用于处理事件的分发。</EventListener></p><blockquote><p>注意点：</p><ul><li>分发NamingEvent时，按照subscribe(…)方法的调用顺序串行依次调用EventListener的onEvent(…)方法。</li><li>调用subscribe(…)方法会引起对应Service的事件分发。</li></ul></blockquote><h2 id="NamingProxy"><a href="#NamingProxy" class="headerlink" title="NamingProxy"></a>NamingProxy</h2><p>NamingProxy用于<strong>与Nacos服务端通信</strong>，注册服务、注销服务、发送心跳等都经由NamingProxy来请求服务端。NamingProxy会启动<strong>1</strong>个名为com.alibaba.nacos.client.naming.serverlist.updater的线程，用于定期调用refreshSrvIfNeed()方法更新Nacos服务端地址，默认间隔为<strong>30秒</strong>，对服务端API的调用将在后文总结。</p><blockquote><p>注意点：refreshSrvIfNeed()方法对Nacos服务端地址的更新仅在使用endpoint的时候才会进行实际更新，如果是通过serverAddr配置的Nacos服务端地址，refreshSrvIfNeed()方法将不会进行任何操作。</p></blockquote><h2 id="BeatReactor"><a href="#BeatReactor" class="headerlink" title="BeatReactor"></a>BeatReactor</h2><p>BeatReactor用于<strong>向Nacos服务端发送已注册服务的心跳</strong>。成员变量Map&lt;String, BeatInfo&gt; dom2Beat中保存了需要发送的BeatInfo，key为{serviceName}#{ip}#{port}，value为对应的BeatInfo。BeatReactor会启动名为com.alibaba.nacos.naming.beat.sender的线程来发送心跳，默认线程数为1~CPU核心数的一半，可由namingClientBeatThreadCount参数指定。<br>默认情况下每<strong>5秒</strong>发送一次心跳，可根据Nacos服务端返回的clientBeatInterval的值调整心跳间隔。</p><h2 id="HostReactor"><a href="#HostReactor" class="headerlink" title="HostReactor"></a>HostReactor</h2><p>HostReactor<strong>用于获取、保存、更新各Service实例信息。</strong>成员变量Map&lt;String, ServiceInfo&gt; serviceInfoMap中保存了已获取到的服务的信息，key为{服务名}@@{集群名}。HostReactor会启动名为com.alibaba.nacos.client.naming.updater的线程来更新服务信息，默认线程数为1~CPU核心数的一半，可由namingPollingThreadCount参数指定。定时任务UpdateTask会根据服务的cacheMillis值定时更新服务信息，默认值为<strong>10秒</strong>。该定时任务会在获取某一服务信息时创建，保存在成员变量Map&lt;String, ScheduledFuture&lt;?&gt;&gt; futureMap中。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="PushReceiver"><a href="#PushReceiver" class="headerlink" title="PushReceiver"></a>PushReceiver</h3><p>PushReceiver<strong>用于接收Nacos服务端的推送</strong>，初始化时会创建DatagramSocket使用UDP的方式接收推送。会启动<strong>1</strong>个名为com.alibaba.nacos.naming.push.receiver的线程。</p><h3 id="FailoverReactor"><a href="#FailoverReactor" class="headerlink" title="FailoverReactor"></a>FailoverReactor</h3><p>用于故障转移，会启动<strong>1</strong>个名为com.alibaba.nacos.naming.failover的线程并定时读取名为00-00—000-VIPSRV_FAILOVER_SWITCH-000—00-00的文件，内容为1时表示开启，此时获取服务信息时会返回FailoverReactor缓存的服务信息。</p><h3 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h3><p>根据服务实例的权重挑选一个实例，实现简单的负载均衡。</p><h3 id="DiskCache"><a href="#DiskCache" class="headerlink" title="DiskCache"></a>DiskCache</h3><p>用于服务信息的持久化。</p><h2 id="Naming-API"><a href="#Naming-API" class="headerlink" title="Naming API"></a>Naming API</h2><p>API汇总如下：</p><table><thead><tr><th>Method</th><th>URI</th><th>含义</th></tr></thead><tbody><tr><td>POST</td><td>/nacos/v1/ns/instance</td><td>注册实例</td></tr><tr><td>DELETE</td><td>/nacos/v1/ns/instance</td><td>注销实例</td></tr><tr><td>GET</td><td>/nacos/v1/ns/instance/list</td><td>获取实例列表</td></tr><tr><td>PUT</td><td>/nacos/v1/ns/instance/beat</td><td>发送心跳</td></tr><tr><td>GET</td><td>/nacos/v1/ns/api/hello</td><td>Nacos服务端状态</td></tr><tr><td>GET</td><td>/nacos/v1/ns/service/list</td><td>获取所有服务名</td></tr></tbody></table><h2 id="参数列表及示例"><a href="#参数列表及示例" class="headerlink" title="参数列表及示例"></a>参数列表及示例</h2><h3 id="注册实例"><a href="#注册实例" class="headerlink" title="注册实例"></a>注册实例</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>ip</td><td>实例IP地址</td><td></td></tr><tr><td>port</td><td>实例端口</td><td></td></tr><tr><td>weight</td><td>权重</td><td>默认为1.0</td></tr><tr><td>enable</td><td>是否开启</td><td>默认为true</td></tr><tr><td>healthy</td><td>健康状态</td><td>默认为true</td></tr><tr><td>metadata</td><td>其他信息</td><td></td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>clusterName</td><td>集群名</td><td>默认为DEFAULT</td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/instance?metadata=%7B%7D&namespaceId=public&port=8888&enable=true&healthy=true&ip=11.11.11.11&clusterName=TEST1&weight=1.0&serviceName=nacos.test.3&encoding=UTF-8&">http://localhost:8848/nacos/v1/ns/instance?metadata=%7B%7D&amp;namespaceId=public&amp;port=8888&amp;enable=true&amp;healthy=true&amp;ip=11.11.11.11&amp;clusterName=TEST1&amp;weight=1.0&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;</a></p><p>返回示例：ok</p><h3 id="注销实例"><a href="#注销实例" class="headerlink" title="注销实例"></a>注销实例</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>ip</td><td>实例IP地址</td><td></td></tr><tr><td>port</td><td>实例端口</td><td></td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>clusterName</td><td>集群名</td><td>默认为DEFAULT</td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/instance?cluster=DEFAULT&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;port=9999&amp;ip=2.2.2.2&amp;">http://localhost:8848/nacos/v1/ns/instance?cluster=DEFAULT&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;port=9999&amp;ip=2.2.2.2&amp;</a></p><p>返回示例：ok</p><h3 id="获取实例列表"><a href="#获取实例列表" class="headerlink" title="获取实例列表"></a>获取实例列表</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>clusters</td><td>集群名</td><td>默认为DEFAULT</td></tr><tr><td>udpPort</td><td>监听的UPD端口号</td><td>由PushReceiver创建</td></tr><tr><td>clientIP</td><td>客户端IP</td><td></td></tr><tr><td>healthyOnly</td><td>是否只返回健康的实例</td><td></td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/instance/list?healthyOnly=false&amp;namespaceId=public&amp;clientIP=172.16.20.114&amp;serviceName=nacos.test.3&amp;udpPort=53957&amp;encoding=UTF-8&amp;">http://localhost:8848/nacos/v1/ns/instance/list?healthyOnly=false&amp;namespaceId=public&amp;clientIP=172.16.20.114&amp;serviceName=nacos.test.3&amp;udpPort=53957&amp;encoding=UTF-8&amp;</a></p><p>返回示例：{“metadata”:{},”dom”:”nacos.test.3”,”cacheMillis”:10000,”useSpecifiedURL”:false,”hosts”:[{“valid”:true,”marked”:false,”metadata”:{},”instanceId”:”2.2.2.2#9999#DEFAULT#nacos.test.3”,”port”:9999,”ip”:”2.2.2.2”,”clusterName”:”DEFAULT”,”weight”:1.0,”serviceName”:”nacos.test.3”,”enabled”:true},{“valid”:true,”marked”:false,”metadata”:{},”instanceId”:”11.11.11.11#8888#TEST1#nacos.test.3”,”port”:8888,”ip”:”11.11.11.11”,”clusterName”:”TEST1”,”weight”:1.0,”serviceName”:”nacos.test.3”,”enabled”:true}],”checksum”:”bd1054e6afb8d10730d945d74c4ce4421550584589236”,”lastRefTime”:1550584589236,”env”:””,”clusters”:””}</p><h3 id="发送心跳"><a href="#发送心跳" class="headerlink" title="发送心跳"></a>发送心跳</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>beat</td><td>BeatInfo的JSON字符串</td><td></td></tr></tbody></table><p>BeatInfo对象结构如下，与Instance对象类似：</p><table><thead><tr><th>field</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>port</td><td>端口</td><td></td></tr><tr><td>ip</td><td>IP地址</td><td></td></tr><tr><td>weight</td><td>权重</td><td></td></tr><tr><td>metadata</td><td>其他信息</td><td></td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>clusterName</td><td>集群名</td><td></td></tr><tr><td>scheduled</td><td>是否心跳中</td><td>这个是BeatReactor用来标识状态的</td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/instance/beat?beat=%7B%22cluster%22:%22DEFAULT%22,%22ip%22:%222.2.2.2%22,%22metadata%22:%7B%7D,%22port%22:9999,%22scheduled%22:true,%22serviceName%22:%22nacos.test.3%22,%22weight%22:1.0%7D&serviceName=nacos.test.3&encoding=UTF-8&namespaceId=public&">http://localhost:8848/nacos/v1/ns/instance/beat?beat=%7B%22cluster%22%3A%22DEFAULT%22%2C%22ip%22%3A%222.2.2.2%22%2C%22metadata%22%3A%7B%7D%2C%22port%22%3A9999%2C%22scheduled%22%3Atrue%2C%22serviceName%22%3A%22nacos.test.3%22%2C%22weight%22%3A1.0%7D&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;</a></p><p>返回示例：{“clientBeatInterval”:5000}</p><h3 id="Nacos服务端状态"><a href="#Nacos服务端状态" class="headerlink" title="Nacos服务端状态"></a>Nacos服务端状态</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/api/hello?encoding=UTF-8&amp;namespaceId=public&amp;">http://localhost:8848/nacos/v1/ns/api/hello?encoding=UTF-8&amp;namespaceId=public&amp;</a></p><p>返回示例：{“msg”:”Hello! I am Nacos-Naming and healthy! total services: raft 2, local port:8848”}</p><h3 id="获取所有服务名"><a href="#获取所有服务名" class="headerlink" title="获取所有服务名"></a>获取所有服务名</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>pageNo</td><td>页码</td><td>注意从1开始</td></tr><tr><td>pageSize</td><td>返回数量</td><td></td></tr><tr><td>selector</td><td>过滤器</td><td></td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/service/list?pageSize=100&amp;encoding=UTF-8&amp;namespaceId=public&amp;pageNo=0&amp;">http://localhost:8848/nacos/v1/ns/service/list?pageSize=100&amp;encoding=UTF-8&amp;namespaceId=public&amp;pageNo=0&amp;</a></p><p>返回示例：{“count”:1,”doms”:[“nacos.test.3”]}</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos之配置中心原理解析</title>
      <link href="2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>作者：逅弈<br>链接：<a href="https://www.jianshu.com/p/38b5452c9fec">https://www.jianshu.com/p/38b5452c9fec</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用长轮询机制：长轮询是在轮询基础上做的，也是不断的访问服务器，但是服务器不会即刻返回，而是等有新消息到来时再返回，或者等到超时时间到了再返回。</p><ol><li>Server端采用队列，为每一个请求创建一个专属队列</li><li>Server端有新消息进来，放入每一个请求的队列中进行返回，或者等待超时时间结束捕获异常后再返回</li></ol><p><strong>聊天室长轮询实例</strong>：</p><p>为每一个进入聊天室的用户（与<code>Server</code>端建立连接的用户）创建一个队列，每个用户轮询时都去询问自己的队列，如果没有新消息就等待，如果后端一旦接收到新消息就将消息放入对应的等待队列中返回本次请求；或者超时也返回请求    </p><h2 id="推还是拉"><a href="#推还是拉" class="headerlink" title="推还是拉"></a>推还是拉</h2><p>客户端和服务端之间的数据交互，无外乎两种情况：</p><ul><li>服务端推数据给客户端</li><li>客户端从服务端拉数据</li></ul><p>那到底是推还是拉呢，从 Nacos 客户端通过 Listener 来接收最新数据的这个做法来看，感觉像是服务端推的数据，但是不能想当然，要想知道答案，最快最准确的方法就是从源码中去寻找。</p><h3 id="创建-ConfigService"><a href="#创建-ConfigService" class="headerlink" title="创建 ConfigService"></a>创建 ConfigService</h3><p>从我们的 demo 中可以知道，首先是创建了一个 ConfigService。而 ConfigService 是通过 ConfigFactory 类创建的，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-ba05ced35148cde1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到实际是通过反射调用了 NacosConfigService 的构造方法来创建 ConfigService 的，而且是有一个 Properties 参数的构造方法。</p><p>需要注意的是，这里并没有通过单例或者缓存技术，也就是说每次调用都会重新创建一个 ConfigService的实例。</p><h3 id="实例化-ConfigService"><a href="#实例化-ConfigService" class="headerlink" title="实例化 ConfigService"></a>实例化 ConfigService</h3><p>现在我们来看下 NacosConfigService 的构造方法，看看 ConfigService 是怎么实例化的，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-f6c665c4e2de941f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>实例化时主要是初始化了两个对象，他们分别是：</p><ul><li>HttpAgent</li><li>ClientWorker</li></ul><h4 id="HttpAgent"><a href="#HttpAgent" class="headerlink" title="HttpAgent"></a>HttpAgent</h4><p>其中 agent 是通过装饰着模式实现的，ServerHttpAgent 是实际工作的类，MetricsHttpAgent 在内部也是调用了 ServerHttpAgent 的方法，另外加上了一些统计操作，所以我们只需要关心 ServerHttpAgent 的功能就可以了。</p><p>agent 实际是在 ClientWorker 中发挥能力的，下面我们来看下 ClientWorker 类。</p><h4 id="ClientWorker"><a href="#ClientWorker" class="headerlink" title="ClientWorker"></a>ClientWorker</h4><p>以下是 ClientWorker 的构造方法，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-5104c6d72e2aaa8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到 ClientWorker 除了将 HttpAgent 维持在自己内部，还创建了两个线程池：</p><p>第一个线程池是只拥有一个线程用来执行定时任务的 executor，executor 每隔 10ms 就会执行一次 checkConfigInfo() 方法，从方法名上可以知道是每 10 ms 检查一次配置信息。</p><p>第二个线程池是一个普通的线程池，从 ThreadFactory 的名称可以看到这个线程池是做长轮询的。</p><p>现在让我们来看下 executor 每 10ms 执行的方法到底是干什么的，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-9e84ab368c709db7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到，checkConfigInfo 方法是取出了一批任务，然后提交给 executorService 线程池去执行，执行的任务就是 LongPollingRunnable，每个任务都有一个 taskId。</p><p>现在我们来看看 LongPollingRunnable 做了什么，主要分为两部分，第一部分是检查本地的配置信息，第二部分是获取服务端的配置信息然后更新到本地。</p><p><strong>1.本地检查</strong></p><p>首先取出与该 taskId 相关的 CacheData，然后对 CacheData 进行检查，包括本地配置检查和监听器的 md5 检查，本地检查主要是做一个故障容错，当服务端挂掉后，Nacos 客户端可以从本地的文件系统中获取相关的配置信息，如下图所示：</p><p><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/5417792-d973ee3fed6496df.png" alt="img"></p><p>通过跟踪 checkLocalConfig 方法，可以看到 Nacos 将配置信息保存在了</p><p>~/nacos/config/fixed-{address}_8848_nacos/snapshot/DEFAULT_GROUP/{dataId}</p><p>这个文件中，我们看下这个文件中保存的内容，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-ba0df548e35c29fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><strong>2.服务端检查</strong></p><p>然后通过 checkUpdateDataIds() 方法从服务端获取那些值发生了变化的 dataId 列表，</p><p>通过 getServerConfig 方法，根据 dataId 到服务端获取最新的配置信息，接着将最新的配置信息保存到 CacheData 中。</p><p>最后调用 CacheData 的 checkListenerMd5 方法，可以看到该方法在第一部分也被调用过，我们需要重点关注一下。</p><p><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/5417792-4de0d8c1acc24260.png" alt="img"></p><p>可以看到，在该任务的最后，也就是在 finally 中又重新通过 executorService 提交了本任务。</p><h3 id="添加-Listener"><a href="#添加-Listener" class="headerlink" title="添加 Listener"></a>添加 Listener</h3><p><font color="red">NacosContextRefresher</font>接收到ApplicationReadyEvent事件时为每个配置文件增加监听器，添加的监听器是AbstractSharedListener的匿名类。匿名内部类中发布<font color="red">RefreshEvent</font>事件，此为动态刷新配置中心配置的关键。即使用 ConfigService 来添加一个 Listener 了，最终是调用了 ClientWorker 的 addTenantListeners 方法，如下图所示：</p><p><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/5417792-35b632cd90154086.png" alt="img"></p><p>该方法分为两个部分，首先根据 dataId，group 和当前的场景获取一个 CacheData 对象，然后将当前要添加的 listener 对象添加到 CacheData 中去。</p><p>也就是说 listener 最终是被这里的 CacheData 所持有了，那 listener 的回调方法 receiveConfigInfo 就应该是在 CacheData 中触发的。</p><p>我们发现 CacheData 是出现频率非常高的一个类，在 LongPollingRunnable 的任务中，几乎所有的方法都围绕着 CacheData 类，现在添加 Listener 的时候，实际上该 Listener 也被委托给了 CacheData，那我们要重点关注下 CacheData 类了。</p><h3 id="CacheData"><a href="#CacheData" class="headerlink" title="CacheData"></a>CacheData</h3><p>首先让我们来看一下 CacheData 中的成员变量，如下图所示：</p><p><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/5417792-d3e711176c9987b9.png" alt="img"></p><p>可以看到除了 dataId，group，content，taskId 这些跟配置相关的属性，还有两个比较重要的属性：listeners、md5。</p><p>listeners 是该 CacheData 所关联的所有 listener，不过不是保存的原始的 Listener 对象，而是包装后的 ManagerListenerWrap 对象，该对象除了持有 Listener 对象，还持有了一个 lastCallMd5 属性。</p><p>另外一个属性 md5 就是根据当前对象的 content 计算出来的 md5 值。</p><h3 id="触发回调"><a href="#触发回调" class="headerlink" title="触发回调"></a>触发回调</h3><p>现在我们对 ConfigService 有了大致的了解了，现在剩下最后一个重要的问题还没有答案，那就是 ConfigService 的 Listener 是在什么时候触发回调方法 receiveConfigInfo 的。</p><p>现在让我们回过头来想一下，在 ClientWorker 中的定时任务中，启动了一个长轮询的任务：LongPollingRunnable，该任务多次执行了 cacheData.checkListenerMd5() 方法，那现在就让我们来看下这个方法到底做了些什么，如下图所示：</p><p><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/5417792-252a0c5c6da61070.png" alt="img"></p><p>到这里应该就比较清晰了，该方法会检查 CacheData 当前的 md5 与 CacheData 持有的所有 Listener 中保存的 md5 的值是否一致，如果不一致，就执行一个安全的监听器的通知方法：safeNotifyListener，通知什么呢？我们可以大胆的猜一下，应该是通知 Listener 的使用者，该 Listener 所关注的配置信息已经发生改变了。现在让我们来看一下 safeNotifyListener 方法，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-991eeb4ef41b05fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到在 safeNotifyListener 方法中，重点关注下红框中的三行代码：获取最新的配置信息，调用 Listener 的回调方法，将最新的配置信息作为参数传入，这样 Listener 的使用者就能接收到变更后的配置信息了，最后更新 ListenerWrap 的 md5 值。和我们猜测的一样， Listener 的回调方法就是在该方法中触发的。</p><h3 id="Md5何时变更"><a href="#Md5何时变更" class="headerlink" title="Md5何时变更"></a>Md5何时变更</h3><p>那 CacheData 的 md5 值是何时发生改变的呢？我们可以回想一下，在上面的 LongPollingRunnable 所执行的任务中，在获取服务端发生变更的配置信息时，将最新的 content 数据写入了 CacheData 中，我们可以看下该方法如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-1a99dccdefa936cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/826/format/webp" alt="img"></p><p>可以看到是在长轮询的任务中，当服务端配置信息发生变更时，客户端将最新的数据获取下来之后，保存在了 CacheData 中，同时更新了该 CacheData 的 md5 值，所以当下次执行 checkListenerMd5 方法时，就会发现当前 listener 所持有的 md5 值已经和 CacheData 的 md5 值不一样了，也就意味着服务端的配置信息发生改变了，这时就需要将最新的数据通知给 Listener 的持有者。</p><p>至此配置中心的完整流程已经分析完毕了，可以发现，Nacos 并不是通过推的方式将服务端最新的配置信息发送给客户端的，而是客户端维护了一个长轮询的任务，定时去拉取发生变更的配置信息，然后将最新的数据推送给 Listener 的持有者。</p><h3 id="拉的优势"><a href="#拉的优势" class="headerlink" title="拉的优势"></a>拉的优势</h3><p>客户端拉取服务端的数据与服务端推送数据给客户端相比，优势在哪呢，为什么 Nacos 不设计成主动推送数据，而是要客户端去拉取呢？如果用推的方式，服务端需要维持与客户端的长连接，这样的话需要耗费大量的资源，并且还需要考虑连接的有效性，例如需要通过心跳来维持两者之间的连接。而用拉的方式，客户端只需要通过一个无状态的 http 请求即可获取到服务端的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Nacos 服务端创建了相关的配置项后，客户端就可以进行监听了。</p><p>客户端是通过一个定时任务来检查自己监听的配置项的数据的，一旦服务端的数据发生变化时，客户端将会获取到最新的数据，并将最新的数据保存在一个 CacheData 对象中，然后会重新计算 CacheData 的 md5 属性的值，此时就会对该 CacheData 所绑定的 Listener 触发 receiveConfigInfo 回调。</p><p>考虑到服务端故障的问题，客户端将最新数据获取后会保存在本地的 snapshot 文件中，以后会优先从文件中获取配置信息的值。</p><p>长轮询请求设置的超时时间为30s。服务端拿到客户端提交的超时时间后，又减去了 500ms 也就是说服务端在这里使用了一个比客户端提交的时间少 500ms 的超时时间，也就是 29.5s。</p><p>ClientLongPolling 被提交给 scheduler 执行之后，实际执行的内容可以拆分成以下四个步骤：</p><ul><li>1.创建一个调度的任务，调度的延时时间为 29.5s</li><li>2.将该 ClientLongPolling 自身的实例添加到一个 allSubs 中去</li><li>3.延时时间到了之后，首先将该 ClientLongPolling 自身的实例从 allSubs 中移除</li><li>4.获取服务端中保存的对应客户端请求的 groupKeys 是否发生变更，将结果写入 response 返回给客户端</li></ul><p><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20210113114155184.png" alt="image-20210113114155184"></p><p><a href="https://www.jianshu.com/p/acb9b1093a54">Nacos 配置实时更新原理分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos之简单使用</title>
      <link href="2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="nacos作用"><a href="#nacos作用" class="headerlink" title="nacos作用"></a>nacos作用</h2><ul><li>配置中心</li><li>注册中心</li></ul><h2 id="nacos组成"><a href="#nacos组成" class="headerlink" title="nacos组成"></a>nacos组成</h2><ul><li>服务端（记录配置信息及注册服务）</li><li>客户端（通过客户端获取配置和注册的服务信息）</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h3><p><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5417792-3f740507702e5345.png" alt="img"></p><p>执行后将打印如下信息：<br><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5417792-bbb7c19dd26d12e7.png" alt="img"></p><h3 id="修改配置信息"><a href="#修改配置信息" class="headerlink" title="修改配置信息"></a>修改配置信息</h3><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5417792-817fcfe4227320fa.png" alt="img" style="zoom: 33%;"><p>修改完配置，点击 “发布” 按钮后，客户端将会收到最新的数据，如下图所示：<br><img src="/2020/12/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5417792-f64c8649f23cde67.png" alt="img" style="zoom:50%;"></p><h2 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring-cloud"></a>spring-cloud</h2><h3 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">10.16</span><span class="number">.35</span><span class="number">.74</span><span class="string">:8848,10.16.32.168:8848,10.16.35.243:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">quixmart2</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">dbf20920b03e6ee725a681a47e4eecec</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">&#x27;yml&#x27;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">&#x27;646e3782-3a6f-46db-9b8c-6cae7f620be1&#x27;</span></span><br><span class="line">        <span class="comment"># 读取公共中间件配置</span></span><br><span class="line">        <span class="string">ext-config[0]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">mysql.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[1]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">redis.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[2]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">rabbitmq.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[3]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">mongodb.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[4]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">elasticjob.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[5]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">mqtt.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">10.16</span><span class="number">.35</span><span class="number">.74</span><span class="string">:8848,10.16.32.168:8848,10.16.35.243:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">quixmart2</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">dbf20920b03e6ee725a681a47e4eecec</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">&#x27;646e3782-3a6f-46db-9b8c-6cae7f620be1&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> nacos </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之字节及字符等详解</title>
      <link href="2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>1.bit:位 （小写b) 也称比特</strong></p><p>是英文 binary digit的缩写 二进制数系统中，每个0或1就是一个位(bit)<br>位是数据存储（计算机中信息）的最小单位<br>计算机中的CPU位数指的是CPU一次能处理的最大位数。例如32位计算机的CPU一次最多能处理32位数据</p><p><strong>2.Byte:字节(大写B)</strong></p><p>8bit就称为一个字节（Byte）, 1Byte=8bit<br>记为Byte或B,是计算机中信息的基本单位</p><p><strong>3.区别</strong><br><img src="/2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/180125-20191106131450465-1166740117.png" alt="img"></p><p> <strong>实例</strong></p><p>bps 是 bits per second 的简称。一般数据机及网络通讯的传输速率都是以「bps」比特/位为单位。如 56Kbps、100.0Mbps 等。<br>Bps 是 Byte per second 的简称。而电脑一般都以「Bps」字节/速度为单位，如 1Mb/s(Mbps) 大约等同 128 KB/s(KBps)。<br>举例：USB 2.0 接口传输速率为 “480Mbps”，很多人误解为 480 兆/秒，实际 “480Mbps” 是指 “480 兆比特/秒” 或 “480 兆位/秒”，等于 “60 兆字节/秒”。</p><p><strong>4.相关换算</strong><br>1个字母=1个字节=8bit(8位)</p><p>1个数字=1个字节=8bit(8位)</p><p>1个汉字=2个字节=16bit(16位)</p><p>1 Byte = 8 Bits</p><p>1 KB = 1024 Bytes</p><p>1 MB = 1024 KB</p><p>1 GB = 1024 MB</p><p><strong>char与byte的区别</strong></p><p> <strong><em>\</em>byte 是字节数据类型 ，是有符号型的，占1 个字节；大小范围为-128—127 。char 是字符数据类型 ，是无符号型的，占2字节(Unicode\</strong>*<em>码*</em> *<em>）；大小*</em>*<em>范围*</em> *<em>是*</em>*<em>0*</em>*<em>—*</em>*<em>65535*</em> *<em>；*</em>*<em>char是一个16位二进制的Unicode字符，JAVA用char来表示一个字符*</em> *<em>。***</em></p><p>通过代码示例来比较二者区别：</p><p>1、Char是无符号型的，可以表示一个整数，不能表示负数；而byte是有符号型的，可以表示-128—127 的数；如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>) -<span class="number">90</span>; <span class="comment">// char不能识别负数，必须强制转换否则报错，即使强制转换之后，也无法识别 </span></span><br><span class="line">System.out.println(c); </span><br><span class="line"><span class="keyword">byte</span> d1 = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">byte</span> d2 = -<span class="number">1</span>; </span><br><span class="line"><span class="keyword">byte</span> d3 = <span class="number">127</span>; <span class="comment">// 如果是byte d3 = 128;会报错 </span></span><br><span class="line"><span class="keyword">byte</span> d4 = -<span class="number">128</span>; <span class="comment">// 如果是byte d4 = -129;会报错 </span></span><br><span class="line">System.out.println(d1); </span><br><span class="line">System.out.println(d2); </span><br><span class="line">System.out.println(d3); </span><br><span class="line">System.out.println(d4); </span><br></pre></td></tr></table></figure><img src="/2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/20180622151733747" alt="img" style="zoom:80%;"><p>2、char可以表中文字符，byte不可以，如：<br>​    char e1 = ‘我’, e2 = ‘你’;<br>​    byte f= (byte) ‘他’; //必须强制转换否则报错<br>​    System.out.println(e1);<br>​    System.out.println(e2);<br>​    System.out.println(f);<br><img src="/2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/20180622152135220" alt="img"></p><p>3、char、byte、int对于英文字符，可以相互转化，如：<br>​    byte g = ‘a’;  //b对应ASCII是98<br>​    char h = (char) g;<br>​    char i = 85;  //U对应ASCII是85<br>​    int j = ‘h’;  //h对应ASCII是104<br>​    System.out.println(g);<br>​    System.out.println(h);<br>​    System.out.println(i);<br>​    System.out.println(j);<br><img src="/2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/20180622152512662" alt="img"></p><p><strong>参考</strong></p><p><a href="https://www.cnblogs.com/tmtony/p/11804575.html">bit(比特)与Byte(字节)的区别与关系</a></p><p><a href="https://blog.csdn.net/m0_37846887/article/details/80774131">char与byte的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名词解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之IO流详解</title>
      <link href="2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/yichunguo/">宜春</a></p><p>出处：<a href="https://www.cnblogs.com/yichunguo/p/11775270.html">https://www.cnblogs.com/yichunguo/p/11775270.html</a></p><p>io流用到的地方很多，就比如上传下载，传输，设计模式等….基础打扎实了，才能玩更高端的。</p><p>真正懂IO流的优秀程序员每次在使用IO流之前都会明确分析如下四点：</p><blockquote><p>（1）明确要操作的数据是数据源还是数据目的(也就是要读还是要写)<br>（2）明确要操作的设备上的数据是字节还是文本<br>（3）明确数据所在的具体设备<br>（4）明确是否需要额外功能（比如是否需要转换流、高效流等）</p></blockquote><h1 id="1、IO流的四点明确"><a href="#1、IO流的四点明确" class="headerlink" title="1、IO流的四点明确"></a>1、IO流的四点明确</h1><p>（1）明确要操作的数据是数据源还是数据目的(要读还是要写)</p><blockquote><p>　源：<strong>InputStream　　Reader</strong><br>目的：<strong>OutputStream　　Writer</strong><br>（2）明确要操作的设备上的数据是字节还是文本<br>　源：字节： <strong>InputStream</strong>    文本： <strong>Reader</strong><br>目的：字节： <strong>OutputStream</strong>  文本： <strong>Writer</strong><br>（3）明确数据所在的具体设备<br>　　　源设备：<br>　　　　　　　　硬盘：文件 <code>File</code>开头<br>　　　　　　　　内存：数组，字符串<br>　　　　　　　　键盘：<code>System.in</code><br>　　　　　　　　网络：<code>Socket</code><br>　　对应目的设备：<br>　　　　　　　　硬盘：文件 <code>File</code>开头<br>　　　　　　　　内存：数组，字符串<br>　　　　　　　　屏幕：<code>System.out</code><br>　　　　　　　　网络：<code>Socket</code><br>（4）明确是否需要额外功能<br>　　需要转换—— 转换流 <strong>InputStreamReader 、OutputStreamWriter</strong><br>　　需要高效—— 缓冲流<strong>Bufferedxxx</strong><br>　　多个源—— 序列流 <strong>SequenceInputStream</strong><br>　　对象序列化—— <strong>ObjectInputStream、ObjectOutputStream</strong><br>　　保证数据的输出形式—— 打印流<strong>PrintStream 、Printwriter</strong><br>　　操作基本数据，保证字节原样性——<strong>DataOutputStream、DataInputStream</strong><br>到这里，我们再来看看IO流的分类吧<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014111930276.png" alt="在这里插入图片描述"></p></blockquote><h1 id="2、File类"><a href="#2、File类" class="headerlink" title="2、File类"></a>2、File类</h1><p>至于IO流，也就是输入输出流，从文件出发到文件结束，至始至终都离不开文件，所以IO流还得从文件File类讲起。</p><h2 id="1-1-File概述"><a href="#1-1-File概述" class="headerlink" title="1.1 File概述"></a>1.1 File概述</h2><p><code>java.io.File</code> 类是专门对文件进行操作的类，只能对文件本身进行操作，不能对文件内容进行操作。<br><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><p>怎么理解上面两句话？其实很简单！</p><p>第一句就是说File跟流无关，File类不能对文件进行读和写也就是输入和输出！<br>第二句就是说File主要表示类似<code>D:\\文件目录1</code>与<code>D:\\文件目录1\\文件.txt</code>,前者是文件夹（Directory）后者则是文件(file)，而File类就是操作这两者的类。</p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><p>在java中，一切皆是对象，File类也不例外，不论是哪个对象都应该从该对象的构造说起，所以博主来分析分析<code>File</code>类的构造方法。首先从API开始着手<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013095030887.png" alt="在这里插入图片描述"><br>我们主要来学习一下比较常用的三个：</p><p>1、 <code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。<br>2、 <code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。<br>3、 <code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。</p><p>看字描述不够生动不够形象不得劲？没得事，下面进行构造举例，马上就生动形象了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 一个File对象代表硬盘中实际存在的一个文件或者目录。</span><br><span class="line"><span class="number">2.</span>  File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。</span><br><span class="line"><span class="comment">// 文件路径名 </span></span><br><span class="line">String path = <span class="string">&quot;D:\\123.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(path); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String path2 = <span class="string">&quot;D:\\1\\2.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path2);     -------------相当于D:\\<span class="number">1</span>\\<span class="number">2.</span>txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;F:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);  --------相当于F:\\aaa\\bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;F:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child); --------相当于F:\\aaa\\bbb.txt</span><br></pre></td></tr></table></figure><blockquote><p>File类的注意点：</p><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><p>File的常用方法主要分为获取功能、获取绝对路径和相对路径、判断功能、创建删除功能的方法</p><h3 id="1-3-1-获取功能的方法"><a href="#1-3-1-获取功能的方法" class="headerlink" title="1.3.1 获取功能的方法"></a>1.3.1 获取功能的方法</h3><p>1、<code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。<br>2、<code>public String getPath()</code> ：将此File转换为路径名字符串。<br>3、<code>public String getName()</code> ：返回由此File表示的文件或目录的名称。<br>4、<code>public long length()</code> ：返回由此File表示的文件的长度。<br>以上方法测试，代码如下【注意测试以自己的电脑文件夹为准】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">2116</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">3236</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>length()</code>，表示文件的长度。但是<code>File</code>对象表示目录，则返回值未指定。</p></blockquote><h3 id="1-3-2-绝对路径和相对路径"><a href="#1-3-2-绝对路径和相对路径" class="headerlink" title="1.3.2 绝对路径和相对路径"></a>1.3.2 绝对路径和相对路径</h3><p><strong>绝对路径</strong>：一个完整的路径，以盘符开头，例如<code>F://aaa.txt</code>。<br><strong>相对路径</strong>：一个简化的路径，不以盘符开头,例如<code>//aaa.txt//b.txt</code>。</p><blockquote><p>1、<strong>路径是不区分大小写</strong><br>2、路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\java\bbb.java</span><br></pre></td></tr></table></figure><h3 id="1-3-3判断功能的方法"><a href="#1-3-3判断功能的方法" class="headerlink" title="1.3.3判断功能的方法"></a>1.3.3判断功能的方法</h3><p>1、 <code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。<br>2、 <code>public boolean isDirectory()</code> ：此File表示的是否为目录。<br>3、<code>public boolean isFile()</code> ：此File表示的是否为文件。</p><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-创建删除功能的方法"><a href="#1-3-4-创建删除功能的方法" class="headerlink" title="1.3.4 创建删除功能的方法"></a>1.3.4 创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：文件不存在，创建一个新的空文件并返回<code>true</code>，文件存在，不创建文件并返回<code>false</code>。</li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。</li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>其中，<code>mkdirs()</code>和<code>mkdir()</code>方法类似，但<code>mkdir()</code>，只能创建一级目录，<code>mkdirs()</code>可以创建多级目录比如<code>//a//b//c</code>，所以<strong>开发中一般用</strong><code>mkdirs()</code>;</p><blockquote><p>这些方法中值得注意的是<strong>createNewFile</strong>方法以及<strong>mkdir</strong>与<strong>mkdirs</strong>的区别</p></blockquote><p>方法测试，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// 以及创建过了所以再使用createNewFile返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 目录的创建</span></span><br><span class="line">      File f2= <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">      File f3= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 文件的删除</span></span><br><span class="line">       System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>delete</code>方法，如果此<code>File</code>表示目录，则目录必须为空才能删除。</p></blockquote><h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;G:\光标&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013114927925.png" alt="在这里插入图片描述"><br><strong>listFiles</strong>在获取指定目录下的文件或者文件夹时必须满足下面两个条件</p><p>1，<strong>指定的目录必须存在</strong></p><p>2，<strong>指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException异常</strong></p><h2 id="1-5-递归遍历文件夹下所有文件以及子文件"><a href="#1-5-递归遍历文件夹下所有文件以及子文件" class="headerlink" title="1.5 递归遍历文件夹下所有文件以及子文件"></a>1.5 递归遍历文件夹下所有文件以及子文件</h2><p>不说啥了，直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归遍历文件夹下所有的文件</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RecursionDirectory</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">      File file=<span class="keyword">new</span> File(<span class="string">&quot;D:\\java专属IO测试&quot;</span>);</span><br><span class="line">        Recursion(file);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">Recursion</span>(<span class="params">File file</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1、判断传入的是否是目录</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">!file.isDirectory()</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//不是目录直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经确保了传入的file是目录</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">//遍历files</span></span><br><span class="line">        <span class="keyword">for</span> (File f: files) &#123;</span><br><span class="line">            <span class="comment">//如果该目录下文件还是个文件夹就再进行递归遍历其子目录</span></span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">f.isDirectory()</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                Recursion(f);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果该目录下文件是个文件，则打印对应的名字</span></span><br><span class="line">                System.out.println(f.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对上面的代码有疑问，可以随时联系我，博主一直都在！</p><h1 id="3、初探IO流"><a href="#3、初探IO流" class="headerlink" title="3、初探IO流"></a>3、初探IO流</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>我想在座各位肯定经历都过这样的场景。当你编辑一个文本文件也好用eclipse打代码也罢，忘记了<code>ctrl+s</code> ，在你关闭文件的哪一瞬间手残点了个不该点的按钮，但你反应过来，心早已拔凉拔凉的了。</p><p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入也叫做读取数据，输出也叫做作写出数据</strong>。</p><h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong> 和 <strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。</li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>根据数据的类型分为：<strong>字节流</strong> 和 <strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><p><strong>分类之后对应的超类</strong>（V8提示：超类也就是父类的意思）</p><table><thead><tr><th></th><th>输入流</th><th>输出流</th></tr></thead><tbody><tr><td>字节流</td><td>字节输入流 <strong>InputStream</strong></td><td>字节输出流 <strong>OutputStream</strong></td></tr><tr><td>字符流</td><td>字符输入流 <strong>Reader</strong></td><td>字符输出流 <strong>Writer</strong></td></tr></tbody></table><p><strong>注</strong>：<br><strong>由这四个类的子类名称基本都是以其父类名作为子类名的后缀</strong>。<br>如：InputStream的子类FileInputStream。<br>如：Reader的子类FileReader。<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/image-20201217200816367.png" alt="image-20201217200816367" style="zoom:80%;"></p><h2 id="1-3-关于IO的分流向说明"><a href="#1-3-关于IO的分流向说明" class="headerlink" title="1.3 关于IO的分流向说明"></a>1.3 关于IO的分流向说明</h2><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013151622369.png" alt="在这里插入图片描述" style="zoom:80%;"><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015144401127.png" alt="在这里插入图片描述" style="zoom:80%;"><h2 id="字节流OutputStream与InputStream的故事"><a href="#字节流OutputStream与InputStream的故事" class="headerlink" title="字节流OutputStream与InputStream的故事"></a>字节流OutputStream与InputStream的故事</h2><p>OutputStream与InputStream的继承关系<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015145625281.png" alt="在这里插入图片描述" style="zoom:80%;"></p><h2 id="2-1-文件的世界里一切皆为字节"><a href="#2-1-文件的世界里一切皆为字节" class="headerlink" title="2.1 文件的世界里一切皆为字节"></a>2.1 文件的世界里一切皆为字节</h2><p>我们必须明确一点的是，一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h2 id="2-2-字节输出流（OutputStream）"><a href="#2-2-字节输出流（OutputStream）" class="headerlink" title="2.2 字节输出流（OutputStream）"></a>2.2 字节输出流（OutputStream）</h2><p><code>java.io.OutputStream</code>抽象类是表示<strong>字节输出流</strong>的所有类的<strong>超类</strong>（父类），将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法，不要问我<code>OutputStream</code>为啥可以定义字节输出流的基本共性功能方法，熊dei啊，上一句说过了<strong>OutputStream是字节输出流的所有类的超类</strong>，<a href="https://blog.csdn.net/qq_44543508/article/details/102375196">继承</a>知识，懂？(如果是真的不理解的小白同学，可以点击蓝色字体<a href="https://blog.csdn.net/qq_44543508/article/details/102375196">继承</a>进入补习)</p><p><strong>字节输出流的基本共性功能方法</strong>:</p><blockquote><p>1、 <code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。<br>2、 <code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。<br>3、 <code>public void write(byte[] b)</code>：将 b.length个字节从指定的字节数组写入此输出流。<br>4、 <code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 <strong>也就是说从off个字节数开始读取一直到len个字节结束</strong><br>5、 <code>public abstract void write(int b)</code> ：将指定的字节输出流。</p></blockquote><blockquote><p><strong>以上五个方法则是字节输出流都具有的方法，由父类OutputStream定义提供，子类都会共享以上方法</strong></p></blockquote><h4 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h4><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类FileOutputStream开始。看名字就知道是文件输出流，用于将数据写出到文件。</p><h4 id="FileOutputStream构造方法"><a href="#FileOutputStream构造方法" class="headerlink" title="FileOutputStream构造方法"></a>FileOutputStream构造方法</h4><p>不管学啥子，只有是对象，就从构造方法开始！</p><blockquote><p>1、 <code>public FileOutputStream(File file)</code>：根据File对象为参数创建对象。<br>2、 <code>public FileOutputStream(String name)</code>： 根据名称字符串为参数创建对象。</p></blockquote><p><strong>推荐第二种构造方法</strong>【开发常用】：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;abc.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>就以上面这句代码来讲，类似这样创建字节输出流对象都做了<strong>三件事情</strong>：<br>1、调用系统功能去创建文件【输出流对象才会自动创建】<br>2、创建outputStream对象<br>3、把foutputStream对象指向这个文件</p><blockquote><p>注意：<br>创建输出流对象的时候，系统会自动去对应位置创建对应文件，而创建输出流对象的时候，文件不存在则会报FileNotFoundException异常，也就是系统找不到指定的文件异常。</p></blockquote><p>当你创建一个流对象时，必须直接或者间接传入一个文件路径。比如现在我们创建一个<code>FileOutputStream</code>流对象，在该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。有兴趣的童鞋可以测试一下，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\自动创建的文件夹\\a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FileOutputStream写出字节数据"><a href="#FileOutputStream写出字节数据" class="headerlink" title="FileOutputStream写出字节数据"></a>FileOutputStream写出字节数据</h4><p>使用FileOutputStream写出字节数据主要通过<code>Write</code>方法，而<code>write</code>方法分如下三种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> write(int b)</span><br><span class="line">public <span class="keyword">void</span> write(byte[] b)</span><br><span class="line">public <span class="keyword">void</span> write(byte[] b,int off,int len)  <span class="comment">//从`off`索引开始，`len`个字节</span></span><br></pre></td></tr></table></figure><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">      fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><blockquote><ol><li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">&quot;麻麻我想吃烤山药&quot;</span>.getBytes();</span><br><span class="line">      <span class="comment">// 写出字节数组数据</span></span><br><span class="line">      fos.write(b);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">麻麻我想吃烤山药</span><br></pre></td></tr></table></figure><ol><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从<code>off</code>索引开始，<code>len</code>个字节，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure><h4 id="FileOutputStream实现数据追加续写、换行"><a href="#FileOutputStream实现数据追加续写、换行" class="headerlink" title="FileOutputStream实现数据追加续写、换行"></a>FileOutputStream实现数据追加续写、换行</h4><p>经过以上的代码测试，每次程序运行，每次创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续<strong>追加新数据</strong>呢？并且实现<strong>换行</strong>呢？其实很简单，这个时候我们又要再学习<code>FileOutputStream</code>的另外两个构造方法了，如下：</p><p>1、<code>public FileOutputStream(File file, boolean append)</code></p><p>2、<code>public FileOutputStream(String name, boolean append)</code></p><p>这两个构造方法，第二个参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示不追加也就是清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，至于Windows换行则是 <code>\n\r</code> ，下面将会详细讲到。</p><p>实现数据追加续写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure><p>Windows系统里，换行符号是<code>\r\n</code> ,具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      <span class="comment">// 定义字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          <span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>回车符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\r</span><br></pre></td></tr></table></figure><p>和换行符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n</span><br></pre></td></tr></table></figure></li></ul><p>  ：</p><ul><li><p>回车符：回到一行的开头（return）。</p></li><li><p>换行符：下一行（newline）。</p></li><li><p>系统中的换行：</p><ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h2 id="2-3-字节输入流（InputStream）"><a href="#2-3-字节输入流（InputStream）" class="headerlink" title="2.3 字节输入流（InputStream）"></a>2.3 字节输入流（InputStream）</h2><p><code>java.io.InputStream</code>抽象类是表示<strong>字节输入流</strong>的所有类的<strong>超类</strong>（父类），可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><p><strong>字节输入流的基本共性功能方法</strong>:</p><blockquote><p>1、 <code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。<br>2、<code>public abstract int read()</code>： 从输入流读取数据的下一个字节。</p><p>3、 <code>public int read(byte[] b)</code>： 该方法返回的int值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1</p></blockquote><h4 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h4><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p><h4 id="FileInputStream的构造方法"><a href="#FileInputStream的构造方法" class="headerlink" title="FileInputStream的构造方法"></a>FileInputStream的构造方法</h4><blockquote><p>1、 <code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。<br>2、 <code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。</p></blockquote><p>同样的，推荐使用第二种构造方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FileInputStream读取字节数据"><a href="#FileInputStream读取字节数据" class="headerlink" title="FileInputStream读取字节数据"></a>FileInputStream读取字节数据</h4><ol><li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码测试如下【read.txt文件中内容为abcde】：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);<span class="comment">//read.txt文件中内容为abcde</span></span><br><span class="line">      <span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">      <span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>循环改进读取方式，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ol><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// read.txt文件中内容为abcde</span></span><br><span class="line">      <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure><p>由于<code>read.txt</code>文件中内容为<code>abcde</code>，而错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全<strong>替换</strong>【注意是替换，看下图】，所以要通过<code>len</code> ，获取有效的字节<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015160242904.png" alt="在这里插入图片描述" style="zoom:80%;"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure><p>在开发中一般强烈推荐使用数组读取文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">input2</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>)</span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">            int len = <span class="number">0</span> ;</span><br><span class="line">            byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="built_in">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字节流FileInputstream复制图片"><a href="#字节流FileInputstream复制图片" class="headerlink" title="字节流FileInputstream复制图片"></a>字节流FileInputstream复制图片</h4><p><strong>复制图片原理</strong><br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013204020152.png" alt="在这里插入图片描述" style="zoom:80%;"></p><p><strong>代码实现</strong></p><p>复制图片文件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：<strong>复制文本、图片、mp3、视频等的方式一样</strong>。</p><p>到这里，已经从File类讲到了字节流OutputStream与InputStream，而现在将主要从字符流Reader和Writer的故事开展。</p><h1 id="字符流Reader和Writer的故事"><a href="#字符流Reader和Writer的故事" class="headerlink" title="字符流Reader和Writer的故事"></a>字符流Reader和Writer的故事</h1><p>字符流Reader和Writer的故事从它们的继承图开始，啥都不说了，直接看图<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015171311217.png" alt="在这里插入图片描述" style="zoom:80%;"></p><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p>字符流的由来：因为数据编码的不同，因而有了对字符进行高效操作的流对象，字符流本质其实就是基于字节流读取时，去查了指定的码表，而字节流直接读取数据会有乱码的问题（读中文会乱码），这个时候小白同学就看不懂了，没事，咋们先来看个程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//FileInputStream为操作文件的字符输入流</span></span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//内容为哥敢摸屎</span></span><br><span class="line"></span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print((char)len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：   ??￥??￠????±</span><br></pre></td></tr></table></figure><p>具体现状分析<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014113505625.png" alt="在这里插入图片描述" style="zoom:80%;"><br>话说，就是你哥我敢摸si,那你哥我肯定也不认识这玩意啊： <code>??￥??￠????±</code></p><blockquote><p>字节流读取中文字符时，可能不会显示完整的字符，那是因为一个中文字符占用多个字节存储。</p></blockquote><p>那字节流就没办法了吗？不，字节流依旧有办法，只是麻烦了点，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        byte[] bytes = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print(<span class="keyword">new</span> <span class="built_in">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果： 哥敢摸屎</span><br></pre></td></tr></table></figure><p>这是为啥呢？没错解码的正是<code>String</code>，查看<code>new String()</code>的源码，<code>String</code>构造方法有解码功能，并且默认编码是<code>utf-8</code>，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line"> </span><br><span class="line"> 再点进decode，循序渐进发现，默认编码是UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>尽管字节流也能有办法决绝乱码问题，但是还是比较麻烦，于是java就有了字符流，<code>字符为单位</code>读写数据，字符流<code>专门用于处理文本</code>文件。如果处理纯文本的数据优先考虑字符流，其他情况就只能用字节流了（图片、视频、等等<code>只文本</code>例外）。</p><blockquote><p>从另一角度来说：<strong>字符流 = 字节流 + 编码表</strong></p></blockquote><h1 id="1、-字符输入流（Reader）"><a href="#1、-字符输入流（Reader）" class="headerlink" title="1、 字符输入流（Reader）"></a>1、 字符输入流（Reader）</h1><p><code>java.io.Reader</code>抽象类是<strong>字符输入流</strong>的所有类的<strong>超类</strong>（父类），可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><p><strong>字符输入流的共性方法</strong>：</p><blockquote><p>1、<code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。<br>2、 <code>public int read()</code>： 从输入流读取一个字符。<br>3、 <code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</p></blockquote><h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote><p>1、<code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的<strong>File对象</strong>。<br>2、 <code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的<strong>字符串名称</strong>。</p></blockquote><p>构造方法的使用就算不写应该都很熟悉了吧，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileReader读取字符数据"><a href="#FileReader读取字符数据" class="headerlink" title="FileReader读取字符数据"></a>FileReader读取字符数据</h3><ol><li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于读取的写法类似字节流的写法，只是读取单位不同罢了。</p><h1 id="2、字符输出流（Writer）"><a href="#2、字符输出流（Writer）" class="headerlink" title="2、字符输出流（Writer）"></a>2、字符输出流（Writer）</h1><p><code>java.io.Writer</code>抽象类是<strong>字符输出流</strong>的所有类的<strong>超类</strong>（父类），将指定的字符信息写出到目的地。它同样定义了字符输出流的基本共性功能方法。</p><p><strong>字符输出流的基本共性功能方法</strong>：</p><blockquote><p>1、<code>void write(int c)</code> 写入单个字符。<br>2、<code>void write(char[] cbuf)</code>写入字符数组。<br>3、 <code>abstract void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>4、 <code>void write(String str)</code>写入字符串。<br>5、<code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>6、<code>void flush()</code>刷新该流的缓冲。<br>7、<code>void close()</code> 关闭此流，但要先刷新它。</p></blockquote><h2 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h2><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、 <code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。<br>2、<code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</p><p>依旧是熟悉的构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种：使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 第二种：使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileWriter写出数据"><a href="#FileWriter写出数据" class="headerlink" title="FileWriter写出数据"></a>FileWriter写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">      fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC</span><br></pre></td></tr></table></figure><blockquote><p>【注意】<strong>关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</strong></p></blockquote><h3 id="关闭close和刷新flush"><a href="#关闭close和刷新flush" class="headerlink" title="关闭close和刷新flush"></a>关闭close和刷新flush</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><p><code>flush</code> ：刷新缓冲区，流对象可以继续使用。<br><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p><p>flush还是比较有趣的，童鞋们不自己运行一下还真不好体会，现在博主就写个程序让你体会体会：<br>字符流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlushDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//源   也就是输入流【读取流】 读取a.txt文件</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);  <span class="comment">//必须要存在a.txt文件，否则报FileNotFoundException异常</span></span><br><span class="line">        <span class="comment">//目的地  也就是输出流</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);  <span class="comment">//系统会自动创建b.txt，因为它是输出流！</span></span><br><span class="line">        int len;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(len=fr.read())!=-<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">           fw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">   注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014222100212.png" alt="在这里插入图片描述" style="zoom:80%;">运行效果是怎么样的呢？答案是b.txt文件中依旧是空的，是的并没有任何东西，为啥呢？熊dei啊，我在上面就用红色字体特别标注过了，就是这句话： 【注意】**关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。**这个时候反应过来了吧，可见实践例子的重要性，**编程就是这样，不去敲，永远学不会**！！！所以一定要去敲，博主没敲过10万行代码真的没有脸出去说自己是学java的。所以，大家一定要多思考，多敲啊！！！<p>所以，我们在以上的代码中再添加下面三句代码，就完美了，b.txt文件就能复制到源文件的数据了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fr.close();</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure><blockquote><p><code>flush()</code>这个函数是清空的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再用数据写到文件中，那么当你数据读完时，我们如果这时调用<code>close()</code>方法关闭读写流，这时就可能造成数据丢失，为什么呢？因为，读入数据完成时不代表写入数据完成，一部分数据可能会留在缓存区中，这个时候<code>flush()</code>方法就格外重要了。</p></blockquote><p>好了，接下来close使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p></blockquote><h3 id="FileWriter的续写和换行"><a href="#FileWriter的续写和换行" class="headerlink" title="FileWriter的续写和换行"></a>FileWriter的续写和换行</h3><p><strong>续写和换行</strong>：操作类似于FileOutputStream操作（上一篇博客讲到过），直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      <span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;哥敢&quot;</span>);</span><br><span class="line">      <span class="comment">// 写出换行</span></span><br><span class="line">      fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      <span class="comment">// 写出字符串</span></span><br><span class="line">  fw.write(<span class="string">&quot;摸屎&quot;</span>);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">哥敢</span><br><span class="line">摸屎</span><br></pre></td></tr></table></figure><h3 id="FileReader和FileWriter类完成文本文件复制"><a href="#FileReader和FileWriter类完成文本文件复制" class="headerlink" title="FileReader和FileWriter类完成文本文件复制"></a>FileReader和FileWriter类完成文本文件复制</h3><p>直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\新建文件夹\\aa.txt&quot;</span>);<span class="comment">//文件不存在会抛出java.io.FileNotFoundException</span></span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\copyaa.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*创建输出流做的工作：</span></span><br><span class="line"><span class="comment">         *      1、调用系统资源创建了一个文件</span></span><br><span class="line"><span class="comment">         *      2、创建输出流对象</span></span><br><span class="line"><span class="comment">         *      3、把输出流对象指向文件        </span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//文本文件复制，一次读一个字符</span></span><br><span class="line">        copyMethod1(fr, fw);</span><br><span class="line">        <span class="comment">//文本文件复制，一次读一个字符数组</span></span><br><span class="line">        copyMethod2(fr, fw);</span><br><span class="line">        </span><br><span class="line">        fr.close();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> copyMethod1(FileReader fr, FileWriter fw) throws IOException &#123;</span><br><span class="line">        int ch;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(ch=fr.read())!=-<span class="number">1</span></span>)</span> &#123;<span class="comment">//读数据</span></span><br><span class="line">            fw.write(ch);<span class="comment">//写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> copyMethod2(FileReader fr, FileWriter fw) throws IOException &#123;</span><br><span class="line">        char chs[]=<span class="keyword">new</span> char[<span class="number">1024</span>];</span><br><span class="line">        int len=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(len=fr.read(chs))!=-<span class="number">1</span></span>)</span> &#123;<span class="comment">//读数据</span></span><br><span class="line">            fw.write(chs,<span class="number">0</span>,len);<span class="comment">//写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyFile</span><br></pre></td></tr></table></figure><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014213256773.png" alt="在这里插入图片描述" style="zoom:80%;"><blockquote><p><strong>最后再次强调：<br>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流</strong></p></blockquote><h3 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h3><p>我们在学习的过程中可能习惯把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，格式代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;哥敢摸si&quot;</span>); <span class="comment">//哥敢摸si</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对异常不是特别熟练的童鞋可以参考这篇文章<a href="https://blog.csdn.net/qq_44543508/article/details/102211261">【java基础之异常】死了都要try，不淋漓尽致地catch我不痛快！</a></p><p>好了，到这里，字符流Reader和Writer的故事的到这里了！</p><p>前面主要写了一些基本的流作为IO流的入门。从这里开始将要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等，而这些强大的流都是在基本的流对象基础之上而来的！这些强大的流将伴随着我们今后的开发！</p><h1 id="1、缓冲流【掌握】"><a href="#1、缓冲流【掌握】" class="headerlink" title="1、缓冲流【掌握】"></a>1、缓冲流【掌握】</h1><h2 id="1-1-简要概述"><a href="#1-1-简要概述" class="headerlink" title="1.1 简要概述"></a>1.1 简要概述</h2><p>首先我们来认识认识一下缓冲流,也叫高效流，是对4个<code>FileXxx</code> 流的“增强流”。</p><p><strong>缓冲流的基本原理</strong>：</p><blockquote><p>1、使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。<br>2、通过缓冲区的read()方法从缓冲区获取具体的字符数据，这样就提高了效率。<br>3、如果用read方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了readLine()功能。</p></blockquote><p>也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><p>缓冲书写格式为<code>BufferedXxx</code>，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code></li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>InputStream</strong>。</li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>OutputStream</strong>。</li></ul><p>构造举例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方式一： 创建字节缓冲输入流【但是开发中一般常用下面的格式申明】</span></span><br><span class="line">FileInputStream fps = <span class="keyword">new</span> FileInputStream(b.txt);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fps)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方式一： 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">///构造方式二： 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="感受缓冲流的高效"><a href="#感受缓冲流的高效" class="headerlink" title="感受缓冲流的高效"></a>感受缓冲流的高效</h3><p>缓冲流读写方法与基本的流是一致的，我们通过复制370多MB的大文件，测试它的效率。</p><ol><li>基本流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>);<span class="comment">//exe文件够大</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>)</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不好意思十分钟过去了还在玩命复制中...</span><br></pre></td></tr></table></figure><ol><li>缓冲流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">         BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>));</span><br><span class="line">     BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure><p>有的童鞋就要说了，我要更快的速度！最近看速度与激情7有点上头，能不能再快些？答案是当然可以</p><p>想要更快可以使用数组的方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">      <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line"> BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>));</span><br><span class="line"> BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">521</span> 毫秒  </span><br></pre></td></tr></table></figure><h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><p>相同的来看看其构造，其格式以及原理和字节缓冲流是一样一样的！</p><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>Reader</strong>。</li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>Writer</strong>。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="字符缓冲流特有方法"><a href="#字符缓冲流特有方法" class="headerlink" title="字符缓冲流特有方法"></a>字符缓冲流特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的<strong>特有</strong>方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: <strong>读一行数据</strong>。 读取到最后返回null</li><li>BufferedWriter：<code>public void newLine()</code>: <strong>换行</strong>,由系统属性定义符号。</li></ul><p><code>readLine</code>方法演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newLine</code>方法演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    <span class="comment">// 创建流对象</span></span><br><span class="line">  BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 写出数据</span></span><br><span class="line">      bw.write(<span class="string">&quot;哥&quot;</span>);</span><br><span class="line">    <span class="comment">// 写出换行</span></span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;敢&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;摸屎&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;你敢吗？&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">  <span class="comment">// 释放资源</span></span><br><span class="line">      bw.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">哥</span><br><span class="line">敢</span><br><span class="line">摸屎</span><br><span class="line">你敢吗？</span><br></pre></td></tr></table></figure><h2 id="1-4-字符缓冲流练习"><a href="#1-4-字符缓冲流练习" class="headerlink" title="1.4 字符缓冲流练习"></a>1.4 字符缓冲流练习</h2><p>字符缓冲流练习啥捏？先放松一下吧各位，先欣赏欣赏我写的下面的诗篇</p><blockquote><p>6.你说你的程序叫简单，我说我的代码叫诗篇<br>1.一想到你我就哦豁豁豁豁豁豁豁豁豁豁….哦nima个头啊，完全不理人家受得了受不了<br>8.Just 简单你和我 ，Just 简单程序员<br>3.约了地点却忘了见面 ，懂得寂寞才明白浩瀚<br>5.沉默是最大的发言权<br>2.总是喜欢坐在电脑前， 总是喜欢工作到很晚<br>7.向左走 又向右走，我们转了好多的弯<br>4.你从来就不问我，你还是不是那个程序员</p></blockquote><p>欣赏完了咩？没错咋们就练习如何使用缓冲流的技术把上面的诗篇归顺序，都编过号了就是前面的1到8的编号</p><p>分析：首先用字符输入缓冲流创建个源，里面放没有排过序的文字，之后用字符输出缓冲流创建个目标接收，排序的过程就要自己写方法了哦，可以从每条诗词的共同点“.”符号下手！</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象  源</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//目标</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            String key = String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            String value = lineMap.get(key);</span><br><span class="line">          <span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">&quot;.&quot;</span>+value);</span><br><span class="line">          <span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>一想到你我就哦豁豁豁豁豁豁豁豁豁豁…哦nima个头啊，完全不理人家受得了受不了</span><br><span class="line"><span class="number">2.</span>总是喜欢坐在电脑前， 总是喜欢工作到很晚</span><br><span class="line"><span class="number">3.</span>约了地点却忘了见面 ，懂得寂寞才明白浩瀚</span><br><span class="line"><span class="number">4.</span>你从来就不问我，你还是不是那个程序员</span><br><span class="line"><span class="number">5.</span>沉默是最大的发言权</span><br><span class="line"><span class="number">6.</span>你说你的程序叫简单，我说我的代码叫诗篇</span><br><span class="line"><span class="number">7.</span>向左走 又向右走，我们转了好多的弯</span><br><span class="line"><span class="number">8.</span>Just 简单你和我 ，Just 简单程序员</span><br></pre></td></tr></table></figure><h1 id="2、转换流【掌握】"><a href="#2、转换流【掌握】" class="headerlink" title="2、转换流【掌握】"></a>2、转换流【掌握】</h1><p>何谓转换流？为何由来？暂时带着问题让我们先来了解了解字符编码和字符集！<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/2019101609401732.png" alt="在这里插入图片描述" style="zoom:80%;"></p><h3 id="2-1-字符编码与解码"><a href="#2-1-字符编码与解码" class="headerlink" title="2.1 字符编码与解码"></a>2.1 字符编码与解码</h3><p>众所周知，计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照<code>A</code>规则存储，同样按照<code>A</code>规则解析，那么就能显示正确的文本符号。反之，按照<code>A</code>规则存储，再按照<code>B</code>规则解析，就会导致乱码现象。</p><p>简单一点的说就是：</p><blockquote><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p></blockquote><p>代码解释则是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName):通过指定的字符集解码字节数组</span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组</span><br><span class="line"></span><br><span class="line">编码:把看得懂的变成看不懂的</span><br><span class="line">String -- <span class="keyword">byte</span>[]</span><br><span class="line"></span><br><span class="line">解码:把看不懂的变成看得懂的</span><br><span class="line"><span class="keyword">byte</span>[] -- String</span><br></pre></td></tr></table></figure><ul><li><p><strong>字符编码</strong> <code>Character Encoding</code>: 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>而<strong>编码表</strong>则是生活中文字和计算机中二进制的对应规则</p></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li><strong>字符集</strong> <code>Charset</code>：也叫<strong>编码表</strong>。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有<code>ASCII</code>字符集、<code>GBK</code>字符集、<code>Unicode</code>字符集等。<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016090127127.png" alt="在这里插入图片描述" style="zoom:80%;"></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><p>ASCII字符集：</p><ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li></ul></li><li><p>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</p></li><li><p>ISO-8859-1字符集：</p><ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li></ul></li><li><p>ISO-8859-1使用单字节编码，兼容ASCII编码。</p></li><li><p>GBxxx字符集：</p><ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li></ul></li><li><p><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><ul><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><p>Unicode字符集：</p><ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li></ul></li><li><p>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</p><ul><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：</li></ul><ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。</li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul><h2 id="2-2-编码问题导致乱码"><a href="#2-2-编码问题导致乱码" class="headerlink" title="2.2 编码问题导致乱码"></a>2.2 编码问题导致乱码</h2><p>在java开发工具IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：���</span><br></pre></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？ 这个时候就得讲讲转换流了！</p><blockquote><p>从另一角度来讲：<strong>字符流=字节流+编码表</strong></p></blockquote><h2 id="2-3-InputStreamReader类—–-字节流到字符流的桥梁"><a href="#2-3-InputStreamReader类—–-字节流到字符流的桥梁" class="headerlink" title="2.3 InputStreamReader类—–(字节流到字符流的桥梁)"></a>2.3 InputStreamReader类—–(字节流到字符流的桥梁)</h2><p>转换流<code>java.io.InputStreamReader</code>，是<code>Reader</code>的子类，从字面意思可以看出它是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote><p><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。<br><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p></blockquote><p>构造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用转换流解决编码问题"><a href="#使用转换流解决编码问题" class="headerlink" title="使用转换流解决编码问题"></a>使用转换流解决编码问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        String FileName = <span class="string">&quot;C:\\A.txt&quot;</span>;</span><br><span class="line">      <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">      <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"><span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">      <span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read); <span class="comment">// �����ʺ      </span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 哥敢摸屎</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-OutputStreamWriter类—–-字符流到字节流的桥梁"><a href="#2-4-OutputStreamWriter类—–-字符流到字节流的桥梁" class="headerlink" title="2.4 OutputStreamWriter类—–(字符流到字节流的桥梁)"></a>2.4 OutputStreamWriter类—–(字符流到字节流的桥梁)</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，字面看容易混淆会误以为是转为字符流，其实不然，OutputStreamWriter为从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote><p><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。<br><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p></blockquote><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="指定编码构造代码"><a href="#指定编码构造代码" class="headerlink" title="指定编码构造代码"></a>指定编码构造代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 定义文件路径</span></span><br><span class="line">        String FileName = <span class="string">&quot;C:\\s.txt&quot;</span>;</span><br><span class="line">      <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      osw.write(<span class="string">&quot;哥敢&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 定义文件路径</span></span><br><span class="line">String FileName2 = <span class="string">&quot;D:\\A.txt&quot;</span>;</span><br><span class="line">     <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      osw2.write(<span class="string">&quot;摸屎&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016100612927.png" alt="在这里插入图片描述"><br>为了达到<strong>最高效率</strong>，可以考虑在 <code>BufferedReader</code> 内包装 <code>InputStreamReader</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader <span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))；</span><br></pre></td></tr></table></figure><h1 id="3、序列化流【理解】"><a href="#3、序列化流【理解】" class="headerlink" title="3、序列化流【理解】"></a>3、序列化流【理解】</h1><blockquote><p>(1)可以把对象写入文本文件或者在网络中传输<br>(2)如何实现序列化呢?<br>让被序列化的对象所属类实现序列化接口。<br>该接口是一个标记接口。没有功能需要实现。<br>(3)注意问题：<br>把数据写到文件后，在去修改类会产生一个问题。<br>如何解决该问题呢?<br>在类文件中，给出一个固定的序列化id值。<br>而且，这样也可以解决黄色警告线问题<br>(4)面试题：<br>什么时候序列化?<br>如何实现序列化?<br>什么是反序列化?</p></blockquote><h2 id="3-1-何谓序列化"><a href="#3-1-何谓序列化" class="headerlink" title="3.1 何谓序列化"></a>3.1 何谓序列化</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化：<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016100818120.png" alt="在这里插入图片描述"></p><h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</p><p>构造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aa.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol><li>一个对象要想序列化，必须满足两个条件:</li></ol><p>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</p><p>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.写出对象方法</p><p><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">    e.age = <span class="number">20</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 写出对象</span></span><br><span class="line">        out.writeObject(e);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure><h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</p><h3 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</p><h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">             ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        <span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong></p><h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a>反序列化操作2</h3><p>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。发生这个异常的原因如下：</p><blockquote><p>1、该类的序列版本号与从流中读取的类描述符的版本号不匹配<br>2、该类包含未知数据类型<br>2、该类没有可访问的无参数构造方法</p></blockquote><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-序列化集合练习"><a href="#3-4-序列化集合练习" class="headerlink" title="3.4 序列化集合练习"></a>3.4 序列化集合练习</h2><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h3 id="案例代码实现"><a href="#案例代码实现" class="headerlink" title="案例代码实现"></a>案例代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建 学生对象</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;laow&quot;</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;老张&quot;</span>, <span class="string">&quot;laoz&quot;</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;老李&quot;</span>, <span class="string">&quot;laol&quot;</span>);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(student);</span><br><span class="line">arrayList.add(student2);</span><br><span class="line">arrayList.add(student3);</span><br><span class="line"><span class="comment">// 序列化操作</span></span><br><span class="line"><span class="comment">// serializ(arrayList);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化  </span></span><br><span class="line">ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          Student s = list.get(i);</span><br><span class="line">        System.out.println(s.getName()+<span class="string">&quot;--&quot;</span>+ s.getPwd());</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建 序列化流 </span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 写出对象</span></span><br><span class="line">oos.writeObject(arrayList);</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">oos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、打印流【掌握】"><a href="#4、打印流【掌握】" class="headerlink" title="4、打印流【掌握】"></a>4、打印流【掌握】</h1><h2 id="4-1-何谓打印流"><a href="#4-1-何谓打印流" class="headerlink" title="4.1 何谓打印流"></a>4.1 何谓打印流</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，各位用了这么久的输出语句肯定没想过这两个方法都来自于<code>java.io.PrintStream</code>类吧，哈哈。该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><p><strong>打印流分类</strong>：</p><blockquote><p>字节打印流PrintStream，字符打印流PrintWriter</p></blockquote><p><strong>打印流特点</strong>：</p><blockquote><p>A:只操作目的地,不操作数据源<br>B:可以操作任意类型的数据<br>C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新<br>D:可以直接操作文件</p></blockquote><p>这个时候有同学就要问了，哪些流可以直接操作文件呢?答案很简单，<strong>如果该流的构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的</strong>！</p><p>PrintStream是OutputStream的子类，PrintWriter是Writer的子类，两者处于对等的位置上，所以它们的API是非常相似的。二者区别无非一个是字节打印流，一个是字符打印流。</p><h2 id="4-2-字节输出打印流PrintStream复制文本文件"><a href="#4-2-字节输出打印流PrintStream复制文本文件" class="headerlink" title="4.2 字节输出打印流PrintStream复制文本文件"></a>4.2 字节输出打印流PrintStream复制文本文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;copy.txt&quot;</span>));</span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> PrintStream(<span class="string">&quot;printcopy.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> line;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(line=br.readLine())!=<span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            ps.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-字符输出打印流PrintWriter复制文本文件"><a href="#4-3-字符输出打印流PrintWriter复制文本文件" class="headerlink" title="4.3 字符输出打印流PrintWriter复制文本文件"></a>4.3 字符输出打印流PrintWriter复制文本文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用打印流复制文本文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;aa.txt&quot;</span>));</span><br><span class="line">        PrintWriter pw=<span class="keyword">new</span> PrintWriter(<span class="string">&quot;printcopyaa.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> line;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(line=br.readLine())!=<span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            pw.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、Properties属性类"><a href="#5、Properties属性类" class="headerlink" title="5、Properties属性类"></a>5、Properties属性类</h1><p>我想各位对这个Properties类多多少少也接触过了，首先Properties类并不在IO包下，那为啥要和IO流一起讲呢？原因很简单因为properties类经常和io流的联合一起使用。</p><blockquote><p>(1)是一个集合类，Hashtable的子类<br>(2)特有功能<br>A:public Object setProperty(String key,String value)<br>B:public String getProperty(String key)<br>C:public Set stringPropertyNames()<br>(3)和IO流结合的方法<br>把键值对形式的文本文件内容加载到集合中<br>public void load(Reader reader)<br>public void load(InputStream inStream)<br>把集合中的数据存储到文本文件中<br>public void store(Writer writer,String comments)<br>public void store(OutputStream out,String comments)</p></blockquote><h2 id="5-1-Properties概述"><a href="#5-1-Properties概述" class="headerlink" title="5.1 Properties概述"></a>5.1 Properties概述</h2><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public Properties()</code> :创建一个空的属性列表。</p><h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li><li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          System.out.println(key+<span class="string">&quot; -- &quot;</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure><h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><p><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</p><p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。现在文本数据格式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename=Properties.txt</span><br><span class="line">length=<span class="number">123</span></span><br><span class="line">location=C:\Properties.txt</span><br></pre></td></tr></table></figure><p>加载代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Properties.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          System.out.println(key+<span class="string">&quot; -- &quot;</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- Properties.txt</span><br><span class="line">length -- <span class="number">123</span></span><br><span class="line">location -- C:\Properties.txt</span><br></pre></td></tr></table></figure><blockquote><p>文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解之@Import注解的三种使用方式</title>
      <link href="2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、-Import注解须知"><a href="#1、-Import注解须知" class="headerlink" title="1、@Import注解须知"></a>1、@Import注解须知</h2><blockquote><p>1、**@Import只能用在类上** ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中</p><p>2、加入IOC容器的方式有很多种，@Import注解就相对很牛皮了，**@Import注解可以用于导入第三方包** ，当然@Bean注解也可以，但是@Import注解快速导入的方式更加便捷</p><p>3、@Import注解有三种用法</p></blockquote><h2 id="2、-Import的三种用法"><a href="#2、-Import的三种用法" class="headerlink" title="2、@Import的三种用法"></a>2、@Import的三种用法</h2><p>@Import的三种用法主要包括：</p><blockquote><p>1、直接填class数组方式<br>2、ImportSelector方式【重点】<br>3、ImportBeanDefinitionRegistrar方式</p></blockquote><h4 id="2-1、第一种用法：直接填class数组"><a href="#2-1、第一种用法：直接填class数组" class="headerlink" title="2.1、第一种用法：直接填class数组"></a>2.1、第一种用法：直接填class数组</h4><p><strong>直接填对应的class数组，class数组可以有0到多个。</strong></p><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123; 类名.class , 类名.class... &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的import的bean都将加入到spring容器中，这些在容器中bean名称是该类的<strong>全类名</strong> ，比如com.yc.类名</p><h4 id="2-2、第二种用法：ImportSelector方式【重点】"><a href="#2-2、第二种用法：ImportSelector方式【重点】" class="headerlink" title="2.2、第二种用法：ImportSelector方式【重点】"></a>2.2、第二种用法：ImportSelector方式【重点】</h4><p>这种方式的前提就是一个类要实现ImportSelector接口，假如我要用这种方法，目标对象是Myclass这个类，分析具体如下：</p><p>创建Myclass类并实现ImportSelector接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"><span class="comment">//既然是接口肯定要实现这个接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析实现接口的selectImports方法中的：</p><ul><li>1、返回值： 就是我们实际上要导入到容器中的组件全类名【<strong>重点</strong> 】</li><li>2、参数： AnnotationMetadata表示当前被@Import注解给标注的所有注解信息【不是重点】</li></ul><blockquote><p>需要注意的是selectImports方法可以返回空数组但是不能返回null，否则会报空指针异常！</p></blockquote><p>以上分析完毕之后，具体用法步骤如下：</p><p>第一步：创建Myclass类并实现ImportSelector接口，这里用于演示就添加一个全类名给其返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> <span class="title">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span>[] <span class="function"><span class="title">selectImports</span>(<span class="params">AnnotationMetadata annotationMetadata</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">&quot;com.yc.Test.TestDemo3&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：编写TestDemo 类，并标注上使用ImportSelector方式的Myclass类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;TestDemo2.class,Myclass.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AccountDao2 <span class="title">accountDao2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AccountDao2();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，宜春故意挑了个龙套角色@Bean注解，若对@Bean注解不是很清晰的童鞋可以参考<a href="https://blog.csdn.net/qq_44543508/article/details/103718958">大白话讲解Spring的@bean注解</a></p><p>第三步：编写打印容器中的组件测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印容器中的组件测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext=<span class="keyword">new</span> AnnotationConfigApplicationContext(TestDemo.class);  <span class="comment">//这里的参数代表要做操作的类</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : beanDefinitionNames)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：运行结果<br><img src="/2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/20191227145414510.png" alt="在这里插入图片描述"></p><h4 id="2-3、第三种用法：ImportBeanDefinitionRegistrar方式"><a href="#2-3、第三种用法：ImportBeanDefinitionRegistrar方式" class="headerlink" title="2.3、第三种用法：ImportBeanDefinitionRegistrar方式"></a>2.3、第三种用法：ImportBeanDefinitionRegistrar方式</h4><p>同样是一个接口，类似于第二种ImportSelector用法，相似度80%，只不过这种用法比较自定义化注册，具体如下：</p><p>第一步：创建Myclass2类并实现ImportBeanDefinitionRegistrar接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass2</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="comment">//该实现方法默认为空</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数分析：</p><ul><li>第一个参数：annotationMetadata 和之前的ImportSelector参数一样都是表示当前被@Import注解给标注的所有注解信息</li><li>第二个参数表示用于注册定义一个bean</li></ul><p>第二步：编写代码，自定义注册bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass2</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定bean定义信息（包括bean的类型、作用域...）</span></span><br><span class="line">        RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(TestDemo4.class);</span><br><span class="line">        <span class="comment">//注册一个bean指定bean名字（id）</span></span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">&quot;TestDemo4444&quot;</span>,rootBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：编写TestDemo 类，并标注上使用ImportBeanDefinitionRegistrar方式的Myclass2类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;TestDemo2.class,Myclass.class,Myclass2.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AccountDao2 <span class="title">accountDao222</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AccountDao2();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：运行结果<br><img src="/2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/2019122715572214.png" alt="在这里插入图片描述"></p><h2 id="3、-Import注解的三种使用方式总结"><a href="#3、-Import注解的三种使用方式总结" class="headerlink" title="3、@Import注解的三种使用方式总结"></a>3、@Import注解的三种使用方式总结</h2><blockquote><p>第一种用法：<code>@Import</code>（{ 要导入的容器中的组件 } ）：容器会自动注册这个组件，<strong>id默认是全类名</strong></p><p>第二种用法：<code>ImportSelector</code>：返回需要导入的组件的全类名数组，springboot底层用的特别多【<strong>重点</strong> 】</p><p>第三种用法：<code>ImportBeanDefinitionRegistrar</code>：手动注册bean到容器</p></blockquote><p><strong>以上三种用法方式皆可混合在一个@Import中使用，特别注意第一种和第二种都是以全类名的方式注册，而第三中可自定义方式。</strong></p><p>@Import注解本身在springboot中用的很多，特别是其中的第二种用法ImportSelector方式在springboot中使用的特别多，尤其要掌握！</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring生态简介</title>
      <link href="2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/"/>
      <url>2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="http://www.cnblogs.com/nuccch/">2Simple</a><br>出处：<a href="http://www.cnblogs.com/nuccch/">http://www.cnblogs.com/nuccch/</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>做Java开发的人一提起Spring，首先在脑海中浮现出的就是“IoC”，“AOP”，“Spring MVC”，“Spring Security”等等这些名词，甚至大有“无Spring不Java”的感慨。<br>实际上，时至今日Spring已不再是一个简单的编程框架了，从最初的“SSH框架”发展到今天，Struts和Hibernate都几乎快要从程序员视野中消失了，而Spring却发展成了一个非常庞大且完整的生态。<br>所以说，除非特别指明是Spring生态中的某个具体框架，否则提起“Spring”应该指的是整个Spring生态。<br>说句不夸张的话，Java程序员只要精通了Spring，也就掌握了Java开发的精髓。</p><p>在整个Spring生态中包含了许多应用在特定场景的具体框架，如：“Spring Framework”，“Spring Security”，“Spring Boot”，“Spring Cloud”等等，其中“Spring Framework”框架是整个生态的核心基础，其他框架都需要依赖“Spring Framework”提供的基础功能，而且每个框架都有自己独立的代码仓库。</p><h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p>Spring生态下的项目分为3类：主要项目（Main Projects），社区项目（Community Projects），已经终止但是目前还保留的项目（Projects in the Attic）。<br>最新的Spring生态项目列表详见：<a href="https://spring.io/projects">https://spring.io/projects</a> 。</p><h3 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h3><p>目前，Spring生态中包含22个主要活跃的项目。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014708455-34471552.png" alt="Spring生态主要项目"></p><p><strong>1.Spring Framework</strong></p><p>Spring Framework项目是整个Spring生态的基础，包含了Spring最核心的功能，如：IoC，AOP，Spring MVC等，其他项目都需要依赖Spring Framework。<br>另外，还<strong>需要注意</strong>的是Spring Framework项目又包含多个子模块，如：spring-core，spring-beans，spring-context，spring-aop，spring-web，spring-webmvc等等。实际上，Spring Framework项目是一个模块化的架构，各模块之间又存在依赖关系。我们在Java Web后台项目中使用得最多的Spring MVC实际上就是模块spring-webmvc，它与其他模块的依赖关系如下所示：<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014737034-413265330.png" alt="Spring MVC对其他模块的依赖关系"></p><p>显然，<code>spring-webmvc</code>模块依赖<code>spring-context</code>，<code>spring-aop</code>和<code>spring-web</code>。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014801760-484921515.png" alt="spring-webmvc模块的依赖关系"></p><p><strong>2.Spring Boot</strong></p><p>Spring Boot是一个开发基于Spring的脚手架项目，它默认集成了嵌入式Tomcat，配置注解化，支持快速集成第三方开发组件（如MyBatis），大大降低了使用Spring的门槛，而且内置了许多可以直接用于生产环境的功能，是目前用于开发微服务架构项目的不二选择。<br><strong>值得注意的是：</strong> 许多人刚接触Spring Boot的人把它神话了，固然使用Spring Boot能快速开发一个健壮的、可直接运行的项目，但是它的核心和基础来源于Spring Framework。对于重度依赖Spring的开发人员，应该先去吃透Spring Framework，只要真正掌握了Spring Framework中各个模块的实现原理，对于在实际开发中使用Spring Boot遇到的问题也就迎刃而解了。</p><p><strong>3.Spring Cloud</strong></p><p>Spring Cloud为开发基于微服务架构的软件系统提供了一整套工具集合，其中包含了开发各个微服务组件的具体项目，如：Spring Cloud Config（配置中心），Spring Cloud Netflix（服务注册中心），Spring Cloud Sleuth（服务调用监控），Spring Cloud Gateway（服务网关）等等。<br>Spring Cloud的基础是Spring Boot，基于Spring Boot可以大大简化开发各微服务组件的流程。</p><p><strong>4.Spring Cloud Data Flow</strong></p><p>Spring Cloud Data Flow用于构建在云环境或K8S中基于微服务的实时或批数据处理架构，具体来讲就是支持一系列需要进行数据处理的场景，如：ETL，数据导入/导出，事件流，预测分析等等。</p><p><strong>5.Spring Data</strong></p><p>Spring Data旨在提供一套基于Spring编程模型的数据访问API，是一个数据访问框架集合，其中包含了多个具体的支持不同方式访问特定数据库类型的子模块，如：Spring Data JDBC（使用JDBC方式访问关系型数据库），Spring Data MongoDB（访问MongoDB数据库）等。<br>这个模块的功能类似于<a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis</a>这样的专门的ORM框架，在实际开发中可以根据需求进行灵活选择。</p><p><strong>6.Spring Integration</strong></p><p>Spring Integration的目的是提供一个简单的模型，用于构建企业级应用集成解决方案。</p><p><strong>7.Spring Batch</strong></p><p>Spring Batch是一个轻量级的批处理框架，旨在开发对企业系统日常运营至关重要的强大批处理应用程序。<br>支持事务管理，提供了基于Web的管理接口。</p><p><strong>8.Spring Security</strong></p><p>Spring Security是用于实现认证和授权，以及访问控制的安全框架，在Java生态与之提供类似的功能还有一个框架：<a href="https://shiro.apache.org/">Apache Shiro</a>。<br>Spring Security依赖于Spring Framework，也就是说如果要Spring Security，那么应用架构也必须是基于Spring Framework的，这大大限制了Spring Security的使用场景；反之，Shiro就没有这样限制，而且从项目架构上Shiro更加简洁。当然，Spring Security提供了非常丰富的安全控制的功能，在某些方面甚至比Shiro更加完善，与之对应的是掌握的Spring Security的复杂度比较大。因此，对于在应用中是否选择Spring Security需要根据实际需求来决定。</p><p><strong>9.Spring HATEOAS</strong></p><p>如果Web应用基于Spring框架（即：使用了Spring MVC）开发，那么可以直接使用<code>Spring HATEOAS</code>来开发满足<code>HATEOAS</code>约束的RESTFul服务。<br>这里需要理解一个单词简写：“HATEOAS”。HATEOAS（Hypermedia as the engine of application state）是REST架构风格中最复杂的约束，也是构建成熟REST服务的核心。它的重要性在于打破了客户端和服务器之间严格的契约，使得客户端可以更加智能和自适应，而 REST 服务本身的演化和更新也变得更加容易。</p><p><strong>10.Spring REST Docs</strong></p><p>Spring REST Docs是一个文档工具，用于为REST架构风格的Web服务自动生成相应的文档，这样可以解放开发者专门撰写API文档的工作。</p><p><strong>11.Spring AMQP</strong></p><p>Spring AMQP项目旨在将核心的Spring概念应用于基于AMQP的消息传递解决方案的开发中，它提供了一个“模板”的抽象用于发送和接收消息。</p><p><strong>12.Spring Mobile</strong></p><p>Spring Mobile是对Spring MVC的扩展，旨在简化移动Web应用的开发。<br>Spring Mobile可以检测出当前请求使用的设备是PC、还是手机或者是平板以及用户设备是安卓平台还是iOS平台，然后根据请求设备的不同，返回适合该设备的视图。</p><p><strong>13.Spring For Android</strong></p><p>虽然官方的说法是Spring For Android旨在简化原声Android应用的开发，但其实这个有点太过于牵强。<br>Spring For Android提供了2个对原生Android应用开发的支持：<br>(1)提供了一个REST客户端<br>(2)支持访问安全API时的认证</p><p><strong>14.Spring Web Flow</strong></p><p>Spring Web Flow主要应用于需要在Web页面上创建引导用户执行类似“下一步”这样的基于流程的应用场景，该框架构建于Spring MVC之上。</p><p><strong>15.Spring Web Services</strong></p><p>Spring Web Services用于开发WebService服务，类似的框架如：<a href="https://cxf.apache.org/">Apache CXF</a>，<a href="http://axis.apache.org/axis2/java/core/">Apache Axis2</a>。</p><p><strong>16.Spring LDAP</strong></p><p>Spring LDAP是一个工具，用于为基于Spring的应用程序使用LDAP（Lightweight Directory Access Protocol）协议。</p><p><strong>17.Spring Session</strong></p><p>Spring Session提供了管理用户Session信息的API和对应实现，Spring Session使得支持集群会话变得简单，而不依赖于特定于应用程序容器的解决方案。<br>简单来讲，传统的Session方案依赖于特定的容器（如：Tomcat），Spring Session就是提供独立于特定容器的Session解决方案。<br>其实，针对Tomcat容器，Session集群化也有一个开源方案：<a href="https://github.com/jcoleman/tomcat-redis-session-manager">tomcat-redis-session-manager</a>。</p><p><strong>18.Spring Shell</strong></p><p>Spring Shell用于开发基于命令行交互的应用。</p><p><strong>19.Spring FLO</strong></p><p>Spring FLO是一个JavaScript类库，是Spring Cloud Data Flow中流构建器的基础。</p><p><strong>20.Spring Kafka</strong></p><p>Spring Kafka用于在Spring项目中与Kafka交互。</p><p><strong>21.Spring Statemachine</strong></p><p>Spring Statemachine是一个为开发人员在Spring项目中使用状态机的框架，帮助开发者简化状态机的开发过程，让状态机结构更加层次化。</p><p><strong>22.Spring IO Platform</strong></p><p>简单来说，Spring IO Platform是一个对项目依赖进行统一版本管理的工具。本质就是一个pom文件，它记录了Spring项目和其它第三方库对应的版本信息。</p><h3 id="社区项目"><a href="#社区项目" class="headerlink" title="社区项目"></a>社区项目</h3><p>社区项目目前只有2个：Spring ROO，Spring Scala。</p><p>1.Spring ROO：这是一个开发工具包，旨在快速构建一个Java应用。<br>2.Spring Scala：支持在Scala中使用Spring框架。</p><h3 id="保留项目"><a href="#保留项目" class="headerlink" title="保留项目"></a>保留项目</h3><p>某些项目已经终止了，但是仍然保留着，不必赘述。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>Spring是一个生态系统，提供许多有用的编程框架或工具集。<br>本文的目的不在于详细介绍Spring生态的每一个项目，而是通过一个全面的整理，对Spring生态有一个完整的认识，在实际中根据需要灵活选择对应的组件来使用即可。<br>可以明确的是，当下最为流行的Spring项目是这4个：<strong>Spring Framework</strong>，<strong>Spring Security</strong>，<strong>Spring Boot</strong>，<strong>Spring Cloud</strong>。<br>如下图所示，再次对Spring生态做一个概括性总结。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014836702-2034259504.png" alt="Spring生态概括"></p><p>【参考】<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-SpringHATEOAS/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-SpringHATEOAS/index.html</a> 使用 Spring HATEOAS 开发 REST 服务<br><a href="https://www.jianshu.com/p/f9024eb3f252">https://www.jianshu.com/p/f9024eb3f252</a> 使用Spring Mobile实现网站移动端适配及更换主题<br><a href="https://blog.csdn.net/csdn_xuexiaoqiang/article/details/65938744">https://blog.csdn.net/csdn_xuexiaoqiang/article/details/65938744</a> Spring学习笔记之Spring Web Flow<br><a href="https://www.hifreud.com/2015/02/27/08-spring-mvc-spring-web-service/">https://www.hifreud.com/2015/02/27/08-spring-mvc-spring-web-service/</a> Spring 使用笔记之(五) - Spring-ws实现基于契约优先的WebService<br><a href="https://www.ibm.com/developerworks/cn/web/wa-spring-session-architecture-and-design/index.html">https://www.ibm.com/developerworks/cn/web/wa-spring-session-architecture-and-design/index.html</a> 详解 Spring Session 架构与设计<br><a href="https://www.ibm.com/developerworks/cn/java/spring-shell-application/index.html">https://www.ibm.com/developerworks/cn/java/spring-shell-application/index.html</a> 使用 Spring Shell 开发 Java 命令行应用<br><a href="http://blog.didispace.com/spring-statemachine/">http://blog.didispace.com/spring-statemachine/</a> 使用Spring StateMachine框架实现状态机<br><a href="https://www.jianshu.com/p/dd0baba45f52">https://www.jianshu.com/p/dd0baba45f52</a> Spring IO Platform 简介<br><a href="https://segmentfault.com/a/1190000012743018">https://segmentfault.com/a/1190000012743018</a> Spring IO Platform项目的介绍和应用<br><a href="https://www.cnblogs.com/chenpi/p/6295855.html">https://www.cnblogs.com/chenpi/p/6295855.html</a> Spring IO Platform简介及示例</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-boot-admin配置属性详解</title>
      <link href="2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="client端配置属性详解"><a href="#client端配置属性详解" class="headerlink" title="client端配置属性详解"></a>client端配置属性详解</h2><p><strong>spring.boot.admin.client.enabled</strong>：是否启用springbootAdmin客户端，默认为true；<br><strong>spring.boot.admin.client.url</strong>：要注册的server端的url地址。如果要同时在多个server端口注册，则用逗号分隔各个server端的url地址；<br><strong>spring.boot.admin.client.api-path</strong>：默认值是instances。server端获取client信息的路径，默认情况下server通过访问/instances请求来获取到client端的信息。（client端向server端注册，注册成功后server端会给该client创建一个唯一的clientID值。当server端需要获取client的信息，比如health信息时，server端会发送<a href="http://111.11.11.1:8080/instances/clientID/actuator/health%E5%8D%B3%E5%8F%AF%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84http://111.11.11.1:8080%E6%98%AFclient%E6%89%80%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8Cinstances%E5%B0%B1%E6%98%AF%E8%AF%A5%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%EF%BC%89">http://111.11.11.1:8080/instances/clientID/actuator/health即可，这里的http://111.11.11.1:8080是client所在服务器的IP地址，instances就是该属性的值）</a></p><p><strong>spring.boot.admin.client.username</strong>：如果server端需要进行认证时，该属性用于配置用户名。<br><strong>spring.boot.admin.client.password</strong>：如果server端需要进行认证时，该属性用于配置密码。</p><p><strong>spring.boot.admin.client.period</strong>：注册时间间隔，单位是毫秒；默认值是10秒钟注册一次。（client通过持续不断地向server端进行注册来保持client端与server端的连接）</p><p><strong>spring.boot.admin.client.connect-timeout</strong>：注册连接超时时间，单位是毫秒，默认值是5秒。当client向server进行注册时，如果5秒钟没有注册完成则认为本次注册失败；</p><p><strong>spring.boot.admin.client.read-timeout</strong>：注册读取超时，单位是毫秒，默认值是5秒；</p><p><strong>spring.boot.admin.client.auto-registration</strong>：是否开启自动注册，默认值是true。</p><p><strong>spring.boot.admin.client.auto-deregistration</strong>：是否开启自动注销，默认值是null。如果服务端运行在云平台，默认值是true；</p><p><strong>spring.boot.admin.client.register-once</strong>：默认值为true。如果值为true的话，client只会在一个server端进行注册（按照spring.boot.admin.client.url中设置的server的顺序）。如果该server端宕机，会自动在下一个server端进行注册。如果该属性值为false，则会在所有的server端进行注册；</p><p><strong>spring.boot.admin.client.instance.management-url</strong>：注册的management-url，如果可用的url不同的话可以重写该值。如果不配置该属性的话，默认该属性值与management-base-url 和 management.context-path两个属性值有关。比如工程中该值为：managementUrl=<a href="http://192.168.200.165:8080/actuator%EF%BC%8C%E5%85%B6%E4%B8%AD[http://192.168.200.165:8080](http://192.168.200.165:8080/)%E4%B8%BAmanagement-base-url%EF%BC%8C/actuator%E6%98%AFmanagement.context-path%EF%BC%88%E8%AF%A5%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AFspring">http://192.168.200.165:8080/actuator，其中[http://192.168.200.165:8080](http://192.168.200.165:8080/)为management-base-url，/actuator是management.context-path（该属性值是spring</a> actuator的属性值）；</p><p><strong>spring.boot.admin.client.instance.management-base-url</strong>：用于计算management-url 的基本URL。该路径值在运行时进行获取并赋值给 base url。如果不配置该属性值的话，默认该属性值与management.port, service-url 以及server.servlet-path有关。比如工程中该值为<a href="http://192.168.200.165:8080/">http://192.168.200.165:8080，其中8080</a>端口是配置的获取actuator信息的端口。192.168.200.165是设置的service-url值，如果没有设置service-url的话，则为配置的server.servlet-path值（项目的启动路径）。</p><p><strong>spring.boot.admin.client.instance.health-url</strong>：注册的health-url地址，如果可用的url不同可以重写该值。如果不配置该属性的话，默认该属性值与management-url 以及endpoints.health.id有关。比如工程中该值为：healthUrl=<a href="http://192.168.200.165:8080/actuator/health%EF%BC%8C%E5%85%B6%E4%B8%ADhttp://192.168.200.165:8080/actuator%E6%98%AFmanagement-url%EF%BC%8Chealth%E6%98%AFendpoints.health.id%E3%80%82">http://192.168.200.165:8080/actuator/health，其中http://192.168.200.165:8080/actuator是management-url，health是endpoints.health.id。</a></p><p><strong>spring.boot.admin.client.instance.service-base-url</strong>：用于计算service-url 的基本URL。该路径值在运行时进行获取并赋值给 base url。如果不配置该属性值的话，默认该属性值与hostname, server.port有关。比如工程中该值为<a href="http://p-v-9:8080/">http://p-v-9:8080，其中8080</a>端口是配置的server.port。p-v-9是client所在服务器的hostname。</p><p><strong>spring.boot.admin.client.instance.service-url</strong>：注册的service-url值。如果不配置该属性值的话，基于 service-base-url 和 server.context-path进行赋值。比如工程中为<a href="http://p-v-9:8080/,%E5%85%B6%E4%B8%ADp-v-9%E6%98%AFbase-url%EF%BC%8C/%E6%98%AF%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%9A%84">http://p-v-9:8080/,其中p-v-9是base-url，/是工程配置的</a> server.context-path值。（这里要注意的是，当server端与client端不在同一台服务器上的时候，要配置该属性的值。如果不配置的话，server端就会根据默认的命名规则来配置该值，比如<a href="http://p-v-9:8080/%EF%BC%8C%E5%A6%82%E6%9E%9Cserver%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%80%BC%E6%9D%A5%E8%8E%B7%E5%8F%96client%E7%9A%84%E5%90%84%E7%A7%8D%E6%80%A7%E8%83%BD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%AF%9D%E6%98%AF%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%9A%84%EF%BC%89%EF%BC%9B">http://p-v-9:8080/，如果server使用这个值来获取client的各种性能信息的话是获取不到的）；</a></p><p><strong>spring.boot.admin.client.instance.name</strong>：客户端工程的名字。默认值是配置的spring.application.name的值，如果没有配置该属性的话，默认值是spring-boot-application；</p><p><strong>spring.boot.admin.client.instance.prefer-ip</strong>：是否使用注册的ip地址来取代上述各个url中hostname的值，默认值是false（也就是说默认情况下上述各个url中会使用hostname的值，比如我的电脑的hostname为p-v-9）。如果设置了server.address或management.address的话ip地址就是该值，如果没有设置这两个属性的话ip地址值是InetAddress.getLocalHost()的值。</p><p>*<em>spring.boot.admin.client.instance.metadata.**</em>：与该应用有关的元数据，以键值对的形式赋值。</p><h2 id="server端配置属性详解"><a href="#server端配置属性详解" class="headerlink" title="server端配置属性详解"></a>server端配置属性详解</h2><p>spring.boot.admin.context-path：server端的访问路径，默认是/。默认情况下server的访问地址是<a href="https://blog.csdn.net/">http://<strong>.</strong>.<strong>.</strong>:**/</a>,这里**.<strong>.</strong>.**:**是server所在服务器的ip地址。我们的工程设置该值是springbootAdmin，那么工程的server端访问地址是<a href="http://111.11.11.1:8000/springbootAdmin">http://111.11.11.1:8000/springbootAdmin</a>;</p><p><strong>spring.boot.admin.monitor.period</strong>:更新client端状态的时间间隔，单位是毫秒，默认值是10秒钟；</p><p><strong>spring.boot.admin.monitor.status-lifetime</strong>：client端状态的生命周期，该生命周期内不会更新client状态。单位是毫秒，默认值是10秒钟；</p><p><strong>spring.boot.admin.monitor.connect-timeout</strong>：查询client状态信息时的连接超时时间，单位是毫秒，默认是2秒（如果2秒内没有获取到client的状态信息，则认为连接已经断开）。</p><p><strong>spring.boot.admin.monitor.read-timeout</strong>：查询client状态信息时的读取超时时间，单位是毫秒，默认是2秒（如果2秒内没有获取到client的状态信息，则认为读取失败）。</p><p><strong>spring.boot.admin.metadata-keys-to-sanitize</strong>：要被过滤掉的元数据（当与正则表达式相匹配时，这些数据会在输出的json数据中过滤掉），默认值是”.<strong>password$”, “.*secret$”, “.*key$”, “.</strong>$token$”, “.<strong>credentials.</strong>“, “.*vcap_services$”；</p><p><strong>spring.boot.admin.probed-endpoints</strong>：要获取的client的端点信息，默认是”health”, “env”, “metrics”, “httptrace:trace”, “threaddump:dump”, “jolokia”, “info”, “logfile”, “refresh”, “flyway”, “liquibase”, “heapdump”, “loggers”, “auditevents”；</p><p><strong>spring.boot.admin.instance-proxy.ignored-headers</strong>：向client发起请求时不会被转发的headers信息，默认值是”Cookie”, “Set-Cookie”, “Authorization”；</p><p><strong>spring.boot.admin.ui.brand</strong>：在导航栏中显示的brand值，默认是”<img src="/2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/img/icon-spring-boot-admin.svg"><span>Spring Boot Admin</span>“；</p><p><strong>spring.boot.admin.ui.title</strong>：显示的页面标题，默认是”Spring Boot Admin”</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 监控 </tag>
            
            <tag> admin </tag>
            
            <tag> Actuator  </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-boot-admin简单使用</title>
      <link href="2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot Admin 用于监控基于 Spring Boot 的应用，它是在 Spring Boot Actuator 的基础上提供简洁的可视化 WEB UI。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Spring Boot Admin 提供了很多功能，如显示 name、id 和 version，显示在线状态，Loggers 的日志级别管理，Threads 线程管理，Environment 管理等。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>在 Spring Boot 项目中，Spring Boot Admin 作为 Server 端，其他的要被监控的应用作为 Client 端</p><h2 id="简单使用（Spring-Boot-项目）"><a href="#简单使用（Spring-Boot-项目）" class="headerlink" title="简单使用（Spring Boot 项目）"></a>简单使用（Spring Boot 项目）</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>代码配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootAdminApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8788</span></span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.boot.admin.client.url</span>: <span class="string">&quot;http://localhost:8788&quot;  </span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>: <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>以上的配置，就可以实现 Spring Boot 项目中 Spring Boot Admin 监控其他应用了。</p><h2 id="进阶使用（Spring-Cloud-项目）"><a href="#进阶使用（Spring-Cloud-项目）" class="headerlink" title="进阶使用（Spring Cloud 项目）"></a>进阶使用（Spring Cloud 项目）</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>此处使用Eureka,端口8761，暂不详解</p><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p><strong>pom配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>启动类配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootAdminApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Profile(&quot;insecure&quot;)</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityPermitAllConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.authorizeRequests().anyRequest().permitAll()<span class="comment">//</span></span><br><span class="line">                    .and().csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Profile(&quot;secure&quot;)</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecuritySecureConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String adminContextPath;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SecuritySecureConfig</span><span class="params">(AdminServerProperties adminServerProperties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.adminContextPath = adminServerProperties.getContextPath();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// @formatter:off</span></span><br><span class="line">            SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">            successHandler.setTargetUrlParameter(<span class="string">&quot;redirectTo&quot;</span>);</span><br><span class="line">            http.authorizeRequests()</span><br><span class="line">                    .antMatchers(adminContextPath + <span class="string">&quot;/assets/**&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(adminContextPath + <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">                    .anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin().loginPage(adminContextPath + <span class="string">&quot;/login&quot;</span>).successHandler(successHandler).and()</span><br><span class="line">                    .logout().logoutUrl(adminContextPath + <span class="string">&quot;/logout&quot;</span>).and()</span><br><span class="line">                    .httpBasic().and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">            <span class="comment">// @formatter:on</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-admin</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secure</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8788</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span>   </span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">leaseRenewalIntervalInSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">health-check-url-path:</span> <span class="string">/actuator/health</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registryFetchIntervalSeconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;EUREKA_SERVICE_URL:http://localhost:8761&#125;/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">insecure</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">secure</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">user.name:</span> <span class="string">&quot;user&quot;</span>         <span class="comment">#These two are needed so that the server</span></span><br><span class="line">      <span class="attr">user.password:</span> <span class="string">&quot;password&quot;</span> <span class="comment">#can access the protected client endpoints</span></span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>配置文件修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8281</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="comment"># 向每个注册中心注册</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/,http://localhost:8762/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-demo-service</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">      <span class="attr">health:</span></span><br><span class="line">        <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 监控 </tag>
            
            <tag> admin </tag>
            
            <tag> Actuator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-boot-amqp自动配置详解</title>
      <link href="2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMQ自动装配类：RabbitAutoConfiguration"><a href="#RabbitMQ自动装配类：RabbitAutoConfiguration" class="headerlink" title="RabbitMQ自动装配类：RabbitAutoConfiguration"></a>RabbitMQ自动装配类：RabbitAutoConfiguration</h2><p>1、@EnableConfigurationProperties启动配置文件RabbitProperties<br>2、@Import导入RabbitAnnotationDrivenConfiguration</p><h3 id="RabbitConnectionFactoryCreator静态内部类："><a href="#RabbitConnectionFactoryCreator静态内部类：" class="headerlink" title="RabbitConnectionFactoryCreator静态内部类："></a>RabbitConnectionFactoryCreator静态内部类：</h3><p>1、RabbitConnectionFactoryBean配置，创建ConnectionFactory对象，内部单例是<strong>com.rabbitmq.client.ConnectionFactory</strong><br>2、使用spring-rabbitmq的<strong>CachingConnectionFactory</strong>包装ConnectionFactory</p><h3 id="RabbitTemplateConfiguration静态内部类："><a href="#RabbitTemplateConfiguration静态内部类：" class="headerlink" title="RabbitTemplateConfiguration静态内部类："></a>RabbitTemplateConfiguration静态内部类：</h3><p>1、@Import(RabbitConnectionFactoryCreator.class)<br>2、RabbitTemplate(操作spring-amqp中的Message对象)<br>3、AmqpAdmin</p><h3 id="MessagingTemplateConfiguration静态内部类："><a href="#MessagingTemplateConfiguration静态内部类：" class="headerlink" title="MessagingTemplateConfiguration静态内部类："></a>MessagingTemplateConfiguration静态内部类：</h3><p>1、(@Import(RabbitTemplateConfiguration.class))<br>2、RabbitMessagingTemplate（操作spring-message中的Message对象，底层也是使用RabbitTemplate）</p><h2 id="RabbitAnnotationDrivenConfiguration注解驱动配置类"><a href="#RabbitAnnotationDrivenConfiguration注解驱动配置类" class="headerlink" title="RabbitAnnotationDrivenConfiguration注解驱动配置类"></a>RabbitAnnotationDrivenConfiguration注解驱动配置类</h2><p>1、<strong>EnableRabbitConfiguration</strong>静态内部类（**@EnableRabbit**）<br>2、SimpleRabbitListenerContainerFactoryConfigurer配置，创建SimpleRabbitListenerContainerFactoryConfigurer<br>3、SimpleRabbitListenerContainerFactory（默认，spring.rabbitmq.listener.type=simple）通过configure方法配置SimpleRabbitListenerContainerFactory工厂对象的属性<br>4、DirectRabbitListenerContainerFactoryConfigurer配置，创建DirectRabbitListenerContainerFactoryConfigurer<br>5、DirectRabbitListenerContainerFactory(spring.rabbitmq.listener.type=direct,只能存在一个)通过configure方法配置DirectRabbitListenerContainerFactory工厂对象的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function">DirectRabbitListenerContainerFactoryConfigurer <span class="title">directRabbitListenerContainerFactoryConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactoryConfigurer configurer = <span class="keyword">new</span> DirectRabbitListenerContainerFactoryConfigurer();</span><br><span class="line">    configurer.setMessageConverter(<span class="keyword">this</span>.messageConverter.getIfUnique());</span><br><span class="line">    configurer.setMessageRecoverer(<span class="keyword">this</span>.messageRecoverer.getIfUnique());</span><br><span class="line">    configurer.setRetryTemplateCustomizers(</span><br><span class="line">        <span class="keyword">this</span>.retryTemplateCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">    configurer.setRabbitProperties(<span class="keyword">this</span>.properties);</span><br><span class="line">    <span class="keyword">return</span> configurer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean(name = &quot;rabbitListenerContainerFactory&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;rabbitListenerContainerFactory&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.rabbitmq.listener&quot;, name = &quot;type&quot;, havingValue = &quot;direct&quot;)</span></span><br><span class="line"><span class="function">DirectRabbitListenerContainerFactory <span class="title">directRabbitListenerContainerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DirectRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactory factory = <span class="keyword">new</span> DirectRabbitListenerContainerFactory();</span><br><span class="line">    <span class="comment">//为ListenerContainerFactory配置属性</span></span><br><span class="line">    configurer.configure(factory, connectionFactory);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象的RabbitListenerContainerFactory 公用参数使用</span></span><br><span class="line">AbstractRabbitListenerContainerFactory&lt;C extends AbstractMessageListenerContainer&gt;</span><br><span class="line">  implements RabbitListenerContainerFactory&lt;C&gt;, ApplicationContextAware, ApplicationEventPublisherAware</span><br><span class="line"><span class="comment">//使用模板方法创建ListenerContainer  -》注册的时候使用-&gt;创建ListenerContainer    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> C <span class="title">createListenerContainer</span><span class="params">(RabbitListenerEndpoint endpoint)</span> </span>&#123;</span><br><span class="line">    C instance = createContainerInstance();</span><br><span class="line">    <span class="comment">//... 设置公用参数</span></span><br><span class="line">    <span class="comment">//初始化实例，设置不同容器的不同配置参数</span></span><br><span class="line">    initializeContainer(instance, endpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnableRabbit注解类"><a href="#EnableRabbit注解类" class="headerlink" title="EnableRabbit注解类"></a>EnableRabbit注解类</h2><h3 id="Import-RabbitListenerConfigurationSelector-class"><a href="#Import-RabbitListenerConfigurationSelector-class" class="headerlink" title="@Import(RabbitListenerConfigurationSelector.class)"></a>@Import(RabbitListenerConfigurationSelector.class)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitListenerConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; RabbitBootstrapConfiguration.class.getName() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>selectImports方法，导入RabbitBootstrapConfiguration</p><h2 id="RabbitBootstrapConfiguration"><a href="#RabbitBootstrapConfiguration" class="headerlink" title="RabbitBootstrapConfiguration"></a>RabbitBootstrapConfiguration</h2><p>RabbitBootstrapConfiguration implements <strong>ImportBeanDefinitionRegistrar</strong>，用于注册BeanDefinition。</p><p>registerBeanDefinitions方法注册BeanDefinition<br>1、RabbitListenerAnnotationBeanPostProcessor<br>2、RabbitListenerEndpointRegistry</p><h2 id="RabbitListenerAnnotationBeanPostProcessor后置处理器"><a href="#RabbitListenerAnnotationBeanPostProcessor后置处理器" class="headerlink" title="RabbitListenerAnnotationBeanPostProcessor后置处理器"></a>RabbitListenerAnnotationBeanPostProcessor后置处理器</h2><p>主要实现了SmartInitializingSingleton，BeanPostProcessor接口，创建<strong>RabbitListenerEndpointRegistrar</strong> <strong>registrar</strong>成员变量，设置setBeanFactory</p><h4 id="afterSingletonsInstantiated方法"><a href="#afterSingletonsInstantiated方法" class="headerlink" title="afterSingletonsInstantiated方法"></a>afterSingletonsInstantiated方法</h4><p>1、**<font color="red">RabbitListenerConfigurer</font><strong>接口可以扩展，configurer.configureRabbitListeners(this.registrar);<br>2、this.registrar.setEndpointRegistry(this.endpointRegistry); 从容器中获取</strong>RabbitListenerEndpointRegistry<strong>对象<br>3、MessageHandlerMethodFactory handlerMethodFactory = this.registrar.getMessageHandlerMethodFactory();<br>4、</strong>this.registrar.afterPropertiesSet()**; //此时注册所有的Endpoints，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerAllEndpoints</span><span class="params">()</span> </span>&#123;   <span class="comment">//每个endpoint创建一个容器</span></span><br><span class="line">    <span class="comment">//通过endpoint注册监听容器</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AmqpListenerEndpointDescriptor descriptor : <span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.endpointRegistry.registerListenerContainer(<span class="comment">// NOSONAR never null</span></span><br><span class="line">                descriptor.endpoint, resolveContainerFactory(descriptor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.startImmediately = <span class="keyword">true</span>;  <span class="comment">// trigger immediate startup</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="postProcessAfterInitialization方法"><a href="#postProcessAfterInitialization方法" class="headerlink" title="postProcessAfterInitialization方法"></a>postProcessAfterInitialization方法</h4><p>1、Bean处理器，获取类、方法上的@RabbitListener，@RabbitHandler[处理不同content_type的消息]注解的元数据(方法上可使用@Payload String body, @Headers Map&lt;String,Object&gt; headers,@Header String token,Message message,String message)<br>2、processAmqpListener（）——&gt;处理RabbitListener的监听——&gt;MethodRabbitListenerEndpoint<br>3、processMultiMethodListeners==》处理RabbitHandler的监听——&gt;MultiMethodRabbitListenerEndpoint<br>4、生成MethodRabbitListenerEndpoint或者MultiMethodRabbitListenerEndpoint的实例Endpoint对象，Endpoint包含监听的相关信息（group，id,queue,exchange,相关执行方法）<br>5、最终：<strong>this.registrar.registerEndpoint(endpoint, factory);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AmqpListenerEndpointDescriptor descriptor = <span class="keyword">new</span> AmqpListenerEndpointDescriptor(endpoint, factory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.startImmediately) &#123; <span class="comment">// Register and start immediately  </span></span><br><span class="line">        <span class="keyword">this</span>.endpointRegistry.registerListenerContainer(descriptor.endpoint, <span class="comment">// NOSONAR never null</span></span><br><span class="line">                                                        resolveContainerFactory(descriptor), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.endpointDescriptors.add(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitListenerEndpointRegistry"><a href="#RabbitListenerEndpointRegistry" class="headerlink" title="RabbitListenerEndpointRegistry"></a>RabbitListenerEndpointRegistry</h2><p>主要实现了DisposableBean, SmartLifecycle接口，SmartLifecycle具有生命周期，负责创建MessageListenerContainer实例，并管理所有监听容器的启动与停止等。</p><p>RabbitListenerEndpointRegistry实例创建的MessageListenerContainer实例在其整个生命周期都是有状态的。<br>SimpleMessageListenerContainer的start()方法，负责创建消费者并启动对消息队列的监听。<br>SimpleMessageListenerContainer的stop()方法，负责销毁消费者并停止对消息队列的监听。</p><p><strong>registerListenerContainer</strong>方法， 注册监听的容器即创建监听容器<br>1、MessageListenerContainer container = createListenerContainer(endpoint, factory);<br>2、this.listenerContainers.put(id, container);<br>3、containerGroup.add(container);<br>4、startIfNecessary(MessageListenerContainer listenerContainer)——》<strong>listenerContainer.start();</strong></p><h2 id="MessageListenerContainer"><a href="#MessageListenerContainer" class="headerlink" title="MessageListenerContainer"></a>MessageListenerContainer</h2><img src="/2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/MessageListenerContainer.png" style="zoom: 67%;"><h3 id="AbstractMessageListenerContainer"><a href="#AbstractMessageListenerContainer" class="headerlink" title="AbstractMessageListenerContainer"></a>AbstractMessageListenerContainer</h3><p><strong>listenerContainer.start();</strong><br>1、configureAdminIfNeeded();<br>2、checkMismatchedQueues();<br>3、最后doStart();</p><p><strong>doStart();</strong><br>1、DirectMessageListenerContainer#doStart();<br>2、SimpleMessageListenerContainer#doStart();</p><h3 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Executor taskExecutor = <span class="keyword">new</span> SimpleAsyncTaskExecutor();</span><br><span class="line"><span class="comment">//容器开始</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> newConsumers = initializeConsumers();</span><br><span class="line">    Set&lt;AsyncMessageProcessingConsumer&gt; processors = <span class="keyword">new</span> HashSet&lt;AsyncMessageProcessingConsumer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (BlockingQueueConsumer consumer : <span class="keyword">this</span>.consumers) &#123;</span><br><span class="line">        AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">        processors.add(processor);</span><br><span class="line">        getTaskExecutor().execute(processor);</span><br><span class="line">        <span class="keyword">if</span> (getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    waitForConsumersToStart(processors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">receiveAndExecute</span><span class="params">(<span class="keyword">final</span> BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">// NOSONAR</span></span><br><span class="line">    PlatformTransactionManager transactionManager = getTransactionManager();</span><br><span class="line">    <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.transactionTemplate == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.transactionTemplate =</span><br><span class="line">                    <span class="keyword">new</span> TransactionTemplate(transactionManager, getTransactionAttribute());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.transactionTemplate</span><br><span class="line">                .execute(status -&gt; &#123; <span class="comment">// NOSONAR null never returned</span></span><br><span class="line">                    RabbitResourceHolder resourceHolder = ConnectionFactoryUtils.bindResourceToTransaction(</span><br><span class="line">                        <span class="keyword">new</span> RabbitResourceHolder(consumer.getChannel(), <span class="keyword">false</span>),</span><br><span class="line">                        getConnectionFactory(), <span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// unbound in ResourceHolderSynchronization.beforeCompletion()</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> doReceiveAndExecute(consumer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (RuntimeException e1) &#123;</span><br><span class="line">                        prepareHolderForRollback(resourceHolder, e1);</span><br><span class="line">                        <span class="keyword">throw</span> e1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> WrappedTransactionException(e2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (WrappedTransactionException e) &#123; <span class="comment">// NOSONAR exception flow control</span></span><br><span class="line">            <span class="keyword">throw</span> (Exception) e.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doReceiveAndExecute</span><span class="params">(BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//NOSONAR</span></span><br><span class="line">        Channel channel = consumer.getChannel();</span><br><span class="line">        List&lt;Message&gt; messages = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> deliveryTag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.batchSize; i++) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Waiting for message from consumer.&quot;</span>);</span><br><span class="line">            Message message = consumer.nextMessage(<span class="keyword">this</span>.receiveTimeout);</span><br><span class="line">            <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.consumerBatchEnabled) &#123;</span><br><span class="line">                Collection&lt;MessagePostProcessor&gt; afterReceivePostProcessors = getAfterReceivePostProcessors();</span><br><span class="line">                <span class="keyword">if</span> (afterReceivePostProcessors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Message original = message;</span><br><span class="line">                    deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">                    <span class="keyword">for</span> (MessagePostProcessor processor : getAfterReceivePostProcessors()) &#123;</span><br><span class="line">                        message = processor.postProcessMessage(message);</span><br><span class="line">                        <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.logger.debug(</span><br><span class="line">                                    <span class="string">&quot;Message Post Processor returned &#x27;null&#x27;, discarding message &quot;</span> + original);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (messages == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        messages = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.batchSize);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isDeBatchingEnabled() &amp;&amp; getBatchingStrategy().canDebatch(message.getMessageProperties())) &#123;</span><br><span class="line">                        <span class="keyword">final</span> List&lt;Message&gt; messageList = messages;</span><br><span class="line">                        getBatchingStrategy().deBatch(message, fragment -&gt; messageList.add(fragment));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        messages.add(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executeListener(channel, message);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (ImmediateAcknowledgeAmqpException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;User requested ack for failed delivery &#x27;&quot;</span></span><br><span class="line">                                          + e.getMessage() + <span class="string">&quot;&#x27;: &quot;</span></span><br><span class="line">                                          + message.getMessageProperties().getDeliveryTag());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.debug(<span class="string">&quot;User requested ack for failed delivery: &quot;</span></span><br><span class="line">                                              + message.getMessageProperties().getDeliveryTag());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (getTransactionManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getTransactionAttribute().rollbackOn(ex)) &#123;</span><br><span class="line">                            RabbitResourceHolder resourceHolder = (RabbitResourceHolder) TransactionSynchronizationManager</span><br><span class="line">                                .getResource(getConnectionFactory());</span><br><span class="line">                            <span class="keyword">if</span> (resourceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                consumer.clearDeliveryTags();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we don&#x27;t actually have a transaction, we have to roll back</span></span><br><span class="line"><span class="comment"> * manually. See prepareHolderForRollback().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">                                consumer.rollbackOnExceptionIfNecessary(ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">throw</span> ex; <span class="comment">// encompassing transaction will handle the rollback.</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.logger.debug(<span class="string">&quot;No rollback for &quot;</span> + ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        consumer.rollbackOnExceptionIfNecessary(ex);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.consumerBatchEnabled &amp;&amp; messages != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executeWithList(channel, messages, deliveryTag, consumer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> consumer.commitIfNecessary(isChannelLocallyTransacted());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、this.consumers = new HashSet<BlockingQueueConsumer>(this.concurrentConsumers);当前消费者数量<br>2、<strong>BlockingQueueConsumer</strong> consumer = createBlockingQueueConsumer();每个消费者处理预处理条数（prefetchCount，batchSize谁大选谁）<br>3、private final BlockingQueue<Delivery> queue =new <strong>LinkedBlockingQueue</strong><Delivery>(prefetchCount，batchSize谁大选谁); BlockingQueueConsumer 里的成员变量<br>3、循环生成<strong>AsyncMessageProcessingConsumer</strong> processor = new AsyncMessageProcessingConsumer(consumer); 私有线程内部类，实现<strong>Runnable</strong><br>4、getTaskExecutor().execute(processor); 线程池执行器执行线程</Delivery></Delivery></BlockingQueueConsumer></p><h4 id="BlockingQueueConsumer"><a href="#BlockingQueueConsumer" class="headerlink" title="BlockingQueueConsumer"></a>BlockingQueueConsumer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, InternalConsumer&gt; consumers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] queues; <span class="comment">//队列名称-》一个监听容器可以监听多个队列，会创建多个Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setQosAndreateConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.acknowledgeMode.isAutoAck() &amp;&amp; !cancelled()) &#123;</span><br><span class="line">        <span class="comment">// Set basicQos before calling basicConsume (otherwise if we are not acking the broker</span></span><br><span class="line">        <span class="comment">// will send blocks of 100 messages)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cancelled()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String queueName : <span class="keyword">this</span>.queues) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.missingQueues.contains(queueName)) &#123;</span><br><span class="line">                    consumeFromQueue(queueName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeFromQueue</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InternalConsumer consumer = <span class="keyword">new</span> InternalConsumer(<span class="keyword">this</span>.channel, queue);</span><br><span class="line">    String consumerTag = <span class="keyword">this</span>.channel.basicConsume(queue, <span class="keyword">this</span>.acknowledgeMode.isAutoAck(),</span><br><span class="line">                                                   (<span class="keyword">this</span>.tagStrategy != <span class="keyword">null</span> ?                        <span class="keyword">this</span>.tagStrategy.createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="keyword">this</span>.noLocal,</span><br><span class="line">                                                   <span class="keyword">this</span>.exclusive, <span class="keyword">this</span>.consumerArgs,</span><br><span class="line">                                                   consumer);</span><br><span class="line">    <span class="keyword">if</span> (consumerTag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.consumers.put(queue, consumer);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Started on queue &#x27;&quot;</span> + queue + <span class="string">&quot;&#x27; with tag &quot;</span> + consumerTag + <span class="string">&quot;: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Null consumer tag received for queue &quot;</span> + queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AsyncMessageProcessingConsumer"><a href="#AsyncMessageProcessingConsumer" class="headerlink" title="AsyncMessageProcessingConsumer"></a>AsyncMessageProcessingConsumer</h4><p>SimpleMessageListenerContainer内部类，实现了Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AsyncMessageProcessingConsumer(BlockingQueueConsumer consumer) &#123;</span><br><span class="line"><span class="keyword">this</span>.consumer = consumer;</span><br><span class="line"><span class="keyword">this</span>.start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// NOSONAR - complexity - many catch blocks</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、redeclareElementsIfNecessary();根据容器中的Queue、Exchange、Binding,在broker中创建</span></span><br><span class="line">    <span class="comment">//2、this.consumer.start();  调用BlockingQueueConsumer中start()。</span></span><br><span class="line">    <span class="comment">//passiveDeclarations();setQosAndreateConsumers();设置Qos</span></span><br><span class="line">    initialize(); </span><br><span class="line">    <span class="comment">//boolean receivedOk = receiveAndExecute(this.consumer);处理堵塞队列message</span></span><br><span class="line">    mainLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InternalConsumer"><a href="#InternalConsumer" class="headerlink" title="InternalConsumer"></a>InternalConsumer</h4><p>InternalConsumer 是BlockingQueueConsumer的私有内部类，继承com.rabbitmq.client.<strong>DefaultConsumer</strong>。handleDelivery方法会向BlockingQueueConsumer实例的成员变量queue中添加数据，等待消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">byte</span>[] body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Storing delivery for consumerTag: &#x27;&quot;</span></span><br><span class="line">                     + consumerTag + <span class="string">&quot;&#x27; with deliveryTag: &#x27;&quot;</span> + envelope.getDeliveryTag() + <span class="string">&quot;&#x27; in &quot;</span></span><br><span class="line">                     + BlockingQueueConsumer.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (BlockingQueueConsumer.<span class="keyword">this</span>.abortStarted &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!BlockingQueueConsumer.<span class="keyword">this</span>.queue.offer(</span><br><span class="line">                <span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body, <span class="keyword">this</span>.queueName),</span><br><span class="line">                BlockingQueueConsumer.<span class="keyword">this</span>.shutdownTimeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line"></span><br><span class="line">                Channel channelToClose = <span class="keyword">super</span>.getChannel();</span><br><span class="line">                RabbitUtils.setPhysicalCloseRequired(channelToClose, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// Defensive - should never happen</span></span><br><span class="line">                BlockingQueueConsumer.<span class="keyword">this</span>.queue.clear();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.canceled) &#123;</span><br><span class="line">                    RabbitUtils.cancel(channelToClose, consumerTag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channelToClose.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> TimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">// no-op</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//核心</span></span><br><span class="line">            BlockingQueueConsumer.<span class="keyword">this</span>.queue</span><br><span class="line">                .put(<span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body, <span class="keyword">this</span>.queueName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        BlockingQueueConsumer.logger.warn(<span class="string">&quot;Unexpected exception during delivery&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DerictMessaeListenerContainer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Executor taskExecutor = <span class="keyword">new</span> SimpleAsyncTaskExecutor();</span><br><span class="line"><span class="comment">//容器开始</span></span><br><span class="line">doStart()&#123;</span><br><span class="line">    actualStart();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真的开始，一个异步线程开始创建监听的Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">actualStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queueNames.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        doRedeclareElementsIfNecessary();</span><br><span class="line">        getTaskExecutor().execute(() -&gt; &#123; <span class="comment">// NOSONAR never null here</span></span><br><span class="line">            startConsumers(queueNames);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过监听的队列名称创建Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startConsumers</span><span class="params">(<span class="keyword">final</span> String[] queueNames)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String queue : queueNames) &#123;</span><br><span class="line">        consumeFromQueue(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更加配置的consumersPerQueue为每个队列创建对应数量的Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeFromQueue</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">    List&lt;SimpleConsumer&gt; list = <span class="keyword">this</span>.consumersByQueue.get(queue);</span><br><span class="line">    <span class="comment">// Possible race with setConsumersPerQueue and the task launched by start()</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.consumersPerQueue; i++) &#123;</span><br><span class="line">            doConsumeFromQueue(queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Consuemer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doConsumeFromQueue</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">    SimpleConsumer consumer = consume(queue, connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SimpleConsumer <span class="title">consume</span><span class="params">(String queue, Connection connection)</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    SimpleConsumer consumer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = connection.createChannel(isChannelTransacted());</span><br><span class="line">        channel.basicQos(getPrefetchCount());</span><br><span class="line">        consumer = <span class="keyword">new</span> SimpleConsumer(connection, channel, queue);</span><br><span class="line">        channel.queueDeclarePassive(queue);</span><br><span class="line">        consumer.consumerTag = channel.basicConsume(queue, getAcknowledgeMode().isAutoAck(),</span><br><span class="line">                                                    (getConsumerTagStrategy() != <span class="keyword">null</span></span><br><span class="line">                                                     ? getConsumerTagStrategy().createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="comment">// NOSONAR never null</span></span><br><span class="line">                                                    isNoLocal(), isExclusive(), getConsumerArguments(), consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AmqpApplicationContextClosedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AmqpConnectException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        RabbitUtils.closeChannel(channel);</span><br><span class="line">        RabbitUtils.closeConnection(connection);</span><br><span class="line"></span><br><span class="line">        consumer = handleConsumeException(queue, consumer, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二个消费者容器区别"><a href="#二个消费者容器区别" class="headerlink" title="二个消费者容器区别"></a>二个消费者容器区别</h2><p><img src="/2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/image-20201216160611728.png" alt="image-20201216160611728"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-boot-amqp配置原理解析</title>
      <link href="2020/12/14/Spring-boot-amqp%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/14/Spring-boot-amqp%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="CachingConnectionFactory"><a href="#CachingConnectionFactory" class="headerlink" title="CachingConnectionFactory"></a>CachingConnectionFactory</h2><p>连接工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">getCachingConnectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    factory.setAddresses(rabbitProperties.getAddresses());</span><br><span class="line">    factory.setUsername(rabbitProperties.getUsername());</span><br><span class="line">    factory.setPassword(rabbitProperties.getPassword());</span><br><span class="line">    factory.setVirtualHost(rabbitProperties.getVirtualHost());</span><br><span class="line">    factory.setPublisherConfirms(rabbitProperties.isPublisherConfirms());</span><br><span class="line">    factory.setPublisherReturns(rabbitProperties.isPublisherReturns());</span><br><span class="line">    factory.addChannelListener(rabbitChannelListener);</span><br><span class="line">    factory.addConnectionListener(rabbitConnectionListener);</span><br><span class="line">    factory.setRecoveryListener(rabbitRecoveryListener);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean(&quot;test-consumer-connection-factory&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">consumerCachingConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getCachingConnectionFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">cachingConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getCachingConnectionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在一个应用里面同时存在消费者和生产者时，为了<strong>避免消费者由于生产者阻塞而阻塞</strong>，需要特别注意：</p><ul><li>使用一个具有相同选项的单独CachingConnectionFactory实例—一个用于生产者，一个用于消费者</li><li>rabbitTemplate.setUsePublisherConnection(true);</li></ul><h2 id="RabbitTemplate"><a href="#RabbitTemplate" class="headerlink" title="RabbitTemplate"></a>RabbitTemplate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(CachingConnectionFactory factory)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;caching factory: &#123;&#125;&quot;</span>, factory.getChannelCacheSize());</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(factory);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(rabbitConfirmCallback);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当mandatory标志位设置为true时</span></span><br><span class="line"><span class="comment">         * 如果exchange根据自身类型和消息routingKey无法找到一个合适的queue存储消息</span></span><br><span class="line"><span class="comment">         * 那么broker会调用basic.return方法将消息返还给生产者</span></span><br><span class="line"><span class="comment">         * 当mandatory设置为false时，出现上述情况broker会直接将消息丢弃</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">    rabbitTemplate.setReturnCallback(rabbitReturnCallback);</span><br><span class="line">    <span class="comment">//使用单独的发送连接，避免生产者由于各种原因阻塞而导致消费者同样阻塞</span></span><br><span class="line">    rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfirmCallback：ConfirmCallback接口用于实现消息发送到RabbitMQ交换器后接收ack回调，不管是否到交换机都会进行回调<br>ReturnCallback：ReturnCallback接口用于实现消息发送到RabbitMQ交换器后，但无相应队列与交换器绑定时的回调，即无法消息从交换机中入相应队列的回调，如果成功入队列则不回调</p><h3 id="发送的消息中携带其它信息，如唯一值"><a href="#发送的消息中携带其它信息，如唯一值" class="headerlink" title="发送的消息中携带其它信息，如唯一值"></a>发送的消息中携带其它信息，如唯一值</h3><ul><li><p>可以使用header存放，使用MessagePostProcessor设置header属性</p></li><li><p>可以发送的时候携带CorrelationData对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData correlationData = <span class="keyword">new</span> CorrelationData();</span><br><span class="line">correlationData.setId(dataId);</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName, rountingKey, message, correlationData);</span><br></pre></td></tr></table></figure><p>从2.1版本开始，CorrelationData对象具有ListenableFuture，可用于获取结果，而不是在rabbitTemplate上使用ConfirmCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData cd1 = <span class="keyword">new</span> CorrelationData();</span><br><span class="line"><span class="keyword">this</span>.templateWithConfirmsEnabled.convertAndSend(<span class="string">&quot;exchange&quot;</span>, queue.getName(), <span class="string">&quot;foo&quot;</span>, cd1);</span><br><span class="line">assertTrue(cd1.getFuture().get(<span class="number">10</span>, TimeUnit.SECONDS).isAck());</span><br></pre></td></tr></table></figure></li></ul><h2 id="Message实体"><a href="#Message实体" class="headerlink" title="Message实体"></a>Message实体</h2><ul><li>Message包含属性：MessageProperties messageProperties包含属性：Map&lt;String, Object&gt; headers</li><li>Message包含属性：byte[] body</li><li>MessagePostProcessor 对Message进行处理</li></ul><h2 id="交换机队列绑定"><a href="#交换机队列绑定" class="headerlink" title="交换机队列绑定"></a>交换机队列绑定</h2><ul><li>通过rabbitAdmin进行创建交换机、队列及绑定key</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTopicExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建交换机，类型为topic, durable 参数表示是否持久化</span></span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> TopicExchange(<span class="string">&quot;test.topic&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// 创建队列 durable 参数表示是否持久化</span></span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">//链式写法</span></span><br><span class="line">    rabbitAdmin.declareBinding(</span><br><span class="line">        BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="keyword">false</span>)) <span class="comment">// 直接创建队列</span></span><br><span class="line">        .to(<span class="keyword">new</span> TopicExchange(<span class="string">&quot;test.topic&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)) <span class="comment">// 直接创建交换机，并建立关联关系</span></span><br><span class="line">        .with(<span class="string">&quot;routing_topic.*&quot;</span>) <span class="comment">// 指定路由 key</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createHeadersExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> HeadersExchange(<span class="string">&quot;test.headers&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.headers.queue&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;headers&quot;</span>);</span><br><span class="line">    Binding binding = BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.headers.queue&quot;</span>, <span class="keyword">false</span>))</span><br><span class="line">        .to(<span class="keyword">new</span> HeadersExchange(<span class="string">&quot;test.headers&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">        .whereAll(map).match();</span><br><span class="line">    rabbitAdmin.declareBinding(binding);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDirectExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue1&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue2&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareBinding(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue1&quot;</span>, <span class="keyword">false</span>)</span><br><span class="line">        ).to(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)).with(<span class="string">&quot;test.direct.routing&quot;</span>));</span><br><span class="line">    rabbitAdmin.declareBinding(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue2&quot;</span>, <span class="keyword">false</span>)</span><br><span class="line">        ).to(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)).with(<span class="string">&quot;test.direct.routing&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单方式即直接创建Bean即可，会帮助在broker上创建对应队列等<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">posThemeExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(posThemeExchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">posThemeQueueName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(posThemeQueueName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bindingPosThemeQueueName</span><span class="params">(FanoutExchange posThemeExchange,Queue posThemeQueueName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(posThemeQueueName).to(posThemeExchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//topic模式</span></span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.topic&quot;</span>, <span class="string">&quot;routing_topic.1&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message1&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.topic&quot;</span>, <span class="string">&quot;routing_topic.2&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message2&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br><span class="line"><span class="comment">//headers模式</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;headers&quot;</span>);</span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.headers&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message3&quot;</span>.getBytes(), messageProperties));</span><br><span class="line"><span class="comment">//direct模式</span></span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.direct&quot;</span>, <span class="string">&quot;test.direct.routing&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message4&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br></pre></td></tr></table></figure><h2 id="消息监听（监听的是队列）"><a href="#消息监听（监听的是队列）" class="headerlink" title="消息监听（监听的是队列）"></a>消息监听（监听的是队列）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(factory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="string">&quot;test.headers.queue&quot;</span>, <span class="string">&quot;test.direct.queue1&quot;</span>, <span class="string">&quot;test.direct.queue2&quot;</span>);</span><br><span class="line">    container.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到：&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleMessageListenerContainer和DirectMessageListenerContainer"><a href="#SimpleMessageListenerContainer和DirectMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer和DirectMessageListenerContainer"></a>SimpleMessageListenerContainer和DirectMessageListenerContainer</h2><p>在版本2.0之前的版本中，只有一种MessageListenerContainer—SimpleMessageListenerContainer;</p><p>2.0之后有第二个容器——DirectMessageListenerContainer</p><h4 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h4><p>默认情况下，侦听器容器将启动单个使用者，该使用者将从队列接收消息。控制并发性的属性concurrentConsumers，它只创建(固定的)将并发处理消息的使用者数量。还添加了一个新的属性maxConcurrentConsumers，容器将根据工作负载动态调整并发性。与四个附加属性一起工作:continutiveactivetrigger、startConsumerMinInterval、continutiveidletrigger、stopConsumerMinInterval。</p><p>在默认设置下，增加消费者的算法工作如下：</p><p>如果尚未到达maxConcurrentConsumers，并且已有的使用者连续10个周期处于活动状态，并且自上一个使用者启动以来至少已经过了10秒，那么将启动一个新的使用者。如果使用者在txSize *中接收到至少一条消息，则认为该使用者处于活动状态。</p><p>在默认设置下，减少消费者的算法工作如下:</p><p>如果有多个concurrentConsumers正在运行，并且某个consumer检测到10个连续超时(空闲)，并且上一个consumer至少在60秒之前停止，那么该consumer将停止。超时取决于receiveTimeout和txSize属性。如果使用者在txSize *中没有接收到任何消息，则认为它是空闲的。因此，在默认超时(1秒)和txSize为4的情况下，在40秒的空闲时间(4个超时对应1个空闲检测)之后将考虑停止使用者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">simpleRabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="comment">//初始化消费者数量</span></span><br><span class="line">    factory.setConcurrentConsumers(<span class="keyword">this</span>.concurrentConsumers);</span><br><span class="line">    <span class="comment">//最大消费者数量</span></span><br><span class="line">    factory.setMaxConcurrentConsumers(<span class="keyword">this</span>.maxConcurrentConsumers);</span><br><span class="line">    <span class="comment">//手动确认消息</span></span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">    factory.setErrorHandler(rabbitErrorHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DirectMessageListenerContainer"><a href="#DirectMessageListenerContainer" class="headerlink" title="DirectMessageListenerContainer"></a>DirectMessageListenerContainer</h4><p>使用DirectMessageListenerContainer，您需要确保ConnectionFactory配置了一个任务执行器，该执行器在使用该ConnectionFactory的所有侦听器容器中具有足够的线程来支持所需的并发性。默认连接池大小仅为5。</p><p>并发性基于配置的队列和consumersPerQueue。每个队列的每个使用者使用一个单独的通道，并发性由rabbit客户端库控制;默认情况下，它使用5个线程池;您可以配置taskExecutor来提供所需的最大并发性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectRabbitListenerContainerFactory <span class="title">directRabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactory factory = <span class="keyword">new</span> DirectRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="comment">//每个队列的消费者数量</span></span><br><span class="line">    factory.setConsumersPerQueue(<span class="keyword">this</span>.consumersPerQueue);</span><br><span class="line">    <span class="comment">//手动确认消息</span></span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">    factory.setErrorHandler(rabbitErrorHandler);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>SimpleMessageListenerContainer提供了以下特性，但DirectMessageListenerContainer不提供:</p><ul><li>txSize—使用SimpleMessageListenerContainer，您可以将其设置为控制事务中传递的消息数量和/或减少ack的数量，但这可能会导致失败后重复传递的数量增加。(与txSize和SimpleMessageListenerContainer一样，DirectMessageListenerContainer也有mesagesPerAck，可以用来减少ack，但不能用于事务—每个消息都在单独的事务中交付和打包)。</li><li>maxconcurrentconsumer和consumer伸缩间隔/触发器—DirectMessageListenerContainer中没有自动伸缩;但是，它允许您以编程方式更改consumersPerQueue属性，并相应地调整使用者。</li></ul><p>与SimpleMessageListenerContainer相比，DirectMessageListenerContainer有以下优点:</p><ul><li>在运行时添加和删除队列更有效;使用SimpleMessageListenerContainer，整个使用者线程重新启动(所有使用者取消并重新创建);对于DirectMessageListenerContainer，不受影响的使用者不会被取消。</li><li>避免了RabbitMQ客户机线程和使用者线程之间的上下文切换。</li><li>线程是跨使用者共享的，而不是为SimpleMessageListenerContainer中的每个使用者都有一个专用线程。但是，请参阅“线程和异步使用者”一节中有关连接工厂配置的重要说明。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yingziisme/category_8289776.html">RabbitMQ</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基础之事件监听</title>
      <link href="2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/"/>
      <url>2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.csdn.net/yingziisme">yingziisme</a></p><p>出处：<a href="https://blog.csdn.net/yingziisme/article/details/86418540">https://blog.csdn.net/yingziisme/article/details/86418540</a></p><h2 id="ChannelListener"><a href="#ChannelListener" class="headerlink" title="ChannelListener"></a>ChannelListener</h2><p>用于监听通道的创建和销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitChannelListener</span> <span class="keyword">implements</span> <span class="title">ChannelListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;======================onCreate channel: &#123;&#125;, transactional: &#123;&#125;&quot;</span>, channel, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可根据isHardError判断是channel断开还是connection断开</span></span><br><span class="line">        <span class="keyword">if</span>(signal.isHardError())&#123;</span><br><span class="line">            AMQImpl.Connection.Close close = (AMQImpl.Connection.Close) signal.getReason();</span><br><span class="line">            log.warn(<span class="string">&quot;=====================Connection onShutDown replyCode: &#123;&#125;, methodId: &#123;&#125;, classId: &#123;&#125;, replyText: &#123;&#125;&quot;</span>,</span><br><span class="line">                    close.getReplyCode(), close.getMethodId(), close.getClassId(), close.getReplyText());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            AMQImpl.Channel.Close close = (AMQImpl.Channel.Close) signal.getReason();</span><br><span class="line">            log.warn(<span class="string">&quot;=====================Channel onShutDown replyCode: &#123;&#125;, methodId: &#123;&#125;, classId: &#123;&#125;, replyText: &#123;&#125;&quot;</span>,</span><br><span class="line">                    close.getReplyCode(), close.getMethodId(), close.getClassId(), close.getReplyText());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConnectionListener"><a href="#ConnectionListener" class="headerlink" title="ConnectionListener"></a>ConnectionListener</h2><p>用于监听连接的创建和关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConnectionListener</span> <span class="keyword">implements</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onCreate: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onClose: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onShutDown: &#123;&#125;&quot;</span>, signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RecoveryListener"><a href="#RecoveryListener" class="headerlink" title="RecoveryListener"></a>RecoveryListener</h2><p>监听自动重连的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitRecoveryListener</span> <span class="keyword">implements</span> <span class="title">RecoveryListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecovery</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================handleRecovery: &#123;&#125;&quot;</span>, recoverable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecoveryStarted</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================handleRecoveryStarted: &#123;&#125;&quot;</span>, recoverable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockedListener"><a href="#BlockedListener" class="headerlink" title="BlockedListener"></a>BlockedListener</h2><p>监听连接阻塞情况的监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitBlockedListener</span> <span class="keyword">implements</span> <span class="title">BlockedListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBlocked</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;=========================connection blocked, reason: &#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUnblocked</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;==============================connection unblocked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="是在RabbitMQ-connection连接上的时候设置进去的"><a href="#是在RabbitMQ-connection连接上的时候设置进去的" class="headerlink" title="是在RabbitMQ connection连接上的时候设置进去的"></a>是在RabbitMQ connection连接上的时候设置进去的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConnectionListener</span> <span class="keyword">implements</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitBlockedListener rabbitBlockedListener;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onCreate: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">        connection.addBlockedListener(rabbitBlockedListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onClose: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onShutDown: &#123;&#125;&quot;</span>, signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，RabbitMQ的状态是这样的</p><p><img src="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/20190113143502400.jpg" alt="在这里插入图片描述"></p><h4 id="测试内存报警"><a href="#测试内存报警" class="headerlink" title="测试内存报警"></a>测试内存报警</h4><p>RabbitMQ内存报警水位是由vm_memory_high_watermark来控制的</p><p>在RabbitMQ使用 rabbitmqctl set_vm_memory_high_watermark 0.01</p><ul><li>设置内存报警的水位，当内存使用达到了该水位时，RabbitMQ将产生报警</li><li>可以通过rabbitmqctl status | grep vm_memory_high_watermark查看当前的水位设置，默认时0.4</li></ul><p>此时查看报警时的RabbitMQ的状态</p><p><img src="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/201901131435132.jpg" alt="在这里插入图片描述"></p><p>此时往RabbitMQ发送一条消息，将会收到BlockedListener的消息，且reason会提示具体的错误原因</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">49</span>:<span class="number">53.408</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : =========================connection blocked, reason:low on memory</span><br></pre></td></tr></table></figure><p>再将水位修改回来<br>rabbitmqctl set_vm_memory_high_watermark 0.4</p><p>查看此时的程序的打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">51</span>:<span class="number">40.386</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">2</span>:<span class="number">351</span>:<span class="number">40.396</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">51</span>:<span class="number">40.398</span>  INFO <span class="number">73408</span> --- [cTaskExecutor-<span class="number">4</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="测试磁盘报警"><a href="#测试磁盘报警" class="headerlink" title="测试磁盘报警"></a>测试磁盘报警</h4><p>同样的修改磁盘的配置rabbitmqctl set_disk_free_limit  48G</p><ul><li>设置空闲磁盘的大小，空闲值小于该值时产生报警，默认时48M</li><li>也可以使用这个命令将磁盘和内存的大小关联起来设置 xx时磁盘和内存的配比 rabbitmqctl set_disk_free_limit mem_relative xx</li></ul><p>此时查看RabbitMQ的控制台<br><img src="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/20190113143526140.jpg" alt="在这里插入图片描述"></p><p>此时往RabbitMQ发送一条消息，将会收到BlockedListener的消息，且reason会提示具体的错误原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-01-09 23:58:17.318  INFO 49240 --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;connection blocked, reason:low on disk</span><br></pre></td></tr></table></figure><p>再将磁盘限制修改回来rabbitmqctl set_disk_free_limit 48M</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.793</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.801</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.806</span>  INFO <span class="number">49240</span> --- [cTaskExecutor-<span class="number">3</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="测试同时报警"><a href="#测试同时报警" class="headerlink" title="测试同时报警"></a>测试同时报警</h4><p>同时设置内存和磁盘报警<br><img src="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/2019011314353976.jpg" alt="在这里插入图片描述"><br>发送消息到队列，则会在这个监听器产生报警信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">08.811</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : =========================connection blocked, reason:low on disk &amp; memory</span><br></pre></td></tr></table></figure><p>需要同时解除内存和磁盘的报警才会收到unblock的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">764</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">765</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">766</span>  INFO <span class="number">49240</span> --- [cTaskExecutor-<span class="number">2</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon源码解析</title>
      <link href="2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://www.cnblogs.com/trust-freedom/">Trust_FreeDom</a></p><p>出处：<a href="https://www.cnblogs.com/trust-freedom/p/11216280.html#3560239013">https://www.cnblogs.com/trust-freedom/p/11216280.html#3560239013</a></p><p>事情的起因是这样的，公司内部要实现基于Zuul网关的灰度路由，在上线时进行灰度测试，故需要配置业务微服务向Eureka注册的metadata元数据，和自定义Ribbon的负载规则达到只访问灰度服务的目的。这样就需要自定义Ribbon的IRule，实现灰度请求只会负载到带有灰度标签元数据的业务微服务上，当自定义IRule规则开发好后，问题是如何将这个IRule规则配置给某个Ribbon Client或者全局生效。</p><blockquote><p>本次使用Spring Cloud Dalston.SR5版本</p><p>在其 <a href="https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi_spring-cloud-ribbon.html">官方文档</a> 中其实已经给出了一些如何针对某个Client 或者 修改默认配置的方式，但没有说明为什么这样使用</p></blockquote><p>下面将按照这样的思路分析：</p><ul><li>简单分析Spring Cloud Ribbon启动时如何自动配置的，以了解其装配到Spring中的Bean</li><li>Spring Cloud Ribbon Client的懒加载</li><li>Spring Cloud Ribbon Client的配置加载，包含全局配置及Client配置</li><li>如何自定义Client配置、全局配置</li><li>解释官方文档中的一些注意事项<h2 id="Spring-Cloud-Ribbon自动配置"><a href="#Spring-Cloud-Ribbon自动配置" class="headerlink" title="Spring Cloud Ribbon自动配置"></a>Spring Cloud Ribbon自动配置</h2></li></ul><p>当前版本中的Netflix所有自动配置都在<code>spring-cloud-netflix-core-xxx.jar</code>中，根据其<code>META-INF/spring.factories</code>中的配置得知，Spring Cloud Ribbon的自动配置类为 <strong><code>RibbonAutoConfiguration</code></strong><br><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/677054-20190719235138006-1969052898.jpg" alt="img"></p><h2 id="RibbonAutoConfiguration"><a href="#RibbonAutoConfiguration" class="headerlink" title="RibbonAutoConfiguration"></a>RibbonAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; IClient.class, RestTemplate.class, AsyncRestTemplate.class, Ribbon.class&#125;)</span></span><br><span class="line"><span class="meta">@RibbonClients</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(name = &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RibbonEagerLoadProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有针对某个RibbonClient指定的配置</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ribbon是否懒加载的配置文件</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会给每个RibbonClient创建独立的ApplicationContext上下文</span></span><br><span class="line">    <span class="comment">// 并在其上下文中创建RibbonClient对应的Bean：如IClient、ILoadbalancer等</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring创建的带负载均衡功能的Client，会使用SpringClientFactory创建对应的Bean和配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(LoadBalancerClient.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(springClientFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到Spring environment中加载针对某个Client的Ribbon的核心接口实现类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertiesFactory <span class="title">propertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PropertiesFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是懒加载，启动时就使用RibbonApplicationContextInitializer加载并初始化客户端配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;ribbon.eager-load.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RibbonApplicationContextInitializer <span class="title">ribbonApplicationContextInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RibbonApplicationContextInitializer(springClientFactory(),</span><br><span class="line">ribbonEagerLoadProperties.getClients());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>RibbonAutoConfiguration</code>创建的Bean主要分以下几类：</p><ul><li>为Ribbon Client创建环境及获取配置<ul><li><strong>SpringClientFactory</strong>： 会给每个Ribbon Client创建一个独立的Spring应用上下文ApplicationContext，并在其中加载对应的配置及Ribbon核心接口的实现类</li><li><strong>PropertiesFactory</strong>： 用于从Spring enviroment环境中获取针对某个Ribbon Client配置的核心接口实现类，并实例化</li></ul></li><li>创建<code>RibbonLoadBalancerClient</code>，并将springClientFactory注入，方便从中获取对应的配置及实现类，<code>RibbonLoadBalancerClient</code>是Spring对<code>LoadBalancerClient</code>接口的实现类，其<code>execute()</code>方法提供客户端负载均衡能力</li><li>懒加载相关<ul><li>RibbonEagerLoadProperties： 懒加载配置项Properties，可以指定是否懒加载，及哪些Client不懒加载</li><li>RibbonApplicationContextInitializer： 启动时就加载RibbonClient配置（非懒加载）的初始化器</li></ul></li></ul><p>可以看到默认启动流程中并没有加载RibbonClient的上下文和配置信息，而是在使用时才加载，即懒加载</p><h2 id="Spring-Cloud-RibbonClient的懒加载"><a href="#Spring-Cloud-RibbonClient的懒加载" class="headerlink" title="Spring Cloud RibbonClient的懒加载"></a>Spring Cloud RibbonClient的懒加载</h2><p>既然是在使用时才会加载，那么以Zuul网关为例，在其<code>RibbonRoutingFilter</code>中会创建RibbonCommand，其包含了Ribbon的负载均衡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## RibbonRoutingFilter  Zuul负责路由的Filter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRoutingFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line"><span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RibbonCommandContext commandContext = buildCommandContext(context);</span><br><span class="line">ClientHttpResponse response = forward(commandContext);</span><br><span class="line">setResponse(response);</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ZuulException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">forward</span><span class="params">(RibbonCommandContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; info = <span class="keyword">this</span>.helper.debug(context.getMethod(),</span><br><span class="line">context.getUri(), context.getHeaders(), context.getParams(),</span><br><span class="line">context.getRequestEntity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ribbonCommandFactory创建RibbonCommand</span></span><br><span class="line">RibbonCommand command = <span class="keyword">this</span>.ribbonCommandFactory.create(context);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ClientHttpResponse response = command.execute();</span><br><span class="line"><span class="keyword">this</span>.helper.appendDebug(info, response.getStatusCode().value(),</span><br><span class="line">response.getHeaders());</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (HystrixRuntimeException ex) &#123;</span><br><span class="line"><span class="keyword">return</span> handleException(info, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行<code>RibbonRoutingFilter#run()</code>进行路由时会执行<code>forward()</code>方法，由于此处是在<strong>HystrixCommand</strong>内部执行Ribbon负载均衡调用，故使用ribbonCommandFactory创建RibbonCommand，Ribbon客户端的懒加载就在这个方法内，这里我们看<code>HttpClientRibbonCommandFactory</code>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.zuul.filters.route.apache.HttpClientRibbonCommandFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonCommandFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRibbonCommandFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpClientRibbonCommand <span class="title">create</span><span class="params">(<span class="keyword">final</span> RibbonCommandContext context)</span> </span>&#123;</span><br><span class="line">ZuulFallbackProvider zuulFallbackProvider = getFallbackProvider(context.getServiceId());</span><br><span class="line"><span class="keyword">final</span> String serviceId = context.getServiceId();</span><br><span class="line">        <span class="comment">// 通过SpringClientFactory获取IClient接口实例</span></span><br><span class="line"><span class="keyword">final</span> RibbonLoadBalancingHttpClient client = <span class="keyword">this</span>.clientFactory.getClient(</span><br><span class="line">serviceId, RibbonLoadBalancingHttpClient.class);</span><br><span class="line">client.setLoadBalancer(<span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommand(serviceId, client, context, zuulProperties, zuulFallbackProvider,</span><br><span class="line">clientFactory.getClientConfig(serviceId));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>RibbonLoadBalancingHttpClient</code>的逻辑在 <code>SpringClientFactory#getClient(serviceId, RibbonLoadBalancingHttpClient.class)</code>，如下：</p><ul><li>SpringClientFactory#getInstance(name, clientClass)<ul><li>NamedContextFactory#getInstance(name, type)：<ul><li>获取Client对应的ApplicationContext，如没有则调用createContext()创建，其中包含注册统一默认配置类RibbonClientConfiguration，或@RibbonClient、@RibbonClients(defaultConfiguration=xxx) 设置的配置类的逻辑</li><li>从ApplicationContext中根据类型获取实例，如没有使用反射创建，并通过IClientConfig配置</li></ul></li></ul></li></ul><p>如上执行完毕RibbonClient就基本懒加载完成了，就可以到RibbonClient对应的ApplicationContext中继续获取其它核心接口的实现类了，这些实现类都是根据 <strong>默认/全局/Client自定义</strong> 配置创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.SpringClientFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringClientFactory</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">RibbonClientSpecification</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String NAMESPACE = <span class="string">&quot;ribbon&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(RibbonClientConfiguration.class, NAMESPACE, <span class="string">&quot;ribbon.client.name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the rest client associated with the name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RuntimeException if any error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;C extends IClient&lt;?, ?&gt;&gt; <span class="function">C <span class="title">getClient</span><span class="params">(String name, Class&lt;C&gt; clientClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getInstance(name, clientClass);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// name代表当前Ribbon客户端，type代表要获取的实例类型，如IClient、IRule</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">getInstance</span><span class="params">(String name, Class&lt;C&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先从父类NamedContextFactory中直接从客户端对应的ApplicationContext中获取实例</span></span><br><span class="line">        <span class="comment">// 如果没有就根据IClientConfig中的配置找到具体的实现类，并通过反射初始化后放到Client对应的ApplicationContext中</span></span><br><span class="line">C instance = <span class="keyword">super</span>.getInstance(name, type);</span><br><span class="line"><span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">IClientConfig config = getInstance(name, IClientConfig.class);</span><br><span class="line"><span class="keyword">return</span> instantiateWithConfig(getContext(name), type, config);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用IClientConfig实例化</span></span><br><span class="line">    <span class="keyword">static</span> &lt;C&gt; <span class="function">C <span class="title">instantiateWithConfig</span><span class="params">(AnnotationConfigApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;C&gt; clazz, IClientConfig config)</span> </span>&#123;</span><br><span class="line">C result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过以IClientConfig为参数的构造创建clazz类实例</span></span><br><span class="line">Constructor&lt;C&gt; constructor = clazz.getConstructor(IClientConfig.class);</span><br><span class="line">result = constructor.newInstance(config);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="comment">// Ignored</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没创建成功，使用无惨构造</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">result = BeanUtils.instantiate(clazz);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用初始化配置方法</span></span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> IClientConfigAware) &#123;</span><br><span class="line">((IClientConfigAware) result).initWithNiwsConfig(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理自动织入</span></span><br><span class="line"><span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.getAutowireCapableBeanFactory().autowireBean(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//## 父类 org.springframework.cloud.context.named.NamedContextFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">// 维护Ribbon客户端对应的ApplicationContext上下文</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护Ribbon客户端的@Configuration配置类</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defaultConfigType;  <span class="comment">// 默认配置类为 RibbonClientConfiguration</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertySourceName;  <span class="comment">// 默认为 ribbon</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertyName;  <span class="comment">// 默认读取RibbonClient名的属性为ribbon.client.name</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamedContextFactory</span><span class="params">(Class&lt;?&gt; defaultConfigType, String propertySourceName,</span></span></span><br><span class="line"><span class="function"><span class="params">String propertyName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType = defaultConfigType;</span><br><span class="line"><span class="keyword">this</span>.propertySourceName = propertySourceName;</span><br><span class="line"><span class="keyword">this</span>.propertyName = propertyName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果包含Client上下文直接返回</span></span><br><span class="line"><span class="comment">// 如果不包含，调用createContext(name)，并放入contexts集合</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建名为name的RibbonClient的ApplicationContext上下文</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// configurations集合中是否包含当前Client相关配置类，包含即注入到ApplicationContext</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//configurations集合中是否包含default.开头的通过@RibbonClients(defaultConfiguration=xxx)配置的默认配置类</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册PropertyPlaceholderAutoConfiguration、RibbonClientConfiguration</span></span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType);</span><br><span class="line"><span class="comment">// 添加 ribbon.client.name=具体RibbonClient name的enviroment配置 </span></span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置父ApplicationContext，这样可以使得当前创建的子ApplicationContext可以使用父上下文中的Bean</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line">context.refresh();  <span class="comment">//刷新Context</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面比较重要的就是在创建每个RibbonClient的ApplicationContext的<code>createContext(name)</code>方法，其中包含了根据哪个@Configuration配置类创建Ribbon核心接口的实现类的逻辑，故需重点分析（Ribbon核心接口讲解 <a href="https://blog.csdn.net/zhxdick/article/details/79710960">参考</a>）</p><p>那么在<code>createContext(name)</code>方法创建当前Ribbon Client相关的上下文，并注入配置类时，除了默认配置类<code>RibbonClientConfiguration</code>是写死的，其它的配置类，如default全局配置类，针对某个Ribbon Client的配置类，又是怎么配置的呢？</p><h2 id="Spring-Cloud-RibbonClient的配置加载，包含全局配置及Client配置"><a href="#Spring-Cloud-RibbonClient的配置加载，包含全局配置及Client配置" class="headerlink" title="Spring Cloud RibbonClient的配置加载，包含全局配置及Client配置"></a>Spring Cloud RibbonClient的配置加载，包含全局配置及Client配置</h2><h2 id="创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类"><a href="#创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类" class="headerlink" title="创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类"></a>创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.context.named.NamedContextFactory#createContext()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、注册专门为RibbonClient指定的configuration配置类，@RibbonClient注解</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、将为所有RibbonClient的configuration配置类注册到ApplicationContext</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、注册defaultConfigType，即Spring的默认配置类 RibbonClientConfiguration</span></span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line">context.refresh();  <span class="comment">// 刷新上下文</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据如上逻辑可以看出会从3个地方将Ribbon相关的Configuration配置类注册到专门为其准备的ApplicationContext上下文，并根据配置类创建Ribbon核心接口的实现类，即达到配置RibbonClient的目的</p><ol><li>从configurations这个Map中根据RibbonClient name获取专门为其指定的configuration配置类，并注册到其对应的ApplicationContext上下文</li><li>从configurations这个Map中找到 <strong>default. 开头</strong> 的配置类，即为所有RibbonClient的默认配置，并注册到其对应的ApplicationContext上下文</li><li>如果不是开发者单独指定的话，前两项都是没有数据的，还会注册Spring Cloud的默认配置类<code>RibbonClientConfiguration</code></li></ol><p>那么configurations这个Map里的配置类数据是从哪儿来的呢？？下面逐步分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## RibbonAutoConfiguration</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是在RibbonAutoConfiguration自动配置类创建<code>SpringClientFactory</code>是设置的，这个configurations集合是@Autowired的Spring容器内的<code>RibbonClientSpecification</code>集合，那么<code>RibbonClientSpecification</code>集合是何时被注册的？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.RibbonClientConfigurationRegistrar</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfigurationRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、@RibbonClients注解</span></span><br><span class="line">Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(</span><br><span class="line">RibbonClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 1.1 value是RibbonClient[]，遍历针对具体的RibbonClient配置的configuration配置类，并注册</span></span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span> &amp;&amp; attrs.containsKey(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">AnnotationAttributes[] clients = (AnnotationAttributes[]) attrs.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes client : clients) &#123;</span><br><span class="line">registerClientConfiguration(registry, getClientName(client),</span><br><span class="line">client.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 1.2 找到@RibbonClients注解的defaultConfiguration，即默认配置</span></span><br><span class="line">        <span class="comment">//     注册成以default.Classname.RibbonClientSpecification为名的RibbonClientSpecification</span></span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span> &amp;&amp; attrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">&#125;</span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">attrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、@RibbonClient注解</span></span><br><span class="line">        <span class="comment">// 注册某个具体Ribbon Client的configuration配置类</span></span><br><span class="line">Map&lt;String, Object&gt; client = metadata.getAnnotationAttributes(</span><br><span class="line">RibbonClient.class.getName(), <span class="keyword">true</span>);</span><br><span class="line">String name = getClientName(client);</span><br><span class="line"><span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">registerClientConfiguration(registry, name, client.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(Map&lt;String, Object&gt; client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String value = (String) client.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(value)) &#123;</span><br><span class="line">value = (String) client.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">&quot;Either &#x27;name&#x27; or &#x27;value&#x27; must be provided in @RibbonClient&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">Object name, Object configuration)</span> </span>&#123;</span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(RibbonClientSpecification.class);</span><br><span class="line">builder.addConstructorArgValue(name);</span><br><span class="line">builder.addConstructorArgValue(configuration);</span><br><span class="line">registry.registerBeanDefinition(name + <span class="string">&quot;.RibbonClientSpecification&quot;</span>,</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可知，configurations配置类集合是根据<code>@RibbonClient</code> 和 <code>@RibbonClients</code> 注解配置的，分别有 <em>针对具体某个RibbonClient的配置</em> 和 <em>default默认配置</em></p><p>总结一下，Ribbon相关的@Configuration配置类是如何加载的</p><ol><li>在创建完RibbonClient对应的AnnotationConfigApplicationContext后，先从根据<code>@RibbonClient</code> 和 <code>@RibbonClients</code> 注解加载的configurations集合中找当前RibbonClient name对应的配置类，如有，就注册到上下文</li><li>再从configurations集合中找根据<code>@RibbonClients</code>注解加载的 <strong>default.开头</strong> 的默认配置类，如有，就注册到上下文</li><li>最后注册Spring Cloud默认的 <code>RibbonClientConfiguration</code></li></ol><p>上面说是如何创建RibbonClient相关的ApplicationContext上下文及注册Ribbon Client相关的配置类的逻辑，在确定配置类后，其中会用到Ribbon的<code>IClientConfig</code>相关的客户端配置来加载Ribbon客户端相关的配置信息，如超时配置、具体创建哪个核心接口的实现类等，可以从Spring Cloud默认注册的 <code>RibbonClientConfiguration</code>来一探究竟</p><h2 id="RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建"><a href="#RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建" class="headerlink" title="RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建"></a>RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration</span></span><br><span class="line"><span class="meta">@Import(&#123;OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;ribbon.client.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name = <span class="string">&quot;client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span></span><br><span class="line"><span class="comment">// associated with ribbon clients</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IClientConfig <span class="title">ribbonClientConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DefaultClientConfigImpl config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">config.loadProperties(<span class="keyword">this</span>.name);</span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">rule.initWithNiwsConfig(config);</span><br><span class="line"><span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只截取了一段代码，给出了Ribbon相关的 <code>IClientConfig</code>客户端配置 和 某一个核心接口<code>IRule</code>实现类 是如何加载配置并创建的</p><p><strong>IClientConfig</strong></p><p><code>IClientConfig</code>就是Ribbon客户端配置的接口，可以看到先是创建了<code>DefaultClientConfigImpl</code>默认实现类，再<code>config.loadProperties(this.name)</code>加载当前Client相关的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## com.netflix.client.config.DefaultClientConfigImpl#loadProperties()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load properties for a given client. It first loads the default values for all properties,</span></span><br><span class="line"><span class="comment"> * and any properties already defined with Archaius ConfigurationManager.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(String restClientName)</span></span>&#123;</span><br><span class="line">    enableDynamicProperties = <span class="keyword">true</span>;</span><br><span class="line">    setClientName(restClientName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、使用Netflix Archaius的ConfigurationManager从Spring env中加载“ribbon.配置项”这类默认配置</span></span><br><span class="line">    <span class="comment">//   如没加载到有默认静态配置</span></span><br><span class="line">    loadDefaultValues();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、使用Netflix Archaius的ConfigurationManager从Spring env中加载“client名.ribbon.配置项”这类针对某个Client的配置信息</span></span><br><span class="line">    Configuration props = ConfigurationManager.getConfigInstance().subset(restClientName);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;String&gt; keys = props.getKeys(); keys.hasNext(); )&#123;</span><br><span class="line">        String key = keys.next();</span><br><span class="line">        String prop = key;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prop.startsWith(getNameSpace()))&#123;</span><br><span class="line">                prop = prop.substring(getNameSpace().length() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setPropertyInternal(prop, getStringValue(props, key));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;Property %s is invalid&quot;</span>, prop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据如上注释，如果你没有在项目中指定ribbon相关配置，那么会使用<code>DefaultClientConfigImpl</code>中的默认静态配置，如果Spring enviroment中包含“ribbon.配置项”这类针对所有Client的配置会被加载进来，有“client名.ribbon.配置项”这类针对某个Client的配置信息也会被加载进来</p><p><strong>静态配置如下：</strong></p><p><a href="https://img2018.cnblogs.com/blog/677054/201907/677054-20190719235215286-1439271885.jpg"><img src="https://img2018.cnblogs.com/blog/677054/201907/677054-20190719235215286-1439271885.jpg" alt="img"></a></p><p><strong>RibbonClient核心接口实现类配置加载及创建</strong></p><p>上面说完<code>IClientCOnfig</code>配置项是如何加载的，按道理说其中已经包含了当前RibbonClient使用哪个核心接口实现类的配置，但Spring Cloud在此处定义了自己的实现逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看propertiesFactory是否有关于当前接口的配置，如有就使用，并创建实例返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spring cloud 默认配置</span></span><br><span class="line">ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">rule.initWithNiwsConfig(config);</span><br><span class="line"><span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看<code>PropertiesFactory</code>的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">PropertiesFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">classToProperty.put(ILoadBalancer.class, <span class="string">&quot;NFLoadBalancerClassName&quot;</span>);</span><br><span class="line">classToProperty.put(IPing.class, <span class="string">&quot;NFLoadBalancerPingClassName&quot;</span>);</span><br><span class="line">classToProperty.put(IRule.class, <span class="string">&quot;NFLoadBalancerRuleClassName&quot;</span>);</span><br><span class="line">classToProperty.put(ServerList.class, <span class="string">&quot;NIWSServerListClassName&quot;</span>);</span><br><span class="line">classToProperty.put(ServerListFilter.class, <span class="string">&quot;NIWSServerListFilterClassName&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看当前clazz是否在classToProperty管理的几个核心接口之一</span></span><br><span class="line">    <span class="comment">// 如是，查看Spring environment中是否能找到 “clientName.ribbon.核心接口配置项”的配置信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StringUtils.hasText(getClassName(clazz, name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">String classNameProperty = <span class="keyword">this</span>.classToProperty.get(clazz);</span><br><span class="line">String className = environment.getProperty(name + <span class="string">&quot;.&quot;</span> + NAMESPACE + <span class="string">&quot;.&quot;</span> + classNameProperty);</span><br><span class="line"><span class="keyword">return</span> className;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是先调用getClassName()获取Spring enviroment中配置的核心接口实现类名</span></span><br><span class="line">    <span class="comment">// 再使用IClientConfig配置信息创建其实例</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">get</span><span class="params">(Class&lt;C&gt; clazz, IClientConfig config, String name)</span> </span>&#123;</span><br><span class="line">String className = getClassName(clazz, name);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(className)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; toInstantiate = Class.forName(className);</span><br><span class="line"><span class="keyword">return</span> (C) instantiateWithConfig(toInstantiate, config);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown class to load &quot;</span>+className+<span class="string">&quot; for class &quot;</span> + clazz + <span class="string">&quot; named &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故以上面创建<code>IRule</code>接口实现类的逻辑</p><ul><li>先通过<strong>propertiesFactory</strong>查看Spring enviroment中是否配置了针对当前Ribbon Client的IRule核心接口实现类的配置信息，如有，就创建其实例返回（相关配置格式： clientName.ribbon.NFLoadBalancerRuleClassName=具体IRule实现类）</li><li>如没有，那么没有直接使用Netflix在其<code>DefaultClientConfigImpl</code>中的静态配置，而是使用Spring Cloud自定义的默认实现类，拿<code>IRule</code>规则接口来说是<code>ZoneAvoidanceRule</code></li></ul><blockquote><p><strong>总结：</strong></p><p>首先会创建RibbonClient的ApplicationContext上下文，并确定使用哪个Configuration配置类</p><p>1、@RibbonClients注册的全局默认配置类</p><p>2、@RibbonClient注册的某个Client配置类</p><p>3、Spring Cloud 默认的RibbonClientConfiguration配置类</p><p>确定配置类后就是加载Client相关的IClientConfig配置信息，并创建核心接口实现类</p><p>如果没有自定义全局/客户端配置类，那么就是使用<code>RibbonClientConfiguration</code>，而其规则是</p><p>对于超时等配置（除核心接口实现类以外）：使用Netflix的配置逻辑，通过 <strong>ribbon.xxx</strong> 作为默认配置，以 <strong>clientName.ribbon.xxx</strong> 作为客户端定制配置</p><p>对于核心接口实现类配置：客户端定制配置仍然使用 <strong>clientName.ribbon.xxx</strong>，但默认配置是Spring Cloud在<code>RibbonClientConfiguration</code>方法中写死的默认实现类</p></blockquote><p>已经知道大概的逻辑了，下面就看看具体如何自定义Client配置、全局配置</p><h2 id="如何自定义RibbonClient配置、全局配置"><a href="#如何自定义RibbonClient配置、全局配置" class="headerlink" title="如何自定义RibbonClient配置、全局配置"></a>如何自定义RibbonClient配置、全局配置</h2><p>这部分在Spring Cloud官方reference中有说明 <a href="https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi_spring-cloud-ribbon.html#_customizing_the_ribbon_client">16.2 Customizing the Ribbon Client</a></p><p><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/677054-20190719235233605-1701546833.jpg" alt="img"></p><p>大致意思如下：</p><ul><li><p>一部分配置（非核心接口实现类的配置）可以使用Netflix原生API提供的方式，即使用如 *<em>.ribbon.**</em> 的方式配置，具体有哪些配置项，可以参考 <code>com.netflix.client.config.CommonClientConfigKey</code></p></li><li><p>如果想比较全面的控制RibbonClient并添加一些额外配置，可以使用 <code>@RibbonClient</code> 或 <code>@RibbonClients</code> 注解，并配置一个配置类，如上的 FooConfiguration</p><ul><li><p>@RibbonClient(name = “foo”, configuration = FooConfiguration.class) 是针对名为 foo 的RibbonClient的配置类，也可以使用@RibbonClients({@RibbonClient数组}) 的形式给某几个RibbonClient设置配置类</p></li><li><p>@RibbonClients( defaultConfiguration = { xxx.class } ) 是针对所有RIbbonClient的默认配置</p><ul><li><p>官方文档说 FooConfiguration配置类 必须是@Configuration的，这样就必须注意，SpringBoot主启动类不能扫描到FooConfiguration，否则针对某个RibbonClient的配置就会变成全局的，原因是在创建每个RibbonClient时会为其创建ApplicationContext上下文，其parent就是主启动类创建的ApplicationContext，子ApplicationContext中可以使用父ApplicationContext中的Bean，且创建Bean时都使用了<code>@ConditionalOnMissingBean</code>，所以FooConfiguration如果被主启动类的上下文加载，且创建了比如IRule的实现类，在某个RIbbonClient创建其子ApplicationContext并@Bean想创建其自定义IRule实现类时，会发现parent ApplicationContext已经存在，就不会创建了，配置就失效了</p><blockquote><p>但在我的实验中，即使FooConfiguration不加@Configuration注解也可以加载为RibbonClient的配置，且由于没有@Configuration了，也不会被主启动类扫描到</p></blockquote></li></ul></li></ul></li></ul><p>所以主要分成2种配置：</p><p>（1）超时时间等静态配置，使用 <strong>ribbon.*** 配置所有Client，使用 *<em>.ribbon.</em></strong> 配置某个Client</p><p>（2）使用哪种核心接口实现类配置，使用**@RibbonClients注解<strong>做默认配置，使用</strong>@RibbonClient**做针对Client的配置（注意@Configuration不要被SpringBoot主启动类扫描到的问题）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-cloud-loadbalancer入门</title>
      <link href="2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://cloud.tencent.com/developer/user/1219867">冷冷</a></p><p>出处：<a href="https://cloud.tencent.com/developer/article/1491013">https://cloud.tencent.com/developer/article/1491013</a></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><strong>加入 loadbalancer pom坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置使用还是和 ribbon 一样配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LbConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://big-provider-server/demo&quot;</span>, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="LoadBalancerClient-实现"><a href="#LoadBalancerClient-实现" class="headerlink" title="LoadBalancerClient 实现"></a>LoadBalancerClient 实现</h3><p><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/1.jpeg"></p><ul><li>目前版本只提供了 BlockingLoadBalancerClient 的实现， 注意看中文注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除只保留了核心代码注意</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingLoadBalancerClient</span> <span class="keyword">implements</span> <span class="title">LoadBalancerClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 根据 服务名称去查询可用实例</span></span><br><span class="line">ServiceInstance serviceInstance = choose(serviceId);</span><br><span class="line"><span class="keyword">return</span> execute(serviceId, serviceInstance, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取负载均衡策略</span></span><br><span class="line">ReactiveLoadBalancer&lt;ServiceInstance&gt; loadBalancer = loadBalancerClientFactory</span><br><span class="line">.getInstance(serviceId);</span><br><span class="line"><span class="comment">// 执行负载均衡策略获取可以实例</span></span><br><span class="line">Response&lt;ServiceInstance&gt; loadBalancerResponse = Mono.from(loadBalancer.choose())</span><br><span class="line">.block();</span><br><span class="line"><span class="keyword">return</span> loadBalancerResponse.getServer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadBalancer-负载均衡策略实现"><a href="#loadBalancer-负载均衡策略实现" class="headerlink" title="loadBalancer 负载均衡策略实现"></a>loadBalancer <a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>策略实现</h3><p><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/2.jpeg">目前只有一个RoundRobinLoadBalancer 轮询选择server的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="title">implements</span> <span class="title">ReactorServiceInstanceLoadBalancer</span> </span>&#123;</span><br><span class="line">public Mono&lt;Response&lt;ServiceInstance&gt;&gt; <span class="function"><span class="title">choose</span>(<span class="params">Request request</span>)</span> &#123;</span><br><span class="line">ServiceInstanceSupplier supplier = <span class="built_in">this</span>.serviceInstanceSupplier.getIfAvailable();</span><br><span class="line"><span class="keyword">return</span> supplier.get().collectList().map(instances -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No servers available for service: &quot;</span> + <span class="built_in">this</span>.serviceId);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EmptyResponse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> enforce order?</span></span><br><span class="line">int pos = <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.position.incrementAndGet());</span><br><span class="line"></span><br><span class="line">ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultResponse(instance);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和ribbon-比较"><a href="#和ribbon-比较" class="headerlink" title="和ribbon 比较"></a>和ribbon 比较</h2><h3 id="默认负载均衡比较"><a href="#默认负载均衡比较" class="headerlink" title="默认负载均衡比较"></a>默认负载均衡比较</h3><ul><li><p>ribbon 提供7中默认的负载均衡策略，常见的常见都有覆盖，一般我们都是使用 ZoneAvoidanceRule复合判断server所在区域的性能和server的可用性选择server</p><p><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/3.jpeg"></p></li></ul><h3 id="配置方面丰富性"><a href="#配置方面丰富性" class="headerlink" title="配置方面丰富性"></a>配置方面丰富性</h3><ul><li><p>目前<code>spring-cloud-loadbalancer</code> 仅支持 重试操作的配置</p></li><li><p>ribbon 支持超时、懒加载处理、重试及其和 hystrix整合高级属性等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> loadbalancer </tag>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack的架构设计</title>
      <link href="2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/u/4376602">osc_s8zboupn</a></p><p>出处：<a href="https://my.oschina.net/u/4376602/blog/3542502">openstack：OpenStack架构详解</a></p><p>OpenStack既是一个社区，也是一个项目和一个开源软件，提供开放源码软件，建立公共和私有云，它提供了一个部署云的操作平台或工具集，其宗旨在于：帮助组织运行为虚拟计算或存储服务的云，为公有云、私有云，也为大云、小云提供可扩展的、灵活的云计算。<br>OpenStackd开源项目由社区维护，包括OpenStack计算（代号为Nova），OpenStack对象存储（代号为Swift），并OpenStack镜像服务（代号Glance）的集合。 OpenStack提供了一个操作平台，或工具包，用于编排云。</p><p>下面列出Openstack的详细构架图</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803154744809-483681990.png" alt="img"></p><p>Openstack的网络拓扑结构图</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803154957606-291369411.png" alt="img"></p><p>整个OpenStack是由控制节点，计算节点，网络节点，存储节点四大部分组成。（这四个节点也可以安装在一台机器上，单机部署）<br>其中：<br>控制节点负责对其余节点的控制，包含虚拟机建立，迁移，网络分配，存储分配等等<br>计算节点负责虚拟机运行<br>网络节点负责对外网络与内网络之间的通信<br>存储节点负责对虚拟机的额外存储管理等等</p><p>控制节点架构：</p><p>控制节点包括以下服务</p><p>  管理支持服务</p><p>  基础管理服务</p><p>  扩展管理服务</p><p>  1）管理支持服务包含MySQL与Qpid两个服务</p><p>MySQL：数据库作为基础/扩展服务产生的数据存放的地方</p><p>Qpid：消息代理(也称消息中间件)为其他各种服务之间提供了统一的消息通信服务</p><p>  2）基础管理服务包含Keystone，Glance，Nova，Neutron，Horizon五个服务</p><p>Keystone：认证管理服务，提供了其余所有组件的认证信息/令牌的管理，创建，修改等等，使用MySQL作为统一的数据库</p><p>Glance：镜像管理服务，提供了对虚拟机部署的时候所能提供的镜像的管理，包含镜像的导入，格式，以及制作相应的模板</p><p>Nova：计算管理服务，提供了对计算节点的Nova的管理，使用Nova-API进行通信</p><p>Neutron：网络管理服务，提供了对网络节点的网络拓扑管理，同时提供Neutron在Horizon的管理面板</p><p>Horizon：控制台服务，提供了以Web的形式对所有节点的所有服务的管理，通常把该服务称为DashBoard</p><p>  3）扩展管理服务包含Cinder，Swift，Trove，Heat，Centimeter五个服务</p><p>Cinder：提供管理存储节点的Cinder相关，同时提供Cinder在Horizon中的管理面板</p><p>Swift：提供管理存储节点的Swift相关，同时提供Swift在Horizon中的管理面板</p><p>Trove：提供管理数据库节点的Trove相关，同时提供Trove在Horizon中的管理面板</p><p>Heat：提供了基于模板来实现云环境中资源的初始化，依赖关系处理，部署等基本操作，也可以解决自动收缩,负载均衡等高级特性。</p><p>Centimeter：提供对物理资源以及虚拟资源的监控，并记录这些数据，对该数据进行分析，在一定条件下触发相应动作</p><p>控制节点一般来说只需要一个网络端口用于通信/管理各个节点</p><p>网络节点架构</p><p>网络节点仅包含Neutron服务</p><p>Neutron：负责管理私有网段与公有网段的通信，以及管理虚拟机网络之间的通信/拓扑，管理虚拟机之上的防火等等</p><p>网络节点包含三个网络端口</p><p>eth0：用于与控制节点进行通信</p><p>eth1：用于与除了控制节点之外的计算/存储节点之间的通信</p><p>eth2：用于外部的虚拟机与相应网络之间的通信</p><p>计算节点架构</p><p>计算节点包含Nova，Neutron，Telemeter三个服务</p><p> 1）基础服务</p><p>Nova：提供虚拟机的创建，运行，迁移，快照等各种围绕虚拟机的服务，并提供API与控制节点对接，由控制节点下发任务</p><p>Neutron：提供计算节点与网络节点之间的通信服务</p><p> 2）扩展服务</p><p>Telmeter：提供计算节点的监控代理，将虚拟机的情况反馈给控制节点，是Centimeter的代理服务</p><p>计算节点包含最少两个网络端口</p><p>eth0：与控制节点进行通信，受控制节点统一调配</p><p>eth1：与网络节点，存储节点进行通信</p><p>存储节点架构</p><p>存储节点包含Cinder，Swift等服务</p><p>Cinder：块存储服务，提供相应的块存储，简单来说，就是虚拟出一块磁盘，可以挂载到相应的虚拟机之上，不受文件系统等因素影响，对虚拟机来说，这个操作就像是新加了一块硬盘，可以完成对磁盘的任何操作，包括挂载，卸载，格式化，转换文件系统等等操作，大多应用于虚拟机空间不足的情况下的空间扩容等等</p><p>Swift：对象存储服务，提供相应的对象存储，简单来说，就是虚拟出一块磁盘空间，可以在这个空间当中存放文件，也仅仅只能存放文件，不能进行格式化，转换文件系统，大多应用于云磁盘/文件</p><p>存储节点包含最少两个网络接口</p><p>eth0：与控制节点进行通信，接受控制节点任务，受控制节点统一调配</p><p>eth1：与计算/网络节点进行通信，完成控制节点下发的各类任务</p><p>-—————————————————————————————————————————————————————————————</p><p>下面说一说Openstack的各个组件作用及关系</p><p>Openstack发展至今，总共集成了下面几个组件：</p><p>Nova - 计算服务<br>Neutron-网络服务<br>Swift - 对象存储服务<br>Cinder-块存储服务<br>Glance - 镜像服务<br>Keystone - 认证服务<br>Horizon - UI服务<br>Ceilometer-监控服务<br>Heat-集群服务<br>Trove-数据库服务</p><p>组件间的关系图如下：</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803161818153-400482667.png" alt="img"></p><p>重要组件介绍</p><p>OpenStack认证服务（Keystone）<br>Keystone为所有的OpenStack组件提供认证和访问策略服务，它依赖自身REST（基于Identity API）系统进行工作，主要对（但不限于）Swift、Glance、Nova等进行认证与授权。事实上，授权通过对动作消息来源者请求的合法性进行鉴定。下图显示了身份认证服务流程：</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/0b988d224229300230a345f657c1c909103.png" alt="img"></p><p>Keystone采用两种授权方式，一种基于用户名/密码，另一种基于令牌（Token）。</p><p>除此之外，Keystone提供以下三种服务：<br>  令牌服务：含有授权用户的授权信息<br>  目录服务：含有用户合法操作的可用服务列表<br>  策略服务：利用Keystone具体指定用户或群组某些访问权限</p><p>keystone认证服务注意点：</p><p>服务入口：如Nova、Swift和Glance一样每个OpenStack服务都拥有一个指定的端口和专属的URL，我们称其为入口（endpoints）。</p><p>区位：在某个数据中心，一个区位具体指定了一处物理位置。在典型的云架构中，如果不是所有的服务都访问分布式数据中心或服务器的话，则也称其为区位。</p><p>用户：Keystone授权使用者<br>　　PS：代表一个个体，OpenStack以用户的形式来授权服务给它们。用户拥有证书（credentials），且可能分配给一个或多个租户。经过验证后，会为每个单独的租户提供一个特定的令牌。</p><p>服务：总体而言，任何通过Keystone进行连接或管理的组件都被称为服务。举个例子，我们可以称Glance为Keystone的服务。</p><p>角色：为了维护安全限定，就云内特定用户可执行的操作而言，该用户关联的角色是非常重要的。<br>　　PS：一个角色是应用于某个租户的使用权限集合，以允许某个指定用户访问或使用特定操作。角色是使用权限的逻辑分组，它使得通用的权限可以简单地分组并绑定到与某个指定租户相关的用户。</p><p>租间：租间指的是具有全部服务入口并配有特定成员角色的一个项目。<br>　　PS：一个租间映射到一个Nova的“project-id”，在对象存储中，一个租间可以有多个容器。根据不同的安装方式，一个租间可以代表一个客户、帐号、组织或项目。</p><p>OpenStack计算设施—-Nova</p><p>Nova是OpenStack计算的弹性控制器。OpenStack云实例生命期所需的各种动作都将由Nova进行处理和支撑，这就意味着Nova以管理平台的身份登场，负责管理整个云的计算资源、网络、授权及测度。虽然Nova本身并不提供任何虚拟能力，但是它将使用libvirt API与虚拟机的宿主机进行交互。Nova通过Web服务API来对外提供处理接口，而且这些接口与Amazon的Web服务接口是兼容的。</p><p>功能及特点：　<br>实例生命周期管理<br>计算资源管理<br>网络与授权管理<br>基于REST的API<br>异步连续通信<br>支持各种宿主：Xen、XenServer/XCP、KVM、UML、VMware vSphere及Hyper-V</p><p>Nova弹性云（OpenStack计算部件）包含以下主要部分：<br>API Server（nova-api）<br>消息队列（rabbit-mq server）<br>运算工作站（nova-compute）<br>网络控制器（nova-network）<br>卷管理（nova-volume）<br>调度器（nova-scheduler）</p><p>解释如下：<br>1）API服务器（nova-api）<br>API服务器提供了云设施与外界交互的接口，它是外界用户对云实施管理的唯一通道。通过使用web服务来调用各种EC2的API，接着API服务器便通过消息队列把请求送达至云内目标设施进行处理。作为对EC2-api的替代，用户也可以使用OpenStack的原生API，我们把它叫做“OpenStack API”。</p><p>2）消息队列（Rabbit MQ Server）<br>OpenStack内部在遵循AMQP（高级消息队列协议）的基础上采用消息队列进行通信。Nova对请求应答进行异步调用，当请求接收后便则立即触发一个回调。由于使用了异步通信，不会有用户的动作被长置于等待状态。例如，启动一个实例或上传一份镜像的过程较为耗时，API调用就将等待返回结果而不影响其它操作，在此异步通信起到了很大作用，使整个系统变得更加高效。</p><p>　3）调度器（nova-scheduler）　　</p><p>调度器负责把nova-API调用送达给目标。调度器以名为“nova-schedule”的守护进程方式运行，并根据调度算法从可用资源池中恰当地选择运算服务器。有很多因素都可以影响调度结果，比如负载、内存、子节点的远近、CPU架构等等。强大的是nova调度器采用的是可插入式架构。</p><p>目前nova调度器使用了几种基本的调度算法：<br>　　随机化：主机随机选择可用节点；<br>　　可用化：与随机相似，只是随机选择的范围被指定；<br>　　简单化：应用这种方式，主机选择负载最小者来运行实例。负载数据可以从别处获得，如负载均衡服务器。</p><p>4）运算工作站（nova-compute）<br>运算工作站的主要任务是管理实例的整个生命周期。他们通过消息队列接收请求并执行，从而对实例进行各种操作。在典型实际生产环境下，会架设许多运算工作站，根据调度算法，一个实例可以在可用的任意一台运算工作站上部署。</p><p>　5）网络控制器（nova-network）<br>网络控制器处理主机的网络配置，例如IP地址分配，配置项目VLAN，设定安全群组以及为计算节点配置网络。</p><p>　6）卷工作站（nova-volume）　<br>卷工作站管理基于LVM的 实例卷，它能够为一个实例创建、删除、附加卷，也可以从一个实例中分离卷。卷管理为何如此重要？因为它提供了一种保持实例持续存储的手段，比如当结束一个 实例后，根分区如果是非持续化的，那么对其的任何改变都将丢失。可是，如果从一个实例中将卷分离出来，或者为这个实例附加上卷的话，即使实例被关闭，数据 仍然保存其中。这些数据可以通过将卷附加到原实例或其他实例的方式而重新访问。</p><p>因此，为了日后访问，重要数据务必要写入卷中。这种应用对于数据服务器实例的存储而言，尤为重要。</p><p>OpenStack镜像服务器—-Glance</p><p>OpenStack镜像服务器是一套虚拟机镜像发现、注册、检索系统，我们可以将镜像存储到以下任意一种存储中：<br>本地文件系统（默认）<br>S3直接存储<br>S3对象存储（作为S3访问的中间渠道）<br>OpenStack对象存储等等。<br>　　<br>功能及特点：<br>提供镜像相关服务。</p><p>Glance构件：<br>1）Glance-API：<br>　 主要负责接收响应镜像管理命令的Restful请求，分析消息请求信息并分发其所带的命令（如新增，删除，更新等）。默认绑定端口是9292。<br>2）Glance-Registry：<br>　　主要负责接收响应镜像元数据命令的Restful请求。分析消息请求信息并分发其所带的命令（如获取元数据，更新元数据等）。默认绑定的端口是9191。</p><p>OpenStack存储设施—-Swift</p><p>Swift为OpenStack提供一种分布式、持续虚拟对象存储，它类似于Amazon Web Service的S3简单存储服务。Swift具有跨节点百级对象的存储能力。Swift内建冗余和失效备援管理，也能够处理归档和媒体流，特别是对大数据（千兆字节）和大容量（多对象数量）的测度非常高效。</p><p>swift功能及特点：　　<br>海量对象存储<br>大文件（对象）存储<br>数据冗余管理<br>归档能力—–处理大数据集<br>为虚拟机和云应用提供数据容器<br>处理流媒体<br>对象安全存储<br>备份与归档<br>良好的可伸缩性</p><p>Swift组件<br>Swift账户<br>Swift容器<br>Swift对象<br>Swift代理<br>Swift RING<br>　　<br>Swift代理服务器　　<br>用户都是通过Swift-API与代理服务器进行交互，代理服务器正是接收外界请求的门卫，它检测合法的实体位置并路由它们的请求。<br>此外，代理服务器也同时处理实体失效而转移时，故障切换的实体重复路由请求。</p><p>Swift对象服务器<br>对象服务器是一种二进制存储，它负责处理本地存储中的对象数据的存储、检索和删除。对象都是文件系统中存放的典型的二进制文件，具有扩展文件属性的元数据（xattr）。</p><p>注意：xattr格式被Linux中的ext3/4，XFS，Btrfs，JFS和ReiserFS所支持，但是并没有有效测试证明在XFS，JFS，ReiserFS，Reiser4和ZFS下也同样能运行良好。不过，XFS被认为是当前最好的选择。</p><p>Swift容器服务器<br>容器服务器将列出一个容器中的所有对象，默认对象列表将存储为SQLite文件（译者注：也可以修改为MySQL，安装中就是以MySQL为例）。容器服务器也会统计容器中包含的对象数量及容器的存储空间耗费。</p><p>Swift账户服务器<br>账户服务器与容器服务器类似，将列出容器中的对象。</p><p>Ring（索引环）</p><p>Ring容器记录着Swift中物理存储对象的位置信息，它是真实物理存储位置的实体名的虚拟映射，类似于查找及定位不同集群的实体真实物理位置的索引服务。这里所谓的实体指账户、容器、对象，它们都拥有属于自己的不同的Rings。</p><p>OpenStack管理的Web接口—-Horizon</p><p>Horizon是一个用以管理、控制OpenStack服务的Web控制面板，它可以管理实例、镜像、创建密匙对，对实例添加卷、操作Swift容器等。除此之外，用户还可以在控制面板中使用终端（console）或VNC直接访问实例。</p><p>总之，Horizon具有如下一些特点：　　<br>实例管理：创建、终止实例，查看终端日志，VNC连接，添加卷等<br>访问与安全管理：创建安全群组，管理密匙对，设置浮动IP等<br>偏好设定：对虚拟硬件模板可以进行不同偏好设定<br>镜像管理：编辑或删除镜像<br>查看服务目录<br>管理用户、配额及项目用途<br>用户管理：创建用户等<br>卷管理：创建卷和快照<br>对象存储处理：创建、删除容器和对象<br>为项目下载环境变量</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudFoundry的架构设计</title>
      <link href="2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/javayou">红薯</a></p><p>出处：<a href="https://www.oschina.net/question/12_32393">深度剖析CloudFoundry的架构设计</a></p><p>VMware发布了业内第一个开源的PaaS——CloudFoundry。Ruby开发的一款开源PaaS云计算平台。</p><p>本文会分为两个部份：第一部份主要介绍CloudFoundry的架构设计，从它所包含的模块介绍起，到各部份的消息流向，各模块如何协调合作；第 二部份会在第一部份的基础上，以如何在你的数据中心里面用CloudFoundry部署一个私有PaaS为目标，把第一部分介绍到的架构知识使用起来。</p><p>第一部份讲的很多内容，会引用Pat在10月12日的VMwareCloud Forum上面关于CloudFoundry架构的演讲。Pat是CloudFoundry Core的负责人，他的那次演讲很值得一听。如果你当时在场，并且理解他所说的内容，本部份可以选择直接跳过。我除了会把说的内容讲具体点外，不太可能可 以讲得比他好。</p><p><strong>一、架构及模块</strong></p><p>从总体地看，CloudFoundry的架构如下：</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_dsI0.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>这个架构图以及下文所用到的各模块架构图均来自Pat的PPT。从上图能够看到CloudFoundry主要有以下几大组件组成：</p><p>1、 Router：顾名思义，Router组件在CloudFoundry中是对所有进来的Request进行路由。进入Router的request主要有两类：首先是来自VMCClient或者STS的，由CloudFoundry使用者发出的，管理型指令。</p><p>例如：列出你所有apps的vmcapps，提交一个apps等等。这类request会被路由到AppLife Management组件，又叫CloudController组件去；第二类是外界对你所部署的apps访问的request。这部份requests 会被路由到Appexecution，又或者叫做DEAs的组件去。所有进入CloudFoundry系统的requests都会经过Router组件， 看到这里可能会有朋友会担心Router成为单点，从而成为整个云的瓶颈。</p><p>但是CloudFoundry作为云系统，其设计的核心就是去单点依赖，组件平行扩充，且可替代的以保证扩展性，这是CloudFoundry，甚 至所有云计算系统的设计原则，后文会讨论CloudFoundry如何做到这点，目前只要知道，系统可以部署多个Routers共同处理进来的 requests，但是Router上层的LoadBalance不在CloudFoundry的实现范围，CloudFoundry只保证所有的 request是无状态的，这样就使上层均衡附载选择面非常非常大了，例如可以通过DNS做，也可以部署硬件的LoadBalancer，或者简单点，弄 台ngnix作负载均衡器，都是可行的。</p><p>Router组件，目前版本是对nginx的一个简单封装。熟悉ngnix的朋友应该知道，它可以一个套接字文件（.sock文件）作为输入输出。所有安装CloudFoundry的Router组件服务器都会安装一个nginx，其ngnix.conf文件有以下配置：</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_k33L.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>从整体的来看，Router组件的结构如下：</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_WBeV.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>外界httprequest进入CloudFoundry服务器，nginx会首先接到request，nginx通过sock与 router.rb进行交互，于是真正处理请求的是Router组件。router.rb里面根据传入的url，用户名密码等，进行逻辑判断，到 CloudController组件或者DEA组件取数据并且返通过与niginx连接的.sock文件返回。</p><p>router.rb是对nginx进行了逻辑封装。熟悉CloudFoundry的朋友肯定知道，CloudFoundry给每一个app分配了一 个url访问，如果直接使用VMware所托管的CloudFoundry.com的话，那你的app的url可能就是 xxx.cloudfoundry.com，无论通过命令给你的app扩展了多少个instances，都是从这个url访问的，这里面的url转换路由 就是由router.rb实现的。</p><p>2、DEA(Droplet Execution Agency): 首先要解析下什么叫做Droplet。Droplet在CloudFoundry的概念里面是指一个把你提交的源代码，以及CloudFoundry配套 好的运行环境，再加上一些管理脚本，例如Start/Stop这些小脚本全部压缩好在一起的tar包。还有一个概念，叫做Stagingapp，就是指制 作上面描述这个包，然后把它存储好的过程。CloudFoundry会自动保存这个Droplet，直到你start一个app的时候，一台部署了DEA 模块的服务器会来拿一个Droplet的copy去运行。所以如果你扩展你的app到10个instances，那这个Droplet就被会复制十份，让 10个DEA服务器拿去运行。</p><p>下图是DEA模块的架构图：</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_GFkn.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>Cloud Controller模块（下面会介绍）会发送start/stop等基本的apps管理请求给DEA，dea.rb接收这些请求，然后从NFS里面找到 合适的Droplet。前面说到Droplet其实是一个带有运行脚本的，带运行环境的tar包，DEA只需要把它拿过来解压，并即行里面的start脚 本，就可以让这个app跑起来。到此，app算是可以访问，并start起来了，换句话说就是有这台服务器的某一个端口已经在待命，只要有request 从这个端口进来，这个app就可以接收并返回正确的信息。</p><p>接着dea.rb要做些善后的工作：1、把这个信息告诉Router模块。我们前面说到，所有进入CloudFoundry的requests都是 由Router模块处理并转发的，包括用户对app的访问request，一个app起来后，需要告诉router，让它根据loadbalance等原 则，把合适的request转进来，使这个app的instance能够干起活；2、一些统计性的工作，例如要把这个用户又新部署了一个app告诉 CloudController，以作quota控制等；3、把运行信息告诉HealthManager模块，实时报告该app的instance运行情 况。另外DEA还要负责部份对Droplet的查询工作，譬如，如果用户通过CloudController想查询一个app的log信息，那DEA需要 从该Droplet里面取到log返回等等。</p><p>3、CloudController：CloudController是CloudFoundry的管理模块。主要工作包括：</p><p>a) 对apps的增删改读；</p><p>b) 启动、停止应用程序；</p><p>c) Staging apps（把apps打包成一个droplet）；</p><p>d) 修改应用程序运行环境，包括instance、mem等等；</p><p>e) 管理service，包括service与app的绑定等；</p><p>f) Cloud环境的管理；</p><p>g) 修改Cloud的用户信息；</p><p>h) 查看Cloud Foundry，以及每一个app的log信息。</p><p>这似乎有点复杂，但简单的说，可以很简单：就是与VMC和STS交互的服务器端。VMC和STS与CloudFoundry通信采用的是 restful接口，另一方面CloudController是一个典型的Rubyon Rails项目，从VMC或者STS接到JSON格式的协议，然后写入CloudController Database，并发消息到各模快去控制管理整个云。和其他ROR项目一样，CloudController的所有API可以从 conf/routes.rb里看到。开放的Restful接口好处在于第三方应用开发和集成，企业在用CloudFoundry部署私有云的时候，可以 通过这些接口来自动化控制管理整个Cloud环境。这部份内容将在第二部份论述。</p><p>下图是Cloud Controller的架构图：</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_4FyB.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>图中Health Manager和DEA是外部模块，CCDatabase就是CloudController Database，这个是整个CloudFoundry不能做HP的地方。CloudController Database的并发性不会很多，应用级别的数据库访问是由底下的Service模块处理的，这个数据库存的是Cloud的配置信息。读操作主要来自 DEA启动，作为初始化DEA的依据；以及healthmanager模块会从这里读取预期的状态信息，这部份数据会与从DEA得到的实际状态信息进行比 对。</p><p>NFS是多个CloudController的共享存储，CloudController其中一个重要工作就是StagingApps。 Droplets的存储是在集群环境的唯一的。而CloudController是集群运行，换言之，就是每一个控制Request可能由不同的 CloudController处理，假设一个简单的用户场景：我们需要部署一个app到CloudFoundry中。我们在敲完那条简单的push命令 后，VMC开始工作，在做完一轮的用户鉴权、查看所部署的apps数量是否超过预定数额，问了一堆相关app的问题后，需要发4个指令：</p><p>1．发一个POST到”apps”，创建一个app;</p><p>2．发一个PUT到”apps/:name/application”，上传app;</p><p>3．发一个GET到”apps/:name/”，取得app状态，看看是否已经启动；</p><p>4．如果没有启动，发一个PUT到”apps/:name/”，使其启动。</p><p>如果第2和第4步由不同的Cloud Controller来处理，而又无法保证他们能找到同一个Droplet，那第4步将会因为找不到对应的Droplet而启动失败。如何保证这一连串指 令过来所指向的Droplet都是同一个呢？使用NFS，使CloudController共享存储是最简单的方法。但是这个方法在安全性等方面并不完 美。在10月12日的VMwareCloud Forum上，Pat告诉我们下一版本的CloudFoundry这里将会有大调整，但是在那部份代码公开前，我不方便在这评价太多。</p><p>4、HealthManager: 做的事情不复杂，简单的说是从各个DEA里面拿到运行信息，然后进行统计分析，报告等。统计数据会与CloudController的设定指标进行比对， 并提供Alert等。HealthManager模块目前还不是十分完善，但是CloudManage栈里面，自动化health管理、分析是一个很重要 的领域，而这方面可以扩展的地方也很多，结合OrchestrationEngine可以使云自管理、自预警；而与BI方面技术结合，可以统计运营情况， 合理分配资源等。这方面CloudFoundry还在发展之中。</p><p>5、Services:Cloud Foundry的Service模块从源代码控制上看就知道是一个独立的、可Plugin的模块，以方便第三方把自己的服务整合入 CloudFoundry生态系统。在Github上看到service是与CloudFoundry Core项目vcap独立的一个repository，为vcap-service。Service模块其中设计原则是方便第三方服务提供商提供服务。在 这方面CloudFoundry做得很成功，从Github上看，已经有以下服务提供：a)MongoDB; b) mysql; c) neo4j; d) PostgreSql; e) RabbitMQ; f) Redis; g)vBlob。基类都是放在base文件夹中。</p><p>第三方如果需要自己开发CloudFoundry的服务，需要继承改写它里面的两个基础类：Node和Gateway；而里面一些操作， 如：Provision，可以在base的provisioner.rb基础上加入自己的逻辑，同样的还有Service_Error和 Service_Message等。关于如何写自己的Service，ELC的博客会推出相应文章详细论述，并不在本文的讨论范围里面，从架构了解上来 说，只要知道服务间的关系，知道个服务与base间透过继承关系来横向扩充，而CloudFoundry与apps调用Service是通过base来完 成这一简单的架构方法即可。</p><p>6、NATS(Message bus): 从CloudFoundry的总架构图看，位于各模块中心位置的是一个叫nats的组件。NATS是由CloudFoundry的架构师Derek开发的一个轻量级的，支持发布、订阅机制的消息系统。Github开源地址是：<a href="https://github.com/derekcollison/nats%E3%80%82%E5%85%B6%E6%A0%B8%E5%BF%83%E5%9F%BA%E4%BA%8EEventMachine%E5%BC%80%E5%8F%91%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%87%8F%E4%B8%8D%E5%A4%9A%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E6%85%A2%E6%85%A2%E7%A0%94%E7%A9%B6%E3%80%82">https://github.com/derekcollison/nats。其核心基于EventMachine开发，代码量不多，可以下载下来慢慢研究。</a></p><p>CloudFoundry是一个多模块的分布式系统，支持模块自发现，错误自检，且模块间低耦合。其核心原理就是基于消息发布订阅机制。每个台服务 器上的每个模块会根据自己的消息类别，向MessageBus发布多个消息主题；而同时也向自己需要交互的模块，按照需要的信息内容的消息主题订阅消息。 譬如：一个DEA被加入CloudFoundry集群中，它需要向大家吼一下，以表明它已经准备好服务了，它会发布一个主题是”dea.start”的消 息：</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_gxEP.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>@ hello_message_json中包括DEA的UUID,ip, port, 版本信息等内容。</p><p>再例如，CloudController需要启动一个Droplet的instance：</p><p>a)首先一个DEA在启动的时候，会首先会对自己UUID的消息主题进行订阅。</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_xEQk.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>其他模块需要通过’’dea.#{uuid}.start”这个主题发送消息来使它启动，一旦这个DEA接收到消息，就会触发process_dea_start(msg)这个方法来处理启动所需要的工作。</p><p>b)Cloud Controller或者其他模块发送消息，让UUID为xxx的DEA启动。</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_FF7U.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>c)DEA模块接收到消息后，就会触发process_dea_start(msg)方法。msg是由其他模块发送过来的消息内容，包 括：droplet_id,instance_index, service, runtime等内容，process_dea_start会取得这些启动DEA必须的信息，然后进行一系列操作，例如从NFS中取得Droplet，解 压，修改必要环境配置，运行启动脚本等等。等一切都准备好后，然后需要给Router发个消息，告诉它这个Droplet已经随时准备好报效国家，以后有 相应的request记得让它来处理。</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_nMFD.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>d)Router模块在启动时就已经订阅”router.register”消息主题。</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BCloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_ehTo.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>收到前面DEA发出的信息后，会触发register_droplet方法，去绑定Droplet。到此启动一个Droplet的instance工作完成。</p><p>我们可以看到整个CloudFoundry的核心就是一套消息系统，如果想了解CloudFoundry的来龙去脉，去跟踪它里面复杂的消息机制是 非常好的方法。另一方面，CloudFoundry是一套基于消息的分布式系统，面向消息的架构是它节点横向扩展，组件自发现等云特性的基础。</p><p>Cloud Foundry的架构简单介绍至此，其实作为第一款开源的PaaS，CloudFoundry架构有很多可以学习借鉴的地方，很多细节上的处理是很精妙 的，这些内容如果有可能会在后续文章继续探讨，本文题虽为深入CloudFoundry，其实也只是浅尝即止，把总体架构介绍一下，目标在于使我们有足够 的背景知识去用CloudFoundry搭建企业内部的私有PaaS。总结一下，笔者从CloudFoundry的结构中学到的东西：</p><p>1、基于消息的多组件架构是实现集群的简单、且有效方法。消息可以使集群节点间解耦，使自注册，自发现这些在大规模数据中心中很重要的功能得到实现；</p><p>2、适当的抽象层，模板模式的使用，方便第三方可以方便在CloudFoundry开发扩展功能。CloudFoundry在DEA及 Service层都做了抽象层处理，相对应地使开发者可以容易地为CloudFoundry开发Runtime和Service。例如，在 CloudFoundry刚推出的时候，只支持Node.js,Java, Ruby，但第三方提供商、开源社区快速跟进，为CloudFoundry添加了PHP,Python的支持。这得益于CloudFoundry精巧的 DEA架构设计，如何开发新的Runtime支持，会在后续博文中有所论述.</p><p><strong>二、源码导读</strong></p><p>笔者一直觉得深入理解一个技术的最好方法就是读它的源码，而CloudFoundry是完全开源的PaaS平台，而因为刚发展起来，代码量不多，主 要作者们的代码功力也相当不错，读起来很舒服，很适合研读。而不得不再次表扬一下它完全基于消息机制的架构设计，对组件扩展性，第三方接入等方面做得很 好，读者可以从中学到不少思想性的东西。笔者很推荐大家去读一下它的源代码。你可以在Github上找到CloudFoundry的全部代码：<a href="https://github.com/cloudfoundry%EF%BC%8C%E4%BD%A0%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%87%A0%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84Repositories%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9A">https://github.com/cloudfoundry，你会看到几个不同的Repositories，它们分别是：</a></p><p>1、vcap: Cloud Foundry的Core，又或者称作Kernel；</p><p>2、vcap-service: Cloud Foundry的Service组件。Cloud Foundry的service是作为插件提供的，这出于它方便第三方开发service而设计的；</p><p>3、vmc: VMware Cloud CLI. 是一个Ruby应用，与Cloud Foundry的CLI交互。主要通过分析用户输入的CLI，向CloudFoundry发送Restful请求；</p><p>4、vcap-java: 如果你的app是用java开发，且需要与Cloud Foundry交互，例如取得当前serviceserver的ip地址等，你可能需要这个jar，里面对我们Java开发常用框架有所支持，它底层也是 对CloudFoundry的Restful请求的包装；</p><p>5、vcap-java-client: Cloud Foundry的Restful API的Java封装，与上面的项目不一样，它只是个简单的读取CloudFoundry信息，并放如JavaBean中；</p><p>6、vcap-test: Cloud Foundry的test cases;</p><p>7、vcap-test-assets: Cloud Foundry一些apps示例。</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudFoundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack和CloudFoundry</title>
      <link href="2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E5%92%8CCloudFoundry/"/>
      <url>2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E5%92%8CCloudFoundry/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h2><p>OpenStack 是一个旨在为公共及私有云的建设与管理提供软件的开源项目。它的社区拥有超过130家企业及1350位开发者，这些机构与个人都将OpenStack作为基础设施即服务（简称IaaS）资源的通用前端。OpenStack项目的首要任务是简化云的部署过程并为其带来良好的可扩展性。OpenStack 源码在 Git@OSC 上的镜像：<a href="http://git.oschina.net/openstack">http://git.oschina.net/openstack</a></p><p>开源项目，搭建私有云，公有云，混合云。openStack是偏IaaS层的开源云计算框架</p><p><img src="/2020/12/10/%E5%AE%B9%E5%99%A8%E4%B9%8BOpenStack%E5%92%8CCloudFoundry/001610_vm0P_5189.jpg" alt="img"></p><h2 id="CloudFoundry"><a href="#CloudFoundry" class="headerlink" title="CloudFoundry"></a>CloudFoundry</h2><p>Cloud Foundry是一个独立于云的平台即服务解决方案，也是业界最成功的PaaS平台，是PaaS层的开源框架。。Cloud Foundry提供了一个可轻松运行、扩展和维护应用程序的环境和快速便捷的开发者体验。Cloud Foundry支持Java、NodeJS、Ruby、Python等大多数语言和环境。</p><p>开源的Cloud Foundry由Cloud Foundry基金会开发并支持，基金会包括Pivotal、IBM、VMware以及其它许多厂商。商业版本的Cloud Foundry，如IBM Bluemix和Pivotal Cloud Foundry，是基于开源的Cloud Foundry项目并在其基础上提供企业级的支持。</p><p>Cloud Foundry对容器采用了一个非常固执的方式。它使用了一个叫garden的容器解决方案。PCF的较早版本的原始容器称为warden，它事实上要早于Docker本身。</p><p>Cloud Foundry自身事实上也早于Kubernetes，它的第一个版本始于2011年，而Kubernetes直到2014年才出现。</p><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Kubernetes是一个来源于谷歌Borg项目的开源云平台。它由Cloud Native Computing Foundation发起，该基金会的成员包括了许多行业巨头，如AWS、Azure、Intel、IBM、RedHat、Pivotal等许多公司。</p><p>Cloud Foundry最重要的特点是，它是一个PaaS。Kubernetes则不太像PaaS，有些人把它看做IaaS+ ，甚至Kubernetes 的文档也把自己描述为“不是传统的、包罗万象的PaaS”。</p><p>Kubernetes首要的功能是一个容器编排和容器生命周期的管理。尽管不限于此，但它通常是被用来运行Docker容器，它的受众人群更广泛一些，比如想要构建在容器服务之上的应用和服务开发人员。有一些解决方案基于Kubernetes提供了PaaS体验，比如IBM的Container Service和RedHat的OpenShift等。</p><h2 id="Cloud-Foundry的优势在于"><a href="#Cloud-Foundry的优势在于" class="headerlink" title="Cloud Foundry的优势在于"></a>Cloud Foundry的优势在于</h2><ol><li>成熟的身份验证系统UAA，用户组和multi-tenancy的支持</li><li>方便快捷的cf push</li><li>自带负载均衡Router</li><li>强大的日志和metrics整合</li><li>成熟的部署工具BOSH</li></ol><h2 id="Kubernetes的优势在于"><a href="#Kubernetes的优势在于" class="headerlink" title="Kubernetes的优势在于"></a>Kubernetes的优势在于</h2><ol><li>大量社区和第三方支持，提供强大的扩展性</li><li>完善的容器生命周期和自动伸缩管理</li><li>方便快捷的容器化应用部署</li><li>良好、多样的持久层支持</li><li>多种开源UI支持</li></ol><h2 id="Cloud-Foundry和Kubernetes相似点"><a href="#Cloud-Foundry和Kubernetes相似点" class="headerlink" title="Cloud Foundry和Kubernetes相似点"></a>Cloud Foundry和Kubernetes相似点</h2><p>两者都使用容器的思想来隔离应用和系统其它组件。<br>两者都可以既运行在公有云（AWS、Azure、GCP）上，也可以运行在预置型云平台，如使用Vmware vsphere的云平台上。<br>两者都提供了混合环境上的运行能力，允许你在不同的云平台运行应用以提高可用性，甚至支持应用在公有云和私有云上同时运行。<br>Pivotal Cloud Foundry的最新版本也开始支持Kubernetes作为通用的容器运行时。</p><h2 id="CloudFoundry和Kubernetes使用"><a href="#CloudFoundry和Kubernetes使用" class="headerlink" title="CloudFoundry和Kubernetes使用"></a>CloudFoundry和Kubernetes使用</h2><p>使用Docker，你需要定义一个Dockerfile以支持运行基于Java的应用。你可以用各种不同方式来定义这个容器。你可以选择不同的基础操作系统，不同服务商提供的不同JDK版本，你可以暴露不同的端口，以支持不同安全级别上的访问。没有一个标准说基于Java的Spring Boot应用该长什么样。</p><p>在Cloud Foundry，所有基于Java的应用都有一个基线buildpack，这个buildpack是由供应商提供的。一个buildpack是针对给定语言创建应用运行时的模板。buildpack是由Cloud Foundry自身管理的。</p><p>Cloud Foundry把定义容器的部分工作从开发者手上接了过来。它定了一个标准，基于Java的容器应该长什么样，这样所有开发者，不管是DevOps团队还是IT专家，都可以同步这个模板。你可以确信你的容器将和其他开发者提供的容器一样运行，不管在现有的集群内，还是将来有可能转到的公有云平台上。</p><h2 id="OpenShift和CloudFoundry比较"><a href="#OpenShift和CloudFoundry比较" class="headerlink" title="OpenShift和CloudFoundry比较"></a>OpenShift和CloudFoundry比较</h2><p>具体未来谁流行现在很难说清楚，从现在热度来看红帽子在云方面的力量还是弱于Vmware的，CloudFoundry应该会更加流行。两者关键区别：<br>1.语言方面：基本相同，都支持java，Pythone,php,perl,ruby等。CF多支持Elang<br>2.关系数据库：都支持mysql和PostgreSql<br>3.NoSQL:都支持MongoDB，CF多支持Redis，Neo4j，分布式缓存memcacheD</p><h2 id="CloudFoundry和Kubernetes结合"><a href="#CloudFoundry和Kubernetes结合" class="headerlink" title="CloudFoundry和Kubernetes结合"></a>CloudFoundry和Kubernetes结合</h2><h4 id="Kubernetes-CPI"><a href="#Kubernetes-CPI" class="headerlink" title="Kubernetes CPI"></a>Kubernetes CPI</h4><p>我们知道BOSH是Cloud Foundry官方指定的部署工具，它是一个针对大规模分布式系统的部署和生命周期管理的开源工具。但是BOSH不仅仅局限于部署Cloud Foundry，也可以应用于别的分布式系统，只需要其提供符合要求的Release即可。CPI全称Cloud Provider Interface，是BOSH用来与IaaS通信完成虚拟机实例和模板的创建和管理的一个API接口，CPI目前能够支持Amazon的AWS、微软的Azure、IBM的SoftLayer等IaaS平台，国内阿里云也提供了CPI的支持。BOSH的主控制器Director通过CPI与底层的IaaS层交互，将BOSH manifest.yaml 文件定义任务及组件部署到IaaS层的VM上。</p><p>也就是开发一套Kubernetes的CPI，通过BOSH和manifest.yaml的配置将Cloud Foundry部署到Kubernetes上。现在有一些大的厂商如IBM、SAP在开发相应的Kubernetes CPI，大家可以在GitHub中搜索到。我个人觉得，这种方式虽然容易上手，但还是以IaaS的角度来看待Kubernetes，底层还是通过BOSH来管理的，没能最大地发挥Kubernetes平台的优势的。</p><h4 id="Cloud-Foundry-Container-Runtime（CFCR）"><a href="#Cloud-Foundry-Container-Runtime（CFCR）" class="headerlink" title="Cloud Foundry Container Runtime（CFCR）"></a>Cloud Foundry Container Runtime（CFCR）</h4><p>Cloud Foundry基金会在2017年底宣布把Pivotal和谷歌捐献的Kubo项目改名为CFCR（Cloud Foundry Container Runtime）。总体来说是利用BOSH来部署Cloud Foundry和Kubernetes，并通过Application Runtime管理Cloud Foundry的Application Service；通过Container Runtime管理Kubernetes的Container Service，比如一些无法部署在Cloud Foundry内的服务，如数据库、监控等。然后通过Open Service Broker将两者连接起来</p><h4 id="容器化Cloud-Foundry"><a href="#容器化Cloud-Foundry" class="headerlink" title="容器化Cloud Foundry"></a>容器化Cloud Foundry</h4><p>将Cloud Foundry所有组件容器化，并部署到Kubernetes上是一种比较新型的整合方式。现在有一些大的厂商做这方面的工作，比如SUSE、IBM和SAP。其核心就是通过将Cloud Foundry的BOSH Release转化成Docker镜像，然后通过Kubernetes的部署工具Helm来将Cloud Foundry更加自然地部署到Kubernetes上。只有在生成Cloud Foundry组件的Docker镜像是需要用到BOSH Cli去转化BOSH release，部署及部署之后的管理，都不需要BOSH，而是交给Kubernetes来对所有Cloud Foundry组件的Pod、服务及相应配置资源的生命周期进行管理。这样既享受到了Cloud Foundry带来的良好的开发者体验，又用到了Kubernetes强大的管理和扩展能力</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然两者结合的探索工作不止于此，现在越来越多的厂商和开发者加入到两者整合的研究中。其中比较火的有IBM主导的Cloud Foundry孵化项目Eirini，其想法是想将Cloud Foundry中的Diego-cell容器Garden替换成Kubernetes的容器，从而将两者更紧密地连接在一起。</p><p>Kubernetes之于Cloud Foundry的关系不是挑战也不是竞争关系，Cloud Foundry希望与其更好地融合，就像Cloud Foundry Foundation执行董事Abby Kearns说的：“Cloud Foundry是结构化的PaaS平台，其他平台是非结构化的，用户的需求是多元化的，并不是一定要如何容器化，而是希望平台能够更开放、支持更多的类型。”</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_30154571/article/details/84955097">Cloud Foundry和 Kubernetes 的区别</a></p><p><a href="http://dockone.io/article/8295">Cloud Foundry和Kubernetes结合的过去与未来</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudFoundry </tag>
            
            <tag> OpenStack </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> OpenShift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之Spring重试机制</title>
      <link href="2020/12/10/Spring-boot-amqp%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
      <url>2020/12/10/Spring-boot-amqp%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/ybyn/">一步一年</a></p><p>出处：<a href="https://www.cnblogs.com/ybyn/p/13691058.html">https://www.cnblogs.com/ybyn/p/13691058.html</a></p><p>消费端在处理消息过程中可能会报错，此时该如何重新处理消息呢？解决方案有以下两种。</p><blockquote><ul><li>在redis或者数据库中记录重试次数，达到最大重试次数以后消息进入死信队列或者其他队列，再单独针对这些消息进行处理；</li><li>使用spring-rabbit中自带的retry功能；</li></ul></blockquote><p>第一种方案我们就不再详细说了，我们主要来看一下第二种方案，老规矩，先上代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span>  <span class="comment"># 自动ack</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">max-interval:</span> <span class="number">10000</span>   <span class="comment"># 重试最大间隔时间</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">2000</span>  <span class="comment"># 重试初始间隔时间</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">2</span> <span class="comment"># 间隔时间乘子，间隔时间*乘子=下一次的间隔时间，最大不能超过设置的最大间隔时间</span></span><br></pre></td></tr></table></figure><p>此时我们的消费者代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;platform.queue-name&#125;&quot;&#125;,concurrency = &quot;1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgConsumer</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;接收到消息&gt;&gt;&gt;&#123;&#125;&quot;</span>,msg);</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">log.info(<span class="string">&quot;消息&#123;&#125;消费成功&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动程序，发送消息后可以看到控制台输出内容如下：</p><p><img src="/2020/12/10/Spring-boot-amqp%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142316393-1426680370.png" alt="img"></p><p>可以看到重试次数是5次（包含自身消费的一次），重试时间依次是2s，4s，8s，10s（上一次间隔时间*间隔时间乘子），最后一次重试时间理论上是16s，但是由于设置了最大间隔时间是10s，因此最后一次间隔时间只能是10s，和配置相符合。</p><blockquote><p>注意：</p><p>重试并不是RabbitMQ重新发送了消息，仅仅是消费者内部进行的重试，换句话说就是重试跟mq没有任何关系；</p><p>因此上述消费者代码不能添加try{}catch(){}，一旦捕获了异常，在自动ack模式下，就相当于消息正确处理了，消息直接被确认掉了，不会触发重试的；</p></blockquote><h2 id="MessageRecoverer"><a href="#MessageRecoverer" class="headerlink" title="MessageRecoverer"></a>MessageRecoverer</h2><p>上面的例子在测试中我们还发现了一个问题，就是经过5次重试以后，控制台输出了一个异常的堆栈日志，然后队列中的数据也被ack掉了（自动ack模式），首先我们看一下这个异常日志是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.amqp.rabbit.listener.exception.ListenerExecutionFailedException: Retry Policy Exhausted</span><br></pre></td></tr></table></figure><p>出现消息被消费掉并且出现上述异常的原因是因为在构建SimpleRabbitListenerContainerFactoryConfigurer类时使用了MessageRecoverer接口，这个接口有一个cover方法，用来实现重试完成之后对消息的处理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListenerRetry retryConfig = configuration.getRetry();</span><br><span class="line"><span class="keyword">if</span> (retryConfig.isEnabled()) &#123;</span><br><span class="line">RetryInterceptorBuilder&lt;?, ?&gt; builder = (retryConfig.isStateless()) ? RetryInterceptorBuilder.stateless()</span><br><span class="line">: RetryInterceptorBuilder.stateful();</span><br><span class="line">RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplateFactory(<span class="keyword">this</span>.retryTemplateCustomizers)</span><br><span class="line">.createRetryTemplate(retryConfig, RabbitRetryTemplateCustomizer.Target.LISTENER);</span><br><span class="line">builder.retryOperations(retryTemplate);</span><br><span class="line">MessageRecoverer recoverer = (<span class="keyword">this</span>.messageRecoverer != <span class="keyword">null</span>) ? <span class="keyword">this</span>.messageRecoverer</span><br><span class="line">: <span class="keyword">new</span> RejectAndDontRequeueRecoverer(); <span class="comment">//&lt;1&gt;</span></span><br><span class="line">builder.recoverer(recoverer);</span><br><span class="line">factory.setAdviceChain(builder.build());</span><br></pre></td></tr></table></figure><p>注意看&lt;1&gt;处的代码，默认使用的是RejectAndDontRequeueRecoverer实现类，根据实现类的名字我们就可以看出来该实现类的作用就是拒绝并且不会将消息重新发回队列，我们可以看一下这个实现类的具体内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectAndDontRequeueRecoverer</span> <span class="keyword">implements</span> <span class="title">MessageRecoverer</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Log logger = LogFactory.getLog(RejectAndDontRequeueRecoverer.class); <span class="comment">// NOSONAR protected</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(Message message, Throwable cause)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(<span class="string">&quot;Retries exhausted for message &quot;</span> + message, cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(<span class="string">&quot;Retry Policy Exhausted&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> AmqpRejectAndDontRequeueException(cause), message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源码给出了异常的来源，但是未看到拒绝消息的代码，猜测应该是使用aop的方式实现的，此处不再继续深究。</p><p>MessageRecoverer接口还有另外两个实现类，分别是<strong>RepublishMessageRecoverer</strong>和<strong>ImmediateRequeueMessageRecoverer</strong>，顾名思义就是重新发布消息和立即重新返回队列，下面我们分别测试一个这两个实现类：</p><h3 id="RepublishMessageRecoverer"><a href="#RepublishMessageRecoverer" class="headerlink" title="RepublishMessageRecoverer"></a>RepublishMessageRecoverer</h3><p>先创建一个异常交换机和异常队列，并将两者进行绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">errorExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;error-exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">errorQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;error-queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorExchange)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorExchange).with(<span class="string">&quot;error-routing-key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建RepublishMessageRecoverer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">messageRecoverer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RepublishMessageRecoverer(rabbitTemplate,<span class="string">&quot;error-exchange&quot;</span>,<span class="string">&quot;error-routing-key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动服务，查看处理结果：</p><p><a href="https://img2020.cnblogs.com/blog/2159277/202009/2159277-20200918142342030-85649685.png"><img src="https://img2020.cnblogs.com/blog/2159277/202009/2159277-20200918142342030-85649685.png" alt="img"></a></p><p>通过控制台可以看到，消息重试5次以后直接以新的routingKey发送到了配置的交换机中，此时再查看监控页面，可以看原始队列中已经没有消息了，但是配置的异常队列中存在一条消息。</p><p><img src="/2020/12/10/Spring-boot-amqp%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142352326-326808881.png" alt="img"></p><p>再测试一下ImmediateRequeueMessageRecoverer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">messageRecoverer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ImmediateRequeueMessageRecoverer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/10/Spring-boot-amqp%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142500644-1269082311.png" alt="img"></p><p>重试5次之后，返回队列，然后再重试5次，周而复始直到不抛出异常为止，这样还是会影响后续的消息消费。</p><blockquote><p>总结：</p><p>通过上面的测试，对于重试之后仍然异常的消息，可以采用RepublishMessageRecoverer，将消息发送到其他的队列中，再专门针对新的队列进行处理。</p></blockquote><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>除了可以采用上述RepublishMessageRecoverer，还可以采用死信队列的方式处理重试失败的消息。</p><p>首先创建死信交换机、死信队列以及两者的绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">dlxExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(dlxExchangeName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">dlxQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(dlxQueueName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列绑定死信交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dlxQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dlxExchange</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">dlcBinding</span><span class="params">(Queue dlxQueue, DirectExchange dlxExchange)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(dlxRoutingKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务队列的创建需要做一些修改，添加死信交换机以及死信路由键的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">Map&lt;String,Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,dlxExchangeName);<span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,dlxRoutingKey);<span class="comment">//声明当前队列的死信路由键</span></span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(queueName).withArguments(params).build();</span><br><span class="line">    <span class="comment">//return new Queue(queueName,true);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动服务，可以看到同时创建了业务队列以及死信队列</p><p><img src="/2020/12/10/Spring-boot-amqp%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142520353-1806232438.png" alt="img"></p><p>在业务队列上出现了DLX以及DLK的标识，标识已经绑定了死信交换机以及死信路由键，此时调用生产者发送消息，消费者在重试5次后，由于MessageCover默认的实现类是RejectAndDontRequeueRecoverer，也就是requeue=false，又因为业务队列绑定了死信队列，因此消息会从业务队列中删除，同时发送到死信队列中。</p><blockquote><p>注意：</p><p>如果ack模式是手动ack，那么需要调用channe.nack方法，同时设置requeue=false才会将异常消息发送到死信队列中</p></blockquote><h2 id="retry使用场景"><a href="#retry使用场景" class="headerlink" title="retry使用场景"></a>retry使用场景</h2><p>上面说了什么是重试，以及如何解决重试造成的数据丢失，那么怎么来选择重试的使用场景呢？</p><p>是否是消费者只要发生异常就要去重试呢？其实不然，假设下面的两个场景：</p><ul><li>http下载视频或者图片或者调用第三方接口</li><li>空指针异常或者类型转换异常（其他的受检查的运行时异常）</li></ul><p>很显然，第一种情况有重试的意义，第二种没有。</p><p>对于第一种情况，由于网络波动等原因造成请求失败，重试是有意义的；</p><p>对于第二种情况，需要修改代码才能解决的问题，重试也没有意义，需要的是记录日志以及人工处理或者轮询任务的方式去处理。</p><h2 id="retry最佳实践"><a href="#retry最佳实践" class="headerlink" title="retry最佳实践"></a>retry最佳实践</h2><p>对于消费端异常的消息，如果在有限次重试过程中消费成功是最好的，如果有限次重试之后仍然失败的消息，不管是采用RejectAndDontRequeueRecoverer还是使用私信队列都是可以的，同时也可以采用折中的方法，先将消息从业务队列中ack掉，再将消息发送到另外的一个队列中，后续再单独处理异常数据的队列。</p><p>另外，看到有人说retry只能在自动ack模式下使用，经过测试在手动ack模式下retry也是生效的，只不过不能使用catch捕获异常，即使在自动ack模式下使用catch捕获异常也是会导致不触发重试的。当然，在手动ackm模式下要记得确认消息，不管是确认消费成功还是确认消费失败，不然消息会一直处于unack状态，直到消费者进程重启或者停止。</p><p>如果一定要在手动ack模式下使用retry功能，最好还是确认在有限次重试过程中可以重试成功，否则超过重试次数，又没办法执行nack，就会出现消息一直处于unack的问题，我想这也就是所说的retry只能在自动ack模式下使用的原因，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;platform.queue-name&#125;&quot;&#125;,concurrency = &quot;1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgConsumer</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;接收到消息&gt;&gt;&gt;&#123;&#125;&quot;</span>,msg);</span><br><span class="line"><span class="keyword">if</span>(msg.indexOf(<span class="string">&quot;0&quot;</span>)&gt;-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">&quot;消息&#123;&#125;消费成功&quot;</span>,msg);</span><br><span class="line">channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之死信队列</title>
      <link href="2020/12/09/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
      <url>2020/12/09/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="死信交换机，死信队列"><a href="#死信交换机，死信队列" class="headerlink" title="死信交换机，死信队列"></a>死信交换机，死信队列</h2><p>DLX 全称（Dead-Letter-Exchange）,称之为死信交换器，当消息变成一个<strong>死信</strong>之后，如果这个消息所在的队列存在<strong>x-dead-letter-exchange</strong>参数，那么它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，与这个死信交换器绑定的队列就是死信队列。</p><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p>在RabbitMQ中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。</p><h2 id="死信消息"><a href="#死信消息" class="headerlink" title="死信消息"></a><strong>死信消息</strong></h2><ol><li>消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false</li><li>消息过期了</li><li>队列达到最大的长度(x-max-length)</li></ol><h2 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h2><ol><li>创建队列的时候绑定死信参数：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx-exchange&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlK-routingKey&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(queue, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params); <span class="comment">//若不存在应该是会创建Queue</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>设置过期时间（TTL）</p><ul><li><p>设置队列中消息的过期时间（所有消息的过期时间都是一样）<strong>将消息的TTL值设置为0，意味着消息到达队列后将会立即过期不会被队列保存，除非消息能够被立即传递给消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(q_name, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map); <span class="comment">//原生jar</span></span><br></pre></td></tr></table></figure></li><li><p>设置单个消息的过期时间（可以设置每个消息的过期时间不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Spring</span></span><br><span class="line"><span class="keyword">this</span>.rabbitTemplate</span><br><span class="line">    .convertAndSend(orderStatusUpdateExchange, orderStatusUpdateKey, orderMessage, message -&gt; &#123;</span><br><span class="line">        message.getMessageProperties().setExpiration(expiration);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//原生jar</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                .expiration(<span class="string">&quot;6000&quot;</span>) <span class="comment">//设置TTL 毫秒</span></span><br><span class="line">                .build();</span><br><span class="line">channel.basicPublish(my-exchange, routing-key, properties, <span class="string">&quot;msg&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>设置队列过期（队列设置TTL过期后会被删除，但是不能保证实时被删除）该值决定了队列不再被使用后直到被自动删除的时长。<strong>不再使用的意思是队列没有订阅的消费者，队列最近没有被重新声明，并且在过期时间basic.get方法没有被调用</strong>。比如，在通过RabbitMQ实现RPC调用时，会生成大量的回复队列。<strong>服务器保证如果队列在最近的过期时间内没有被使用，那么该队列将会被删除。但是不保证在过期后能够以多快的速度删除</strong>。当服务器重启时，队列的租期重新开始计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;x-expires&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(q_name, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="死信注意点"><a href="#死信注意点" class="headerlink" title="死信注意点"></a>死信注意点</h2><blockquote><p>Caveats<br>Queues that had a per-message TTL applied to them retroactively (when they already had messages) will discard the messages when specific events occur. Only when expired messages reach the head of a queue will they actually be discarded (or dead-lettered). Consumers will not have expired messages delivered to them. Keep in mind that there can be a natural race condition between message expiration and consumer delivery, e.g. a message can expire after it was written to the socket but before it has reached a consumer.<br>When setting per-message TTL expired messages can queue up behind non-expired ones until the latter are consumed or expired. Hence resources used by such expired messages will not be freed, and they will be counted in queue statistics (e.g. the number of messages in the queue).<br>When retroactively applying a per-message TTL policy, it is recommended to have consumers online to make sure the messages are discarded quicker.<br>Given this behaviour of per-message TTL settings on existing queues, when the need to delete messages to free up resources arises, queue TTL should be used instead (or queue purging, or queue deletion).</p></blockquote><p><strong>注意事项</strong><br>当队列中已有消息，并设置消息的TTL，那么会追溯设置消息的有效期，当在特定情况下将会丢弃这些消息。**只有当过期消息到达队列的头部时，它们才会被真实地丢弃(或死信路由)**。消费者将不会接收到过期的消息，但是消息的传递和有效期有天然的竞争关系。比如，一个消息在被写入到socket但还未到达消费者时过期。</p><p>当设置了TTL过期时间的消息，可以在未过期消息后面排队，直到后者被消费或者过期。因此，被过期消息使用的资源并不会被释放，它们也会被队列的统计记入(比如，队列中消息的数量)。</p><p>当回溯地设置消息的TTL策略时，建议有消费者同时在线，可以保证消息的尽快丢弃。</p><p>考虑到给已存在的队列设置消息的TTL，来实现删除消息释放资源。设置队列的TTL（或队列清空，队列删除）应该替代这种方式</p><p><strong>测试</strong>：</p><ol><li>可以看出这次是正常发送，正常消费</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.036</span>， 消息内容：<span class="number">798</span></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.039</span>， 消息内容：<span class="number">456</span></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.039</span>， 消息内容：<span class="number">123</span></span><br><span class="line">2020-07-02 15:03:35.116  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br><span class="line">2020-07-02 15:03:39.054  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:03:44.055  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>可以看出消息正常发出，但是过了10s同时被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.654</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.654</span>， 消息内容：<span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.655</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.655</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.655</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.655</span>， 消息内容：<span class="number">798</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:05:55.665  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line">2020-07-02 15:05:55.666  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:05:55.666  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br></pre></td></tr></table></figure><ol start="3"><li>可以看出过了5秒第一次被消费，再过5秒后后两条消息同时被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.929</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.929</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.931</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.931</span>， 消息内容：<span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.931</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.931</span>， 消息内容：<span class="number">798</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:11:31.928  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:11:36.946  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line">2020-07-02 15:11:36.947  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br></pre></td></tr></table></figure><ol start="4"><li>可以看出过了5秒前两条消息同时被消费，再过了5秒最后一条消息被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.818</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.818</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.821</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.821</span>， 消息内容：<span class="number">798</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.821</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.821</span>， 消息内容：<span class="number">123</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:12:32.834  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:12:32.834  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br><span class="line">2020-07-02 15:12:37.837  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br></pre></td></tr></table></figure><p><font color="red">可以看出应该就是只有消息队列头的消息被消费后，过期的消息才会被消费。</font></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>安装一个插件即可：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedRabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delay.queue.demo.delay.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delay.queue.demo.delay.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.delay.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">immediateQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">customExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingNotify</span><span class="params">(<span class="meta">@Qualifier(&quot;immediateQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;customExchange&quot;)</span> CustomExchange customExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息生产者的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayMsg</span><span class="params">(String msg, Integer delayTime)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, a -&gt;&#123;</span><br><span class="line">        a.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,延时队列收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/m0_37801313/article/details/107084076">RabbitMq 死信消息的过期时间的不同 会导致消费延时</a></p><p><a href="https://www.cnblogs.com/mfrank/p/11260355.html">【RabbitMQ】一文带你搞定RabbitMQ延迟队列</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之消息可靠性处理</title>
      <link href="2020/12/09/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/"/>
      <url>2020/12/09/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么做到消息不丢失（可靠性）"><a href="#怎么做到消息不丢失（可靠性）" class="headerlink" title="怎么做到消息不丢失（可靠性）"></a>怎么做到消息不丢失（可靠性）</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a><strong>持久化</strong></h3><ul><li><p>exchange要持久化</p></li><li><p>queue要持久化</p></li><li><p>message要持久化</p><h3 id="消息确认（producer回调，consumer手动消费确认）"><a href="#消息确认（producer回调，consumer手动消费确认）" class="headerlink" title="消息确认（producer回调，consumer手动消费确认）"></a>消息确认（producer回调，consumer手动消费确认）</h3></li><li><p>生产者发送消息开启确认confirm机制：如果消息没有到达交换机,则该方法中isSuccess = false,error为错误信息; 如果消息正确到达交换机,则该方法中isSuccess = true;</p></li><li><p>生产者发送消息开启返回returnedMessage机制：消息从交换机成功到达队列，则returnedMessage方法不会执行; 消息从交换机未能成功到达队列，则returnedMessage方法会执行;</p></li><li><p>生产者发送消息开启事务，同步操作，直到入队列之后才会结束，影响性能。（一般不用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.transaction.RabbitTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">// @Transactional //开启事务</span><br></pre></td></tr></table></figure></li><li><p>消费者开启手动确认模式：只有手动确认返回，才删除队列里的数据，需要注意幂等性。</p></li></ul><h2 id="实现消息的失败重试"><a href="#实现消息的失败重试" class="headerlink" title="实现消息的失败重试"></a>实现消息的失败重试</h2><h4 id="生产者发送失败重试"><a href="#生产者发送失败重试" class="headerlink" title="生产者发送失败重试"></a>生产者发送失败重试</h4><p><strong>开启确认机制</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#旧版本已过期可以设置为：publisher-confirm-type=correlated 确认消息已发送到交换机选择确认类型为交互</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>确认机制代码处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitTemplateConfig</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>,<span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);            <span class="comment">//指定 ConfirmCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);             <span class="comment">//指定 ReturnCallback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息是否发送到了交换机，ack为结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息唯一标识：&quot;</span>+correlationData);</span><br><span class="line">        System.out.println(<span class="string">&quot;确认结果：&quot;</span>+ack);</span><br><span class="line">        System.out.println(<span class="string">&quot;失败原因：&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息未从交换机到达队列执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体 message : &quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体 message : &quot;</span>+replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;描述：&quot;</span>+replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的交换器 exchange : &quot;</span>+exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的路由键 routing : &quot;</span>+routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心逻辑在二个回调方法中</strong></p><ul><li><strong>发送消息异常</strong>，即可能没有连接上RabbitMQ，此时可以通过定时任务Job去重试</li><li><strong>确认回调确定消息发送失败</strong>，可以记录发送结果在Redis中，直接再次重新发送消息入队列</li><li>还有一种情况就是，发送连接超时这种情况，需要存入Redis，扫描继续发送,或者存入文件中，可以设计二块区域，满了之后刷新到磁盘中</li><li><strong>总结</strong>：redis中保存message，可以先收到回调之后自动发送记录发送次数，超过如5次之后，使用定时任务阶梯时间发送消息入队列</li></ul><h4 id="消费者处理失败重试（可阶梯延时处理或重试）"><a href="#消费者处理失败重试（可阶梯延时处理或重试）" class="headerlink" title="消费者处理失败重试（可阶梯延时处理或重试）"></a>消费者处理失败重试（可阶梯延时处理或重试）</h4><h5 id="简单重试（手动确认）"><a href="#简单重试（手动确认）" class="headerlink" title="简单重试（手动确认）"></a>简单重试（手动确认）</h5><p>spring还封装了消费重试机制，可以做到阶段重试</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="comment">#NONE：自动确认 AUTO：根据情况确认 MANUAL：手动确认</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>AcknowledgeMode使用AUTO时，它会根据方法的执行情况来决定是否确认还是拒绝（是否重新入queue）</p><ul><li>如果消息成功被消费（成功的意思是在消费的过程中没有抛出异常），则自动确认</li><li>当抛出 AmqpRejectAndDontRequeueException 异常的时候，则消息会被拒绝，且 requeue = false（不重新入队列）</li><li>当抛出 ImmediateAcknowledgeAmqpException 异常，则消费者会被确认</li><li>其他的异常，则消息会被拒绝，且 requeue = true（如果此时只有一个消费者监听该队列，则有发生死循环的风险，多消费端也会造成资源的极大浪费，这个在开发过程中一定要避免的）。可以通过 setDefaultRequeueRejected（默认是true）去设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二种监听处理方式</span></span><br><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">    bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(exchange = @Exchange(value = &quot;$&#123;order.order-status.update.dlx.exchange&#125;&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;$&#123;order.order-status.update.dlx.key&#125;&quot;,</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;$&#123;order.order-status.update.dlx.queue&#125;&quot;, durable = &quot;true&quot;))&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(String message,Channel channel,<span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(tag,<span class="keyword">false</span>);            <span class="comment">// 确认消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局处理消息</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>);              <span class="comment">// 监听的队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL);        <span class="comment">// 手动确认</span></span><br><span class="line">    container.setMessageListener((ChannelAwareMessageListener) (message, channel) -&gt; &#123;      <span class="comment">//消息处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="keyword">if</span>(message.getMessageProperties().getHeaders().get(<span class="string">&quot;error&quot;</span>) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息已经确认&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);</span></span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息拒绝&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="阶梯重试（考虑幂等性）"><a href="#阶梯重试（考虑幂等性）" class="headerlink" title="阶梯重试（考虑幂等性）"></a>阶梯重试（考虑幂等性）</h5><ol><li>消息生产者将消息发送到普通队列，消费者接受到后进行处理；</li><li>若处理失败，将该消息发送到缓冲队列；</li><li>消息在队列到期后会自动的被发送到普通队列，再次消费。<br><img src="/2020/12/09/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/20190113192348240.png" alt="在这里插入图片描述"></li></ol><h2 id="极端情况下需要重试"><a href="#极端情况下需要重试" class="headerlink" title="极端情况下需要重试"></a>极端情况下需要重试</h2><p>网络情况，导致未回调，生产端并不知道是否已发送成功，此时需要确认是否触发重试机制。</p><p><a href="https://blog.csdn.net/qianshangding0708/article/details/90255684?spm=1001.2014.3001.5501">RabbitMQ保障消息 100% 投递成功方案</a></p><p>文章中通过消息补偿机制，再次发送消息，需要做幂等处理。通过数据库和MQ还可以通过Redis，进行重试</p><h2 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h2><p>消息中心的消息追踪需要使用 Trace 实现，Trace 是 Rabbitmq 用于记录每一次发送的消息，方便使用 Rabbitmq 的开发者调试、排错。可通过插件形式提供可视化界面。Trace 启动后会自动创建系统 Exchange：amq.rabbitmq.trace ,每个队列会自动绑定该 Exchange，绑定后发送到队列的消息都会记录到 Trace 日志。</p><h3 id="消息开启"><a href="#消息开启" class="headerlink" title="消息开启"></a>消息开启</h3><p>需要先 用rabbitmq 启用插件，再打开开关才能使用</p><table><thead><tr><th>命令集</th><th>描述</th></tr></thead><tbody><tr><td>rabbitmq-plugins list</td><td>查看插件列表</td></tr><tr><td>rabbitmq-plugins enable rabbitmq_tracing</td><td>rabbitmq 启用 trace 插件</td></tr><tr><td>rabbitmqctl trace_on</td><td>打开 trace 的开关</td></tr><tr><td>rabbitmqctl trace_on -p huali</td><td>打开 trace 的开关(huali为需要日志追踪的 vhost)</td></tr><tr><td>rabbitmqctl trace_off</td><td>关闭 trace 的开关</td></tr><tr><td>rabbitmq-plugins disable rabbitmq_tracing</td><td>rabbitmq 关闭 Trace 插件</td></tr><tr><td>rabbitmqctl set_user_tags heima administrator</td><td>只有 administrator 的角色才能查看日志界面</td></tr></tbody></table><p>安装插件并开启 trace_on 之后，会发现多个 exchange：amq.rabbitmq.trace ，类型为：topic。<br><img src="/2020/12/09/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/20201104111658326.png" alt="在这里插入图片描述"><br><img src="/2020/12/09/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/20201104111750995.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之management管理端详解</title>
      <link href="2020/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8Bmanagement%E7%AE%A1%E7%90%86%E7%AB%AF%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%B9%8Bmanagement%E7%AE%A1%E7%90%86%E7%AB%AF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.csdn.net/qq_27409289">坑里水库</a></p><p>出处：<a href="https://blog.csdn.net/qq_27409289/article/details/89510687">https://blog.csdn.net/qq_27409289/article/details/89510687</a></p><p><a href="https://link.jianshu.com/?t=https://github.com/rabbitmq/rabbitmq-management">rabbitmq-management</a>是RabbitMq web管理端，用的是erlang的cowboy框架进行开发。web页面包括Overview(概述)、Connections(连接)、Channels(通道)、Exchanges(交换器)、Queues(队列)、Admin(用户管理)</p><h2 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview(概述)"></a>Overview(概述)</h2><h3 id="overview-gt-Totals"><a href="#overview-gt-Totals" class="headerlink" title="overview-&gt;Totals"></a>overview-&gt;Totals</h3><p>Ready：待消费的消息总数。<br>Unacked：待应答的消息总数。<br>Total：总数 Ready+Unacked。</p><p>所有队列的消费情况。速率=(num1-num0)/(s1-s0) num1：s1时刻的个数。num0：s0时刻的个数。</p><p>Publish：producter pub消息的速率。<br>Publisher confirm：broker确认pub消息的速率。<br>Deliver(manual ack)：customer手动确认的速率。<br>Deliver( auto ack)：customer自动确认的速率。<br>Consumer ack：customer正在确认的速率。<br>Redelivered：正在传递’redelivered’标志集的消息的速率。<br>Get (manual ack)：响应basic.get而要求确认的消息的传输速率。<br>Get (auto ack)：响应于basic.get而发送不需要确认的消息的速率。<br>Return：将basic.return发送给producter的速率。<br>Disk read：queue从磁盘读取消息的速率。<br>Disk write：queue从磁盘写入消息的速率。</p><p>整体角色的个数</p><p>Connections：client的tcp连接的总数。<br>Channels：通道的总数。<br>Exchange：交换器的总数。<br>Queues：队列的总数。<br>Consumers：消费者的总数。</p><h3 id="Overview-gt-Nodes"><a href="#Overview-gt-Nodes" class="headerlink" title="Overview-&gt;Nodes"></a>Overview-&gt;Nodes</h3><p>broker的属性</p><p>Name：broker名称<br>File descriptors：broker打开的文件描述符和限制。<br>Socket descriptors：broker管理的网络套接字数量和限制。当限制被耗尽时，RabbitMQ将停止接受新的网络连接。<br>Erlang processes：erlang启动的进程数。<br>Memory：当前broker占用的内存。<br>Disk space：当前broker占用的硬盘。<br>Uptime：当前broker持续运行的时长。<br>Info：未知。<br>Reset stats：未知。</p><h3 id="Overview-gt-Export-definitions"><a href="#Overview-gt-Export-definitions" class="headerlink" title="Overview-&gt;Export definitions"></a>Overview-&gt;Export definitions</h3><p>定义由用户，虚拟主机，权限，参数，交换，队列和绑定组成。 它们不包括队列的内容或集群名称。 独占队列不会被导出。</p><h3 id="Overview-gt-Export-definitions-1"><a href="#Overview-gt-Export-definitions-1" class="headerlink" title="Overview-&gt;Export definitions"></a>Overview-&gt;Export definitions</h3><p>导入的定义将与当前定义合并。 如果在导入过程中发生错误，则所做的任何更改都不会回滚。</p><h2 id="Connections（当前所有客户端活动的连接。包括生成者和消费者）"><a href="#Connections（当前所有客户端活动的连接。包括生成者和消费者）" class="headerlink" title="Connections（当前所有客户端活动的连接。包括生成者和消费者）"></a>Connections（当前所有客户端活动的连接。包括生成者和消费者）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>User name：使用的用户名。<br>State：当前的状态，running：运行中；idle：空闲。<br>SSL/TLS：是否使用ssl进行连接。<br>Protocol：使用的协议。<br>Channels：创建的channel的总数。<br>From client：每秒发出的数据包。<br>To client：每秒收到的数据包。</p><h2 id="Channels（当前连接所有创建的通道）"><a href="#Channels（当前连接所有创建的通道）" class="headerlink" title="Channels（当前连接所有创建的通道）"></a>Channels（当前连接所有创建的通道）</h2><p>channel：名称。<br>Virtual host：所属的虚拟主机。<br>User name：使用的用户名。<br>Mode：渠道保证模式。 可以是以下之一，或者不是：C: confirm。T：transactional(事务)。<br>State ：当前的状态，running：运行中；idle：空闲。<br>Unconfirmed：待confirm的消息总数。<br>Prefetch：设置的prefetch的个数。<br>Unacker：待ack的消息总数。<br>publish：producter pub消息的速率。<br>confirm：producter confirm消息的速率。<br>deliver/get：consumer 获取消息的速率。<br>ack：consumer ack消息的速率。</p><h2 id="Exchanges（交换器属性）"><a href="#Exchanges（交换器属性）" class="headerlink" title="Exchanges（交换器属性）"></a>Exchanges（交换器属性）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>Type：exchange type，具体的type可以查看<a href="https://www.jianshu.com/p/5319b06f2e80">RabbitMq系列之一：基础概念</a>。<br>Features：功能。 可以是以下之一，或者不是：D: 持久化。T：Internal，存在改功能表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定，否则可以推送消息也可以绑定。<br>Message rate in：消息进入的速率。<br>Message rate out：消息出去的速率。</p><h2 id="Queues（队列的属性）"><a href="#Queues（队列的属性）" class="headerlink" title="Queues（队列的属性）"></a>Queues（队列的属性）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>Features：功能。 可以是以下之一，或者不是：D: 持久化。<br>State：当前的状态，running：运行中；idle：空闲。<br>Ready：待消费的消息总数。<br>Unacked：待应答的消息总数。<br>Total：总数 Ready+Unacked。<br>incoming：消息进入的速率。<br>deliver/get：消息获取的速率。<br>ack：消息应答的速率。</p><h2 id="Admin（用户属性）"><a href="#Admin（用户属性）" class="headerlink" title="Admin（用户属性）"></a>Admin（用户属性）</h2><p>Name：名称。<br>Tags：角色标签，只能选取一个。<br>Can access virtual hosts：允许进入的vhost。<br>Has password：设置了密码。</p><p>tags(原链接:<a href="https://link.jianshu.com/?t=https://www.cnblogs.com/java-zhao/p/5670476.html">https://www.cnblogs.com/java-zhao/p/5670476.html</a>)</p><ul><li>administrator (超级管理员)<br>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li><li>monitoring(监控者)<br>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li>policymaker(策略制定者)<br>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。</li><li>management(普通管理者)<br>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</li><li>none(其他)<br>无法登陆管理控制台，通常就是普通的生产者和消费者。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（九）之堆排序</title>
      <link href="2020/12/08/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2020/12/08/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>借助于二叉堆。使用二叉堆还实现了优先级队列，出队列的永远是最大优先级的数据即删除节点，入队列上浮即插入节点。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ol><li>把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。 </li><li>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。</li></ol><p>第1步，把无序数组构建成二叉堆，这一步的时间复杂度是O(n)。<br>第2步，需要进行n-1次循环。每次循环调用一次downAdjust方法，所以第2步的计算规模是 (n-1)×logn ，时间复杂度为O(nlogn)。<br>两个步骤是并列关系，所以整体的时间复杂度是O(nlogn)。</p><h2 id="堆排序和快速排序区别"><a href="#堆排序和快速排序区别" class="headerlink" title="堆排序和快速排序区别"></a>堆排序和快速排序区别</h2><p>相同点，堆排序和快速排序的平均时间复杂度都是O(nlogn)，并且都是不稳定排序。至于不同点，快速排序的最坏时间复杂度是O(n2)，而堆排序的最坏时间复杂度稳定在O(nlogn)。 </p><p>快速排序递归和非递归方法的平均空间复杂度都是O(logn)，而堆排序的空间复杂度是O(1)。 </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array       待调整的堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex 要“下沉”的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length      堆的有效大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">  <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">  <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">    <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">      childIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果父节点大于任何一个孩子的值，则直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">    array[parentIndex] = array[childIndex];</span><br><span class="line">    parentIndex = childIndex;</span><br><span class="line">    childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序（升序） * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 把无序数组构建成最大堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    downAdjust(array, i, array.length);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(Arrays.toString(array));</span><br><span class="line">  <span class="comment">// 循环删除堆顶元素，移到集合尾部，调整堆产生新的堆顶</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 最后1个元素和第1个元素进行交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[<span class="number">0</span>];</span><br><span class="line">    array[<span class="number">0</span>] = temp;</span><br><span class="line">    <span class="comment">// “下沉”调整最大堆</span></span><br><span class="line">    downAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  heapSort(arr);</span><br><span class="line">  System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux发送http请求</title>
      <link href="2020/12/04/Linux%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/"/>
      <url>2020/12/04/Linux%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/kaleidoscope/">kaleidoscopic</a></p><p>出处：<a href="https://www.cnblogs.com/kaleidoscope/p/9719841.html">https://www.cnblogs.com/kaleidoscope/p/9719841.html</a></p><h2 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h2><h3 id="curl命令模拟Get请求："><a href="#curl命令模拟Get请求：" class="headerlink" title="curl命令模拟Get请求："></a>curl命令模拟Get请求：</h3><p>1、使用curl命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://www.baidu.com&quot;     如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span><br><span class="line">curl -i &quot;http://www.baidu.com&quot;  显示全部信息</span><br><span class="line">curl -I &quot;http://www.baidu.com&quot;  只显示头部信息</span><br><span class="line">curl -v &quot;http://www.baidu.com&quot;  显示get请求全过程解析</span><br></pre></td></tr></table></figure><p>2、使用wget命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;http://www.baidu.com&quot;</span><br></pre></td></tr></table></figure><h3 id="curl命令模拟Get请求携带参数（linux）："><a href="#curl命令模拟Get请求携带参数（linux）：" class="headerlink" title="curl命令模拟Get请求携带参数（linux）："></a>curl命令模拟Get请求携带参数（linux）：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com</span><br></pre></td></tr></table></figure><p>上述命令在linux系统，get请求携带的参数只到version=1，”&amp;”符号在linux系统中为后台运行的操作符，此处需要使用反斜杠”\”转义，即：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://127.0.0.1:80/xcloud/test?version=1\&amp;client_version=1.1.0\&amp;seq=1001\&amp;host=aaa.com</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com&quot;</span><br></pre></td></tr></table></figure><h2 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h2><p>1、使用curl命令，通过-d参数，把访问参数放在里面，如果没有参数，则不需要-d，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;username=user1&amp;password=123&quot; &quot;www.test.com/login&quot;</span><br></pre></td></tr></table></figure><p>2、使用wget命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget –post-data &#x27;username=user1&amp;password=123&#x27; http://www.baidu.com</span><br></pre></td></tr></table></figure><p>3、发送格式化json请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -k -H &quot;Content-type: application/json&quot; -X POST -d &#x27;&#123;&quot;version&quot;:&quot;6.6.0&quot;, &quot;from&quot;:&quot;mu&quot;, &quot;product_version&quot;:&quot;1.1.1.0&quot;&#125;&#x27; https://10.10.10.10:80/test</span><br></pre></td></tr></table></figure><h2 id="curl和wget区别"><a href="#curl和wget区别" class="headerlink" title="curl和wget区别"></a>curl和wget区别</h2><p>curl模拟的访问请求一般直接在控制台显示，而wget则把结果保存为一个文件。如果结果内容比较少，需要直接看到结果可以考虑使用curl进行模拟请求，如果返回结果比较多，则可考虑wget进行模拟请求。</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（八）之快速排序</title>
      <link href="2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快排原理"><a href="#快排原理" class="headerlink" title="快排原理"></a>快排原理</h2><ol><li>随机选择一个元素作为基准元素（pivot），并且让基准元素和数列首元素交换位置。解决最大值或最小值本身就是第一个元素，退化成O(n^2^)。</li><li>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。</li></ol><p>虽然快速排序的平均时间复杂度是O(nlogn)，但最坏情况下的时间复杂度是O(n^2^)。</p><h2 id="元素的交换"><a href="#元素的交换" class="headerlink" title="元素的交换"></a>元素的交换</h2><ul><li>双边循环法。</li><li>单边循环法</li></ul><h4 id="双边循环法"><a href="#双边循环法" class="headerlink" title="双边循环法"></a>双边循环法</h4><p><strong>原则</strong>：</p><ol><li>选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。<img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207112907329.png" alt="image-20201207112907329" style="zoom: 50%;"></li><li>从right指针开始，让指针所指向的元素和基准元素做比较。如果大于或等于pivot，则指针向左移动；如果小于pivot，则right指针停止移动，切换到left指针。 <img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207132506437.png" alt="image-20201207132506437" style="zoom:50%;"></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex&gt;=endIndex)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition(arrays, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort(arrays,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">    quickSort(arrays,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arrays[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line">    <span class="keyword">while</span> (left!=right)&#123;</span><br><span class="line">      <span class="comment">//控制right 指针比较并左移</span></span><br><span class="line">      <span class="keyword">while</span> (left&lt;right &amp;&amp; arrays[right]&gt;pivot)&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">      <span class="keyword">while</span> (left&lt;right &amp;&amp; arrays[left]&lt;=pivot)&#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//交换left和right 指针所指向的元素</span></span><br><span class="line">      <span class="keyword">if</span>(right&gt;left)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arrays[right];</span><br><span class="line">        arrays[right] = arrays[left];</span><br><span class="line">        arrays[left] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pivot 和指针重合点交换</span></span><br><span class="line">    arrays[startIndex] = arrays[left];</span><br><span class="line">    arrays[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="单边循环法"><a href="#单边循环法" class="headerlink" title="单边循环法"></a>单边循环法</h4><p><strong>原理</strong>：</p><ol><li>首先选定基准元素pivot。同时，设置一个mark指针指向数列起始位置，这个mark指针代表小于基准元素的区域边界<img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207135733083.png" alt="image-20201207135733083" style="zoom:50%;"></li><li>如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1；第二，让最新遍历到的元素和mark指针所 在位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。 <img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207135924557.png" alt="image-20201207135924557" style="zoom:50%;"></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex&gt;=endIndex)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition2(arrays, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort2(arrays,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">    quickSort2(arrays,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arrays[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= startIndex+<span class="number">1</span>;i&lt;=endIndex;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrays[i]&lt; pivot)&#123;</span><br><span class="line">        mark++;</span><br><span class="line">        <span class="keyword">int</span> temp = arrays[mark];</span><br><span class="line">        arrays[mark] = arrays[i];</span><br><span class="line">        arrays[i] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arrays[startIndex] = arrays[mark];</span><br><span class="line">    arrays[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用一个集合栈来代替递归的函数栈 </span></span><br><span class="line">  Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">  <span class="comment">// 整个数列的起止下标，以哈希的形式入栈 </span></span><br><span class="line">  Map rootParam = <span class="keyword">new</span> HashMap();</span><br><span class="line">  rootParam.put(<span class="string">&quot;startIndex&quot;</span>, startIndex);</span><br><span class="line">  rootParam.put(<span class="string">&quot;endIndex&quot;</span>, endIndex);</span><br><span class="line">  quickSortStack.push(rootParam);</span><br><span class="line">  <span class="comment">// 循环结束条件：栈为空时 </span></span><br><span class="line">  <span class="keyword">while</span> (!quickSortStack.isEmpty()) &#123; </span><br><span class="line">    <span class="comment">// 栈顶元素出栈，得到起止下标 </span></span><br><span class="line">    Map&lt;String, Integer&gt; param = quickSortStack.pop(); </span><br><span class="line">    <span class="comment">// 得到基准元素位置 </span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, param.get(<span class="string">&quot;startIndex&quot;</span>), param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">    <span class="comment">// 根据基准元素分成两部分, 把每一部分的起止下标入栈 </span></span><br><span class="line">    <span class="keyword">if</span> (param.get(<span class="string">&quot;startIndex&quot;</span>) &lt; pivotIndex - <span class="number">1</span>) &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">      leftParam.put(<span class="string">&quot;startIndex&quot;</span>, param.get(<span class="string">&quot;startIndex&quot;</span>));</span><br><span class="line">      leftParam.put(<span class="string">&quot;endIndex&quot;</span>, pivotIndex - <span class="number">1</span>);</span><br><span class="line">      quickSortStack.push(leftParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pivotIndex + <span class="number">1</span> &lt; param.get(<span class="string">&quot;endIndex&quot;</span>)) &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">      rightParam.put(<span class="string">&quot;startIndex&quot;</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">      rightParam.put(<span class="string">&quot;endIndex&quot;</span>, param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">      quickSortStack.push(rightParam);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（七）之排序算法</title>
      <link href="2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法时间复杂度对比"><a href="#排序算法时间复杂度对比" class="headerlink" title="排序算法时间复杂度对比"></a>排序算法时间复杂度对比</h2><table><thead><tr><th>排序算法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2^)</td></tr><tr><td>选择排序</td><td>O(n^2^)</td></tr><tr><td>插入排序</td><td>O(n^2^)</td></tr><tr><td>希尔排序</td><td>性能略优于O(n^2^),但又比不上O(nlog<del>2</del>n)</td></tr><tr><td>快速排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>归并排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>堆排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>计数排序</td><td>O(n)</td></tr><tr><td>桶排序</td><td>O(n)</td></tr><tr><td>基数排序</td><td>O(n)</td></tr></tbody></table><h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 更新为最后一次交换元素的位置</span></span><br><span class="line">          lastExchangeIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortBorder = lastExchangeIndex;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    bubbleSort2(array);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>排序过程就像钟摆一样，第1轮从左到右，第2轮从右到左，第3轮再从左到右……</p><p>在大部分元素已经有序的情况下能发挥优势，减少排序的回合数；代码量几乎增加了1倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 有元素交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在偶数轮之前，将isSorted重新标记为true</span></span><br><span class="line">      isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 偶数轮，从右向左比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length - i - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">          array[j - <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一轮：从左到右，先从2开始比较，找到最大值</span></span><br><span class="line">    <span class="comment">//第二轮：从右到左，从8开始比较，找到最小值</span></span><br><span class="line">    <span class="comment">//之后轮询继续比较</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（六）之二叉堆实现优先级队列</title>
      <link href="2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的特点是先进先出（FIFO）。 </p><ul><li>入队列，将新元素置于队尾。</li><li>出队列，队头元素最先被移出。</li></ul><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列不再遵循先入先出的原则，而是分为两种情况。</p><ul><li>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 </li><li>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队 </li></ul><h2 id="优先队列实现"><a href="#优先队列实现" class="headerlink" title="优先队列实现"></a>优先队列实现</h2><p>利用线性数据结构并非不能实现，但是时间复杂度较高。因此可以利用二叉堆的特性来实现优先队列。最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。</p><p><strong>二叉堆的特性</strong>：</p><ul><li><p>最大堆的堆顶是整个堆中的最大元素。 </p></li><li><p>最小堆的堆顶是整个堆中的最小元素。 </p></li></ul><p><strong>二叉堆的时间复杂度</strong>：</p><p>插入和删除操作都是O(logn)，构建二叉堆的时间复杂度为O(n)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列初始长度为</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队 * <span class="doctag">@param</span> key 入队元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列长度超出范围，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= array.length) &#123;</span><br><span class="line">      resize();</span><br><span class="line">    &#125;</span><br><span class="line">    array[size++] = key;</span><br><span class="line">    upAdjust();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;the queue is empty !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取堆顶元素</span></span><br><span class="line">    <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 让最后一个元素移动到堆顶</span></span><br><span class="line">    array[<span class="number">0</span>] = array[--size];</span><br><span class="line">    downAdjust();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “上浮”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex]) &#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childIndex] = array[parentIndex];</span><br><span class="line">      childIndex = parentIndex;</span><br><span class="line">      parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “下沉”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp 保存父节点的值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">        childIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点大于任何一个孩子的值，直接跳出</span></span><br><span class="line">      <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childIndex];</span><br><span class="line">      parentIndex = childIndex;</span><br><span class="line">      childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 队列扩容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列容量翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">    priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（五）之二叉堆</title>
      <link href="2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
      <url>2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆本质上是一种完全二叉树，它分为两个类型。 </p><ol><li><p>最大堆。 最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值</p></li><li><p>最小堆。最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200307460.png" alt="image-20201203200307460" style="zoom:80%;"></li></ol><p>二叉堆的根节点叫作<strong>堆顶</strong>。最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>插入节点：单一节点上浮，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li><li>删除节点：单一节点下沉，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li><li>构建二叉堆：要所有非叶子节点依次“下沉”，时间复杂度是O(n)</li></ul><p><strong>时间复杂度推导</strong></p><p>n为节点数，level为层级</p><ul><li>插入和删除：f(n) = level-1; n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=log<del>2</del>(n+1)-1，所以时间复杂度为O(log<del>2</del>n)</li><li>构建二叉堆：满二叉树堆则f(n) = 2^level-1^；n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=2^log(n+1)^-2=n-1,所以为O(n)</li></ul><h2 id="自我调整"><a href="#自我调整" class="headerlink" title="自我调整"></a>自我调整</h2><p>这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。</p><ol><li>插入节点 </li></ol><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是 0。这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节点“上浮”，和父节点交换位置。继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。继续比较，最终新节点0“上浮”到了堆顶位置。<br><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203105517492.png" alt="image-20201203105517492"></p><ol start="2"><li>删除节点 </li></ol><p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点。例如删除最小堆的堆顶节点1。这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到原本堆顶的位置。接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果左、右孩子节点中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203194844232.png" alt="image-20201203194844232"><ol start="3"><li>构建二叉堆</li></ol><p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，**<font color="red">本质就是让所有 非叶子节点依次“下沉”</font>**。</p><p>如下图的无序完全二叉树，找到第一个非叶子节点即10，与其子节点比较，节点6与节点10交互位置。数组方式存储，则下一个节点为节点3，与其子节点比较，节点3与节点2交互位置。下一个节点为1，与字节点比较，不用交换位置。最后一个节点为7，与其子节点比较，节点7下沉，与节点1交互位置，继续与子节点比较，子节点为6和5，最后于5节点交换位置。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200122412.png" alt="image-20201203200122412" style="zoom:80%;"><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childrenIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&gt;<span class="number">0</span> &amp;&amp; temp&lt;array[parentIndex])&#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childrenIndex] = array[parentIndex];</span><br><span class="line">      childrenIndex = parentIndex;</span><br><span class="line">      parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childrenIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> array  待调整的堆</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parentIndex  要“下沉”的父节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> parentIndex,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&lt;length)&#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span>(childrenIndex+<span class="number">1</span>&lt;length &amp;&amp; array[childrenIndex+<span class="number">1</span>]&lt;array[childrenIndex])&#123;</span><br><span class="line">        childrenIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">      <span class="keyword">if</span>(temp&lt;array[childrenIndex])&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childrenIndex];</span><br><span class="line">      parentIndex = childrenIndex;</span><br><span class="line">      childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeapTree</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">      downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    upAdjust(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    buildHeapTree(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除是用最后一个节点值替换要删除的节点，之后再下沉自我调整</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    downAdjust(array,<span class="number">1</span>,array.length);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉堆的使用场景"><a href="#二叉堆的使用场景" class="headerlink" title="二叉堆的使用场景"></a>二叉堆的使用场景</h2><p>二叉堆是实现<strong>堆排序</strong>及<strong>优先队列</strong>的基础</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（四）之树及二叉树和遍历</title>
      <link href="2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/"/>
      <url>2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="树概念"><a href="#树概念" class="headerlink" title="树概念"></a>树概念</h2><p>树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。 </p><ol><li>有且仅有一个特定的称为根的节点。</li><li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 <img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134605336.png" alt="image-20201201134605336" style="zoom: 33%;"></li></ol><p>在上图中，节点1是根节点（root）；节点5、6、7、8是树的末端，没有“孩子”，被称为叶子节点（leaf）。图中的虚线部分，是根节点1的其中一个子树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134818417.png" alt="image-20201201134818417" style="zoom: 33%;"></p><p>树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如下。</p><p>在上图中，节点4的上一级节点，是节点4的<strong>父节点（parent）</strong>；从节点4衍生出来的节点，是节点4的<strong>孩子节点（child）</strong>；和节点4同级，由同一个父节点衍生出来的节点，是节点4的<strong>兄弟节点（sibling）</strong></p><p>树的最大层级数，被称为树的高度或深度。显然，上图这个树的高度是4。</p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135228229.png" alt="image-20201201135228229" style="zoom: 33%;"><br>二叉树节点的两个孩子节点，一个被称为<strong>左孩子（left child）</strong>，一个被称为<strong>右孩子（right child）</strong>。这两个孩子节点的顺序是固定的，就像人的左手就是左手，右手就是右手，不能够颠倒或混淆。</p><p>二叉树还有两种特殊形式，一个叫作<strong>满二叉树</strong>，另一个叫作<strong>完全二叉树</strong></p><h3 id="什么是满二叉树"><a href="#什么是满二叉树" class="headerlink" title="什么是满二叉树"></a>什么是满二叉树</h3><p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。简单点说，满二叉树的每一个分支都是满的。一棵深度为k且有2^K^-1个节点的二叉树称为满二叉树。满二叉树每一层的结点个数都达到了最大值, 即满二叉树的第i层上有2^i-1^个节点（i&gt;=1）<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135513962.png" alt="image-20201201135513962" style="zoom:33%;"></p><h3 id="什么是完全二叉树"><a href="#什么是完全二叉树" class="headerlink" title="什么是完全二叉树"></a>什么是完全二叉树</h3><p>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135646991.png" alt="image-20201201135646991" style="zoom:33%;"><br>在上图中，二叉树编号从1到12的12个节点，和前面满二叉树编号从1到12的节点位置完全对应。因此这个树是完全二叉树。<br>完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树</p><h3 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h3><p>链式存储结构。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140333971.png" alt="image-20201201140333971" style="zoom:25%;"></p><ul><li>存储数据的data变量 </li><li>指向左孩子的left指针 </li><li>指向右孩子的right指针</li></ul><p>数组。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140524048.png" alt="image-20201201140524048" style="zoom:25%;"><br>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p><p><strong>为什么这样设计</strong><br>因为这样可以更方便地在数组中定位二叉树的孩子节点和 父节点。</p><p>假设一个父节点的下标是parent，那么它的左孩子节点下标就是2×parent +1；右孩子节点下标就是2×parent + 2。<br>反过来，假设一个左孩子节点的下标是leftChild，那么它的父节点下标就是（leftChild-1）/ 2。<br>假如节点4在数组中的下标是3，节点4是节点2的左孩子，节点2的下标可以直接<br>通过计算得出。节点2的下标 = (3-1)/2 = 1 </p><p>显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p><p><strong>什么样的二叉树最适合用数组表示呢？</strong></p><p>一种特殊的完全二叉树，就是用数组来存储的。</p><h3 id="二叉树应用"><a href="#二叉树应用" class="headerlink" title="二叉树应用"></a>二叉树应用</h3><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行<strong>查找操作和维持相对顺序</strong>这两个方面。 </p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>二叉树的树形结构使它很适合扮演索引的角色。 <strong>二叉查找树（binary search tree）</strong>主要作用就是进行查找操作</p><p><strong>二叉查找树</strong><br>二叉查找树在二叉树的基础上增加了以下几个条件。 <font color="red"><strong>为了查找方便</strong></font>。</p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值 </li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值 </li><li>左、右子树也都是二叉查找树<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141125488.png" alt="image-20201201141125488" style="zoom:25%;">对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度是一样的。这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。 #### **维持相对顺序**二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。因此二叉查找树还有另一个名字——二叉排序树（binary sort tree）。 </li></ul><h4 id="二叉查找树（二叉排序树）的问题"><a href="#二叉查找树（二叉排序树）的问题" class="headerlink" title="二叉查找树（二叉排序树）的问题"></a>二叉查找树（二叉排序树）的问题</h4><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141637961.png" alt="image-20201201141637961" style="zoom:25%;">在根节点为10的节点情况下，插入9、8、7节点时，会出现如图的情况。查询节点的时间复杂度退化成O(n)。<h4 id="二叉树自平衡"><a href="#二叉树自平衡" class="headerlink" title="二叉树自平衡"></a>二叉树自平衡</h4><p>二叉树自平衡的方式有多种，如红黑树、AVL树、树堆等</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>从节点之间位置关系的角度来看，二叉树的遍历分为4种</p><ul><li><p><strong>前序遍历</strong>：输出顺序是根节点、左子树、右子树。</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200256982.png" alt="image-20201201200256982" style="zoom:25%;"></li><li><p><strong>中序遍历</strong>：输出顺序是左子树、根节点、右子树</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200341762.png" alt="image-20201201200341762" style="zoom:25%;"></li><li><p><strong>后序遍历</strong>：输出顺序是左子树、右子树、根节点</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200417902.png" alt="image-20201201200417902" style="zoom:25%;"></li><li><p>层序遍历。层级输出</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201202112654756.png" alt="image-20201202112654756" style="zoom:25%;"></li></ul><p>从更宏观的角度来看，二叉树的遍历归结为两大类。</p><ul><li><p>深度优先遍历（前序遍历、中序遍历、后序遍历）。 所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。</p></li><li><p>广度优先遍历（层序遍历）。就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点 。</p><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。 </p></li></ul><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(LinkedList list)</span> </span>&#123;</span><br><span class="line">    TreeNode treeNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(list) || list.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object o = list.removeFirst();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(o)) &#123;</span><br><span class="line">      treeNode = <span class="keyword">new</span> TreeNode();</span><br><span class="line">      treeNode.date = o;</span><br><span class="line">      treeNode.leftNode = createTree(list);</span><br><span class="line">      treeNode.rightNode = createTree(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeachWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode treeNode = root;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (treeNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        stack.push(treeNode.leftNode);</span><br><span class="line">        treeNode = treeNode.leftNode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop != <span class="keyword">null</span>) &#123;</span><br><span class="line">          treeNode = pop.rightNode;</span><br><span class="line">          stack.push(treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    Object date;</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList list = <span class="keyword">new</span> LinkedList(Arrays</span><br><span class="line">        .asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">7</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">10</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="number">4</span>&#125;));</span><br><span class="line">    TreeNode treeNode = createTree(list);</span><br><span class="line">    preOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    preOrderForeachWithStack(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    inOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    postOrderForeach(treeNode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderForeach</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">    TreeNode treeNode = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(treeNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.print(treeNode.date+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(treeNode.leftNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.leftNode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(treeNode.rightNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.rightNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之数据结构线性结构和非线性结构</title>
      <link href="2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://www.cnblogs.com/mr-wuxiansheng/">Mr_伍先生</a></p><p>出处：<a href="https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html">https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html</a></p><h2 id="线性结构："><a href="#线性结构：" class="headerlink" title="线性结构："></a>线性结构：</h2><p>一、概念</p><ol><li><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</p></li><li><p>线性结构拥有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</p></li><li><p>线性结构中存在两种操作受限的使用场景，即队列和栈。栈的操作只能在线性表的一端进行，就是我们常说的先进后出（FILO），队列的插入操作在线性表的一端进行而其他操作在线性表的另一端进行，先进先出（FIFO），由于线性结构存在两种存储结构，因 此队列和栈各存在两个实现方式。</p></li></ol><p>二、部分实现</p><ol><li><p>顺序表（顺序存储）</p><p>　　按照我们的习惯，存放东西时，一般是找一块空间，然后将需要存放的东西依次摆放，这就是顺序存储。计算机中的顺序存储是指在内存中用一块地址连续的空间依次存放数据元素，用这种方式存储的线性表叫顺序表其特点是表中相邻的数据元素在内存中存储位置也相邻，如下图：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809140928262-492338500.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置线性表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     T tmp = <span class="keyword">default</span>(T);</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> len = GetLength() - <span class="number">1</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (i.Equals(len - i))</span><br><span class="line"><span class="number">10</span>         &#123;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>         tmp = data[i];</span><br><span class="line"><span class="number">15</span>         data[i] = data[len - i];</span><br><span class="line"><span class="number">16</span>         data[len - i] = tmp;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>链表（链式存储）</p><p>　　假如我们现在要存放一些物品，但是没有足够大的空间将所有的物品一次性放下（电脑中使用链式存储不是因为内存不够先事先说明一下…，具体原因后续会说到），同时设定我们因为脑容量很小，为了节省空间，只能记住一件物品位置。此时我们很机智的找到了解决方案：存放物品时每放置一件物品就在物品上贴一个小纸条，标明下一件物品放在那里，只记住第一件物品的位置，寻找的时候从第一件物品开始寻找，通过小纸条我们可以找到所有的物品，这就是链式存储。链表实现的时候不再像线性表一样只存储数据即可，还有下一个数据元素的地址，因此先定义一个节点类(Node)，记录物品信息和下一件物品的位置，我们把物品本身叫做数据域，存储下一件物品地址信息的小纸条称为引用域。链表结构示意图如下：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809143506652-1333091670.png" alt="img"></p><p>　　寻找物品的时候发现了一个问题，我们从一件物品找下一件物品的时候很容易，但是如果要找上一件物品就得从头开始找，真的很麻烦。为了解决这个问题我们又机智了一把，模仿之前的做法，在存放物品的时候多放置一个小纸条记录上一件物品的位置，这样就可以很快的找到上一件物品了。我们把这种方式我们称为双向链表，前面只放置一张小纸条的方式称为单向链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置单链表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; oldHead = Head;</span><br><span class="line"> <span class="number">5</span>     Node&lt;T&gt; tmp ;</span><br><span class="line"> <span class="number">6</span>     Head = <span class="keyword">null</span>;    <span class="comment">//清空链表，解除Head跟oldHead之间的相同引用</span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="keyword">while</span> (oldHead != <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">9</span>     &#123;</span><br><span class="line"><span class="number">10</span>         tmp = Head;</span><br><span class="line"><span class="number">11</span>         Head = oldHead;</span><br><span class="line"><span class="number">12</span>         <span class="comment">//解除Head跟oldHead之间的相同引用</span></span><br><span class="line"><span class="number">13</span>         oldHead = oldHead.Next;</span><br><span class="line"><span class="number">14</span>         Head.Next = tmp;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure><p>　　由于数据存储结构不同导致使用场景上的巨大差异，顺序表由于元素连续具有随机存储的特点，所以查找数据很方便效率很高，但是插入、删除操作为了确保数据元素连续，需要移动大量的数据导致效率很低。而链表由于存储空间不要求连续，插入、删除只需修改相邻元素的引用域地址即可，所以效率很高，但查询需要从头引用开始遍历链表，效率很低。因此，如果只是进行查找操作而不经常插入、删除线性表中的数据元素，则使用顺序存储结构，反之，使用链式存储结构。</p></li><li><p>栈</p><p>　　其实成功完成顺序表和链表之后，栈已经没太多可说的了，主要是逻辑上的不同，毕竟栈也是一种特殊的线性结构。栈是一种操作限定在表尾部进行的线性表，表尾称为栈顶（Top），另一端固定不动，称为栈底（Bottom）。进栈、出栈示意图如下：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809151153090-1514548602.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链栈入驻</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; tmp = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Top == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Top = tmp;</span><br><span class="line"> <span class="number">8</span>     &#125;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>     &#123;</span><br><span class="line"><span class="number">11</span>         tmp.Next = Top;</span><br><span class="line"><span class="number">12</span>         Top = tmp;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     Num++;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">//顺序栈入栈</span></span><br><span class="line"><span class="number">18</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">19 </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">21</span>     &#123;</span><br><span class="line"><span class="number">22</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"><span class="number">25</span>     data[++Top] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>队列</p><p>　　队列与栈类似，仅仅是逻辑有一丢丢不同。队列是一种插入操作限定在表尾其他操作限定在表头的线性表。把进行插入操作的表尾称为队尾（Rear）,把进行其它操作的头部称为队首（Front）。入队、出队示意图如下：</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809152906777-1048463470.png" alt="img" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链队入队</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Rear == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Rear = node;</span><br><span class="line"> <span class="number">8</span>         Front = Rear;</span><br><span class="line"> <span class="number">9</span>     &#125;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">11</span>     &#123;</span><br><span class="line"><span class="number">12</span>         Rear.Next = node;</span><br><span class="line"><span class="number">13</span>         Rear = Rear.Next;</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     ++num;</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span> <span class="comment">//循环队列入队</span></span><br><span class="line"><span class="number">19</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">20 </span>&#123;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">22</span>     &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span>     data[++Rear] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="非线性结构："><a href="#非线性结构：" class="headerlink" title="非线性结构："></a>非线性结构：</h2><h3 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a><strong>一、相关概念</strong></h3><p>　　树作为一种应用广泛的一对多非线性数据结构，不仅有数据间的指向关系，还有层级关系，示例见图一。因树的结构比较复杂，为了简化操作及存储，我们一般将树转换为二叉树处理，因此本文主要讨论二叉树。</p><ol><li><p><strong>二叉树</strong><br>　　二叉树是每个节点最多拥有两个子节点的树结构，若移除根节点则其余节点会被分成两个互不相交的子树，分别称为左子树和右子树。二叉树是有序树，左右子树有严格的次序，若颠倒则成为一棵不一样的二叉树。</p></li><li><p><strong>满二叉树</strong>　　</p><p>​       满二叉树，顾名思义除叶子节点外所有节点都拥有两个孩子，且叶子节点在同一层的二叉树，示例见图二。</p></li><li><p><strong>完全二叉树</strong>　　</p><p>​        完全二叉树，移除最后一层节点后是满二叉树，且最后一层的节点都连续集中在最左面，示例见图三。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812141855625-736751376.png" alt="img"></p></li></ol><h3 id="二、二叉树存储结构"><a href="#二、二叉树存储结构" class="headerlink" title="二、二叉树存储结构"></a>二、二叉树存储结构</h3><ol><li><p><strong>顺序存储</strong>　　</p><p>​        根据完全二叉树的特性，可以计算出任意节点n的双亲节点及左右孩子节点的序号，因此完全二叉树的节点可以按照从上到下从左到右的顺序依次存储到一维数组中。非完全二叉树存储时应先将其改造为完全二叉树，以空替代不存在的节点，比较浪费存储空间，存储示意图见图四。</p></li><li><p><strong>链式存储</strong></p><p>　　树结构链式存储类似线性结构链式存储，先定义包含数据域和引用域的节点(Node)，然后通过引用域存储节点之间的关系。根据二叉树的结构来看，节点Node至少包含数据域(Data)，引用域(左孩子LChild、右孩子RChild)，为了方便通过孩子节点查找父节点，引用域中可以考虑添加父节点引用(Parent)，存储示意图见图五。</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812161601265-1301764954.png" alt="img"> </p></li></ol><h3 id="三、树与二叉树的转换"><a href="#三、树与二叉树的转换" class="headerlink" title="三、树与二叉树的转换"></a>三、树与二叉树的转换</h3><ol><li><p>树转二叉树</p><p><strong>加线</strong>，所有兄弟结点之间加一条连线。<br><strong>抹线</strong>，对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812155626000-1300189010.png" alt="img"></p></li><li><p>二叉树转树</p><p><strong>加线</strong>，若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来。<br><strong>抹线</strong>，删除原二叉树中所有结点与其右孩子结点的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812160125515-698914833.png" alt="img"></p></li></ol><h3 id="四、树遍历实现"><a href="#四、树遍历实现" class="headerlink" title="四、树遍历实现"></a>四、树遍历实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"> <span class="number">2</span> <span class="comment">/// 先序遍历（DLR）</span></span><br><span class="line"> <span class="number">3</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"> <span class="number">4</span> <span class="comment">/// &lt;![CDATA[首先访问跟节点，然后遍历左子树，最后右子树]]&gt;</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function"> 6 </span>&#123;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     Print(root);</span><br><span class="line"><span class="number">13</span>     PreOrder(root.LChild);</span><br><span class="line"><span class="number">14</span>     PreOrder(root.RChild);</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/// 中序遍历（LDR）</span></span><br><span class="line"><span class="number">19</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">20</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后根节点，最后遍历右子树]]&gt;</span></span><br><span class="line"><span class="number">21</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">22 </span>&#123;</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">24</span>     &#123;</span><br><span class="line"><span class="number">25</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     InOrder(root.LChild);</span><br><span class="line"><span class="number">29</span>     Print(root);</span><br><span class="line"><span class="number">30</span>     InOrder(root.RChild);</span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">34</span> <span class="comment">/// 后序遍历（LRD）</span></span><br><span class="line"><span class="number">35</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">36</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后遍历右子树，最后遍历根节点]]&gt;</span></span><br><span class="line"><span class="number">37</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">38 </span>&#123;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">40</span>     &#123;</span><br><span class="line"><span class="number">41</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">42</span>     &#125;</span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>     PostOrder(root.LChild);</span><br><span class="line"><span class="number">45</span>     PostOrder(root.RChild);</span><br><span class="line"><span class="number">46</span>     Print(root);</span><br><span class="line"><span class="number">47</span> &#125;</span><br><span class="line"><span class="number">48</span> </span><br><span class="line"><span class="number">49</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">50</span> <span class="comment">/// 层序遍历</span></span><br><span class="line"><span class="number">51</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">52</span> <span class="comment">/// &lt;![CDATA[从上向下从左到右]]&gt;</span></span><br><span class="line"><span class="number">53</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">54 </span>&#123;</span><br><span class="line"><span class="number">55</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">56</span>     &#123;</span><br><span class="line"><span class="number">57</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">58</span>     &#125;</span><br><span class="line"><span class="number">59</span>     CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt; sq = <span class="keyword">new</span> CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt;(<span class="number">50</span>);</span><br><span class="line"><span class="number">60</span>     sq.In(root);</span><br><span class="line"><span class="number">61</span>     <span class="keyword">while</span> (!sq.IsEmpty())</span><br><span class="line"><span class="number">62</span>     &#123;</span><br><span class="line"><span class="number">63</span>         Node&lt;<span class="keyword">char</span>&gt; tmp = sq.Out();</span><br><span class="line"><span class="number">64</span>         Print(tmp);</span><br><span class="line"><span class="number">65</span> </span><br><span class="line"><span class="number">66</span>         <span class="keyword">if</span> (tmp.LChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">67</span>         &#123;</span><br><span class="line"><span class="number">68</span>             sq.In(tmp.LChild);</span><br><span class="line"><span class="number">69</span>         &#125;</span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">71</span>         <span class="keyword">if</span> (tmp.RChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">72</span>         &#123;</span><br><span class="line"><span class="number">73</span>             sq.In(tmp.RChild);</span><br><span class="line"><span class="number">74</span>         &#125;</span><br><span class="line"><span class="number">75</span>     &#125;</span><br><span class="line"><span class="number">76</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程池</title>
      <link href="2020/11/30/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/11/30/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池关键类"><a href="#线程池关键类" class="headerlink" title="线程池关键类"></a>线程池关键类</h2><ul><li>Executors 线程池工具类</li><li>ExecutorService接口<ul><li>ThreadPoolExecutor实现类</li><li>ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService</li><li>ForkJoinPool</li></ul></li><li>RejectedExecutionHandler 拒绝执行处理器接口<ul><li>AbortPolicy 抛出RejectedExecutionException异常，默认策略</li><li>DiscardPolicy 忽略新任务</li><li>DiscardOldestPolicy 丢弃最旧的任务，执行新的任务</li><li>CallerRunsPolicy 由调用线程处理该任务</li></ul></li></ul><h2 id="新建线程池参数"><a href="#新建线程池参数" class="headerlink" title="新建线程池参数"></a>新建线程池参数</h2><ul><li>核心线程数corePoolSize</li><li>最大线程数maximumPoolSize</li><li>存活时间keepAliveTime</li><li>时间单位TimeUnit unit</li><li>堵塞队列BlockingQueue<Runnable> workQueue</Runnable></li><li>线程工厂ThreadFactory threadFactory</li><li>拒绝策略RejectedExecutionHandler handler</li></ul><h2 id="线程池内部实现"><a href="#线程池内部实现" class="headerlink" title="线程池内部实现"></a>线程池内部实现</h2><ul><li>Worker工作线程，使用的是HashSet保存，Worker继承了AbstractQueuedSynchronizer实现了Runnable,具有final Thread全局变量，初始化Worker时，会传入第一个任务，并初始化线程，Thread中的Runnable对象为Worker类自己。</li><li>工作队列BlockingQueue<Runnable> workQueue，堵塞队列。</Runnable></li><li>使用ReentrantLock获取锁之后，创建工作线程，保存到HashSet中，启动使用woker.thread.start()，最终还是使用的Worker类中的Run方法；运行时，死循环执行，获取任务（从BlockQueue中获取任务,task是Runnable对象），worker加锁，task.run()。</li></ul><h2 id="线程池工具类创建线程问题"><a href="#线程池工具类创建线程问题" class="headerlink" title="线程池工具类创建线程问题"></a>线程池工具类创建线程问题</h2><p>Executors返回的线程池对象弊端如下：</p><ol><li>FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。使用的队列为LinkedBlockingQueue，队列最大长度为Integer.MAX_VALUE</li><li>CacheThreadPool和ScheduledThreadPool：允许创建线程数量最大为Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM。分别使用的队列为<font color="red">SynchronousQueue</font>和<font color="red">DelayedWorkQueue</font></li></ol><h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><p>线程数固定的线程池,使用的是ThreadPoolExecutor，核心线程数和最大线程数一致，</p><h2 id="SingleThreadPool"><a href="#SingleThreadPool" class="headerlink" title="SingleThreadPool"></a>SingleThreadPool</h2><p>仅单线程执行的线程池，使用ThreadPoolExecutor，使用FinalizableDelegatedExecutorService委托类，finalize方法调用shutdown方法，保底</p><h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><p>线程数根据任务动态调整的线程池</p><h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行: FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行: 上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><ul><li>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</li><li>如果任务抛出了异常，后续任务是否继续执行？</li></ul><p>Java标准库还提供了一个<code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code>Timer</code>会对应一个<code>Thread</code>，所以，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用<code>ScheduledThreadPool</code>取代旧的<code>Timer</code>。</p><h2 id="线程池线程数量"><a href="#线程池线程数量" class="headerlink" title="线程池线程数量"></a>线程池线程数量</h2><ul><li>如果是CPU密集型应用，则线程池大小设置为N+1，所谓CPU密集型就是指系统大部分时间是在做程序正常的计算任务，例如数字运算、赋值、分配内存、内存拷贝、循环、查找、排序等，这些处理都需要CPU来完成</li><li>如果是IO密集型应用，则线程池大小设置为2N+1，是指系统大部分时间在跟I/O交互，而这个时间线程不会占用CPU来处理，即在这个时间范围内，可以由其他线程来使用CPU，因而可以多配置一些线程</li><li>最佳线程数 = CPU数量 * CPU利用率 *（线程等待时间/线程CPU时间 + 1）</li><li>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</li></ul><h2 id="线程大小总结"><a href="#线程大小总结" class="headerlink" title="线程大小总结"></a>线程大小总结</h2><p>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程</p><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>当新提交一个任务时：</p><ol><li>如果poolSize&lt;corePoolSize，新增加一个线程处理新的任务。</li><li>如果poolSize=corePoolSize，新任务会被放入阻塞队列等待。</li><li>如果阻塞队列的容量达到上限，且这时poolSize&lt;maximumPoolSize，新增线程来处理任务。</li><li>如果阻塞队列满了，且poolSize=maximumPoolSize，那么线程池已经达到极限，会根据饱和策略RejectedExecutionHandler拒绝新的任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程池中加锁：addWorker（）新增工作线程加锁mainLock.lock()，工作线程存放在HashSet中，为非线程安全集合，</span><br><span class="line">  执行工作线程中的t.start()方法，及执行新线程，调用Worker类中的run方法，调用runWorker方法，循环获取任务</span><br><span class="line">  w.lock(); 加锁，不可重入锁，Worker实现AbstractQueuedSynchronizer重写方法，执行线程task.run（）方法</span><br><span class="line">线程池中工作线程为什么使用非重入锁</span><br><span class="line">线程池执行shutdown（）和shutdownNow（）方法时会设置线程池状态为shutdown或stop ，工作线程获取锁成功，中断执行线程，设置状态为TIDYING</span><br><span class="line"></span><br><span class="line">shutdownNow（） 会返回队列中未执行完的任务</span><br><span class="line">shutdown（）    不接收新任务，但能处理已添加的任务,中断工作线程，但是工作线程并没有退出</span><br><span class="line">shutdownNow（） 不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</span><br></pre></td></tr></table></figure><h2 id="线程池生命周期"><a href="#线程池生命周期" class="headerlink" title="线程池生命周期"></a>线程池生命周期</h2><p>线程池状态：Running、ShutDown、Stop、Tidying、Terminated</p><p>running  -》  shutdown（）  -》 shutdown   队列为空，且线程池执行的任务为空<br>tidying   -》  terminated（） 执行完毕   terminated<br>running  -》 shutdownNow（） -》 stop       线程池执行的任务为空 tidying  terminated（） 执行完毕   terminated</p><h2 id="并发线程池"><a href="#并发线程池" class="headerlink" title="并发线程池"></a>并发线程池</h2><p>ForkJoinPool</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ForkJoin设计：并发处理框架，将大任务拆分为小任务，之后将结果聚合起来得到结果</span><br><span class="line">ForkJoin框架使用了工作窃取的思想（work-stealing），算法从其他队列中窃取任务来执行</span><br><span class="line">ForkJoinPool 分割的子任务也会添加到当前工作线程的双端队列中，进入队列的头部。当一个工作线程中没有任务时，会从其他工作线程的队列尾部获取一个任务</span><br><span class="line">ForkJoinTask 创建一个ForkJoin任务。它提供在任务中执行fork()和join的操作机制，通常我们不直接继承ForkjoinTask类，只需要直接继承其子类</span><br><span class="line">1. RecursiveAction，用于没有返回结果的任务</span><br><span class="line">2. RecursiveTask，用于有返回值的任务</span><br></pre></td></tr></table></figure><p><a href="https://my.oschina.net/u/566591/blog/1791994">https://my.oschina.net/u/566591/blog/1791994</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发集合</title>
      <link href="2020/11/30/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/"/>
      <url>2020/11/30/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h2><p><code>implements ConcurrentMap</code>实现了<code>ConcurrentMap</code>，需要重新定义集合的并发操作。数据结构及逻辑与<code>HashMap</code>类似，增加了<code>CAS</code>和<code>synchronized</code>保证数据一致，线程安全。</p><h2 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a><code>ConcurrentLinkedDeque</code></h2><p>双向链表实现双端并发队列，使用<code>CAS</code>保证线程安全。</p><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a><code>ConcurrentLinkedQueue</code></h2><p>单链表实现并发队列，使用<code>CAS</code>保证线程安全。</p><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a><code>ConcurrentSkipListMap</code></h2><p><code>implements ConcurrentNavigableMap</code>实现了<code>ConcurrentNavigableMap</code>，定义了并发可导航访问的Map，如获取<code>headMap</code>。<br><a href="https://blog.csdn.net/sunxianghuang/article/details/52221913">跳表（SkipList）及ConcurrentSkipListMap源码解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head; <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">    HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">        <span class="keyword">super</span>(node, down, right);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">    <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> Object value;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a><code>ConcurrentSkipListSet</code></h2><p><code>implements NavigableSet</code>，内部实现是使用<code>ConcurrentSkipListMap</code>，value为<code>Boolean.TRUE</code></p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h2><p>使用<code>ReentrantLock</code>实现写入时加锁，复制新的数组，写入到数组之后，替换掉以前的数组。读取时，使用原数组。</p><h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a><code>CopyOnWriteArraySet</code></h2><p>内部使用<code>CopyOnWriteArrayList</code>，使用<code>addIfAbsent</code>方法，先判断是否存在，不存在则添加。使用<code>ReentrantLock</code>加锁，保证线程安全。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="2020/11/30/java%E9%9B%86%E5%90%88/"/>
      <url>2020/11/30/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>​    开辟连续内存地址空间，数组长度固定，不能进行扩容，顺序存储。</p><hr><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h2><p>​    list集合可以使用数组或链表存储数据。</p><ul><li><p><code>ArrayList</code>使用数组进行存储。查找、更新效率高，插入、删除效率低，顺序存储，扩容为旧数组</p></li><li><p><code>LinkedList</code> 使用双向链表进行存储。查找、更新效率低，插入、删除效率高，随机存储，不需要考虑扩容。<font color="red">使用二分查找法</font></p></li><li><p><code>Vector</code> 使用数组进行存储，使用synchronized保证线程安全</p></li></ul><hr><h2 id="Map哈希表"><a href="#Map哈希表" class="headerlink" title="Map哈希表"></a><strong>Map哈希表</strong></h2><h3 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a><code>HashMap详解</code></h3><p>1.7中使用数组+单链表 ，1.8使用数组+单链表/红黑树(提升插入和查找的效率)，原容量的二倍扩容<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611175546307.png" alt="image-20210611175546307" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_INITIAL_CAPACITY <span class="comment">//初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</span></span><br><span class="line">MAXIMUM_CAPACITY <span class="comment">//哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</span></span><br><span class="line">DEFAULT_LOAD_FACTOR <span class="comment">//默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。存值之后扩容</span></span><br><span class="line">TREEIFY_THRESHOLD <span class="comment">//如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于等于 8 时，有可能会转化成树。</span></span><br><span class="line">UNTREEIFY_THRESHOLD <span class="comment">// 在哈希表扩容时，如果发现链表长度小于等于 6，则会由树重新退化为链表。</span></span><br><span class="line">MIN_TREEIFY_CAPACITY <span class="comment">//在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash <span class="comment">//计算下标</span></span><br></pre></td></tr></table></figure><h4 id="hash优化"><a href="#hash优化" class="headerlink" title="hash优化"></a>hash优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure><p><code>hashcdoe</code>值是32位，无符号右移16位，再与<code>hashcode</code>做^异或计算，使高位也参与计算，减少hash冲突</p><h4 id="寻址优化"><a href="#寻址优化" class="headerlink" title="寻址优化"></a>寻址优化</h4><p>h&amp;(n-1) 位与运算，等价于对n进行取模</p><h4 id="链表转换成树"><a href="#链表转换成树" class="headerlink" title="链表转换成树"></a>链表转换成树</h4><p>链表长度大等于8且键值对数量大于64</p><h4 id="树退化为链表"><a href="#树退化为链表" class="headerlink" title="树退化为链表"></a>树退化为链表</h4><p>链表长度小于等于6</p><h4 id="为何链表-→-红黑树的阈值是8"><a href="#为何链表-→-红黑树的阈值是8" class="headerlink" title="为何链表 → 红黑树的阈值是8"></a>为何链表 → 红黑树的阈值是8</h4><p>在理想的情况下随机hashCode算法下所有节点的分布频率会遵循<a href="http://en.wikipedia.org/wiki/Poisson_distribution">泊松分布(Poisson distribution)</a> ，链表长度达到8的概率是0.00000006，也就是说我们几乎不可能会使用到红黑树 , 所以作者使用8作为一个分水岭。<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611173731097.png" alt="image-20210611173731097" style="zoom: 67%;"></p><h4 id="为何链表-→-红黑树的阈值是6"><a href="#为何链表-→-红黑树的阈值是6" class="headerlink" title="为何链表 → 红黑树的阈值是6"></a>为何链表 → 红黑树的阈值是6</h4><p>假设<code>UNTREEIFY_THRESHOLD</code>的 = 7 , 当我们有频繁的添加和删除操作时 ,hash碰撞产生的节点数量 一旦在7附件徘徊就会造成红黑树和链表的频繁转换 , 此时我们大多数的性能就都耗费在了链表 → 红黑树和红黑树 → 链表` ,这样反而就得不偿失了 , 所以作者将长度为7作为一个缓存地段从而选取了6作为红黑树 → 链表的阈值</p><h3 id="LinkedHashMap详情"><a href="#LinkedHashMap详情" class="headerlink" title="LinkedHashMap详情"></a><code>LinkedHashMap详情</code></h3><p>继承<code>HashMap</code>,多了二个自定义的继承<code>HashMap</code>的Node(增加了Entry&lt;K,V&gt; before, after)类的Entry类型的变量head、tail。通过head和tail节点记录数据的<font color="red">插入顺序或者访问顺序。</font>默认是插入顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head; <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail; <span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">//访问顺序，默认为false</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向链表，确定顺序。<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/4843132-7abca1abd714341d.png" style="zoom:67%;"></p><h3 id="TreeMap详情"><a href="#TreeMap详情" class="headerlink" title="TreeMap详情"></a><code>TreeMap详情</code></h3><p>使用红黑树，可以自定义<font color="red">Comparator比较器</font>。自动通过key比较大小，如果key相等，则覆盖value的值</p><p>当比较器为null时，使用key对象的类，必须实现Comparable，强转为Comparable类型进行key比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//根节点</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap详解"><a href="#WeakHashMap详解" class="headerlink" title="WeakHashMap详解"></a><code>WeakHashMap详解</code></h3><p>弱键值对，与HashMap类似，使用的是数组+单链表，涉及到扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;(); <span class="comment">//弱引用队列</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弱引用——&gt;回收之后会存入引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashTable详解"><a href="#HashTable详解" class="headerlink" title="HashTable详解"></a><code>HashTable详解</code></h3><p> 线程安全的，与<code>HashMap</code>类似，使用数组+单链表，涉及到扩容。使用同步块Synchronized，保证线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a><code>EnumMap</code></h3><hr><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set集合</strong></h2><h3 id="HashSet详解"><a href="#HashSet详解" class="headerlink" title="HashSet详解"></a><code>HashSet详解</code></h3><p>使用的是<code>HashMap</code>进行数据存储，value为全局的Object对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedHashSe详解"><a href="#LinkedHashSe详解" class="headerlink" title="LinkedHashSe详解"></a><code>LinkedHashSe详解</code></h3><p>继承<code>HashSet</code>，使用<code>LinkedHashMap</code>进行数据存储，value为全局的Object对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet详解"><a href="#TreeSet详解" class="headerlink" title="TreeSet详解"></a><code>TreeSet详解</code></h3><p>成员变量m的类型为<code>TreeMap</code>，value为全局的Object对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a><strong>Stack栈</strong></h2><p>先进后出（<code>FILO</code>）或者后进先出（LIFO），synchronized同步块保证线程安全，继承Vector，底层使用数组保存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Vector,线程同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="位图BitSet"><a href="#位图BitSet" class="headerlink" title="位图BitSet"></a><strong>位图<code>BitSet</code></strong></h2><p> 使用数组存储，每位存储的值为0或者1，使用位运算。二倍原数组长度扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] words;</span><br><span class="line"><span class="comment">//计算value[值为0,1]在那个数组里下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;  <span class="comment">//ADDRESS_BITS_PER_WORD=6,&gt;&gt;6表示除以2的6次方即64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算bitIndex的值 1L&lt;&lt;64 还是等于为1</span></span><br><span class="line">(words[wordIndex] &amp; (<span class="number">1L</span> &lt;&lt; bitIndex)) != <span class="number">0</span></span><br><span class="line"><span class="comment">//设置bitIndex的值为1</span></span><br><span class="line">words[wordIndex] |= (<span class="number">1L</span> &lt;&lt; bitIndex);</span><br></pre></td></tr></table></figure><hr><h2 id="队列Queue和Deque双端队列"><a href="#队列Queue和Deque双端队列" class="headerlink" title="队列Queue和Deque双端队列"></a><strong><code>队列Queue和Deque双端队列</code></strong></h2><p>队列类图如下：<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/1182892-20171122100317930-842768608.png" style="zoom:67%;"></p><h3 id="ArrayDeque双端队列"><a href="#ArrayDeque双端队列" class="headerlink" title="ArrayDeque双端队列"></a><code>ArrayDeque双端队列</code></h3><h3 id="LinkedList-实现了Deque接口"><a href="#LinkedList-实现了Deque接口" class="headerlink" title="LinkedList 实现了Deque接口"></a><code>LinkedList 实现了Deque接口</code></h3><h3 id="PriorityQueue-优先级队列"><a href="#PriorityQueue-优先级队列" class="headerlink" title="PriorityQueue 优先级队列"></a><code>PriorityQueue 优先级队列</code></h3><h3 id="BlockingQueue-堵塞队列"><a href="#BlockingQueue-堵塞队列" class="headerlink" title="BlockingQueue 堵塞队列"></a><code>BlockingQueue 堵塞队列</code></h3><p>使用可重入锁<code>ReentrantLock</code>实现线程安全，使用Condition实现阻塞</p><ul><li><p><strong><code>LinkedBlockingQueue</code></strong> 的容量是没有上限的（说的不准确，在不指定时容量为<code>Integer.MAX_VALUE</code>，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，基于单链表的队列，此队列按 FIFO（先进先出）排序元素。（<code>LinkedBlockingDeque</code>）</p></li><li><p><strong><code>ArrayBlockingQueue</code></strong> 在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将<code>ReentrantLock</code>设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p></li><li><p>**<code>DelayQueue</code>**（基于<code>PriorityQueue</code>来实现的）是一个存放Delayed元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 <code>getDelay(TimeUnit.NANOSECONDS)</code> 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。 内部使用了优先级队列<code>PriorityQueue</code></p></li><li><p><strong><code>PriorityBlockingQueue</code></strong> 是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，<code>PriorityBlockingQueue</code>是对 <code>PriorityQueue</code>的再次包装，是基于堆数据结构的，而<code>PriorityQueue</code>是没有容量限制的，与<code>ArrayList</code>一样，所以在优先阻塞队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 <code>OutOfMemoryError</code>），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。</p></li><li><p><strong><code>SynchronousQueue</code></strong> 一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没 有元素可用于迭代。队列的头是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），<code>SynchronousQueue</code> 作为一个空 collection。此队列不允许 null 元素。</p><p>同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p><p>看起来很有意思吧。队列竟然是没有内部容量的。这个队列其实是<code>BlockingQueue</code>的一种实现。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。它给我们提供了在线程之间交换单一元素的极轻量级方法</p></li><li><p><code>LinkedTransferQueue implements TransferQueue</code>  LinkedBlockingDeque</p></li><li><p>ConcurrentLinkedQueue   ConcurrentLinkedDeque</p></li></ul><h3 id="队列中的方法"><a href="#队列中的方法" class="headerlink" title="队列中的方法"></a>队列中的方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><strong>add</strong></td><td>增加一个元索，如果队列已满，则抛出一个<code>IIIegaISlabEepeplian</code>异常</td></tr><tr><td><strong>remove</strong></td><td>移除并返回队列头部的元素，如果队列为空，则抛出一个<code>NoSuchElementException</code>异常</td></tr><tr><td><strong>element</strong></td><td>返回队列头部的元素 ，如果队列为空，则抛出一个<code>NoSuchElementException</code>异常</td></tr><tr><td><strong>offer</strong></td><td>添加一个元素并返回true ，如果队列已满，则返回false</td></tr><tr><td><strong>poll</strong></td><td>移除并返问队列头部的元素，如果队列为空，则返回null</td></tr><tr><td><strong>peek</strong></td><td>返回队列头部的元素，如果队列为空，则返回null</td></tr><tr><td><strong>put</strong></td><td>添加一个元素，如果队列满，则==阻塞==</td></tr><tr><td><strong>take</strong></td><td>移除并返回队列头部的元素，如果队列为空，则==阻塞==</td></tr></tbody></table><h2 id="快速失败fail-fast"><a href="#快速失败fail-fast" class="headerlink" title="快速失败fail-fast"></a>快速失败fail-fast</h2><p>集合中<strong>modCount</strong>变量，用modCount来记录修改集合修改次数。</p><ul><li>modCount成员变量，对集合进行增删改时，都会加1</li><li>集合迭代器操作时，会先赋值expectedModCount=modCount，遍历或删除等操作会判断expectedModCount与modCount 是否相等，如果不相等，throw new ConcurrentModificationException();</li></ul><h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历</li><li>java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java集合 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s之调度器和调度过程</title>
      <link href="2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/"/>
      <url>2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本文作者</strong>：**<a href="https://www.cnblogs.com/xzkzzz/p/9963511.html">大胖猴</a>**<br><strong>本文链接</strong>：<a href="https://www.cnblogs.com/xzkzzz/p/9963511.html">https://www.cnblogs.com/xzkzzz/p/9963511.html</a></p><h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><p>当Scheduler通过API server 的watch接口监听到新建Pod副本的信息后，它会检查所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。Scheduler在整个系统中承担了承上启下的作用，承上是负责接收创建的新Pod，为安排一个落脚的地（Node）,启下是安置工作完成后，目标Node上的kubelet服务进程接管后继工作，负责Pod生命周期的后半生。具体来说，Scheduler的作用是将待调度的Pod安装特定的调度算法和调度策略绑定到集群中的某个合适的Node上，并将绑定信息传给API server 写入etcd中。整个调度过程中涉及三个对象，分别是：待调度的Pod列表，可以的Node列表，以及调度算法和策略。</p><p>Kubernetes Scheduler 提供的调度流程分三步：</p><ol><li>预选策略(predicate) 遍历nodelist，选择出符合要求的候选节点，Kubernetes内置了多种预选规则供用户选择。</li><li>优选策略(priority) 在选择出符合要求的候选节点中，采用优选规则计算出每个节点的积分，最后选择得分最高的。</li><li>选定(select) 如果最高得分有好几个节点，select就会从中随机选择一个节点。</li></ol><p>如图：</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/1076553-20181115142949847-1134192119.png" alt="img"></p><p>预选策略算法的集合在<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithm/predicates/predicates.go">官方源码</a></p><h3 id="常用的预选策略（代码里的策略不一定都会被使用）"><a href="#常用的预选策略（代码里的策略不一定都会被使用）" class="headerlink" title="常用的预选策略（代码里的策略不一定都会被使用）"></a>常用的预选策略（代码里的策略不一定都会被使用）</h3><ul><li>CheckNodeConditionPred 检查节点是否正常</li><li>GeneralPred HostName(如果pod定义hostname属性，会检查节点是否匹配。pod.spec.hostname)、PodFitsHostPorts（检查pod要暴露的hostpors是否被占用。pod.spec.containers.ports.hostPort）</li><li>MatchNodeSelector pod.spec.nodeSelector 看节点标签能否适配pod定义的nodeSelector</li><li>PodFitsResources 判断节点的资源能够满足Pod的定义（如果一个pod定义最少需要2C4G node上的低于此资源的将不被调度。用kubectl describe node NODE名称 可以查看资源使用情况）</li><li>NoDiskConflict 判断pod定义的存储是否在node节点上使用。（默认没有启用）</li><li>PodToleratesNodeTaints 检查pod上Tolerates的能否容忍污点（pod.spec.tolerations）</li><li>CheckNodeLabelPresence 检查节点上的标志是否存在 （默认没有启动）</li><li>CheckServiceAffinity 根据pod所属的service。将相同service上的pod尽量放到同一个节点（默认没有启动）</li><li>CheckVolumeBinding 检查是否可以绑定（默认没有启动）</li><li>NoVolumeZoneConflict 检查是否在一起区域（默认没有启动）</li><li>CheckNodeMemoryPressure 检查内存是否存在压力</li><li>CheckNodeDiskPressure  检查磁盘IO压力是否过大</li><li>CheckNodePIDPressure 检查pid资源是否过大</li></ul><h3 id="优选策略"><a href="#优选策略" class="headerlink" title="优选策略"></a>优选策略</h3><ul><li>least_requested 选择消耗最小的节点（根据空闲比率评估 cpu(总容量-sum(已使用)*10/总容量) ）**<br>**</li><li>balanced_resource_allocation 从节点列表中选出各项资源使用率最均衡的节点（CPU和内存）</li><li>node_prefer_avoid_pods 节点倾向</li><li>taint_toleration 将pod对象的spec.toleration与节点的taints列表项进行匹配度检查，匹配的条目越多，得分越低。</li><li>selector_spreading 与services上其他pod尽量不在同一个节点上，节点上通一个service的pod越少得分越高。</li><li>interpod_affinity 遍历node上的亲和性条目，匹配项越多的得分越高</li><li>most_requested 选择消耗最大的节点上（尽量将一个节点上的资源用完）</li><li>node_label 根据节点标签得分，存在标签既得分，没有标签没得分。标签越多 得分越高。</li><li>image_locality 节点上有所需要的镜像既得分，所需镜像越多得分越高。（根据已有镜像体积大小之和）</li></ul><h2 id="高级调度方式"><a href="#高级调度方式" class="headerlink" title="高级调度方式"></a>高级调度方式</h2><p>当我们想把调度到预期的节点，我们可以使用高级调度分为：</p><ul><li>节点选择器： nodeSelector、nodeName</li><li>节点亲和性调度： nodeAffinity</li><li>Pod亲和性调度：PodAffinity</li><li>Pod反亲和性调度：podAntiAffinity</li></ul><h3 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h3><p>我们定义一个pod,让其选择带有node=ssd这个标签的节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-1</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  nodeSelector:</span><br><span class="line">    node: ssdkubectl apply -f test.yaml</span><br></pre></td></tr></table></figure><p>查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#get一下pod 一直处于Pending状态</span><br><span class="line">$ kubectl get pod </span><br><span class="line">NAME      READY     STATUS    RESTARTS   AGE</span><br><span class="line">pod-1     0&#x2F;1       Pending   0          7s</span><br><span class="line">#查看详细信息,是没有可用的selector</span><br><span class="line">$ kubectl describe pod pod-1</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  9s (x14 over 36s)  default-scheduler  0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line">#我们给node2打上这个标签</span><br><span class="line">$  kubectl label node k8s-node02 node&#x3D;ssd</span><br><span class="line">node&#x2F;k8s-node02 labeled</span><br><span class="line">#Pod正常启动</span><br><span class="line">$  kubectl describe pod pod-1</span><br><span class="line">....</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From                 Message</span><br><span class="line">  ----     ------            ----               ----                 -------</span><br><span class="line">  Warning  FailedScheduling  2m (x122 over 8m)  default-scheduler    0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line">  Normal   Pulled            7s                 kubelet, k8s-node02  Container image &quot;ikubernetes&#x2F;myapp:v1&quot; already present on machine</span><br><span class="line">  Normal   Created           7s                 kubelet, k8s-node02  Created container</span><br><span class="line">  Normal   Started           7s                 kubelet, k8s-node02  Started container</span><br></pre></td></tr></table></figure><h3 id="nodeAffinity"><a href="#nodeAffinity" class="headerlink" title="nodeAffinity"></a>nodeAffinity</h3><p>kubectl explain pod.spec.affinity.nodeAffinity </p><ul><li>requiredDuringSchedulingIgnoredDuringExecution 硬亲和性 必须满足亲和性。<ul><li>matchExpressions 匹配表达式,这个标签可以指定一段，例如pod中定义的key为zone，operator为In(包含那些)，values为 foo和bar。就是在node节点中包含foo和bar的标签中调度</li><li>matchFields 匹配字段 和上面的意思 不过他可以不定义标签值，可以定义</li></ul></li><li>preferredDuringSchedulingIgnoredDuringExecution  软亲和性 能满足最好，不满足也没关系。<ul><li>preference 优先级</li><li>weight 权重1-100范围内，对于满足所有调度要求的每个节点，调度程序将通过迭代此字段的元素计算总和，并在节点与对应的节点匹配时将“权重”添加到总和。</li></ul></li></ul><p>运算符包含：<code>In</code>，<code>NotIn</code>，<code>Exists</code>，<code>DoesNotExist</code>，<code>Gt</code>，<code>Lt</code>。可以使用<code>NotIn</code>和<code>DoesNotExist</code>实现节点反关联行为。</p><p>硬亲和性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - foo</span><br><span class="line">            - bar</span><br><span class="line">$ kubectl apply -f pod-affinity-demo.yaml </span><br><span class="line">$ kubectl describe pod node-affinity-pod </span><br><span class="line">.....</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  33s (x25 over 1m)  default-scheduler  0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line"># 给其中一个node打上foo的标签</span><br><span class="line">$ kubectl label node k8s-node03 zone&#x3D;foo</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                READY     STATUS    RESTARTS   AGE</span><br><span class="line">node-affinity-pod   1&#x2F;1       Running   0          8m</span><br></pre></td></tr></table></figure><p> 软亲和性：</p><p>与requiredDuringSchedulingIgnoredDuringExecution比较，这里需要注意的是preferredDuringSchedulingIgnoredDuringExecution是个列表项，而preference不是一个列表项了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod-2</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 50</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - foo</span><br><span class="line">            - bar$ kubectl get pod -o wide NAME                  READY     STATUS    RESTARTS   AGE       IP           NODEnode-affinity-pod     1&#x2F;1       Running   0          3h        10.244.3.2   k8s-node03node-affinity-pod-2   1&#x2F;1       Running   0          1m        10.244.3.3   k8s-node03</span><br></pre></td></tr></table></figure><h3 id="podAffinity"><a href="#podAffinity" class="headerlink" title="podAffinity"></a>podAffinity</h3><p>Pod亲和性场景，我们的k8s集群的节点分布在不同的区域或者不同的机房，当服务A和服务B要求部署在同一个区域或者同一机房的时候，我们就需要亲和性调度了。</p><p>kubectl explain pod.spec.affinity.podAffinity 和NodeAffinity是一样的，都是有硬亲和性和软亲和性</p><p>硬亲和性：</p><ul><li>labelSelector 选择跟那组Pod亲和</li><li>namespaces 选择哪个命名空间</li><li>topologyKey 指定节点上的哪个键</li></ul><p>样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod1</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: service</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod2</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: front</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - podaffinity-myapp</span><br><span class="line">        topologyKey: kubernetes.io&#x2F;hostname </span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide </span><br><span class="line">NAME                  READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">node-affinity-pod1    1&#x2F;1       Running   0          12s       10.244.2.6   k8s-node02</span><br><span class="line">node-affinity-pod2    1&#x2F;1       Running   0          12s       10.244.2.5   k8s-node02</span><br></pre></td></tr></table></figure><h3 id="podAntiAffinity"><a href="#podAntiAffinity" class="headerlink" title="podAntiAffinity"></a>podAntiAffinity</h3><p>Pod反亲和性场景，当应用服务A和数据库服务B要求尽量不要在同一台节点上的时候。</p><p> kubectl explain pod.spec.affinity.podAntiAffinity 也分为硬反亲和性和软反亲和性调度（和podAffinity一样的配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#首先把两个node打上同一个标签。</span><br><span class="line">kubectl label node k8s-node02 zone&#x3D;foo </span><br><span class="line">kubectl label node k8s-node03 zone&#x3D;foo</span><br><span class="line">#反硬亲和调度</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod1</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: service</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod2</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: front</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - podaffinity-myapp</span><br><span class="line">        topologyKey: zone</span><br></pre></td></tr></table></figure><p>查看一下(因为zone这个key在每个node都有会，所以第二个Pod没有办法调度，所以一直Pending状态)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get  pod </span><br><span class="line">NAME                 READY     STATUS    RESTARTS   AGE</span><br><span class="line">node-affinity-pod1   1&#x2F;1       Running   0          11s</span><br><span class="line">node-affinity-pod2   0&#x2F;1       Pending   0          11s</span><br></pre></td></tr></table></figure><h3 id="污点容忍调度（Taint和Toleration）"><a href="#污点容忍调度（Taint和Toleration）" class="headerlink" title="污点容忍调度（Taint和Toleration）"></a>污点容忍调度（Taint和Toleration）</h3><p>前两种方式都是pod选择那个pod，而污点调度是node选择的pod，污点就是定义在节点上的键值属性数据。举要作用是让节点拒绝pod，拒绝不合法node规则的pod。Taint（污点）和 Toleration（容忍）是相互配合的，可以用来避免 pod 被分配到不合适的节点上,每个节点上都可以应用<strong>一个或多个</strong> taint ，这表示对于那些不能容忍这些 taint 的 pod，是不会被该节点接受的。</p><h4 id="Taint"><a href="#Taint" class="headerlink" title="Taint"></a>Taint</h4><p>Taint是节点上属性，我们看一下Taints如何定义</p><p>kubectl explain node.spec.taints（对象列表）</p><ul><li>key 定义一个key</li><li>value 定义一个值</li><li>effect pod不能容忍这个污点时，他的行为是什么，行为分为三种：NoSchedule 仅影响调度过程，对现存的pod不影响。PreferNoSchedule 系统将<em>尽量</em>避免放置不容忍节点上污点的pod，但这不是必需的。就是软版的NoSchedule NoExecute 既影响调度过程，也影响现存的pod，不满足的pod将被驱逐。</li></ul><h4 id="node-打-taint"><a href="#node-打-taint" class="headerlink" title="node 打 taint"></a>node 打 taint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint NODE NAME KEY_1&#x3D;VAL_1:TAINT_EFFECT_1 ... KEY_N&#x3D;VAL_N:TAINT_EFFECT_N [options]</span><br><span class="line">增加taint</span><br><span class="line">kubectl  taint node k8s-node02 node-type&#x3D;prod:NoSchedule</span><br><span class="line">删除taint</span><br><span class="line">kubectl  taint node k8s-node02 node-type:NoSchedule-</span><br></pre></td></tr></table></figure><h4 id="tolerations"><a href="#tolerations" class="headerlink" title="tolerations"></a>tolerations</h4><ul><li>key 被容忍的key</li><li>tolerationSeconds 被驱逐的宽限时间，默认是0 就是立即被驱逐</li><li>value 被容忍key的值</li><li>operator Exists只要key在就可以调度，Equal（等值比较）必须是值要相同</li><li>effect 节点调度后的操作</li></ul><p>创建一个容忍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-deploy</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">      release: dev</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myapp</span><br><span class="line">        release: dev</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myapp-containers</span><br><span class="line">        image: ikubernetes&#x2F;myapp:v2</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: &quot;node-type&quot;</span><br><span class="line">        operator: &quot;Equal&quot;</span><br><span class="line">        value: &quot;prod&quot;</span><br><span class="line">        effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s控制台rancher</title>
      <link href="2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0rancher/"/>
      <url>2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0rancher/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> rancher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s控制台Dashboard</title>
      <link href="2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/"/>
      <url>2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.51cto.com/happylab">Happy老师</a></p><p>出处：[<a href="https://blog.51cto.com/happylab/2496756]">https://blog.51cto.com/happylab/2496756]</a>(</p><h2 id="kubernetes-dashboard简介"><a href="#kubernetes-dashboard简介" class="headerlink" title="kubernetes-dashboard简介"></a>kubernetes-dashboard简介</h2><p>kubernetes中管理集群中资源的方式通常有四种：命令行、YAML、API和图形界面，四种不同的方式适用于不同的人群和场景，对比如下：</p><ul><li>命令行kubectl，kubectl提供了命令行管理kubernetes资源<ul><li>优点：使用方便、便捷、快速管理集群资源</li><li>缺点：功能相对有限，部分操作无法支持，有一定的门槛</li></ul></li><li>YAML资源定义，kubernetes中最终转换形式，推荐使用方式<ul><li>优点：功能齐备，能够定义kubernetes的所有对象和资源</li><li>缺点：门槛较高，需要具备专业技术能力，使用排障难度大</li></ul></li><li>API管理接入，提供各种编程语言SDK接口，方便各种编程语言应用程序接入<ul><li>优点：适配各种编程语言，如Java，Go，Python，C等，方便开发kubernetes</li><li>缺点：门槛较高，适用于开发人员</li></ul></li><li>图形kubernetes-dashboard，提供图形化管理界面，能够利用metric-server实现node和pod的监控<ul><li>优点：使用简单，便捷，适合大众。</li><li>缺点：功能相对简单，功能原生，适用于demo</li></ul></li></ul><h2 id="kubernetes-dashboard安装"><a href="#kubernetes-dashboard安装" class="headerlink" title="**kubernetes-**dashboard安装"></a>**kubernetes-**dashboard安装</h2><p>社区提供了kubernetes-dashbaord的YAML资源定义文件，直接下载YAML文件安装即可实现dashboard的安装接入，需要准备条件如下：</p><ul><li>已安装好的kubernetes集群，本文环境为1.15.3</li><li>metric-server监控，node监控和pod监控视图需依赖于监控系统</li><li>RBAC认证授权，设置好账户并授予访问权限</li></ul><p>1、下载kubernetes-dashboard安装文件并应用YAML资源定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard configured</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard unchanged</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br></pre></td></tr></table></figure><p>安装文件中定义了dashboard相关的资源，可以查阅YAML文件，资源包含有：</p><ul><li>kubernetes-dashboard命名空间</li><li>ServiceAccount访问用户</li><li>Service服务访问应用，默认为ClusterIP</li><li>Secrets，存放有kubernetes-dashboard-certs，kubernetes-dashboard-csrf，kubernetes-dashboard-key-holder证书</li><li>ConfigMap配置文件</li><li>RBAC认证授权，包含有Role，ClusterRole，RoleBinding，ClusterRoleBinding</li><li>Deployments应用，kubernetes-dashboard核心镜像，还有一个和监控集成的dashboard-metrics-scraper</li></ul><p>2、校验资源的安装情况，kubernetes-dashbaord的资源都安装在kubernetes-dashboard命名空间下,包含有Deployments，Services，Secrets，ConfigMap等</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/1.gif"></p><p>3、kubernetes-dashbaord安装完毕后，kubernetes-dashboard默认service的类型为ClusterIP，为了从外部访问控制面板，开放为NodePort类型</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/2.gif"></p><p>4、此时通过https协议访问30433端口即可打开dashboard的控制台，为了保护数据安全性，集群默认开启了RBAC认证授权，需要授予权限的用户才可以访问到kubernetes集群，因此需要授权用户访问集群，集群中已定有了cluster-admin的角色和相关的Role，ClusterRole和ClusterRoleBinding角色，定义ServiceAccount将其关联即可，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# cat dashboard-rbac.yaml </span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: happycloudlab </span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: happycloudlab</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: happycloudlab</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>5、应用RBAC规则，创建一个happycloudlab的用户，并和cluster-admin的角色关联</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# kubectl apply -f dashboard-rbac.yaml </span><br><span class="line">serviceaccount/happycloudlab created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/happylau created</span><br><span class="line">[root@node-1 ~]# kubectl get serviceaccounts -n kubernetes-dashboard </span><br><span class="line">NAME                   SECRETS   AGE</span><br><span class="line"><span class="keyword">default</span>                <span class="number">1</span>         <span class="number">114</span>m</span><br><span class="line">happycloudlab   <span class="number">1</span>         <span class="number">8</span>s</span><br><span class="line">kubernetes-dashboard   <span class="number">1</span>         <span class="number">114</span>m</span><br></pre></td></tr></table></figure><p>6、此时通过kubernetes-dashboard-csrf服务会自动创建一个和用户名关联的Secrets，通过token字段来登陆，token通过base64加密，解密后即可登录，如下演示登录的过程<img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/3.gif"></p><p>自此，kubernetes-dashboard安装完毕，通过RBAC认证授权特定用户访问集群权限，接下来一起探索dashboard带来的魔力吧。</p><h2 id="探索kubernetes-dashboard"><a href="#探索kubernetes-dashboard" class="headerlink" title="探索kubernetes-dashboard"></a>探索<strong>kubernetes-dashboard</strong></h2><p>kubernetes-dashboard图形工具能提供以下功能：</p><ul><li>查看kubernetes中的资源对象，包含kubernetes中各种资源<ul><li>Cluster 集群级别的资源，如命名空间，节点，PV，StorageClass，ClusterRole等</li><li>Workloads，不同类型的工作负载，包含Deployments，StatefulSets，DaemonSets，Jobs等</li><li>Discovery and LoadBalancing，服务发现和负载均衡，包含service和ingress</li><li>ConfigMap and Storage，包含ConfigMap，Secrets和PVC</li><li>Costom Resource Definition，自定义资源定义</li></ul></li><li>kubernetes资源监控，调用metric-server监控系统，实现Cluster集群，Workloads应用负载，存储等资源的监控</li><li>管理资源对象，包含创建，编辑yaml，删除负载等，主要是以Deployments等应用为主的管理</li></ul><p>1、查看集群整体概览资源，可以看到整体集群，应用负载，Pod资源的资源使用情况</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/4.gif" alt="资源概览"></p><p>2、Cluster集群资源管理，包含还有Nodes，Namespace，StorageClass等，提供在线编辑yaml方式</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/5.gif" alt="集群资源"></p><p>3、查看应用工作负载Workloads，包含各种不同的工作负载如Deployments，StatefulSets，Jobs等</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/6.gif" alt="工作负载"></p><p>4、部署Deployments工作负载，支持从YAML文件输入，YAML文件加载和图形界面部署应用</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/7.gif" alt="部署工作负载"></p><p>5、工作负载管理，扩展工作负载副本数目，滚动更新等</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/8.gif" alt="扩展副本+滚动更新"></p><p>6、远程登录容器和查看容器日志</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/9.gif" alt="登录容器和查看日志"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>kubernetes-dashboard提供了原生的k8s管理工具，提供一个便捷的可视化界面，方便使用控制台管理k8s资源，dashboard提供的功能相对原生，企业可以根据公司的需求通过api进行二次开发，以满足需求。对于k8s管理员而言，一般以使用命令行或yaml文件为主。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>dashboard安装手册：<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p><p>RBAC认证授权：<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p><p><a href="https://www.jianshu.com/p/40c0405811ee">k8s Dashboard部署</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络</title>
      <link href="2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E7%BD%91%E7%BB%9C/"/>
      <url>2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s基础</title>
      <link href="2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.51cto.com/happylab">Happy老师</a></p><p>出处：<a href="https://blog.51cto.com/happylab/2496756">https://blog.51cto.com/happylab/2496756</a></p><h2 id="kubernetes简介与功能"><a href="#kubernetes简介与功能" class="headerlink" title="kubernetes简介与功能"></a>kubernetes简介与功能</h2><p>Kubernetes是google开源的一套微服务，容器化的编排引擎，提供容器话应用的自动化部署，横向扩展和管理，是google内部容器十多年实战沉淀的结晶，已战胜Swarm，Mesos成为容器编排的行业标准。</p><p>三大容器编排引擎：</p><ul><li>Swarm Docker原生提供的容器化编排引擎，随着docker支持kubernetes逐渐废弃</li><li>Mesos 结合Marathon提供容器调度编排的能力，还能提供其他framwork的调度</li><li>Kubernetes 已成为容器编排引擎的唯一标准，越来越多程序支持kubernetes。</li></ul><p>kuberntes内置有很多非常优秀的特性使开发者专注于业务本身，其包含的功能如下：</p><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/c23e352655b2ddd6d7e9fffd224accc9.png" alt="kubernetes入门到实战（一）初窥kubernetes全貌"></p><ul><li>Service discovery and load balancing，服务发现和负载均衡，通过DNS实现内部解析，service实现负载均衡</li><li>Storage orchestration，存储编排，通过plungin的形式支持多种存储，如本地，nfs，ceph，公有云快存储等</li><li>Automated rollouts and rollbacks，自动发布与回滚，通过匹配当前状态与目标状态一致，更新失败时可回滚</li><li>Automatic bin packing，自动资源调度，可以设置pod调度的所需（requests）资源和限制资源（limits）</li><li>Self-healing，内置的健康检查策略，自动发现和处理集群内的异常，更换，需重启的pod节点</li><li>Secret and configuration management，密钥和配置管理，对于敏感信息如密码，账号的那个通过secret存储，应用的配置文件通过configmap存储，避免将配置文件固定在镜像中，增加容器编排的灵活性</li><li>Batch execution，批处理执行，通过job和cronjob提供单次批处理任务和循环计划任务功能的实现</li><li>Horizontal scaling,横向扩展功能，包含有HPA和AS，即应用的基于CPU利用率的弹性伸缩和基于平台级的弹性伸缩，如自动增加node和删除nodes节点。</li></ul><h2 id="kubernetes架构解析"><a href="#kubernetes架构解析" class="headerlink" title="kubernetes架构解析"></a>kubernetes架构解析</h2><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/9b512f2d62081a5fa35d8266f5c03a78.png" alt="kubernetes组件"></p><p>kubernetes包含两种角色：master节点和node节点，master节点是集群的控制管理节点，作为整个k8s集群的大脑。</p><ul><li>负责集群所有接入请求(kube-apiserver)，在整个集群的入口；</li><li>集群资源调度(kube-controller-scheduler)，通过watch监视pod的创建，负责将pod调度到合适的node节点；</li><li>集群状态的一致性(kube-controller-manager)，通过多种控制器确保集群的一致性，包含有Node Controller，Replication Controller，Endpoints Controller等；</li><li>元数据信息存储(etcd)，数据持久存储化，存储集群中包括node，pod，rc，service等数据；</li></ul><p>node节点是实际的工作节点，负责集群负载的实际运行，即pod运行的载体，其通常包含三个组件：Container Runtime，kubelet和kube-proxy</p><ul><li>Container Runtime是容器运行时，负责实现container生命周期管理，如docker，containerd，rktlet；</li><li>kubelet负责镜像和pod的管理，</li><li>kube-proxy是service服务实现的抽象，负责维护和转发pod的路由，实现集群内部和外部网络的访问。</li></ul><p>其他组件还包括：</p><ul><li>cloud-controller-manager，用于公有云的接入实现，提供节点管理(node)，路由管理，服务管理(LoadBalancer和Ingress)，存储管理(Volume，如云盘，NAS接入)，需要由公有云厂商实现具体的细节，kubernetes提供实现接口的接入，如腾讯云目前提供CVM的node管理，节点的弹性伸缩(AS),负载均衡的接入(CLB),存储的管理(CBS和CFS)等产品的集成；</li><li>DNS组件由kube-dns或coredns实现集群内的名称解析；</li><li>kubernetes-dashboard用于图形界面管理；</li><li>kubectl命令行工具进行API交互；</li><li>服务外部接入，通过ingress实现七层接入，由多种controller控制器组成<ul><li>traefik</li><li>nginx ingress controller</li><li>haproxy ingress controller</li><li>公有云厂商ingress controller</li></ul></li><li>监控系统用于采集node和pod的监控数据<ul><li>metric-server 核心指标监控</li><li>prometheus 自定义指标监控，提供丰富功能</li><li>heapster+influxdb+grafana 旧核心指标监控方案，现已废弃</li></ul></li><li>日志采集系统，用于收集容器的业务数据,实现日志的采集，存储和展示，由EFK实现<ul><li>Fluentd 日志采集</li><li>ElasticSearch 日志存储+检索</li><li>Kiabana 数据展示</li></ul></li></ul><h2 id="kubernetes生态"><a href="#kubernetes生态" class="headerlink" title="kubernetes生态"></a>kubernetes生态</h2><p><a href="https://landscape.cncf.io/">https://landscape.cncf.io/</a></p><h2 id="kubernetes高可用架构"><a href="#kubernetes高可用架构" class="headerlink" title="kubernetes高可用架构"></a>kubernetes高可用架构</h2><p>kubernetes高可用集群通常由3或5个节点组成高可用集群，需要保障各个节点的高可用性</p><ul><li>etcd 内置集群机制，保障数据持久存储</li><li>kube-apiserver 无状态api服务，有负载均衡调度器做负载分发，如haproxy或nginx</li><li>kube-scheduler 内置选举机制，保障调度器高可用，确保同个时刻一个leader节点工作，其他处于阻塞，防止脑裂</li><li>kube-controller-manager 内置的选举机制保障控制器高可用，机制和kube-scheduler一致。<br><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/61235bc58859458922f5ab4f6484ed99.jpg" alt="kubernetes入门到实战（一）初窥kubernetes全貌"></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li>kubernetes功能介绍，<a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></li><li>kubernetes组件介绍<a href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker网络</title>
      <link href="2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E7%BD%91%E7%BB%9C/"/>
      <url>2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="docker网络知识"><a href="#docker网络知识" class="headerlink" title="docker网络知识"></a>docker网络知识</h2><h3 id="docker网络类型（–network指定网络）"><a href="#docker网络类型（–network指定网络）" class="headerlink" title="docker网络类型（–network指定网络）"></a>docker网络类型（–network指定网络）</h3><ul><li><p>bridge  默认连接到docker0这个网桥上</p></li><li><p>none 容器只能使用127.0.0.1的本机网络</p></li><li><p>host 与宿主机共享ip</p></li><li><p>link  docker run -it –name vm5 –link vm1:db1 ubuntu 创建一个容器vm5，并使用link方式连接vm1,此时的vm1的是容器名，db1是容器的别名</p></li><li><p>container 网络模式，必须同一个宿主机</p></li><li><p>自定义网络模式：</p><ul><li>bridge network  可以通过容器名互通，单一主机上运行一个相对小的网络，使用桥接网络</li><li>overlay network  创建一个大网络，可以通过overlay 网络来实现</li><li>MACVLAN network</li><li>network plugin</li><li>remote network</li></ul></li><li><p>跨主机docker容器通信方案介绍（就是自定义网络下的方案，除开bridge）</p><ul><li><p>隧道（Overlay Networking）方案：</p><ul><li>  Weave：UDP广播，本机建立新的BR，通过PCAP互通。</li><li>  Open vSwitch(OVS)：基于VxLAN和GRE协议，但是性能方面损失比较严重。</li><li>  Flannel：UDP广播，VxLan。  </li></ul></li><li><p>路由方案</p><ul><li>  Calico：基于BGP协议的路由方案，支持很细致的ACL控制，对混合云亲和度比较高。</li><li>  Macvlan：从逻辑和Kernel层来看隔离性和性能最优的方案，基于二层隔离，所以需要二层路由器支持，大多数云服务商不支持，所以混合云上比较难以实现。</li></ul></li></ul></li></ul><p><code>    隧道方案在IaaS层的网络中应用也比较多，大家共识是随着节点规模的增长复杂度会提升，而且出了网络问题跟踪起来比较麻烦，大规模集群情况下这是需要考虑的一个点。</code></p><p><code>    路由方案一般是从3层或者2层实现隔离和跨主机容器互通的，出了问题也很容易排查。</code></p><h5 id="bridge-模式的网络。其特点如下："><a href="#bridge-模式的网络。其特点如下：" class="headerlink" title="bridge 模式的网络。其特点如下："></a>bridge 模式的网络。其特点如下：</h5><ul><li>  使用一个 linux bridge，默认为 docker0</li><li>  使用 veth 对，一头在容器的网络 namespace 中，一头在 docker0 上</li><li>  该模式下Docker Container不具有一个公有IP，因为宿主机的IP地址与vethpair的 IP地址不在同一个网段内</li><li>  Docker采用NAT网络地址转换(Network Address Translation)方式，将容器内部的服务监听的端口与宿主机的某一个端口port 进行“绑定”，使得宿主机以外的世界可以主动将网络报文发送至容器内部</li><li>  外界访问容器内的服务时，需要访问宿主机的 IP 以及宿主机的端口 port</li><li>  NAT 模式由于是在三层网络上的实现手段，故肯定会影响网络的传输效率。</li><li>容器拥有独立、隔离的网络栈；让容器和宿主机以外的世界通过NAT建立通信<br>  <img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E7%BD%91%E7%BB%9C/bridge_20201013104542.png" alt="输入图片描述"></li></ul><h5 id="主要使用的网络模式"><a href="#主要使用的网络模式" class="headerlink" title="主要使用的网络模式"></a>主要使用的网络模式</h5><ul><li>Libnetwork 从Docker核心代码中分离出去，形成一个单独的库</li><li>Flannel CoreOS团队针对Kubernetes设计的一个重载网络工具，它的主要思路是：预先留出一个网段，每个主机使用其中一部分，然后每个容器被分配不同的ip；让所有的容器认为大家在同一个直连的网络，底层通过UDP/VxLAN等进行报文的封装和转发</li><li>Calico 是一个纯3层的数据中心网络方案，而且无缝集成像OpenStack这种IaaS云架构，能够提供可控的VM、容器、裸机之间的IP通信</li></ul><p><a href="https://www.jianshu.com/p/d84cdfe2ea86">详细网络知识</a><br><a href="https://blog.csdn.net/dhaiuda/article/details/82824333">docker的overlay网络</a></p><h3 id="docker网络操作"><a href="#docker网络操作" class="headerlink" title="docker网络操作"></a>docker网络操作</h3><ul><li>docker network ls            查看docker网卡</li><li>docker network rm 网卡id    删除docker网卡</li><li>docker network inspect 网卡id   查看docker网卡的相关详细信息</li><li>创建网络，如下使用–subnet创建网络（用来指定ip段），–gateway（用来指定网关），my_net3为创建的名字：<br>docker network create –driver bridge –subnet 172.22.1.0/24 –gateway 172.22.1.1 my_net3</li></ul><h3 id="设置主机名和DNS"><a href="#设置主机名和DNS" class="headerlink" title="设置主机名和DNS"></a>设置主机名和DNS</h3><p>docker run -it –name mycon -h lion –dns=8.8.8.8 ubuntu:14.04</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Docker提供了一种将应用程序安全，隔离运行的一种方式，能够将应用程序依赖和库文件打包在一个容器中，后续再任何地方运行起来即可，其包含了应用程序所依赖相关环境，一次构建，任意运行（build once，run anywhere）</p><h2 id="Docker-包括三个基本概念"><a href="#Docker-包括三个基本概念" class="headerlink" title="Docker 包括三个基本概念"></a>Docker 包括三个基本概念</h2><ul><li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。<br>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li></ul><p>Docker容器通过Docker镜像来创建。</p><h2 id="Docker原理"><a href="#Docker原理" class="headerlink" title="Docker原理"></a>Docker原理</h2><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E5%9F%BA%E7%A1%80/6d20ecb467fa6d571d7dd74fe0187f07.png" alt="docker架构" style="zoom: 50%;"><table><thead><tr><th align="left">概念</th><th>说明</th></tr></thead><tbody><tr><td align="left">Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td align="left">Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td align="left">Docker Daemon</td><td>容器管理组件，守护进程，负载容器，镜像，存储，网络等管理</td></tr><tr><td align="left">Docker 客户端(Client)</td><td>Docker客户端通过命令行或者其他工具使用 <a href="https://docs.docker.com/develop/sdk/">Docker SDK </a> 与Docker的守护进程（Docker Daemon）通信</td></tr><tr><td align="left">Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="left">Docker Registry</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。容器镜像仓库，负责存储，分发，打包</td></tr><tr><td align="left">Docker Object</td><td>容器对象，主要包含container和images</td></tr><tr><td align="left">Docker Machine</td><td>是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，<br>比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr><tr><td align="left">docker swarm</td><td>Swarm 集群中每台 Docker 主机称为一个节点。集群管理，容器编排项目</td></tr><tr><td align="left">docker compose</td><td>容器编排项目，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具</td></tr></tbody></table><p><a href="https://hub.docker.com/">Docker Hub</a> 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><h2 id="容器优缺点"><a href="#容器优缺点" class="headerlink" title="容器优缺点"></a>容器优缺点</h2><p>容器给应用程序开发环境带来很大的便利，从根本上解决了容器的环境依赖，打包等问题，然而，Docker带来的容器打包的便利，同时也带来了以下的挑战：</p><ul><li><p>容器如何调度，分发</p></li><li><p>多台机器如何协同工作</p></li><li><p>Docker主机故障时应用如何恢复</p></li><li><p>如何保障应用高可用，横向扩展，动态伸缩</p></li></ul><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E5%9F%BA%E7%A1%80/875f955cc9bb7b51036b58e59a2763bb.png" alt="容器挑战" style="zoom:50%;"><h2 id="docker容器命令"><a href="#docker容器命令" class="headerlink" title="docker容器命令"></a>docker容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -q </span><br><span class="line">docker container stop|start|rm nginx</span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx-test -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it nginx sh|bash</span><br></pre></td></tr></table></figure><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p><a href="https://www.runoob.com/docker/docker-dockerfile.html" title="dockerfile描述文件细节">如何写dockerfile文件</a></p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>容器编排工具 <a href="https://www.runoob.com/docker/docker-compose.html" title="docker-compose描述文件细节">如何写docker-compose.yml</a></p><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d //后台运行</span><br><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h2 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker swarm"></a>docker swarm</h2><p>Swarm 集群中每台 Docker 主机称为一个节点。其中主动初始化一个 Swarm 集群的节点称为管理节点（Manager），加入一个Swarm 集群的节点称为工作节点（Worker Node）。工作节点是任务执行节点，管理节点将任务下发至工作节点执行。管理节点默认也作为工作节点。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader</p><p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p><p>swarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。<br>work node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</p><h4 id="基本实用命令"><a href="#基本实用命令" class="headerlink" title="基本实用命令"></a>基本实用命令</h4><ul><li>docker swarm init –advertise-addr 192.168.58.144</li><li>docker swarm join 。。。</li><li>docker swarm leave –f</li><li>docker node ls</li><li>docker node ls –filter role=worker</li><li>docker node ls –filter role=manager</li><li>docker node update swarm02 –role=worker //将swarm02节点降级为worker节点</li><li>docker service inspect mynginx</li><li>docker service create –replicas 3 -p 8888:80 –name mynginx nginx</li><li>docker service rm mynginx</li><li>docker stack rm getstartedlab</li><li>docker stack deploy -c docker-compose.yml getstartedlab</li></ul><h4 id="docker-service"><a href="#docker-service" class="headerlink" title="docker service"></a>docker service</h4><p>与docker swarm一起使用，docker service部署的是单个服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 3 -p 8888:80 --name mynginx nginx</span><br></pre></td></tr></table></figure><h4 id="Docker-Stack"><a href="#Docker-Stack" class="headerlink" title="Docker Stack"></a>Docker Stack</h4><p>与docker swarm一起使用，使用docker-compose.yml配置文件，进行多服务编排部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stack  deploy -c docker-compose1.yml phpadmin</span><br><span class="line"></span><br><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure><h4 id="Swarm-Service网络模型"><a href="#Swarm-Service网络模型" class="headerlink" title="Swarm Service网络模型"></a>Swarm Service网络模型</h4><ul><li><strong>Overlay networks</strong> 管理 Swarm 中 Docker 守护进程间的通信。你可以将服务附加到一个或多个已存在的 overlay 网络上，使得服务与服务之间能够通信。</li><li><strong>ingress network</strong> 是一个特殊的 overlay 网络，用于服务节点间的负载均衡。当任何 Swarm 节点在发布的端口上接收到请求时，它将该请求交给一个名为 IPVS 的模块。IPVS 跟踪参与该服务的所有IP地址，选择其中的一个，并通过 ingress 网络将请求路由到它。<br>初始化或加入 Swarm 集群时会自动创建 ingress 网络，大多数情况下，用户不需要自定义配置，但是 docker 17.05 和更高版本允许你自定义。</li><li><strong>docker_gwbridge</strong>是一种桥接网络，将 overlay 网络（包括 ingress 网络）连接到一个单独的 Docker 守护进程的物理网络。默认情况下，服务正在运行的每个容器都连接到本地 Docker 守护进程主机的 docker_gwbridge 网络。<br>docker_gwbridge 网络在初始化或加入 Swarm 时自动创建。大多数情况下，用户不需要自定义配置，但是 Docker 允许自定义。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create</span><br><span class="line">docker network connect</span><br><span class="line">docker network ls</span><br><span class="line">docker network rm</span><br><span class="line">docker network disconnect</span><br><span class="line">docker network inspect</span><br><span class="line">docker run --rm --network=host alpine ifconfig</span><br></pre></td></tr></table></figure><h4 id="swarm编排工具的控制台docker-portainer"><a href="#swarm编排工具的控制台docker-portainer" class="headerlink" title="swarm编排工具的控制台docker portainer"></a>swarm编排工具的控制台docker portainer</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--constraint &#x27;node.role == manager&#x27; \</span><br><span class="line">--mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><h2 id="docker-compose与docker-swarm区别"><a href="#docker-compose与docker-swarm区别" class="headerlink" title="docker compose与docker swarm区别"></a>docker compose与docker swarm区别</h2><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合</p><h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>创建Docker主机（开放远程2375端口 安装docker）</p><ul><li>docker-machine create -d hyperv –hyperv-virtual-switch “myswitch” myvm2</li><li>docker-machine env myvm3</li><li>docker-machine ssh myvm1</li><li>docker-machine ls</li><li>docker-machine stop</li><li>docker-machine start</li><li>docker-machine env</li><li>docker-machine regenerate-certs</li></ul><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基础</title>
      <link href="2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>消息队列可以实现流量削峰、降低系统耦合度、提高系统性能等。</p><p><strong>RabbitMQ</strong>是一个实现了AMQP协议（Advanced Message Queue Protocol）的消息队列。</p><h2 id="RabbitMQ中的概念"><a href="#RabbitMQ中的概念" class="headerlink" title="RabbitMQ中的概念"></a><strong>RabbitMQ中的概念</strong></h2><ul><li><strong>producer</strong>： producer 是一个发送消息的应用</li><li><strong>exchange</strong>：producer并不会直接将消息发送到 queue 上，而是将消息发送给exchange，由exchange按照一定规则转发给指定queue</li><li><strong>queue</strong>： queue 用来存储 producer 发送的消息</li><li><strong>consumer</strong>： consumer是接收并处理消息的应用</li><li><strong>routing key</strong>：发送消息时绑定的路由key</li><li><strong>binding key</strong>：队列与交换机绑定的key</li><li><strong>consumerTag</strong>: 消费者标签，同一个会话， consumerTag 是固定的 可以做此会话的名字。</li><li><strong>consumer</strong>：消费者，extends DefaultConsumer。一个channel上可以配置多个consumer，真正的接收消息类，有处理消息的方法</li><li><strong>Envelope</strong>：可以获取交换机及routingKey信息和deliveryTag</li><li><strong>deliveryTag</strong>： deliveryTag 每次接收消息+1，可以做此消息处理通道的名字。用来回传告诉 rabbitmq 这个消息处理成功 清除此消息</li><li><strong>BasicProperties</strong>：基本属性，如Header中的信息。</li><li><strong>Delivery</strong>：封装了Envelope，BasicProperties及字节数组消息</li></ul><h2 id="Exchanges交换机"><a href="#Exchanges交换机" class="headerlink" title="Exchanges交换机"></a>Exchanges交换机</h2><p><strong>默认Exchange(RabbitMQ自带的Direct交换机，没有名称，与所有队列相连)**：比较Message的routing key和Queue的名字，完全匹配时，Message才会发送到该Queue<br><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/1-1607999220900.gif" style="zoom:80%;"><br>**Direct Exchange</strong>：比较Message的routing key和Queue的binding key，完全匹配时，Message才会发送到该Queue<br><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/2.gif" style="zoom:80%;"><br><strong>Fanout Exchange</strong>：忽略key对比，发送Message到Exchange下游绑定的所有Queue<br><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/1.gif" style="zoom: 80%;"><br><strong>Topic Exchange</strong>：比较Message的routing key和Queue的binding key，按规则匹配成功时，Message才会发送到该Queue</p><ul><li><strong>routing key命名规则</strong>：用”.”分割的字母或数字</li><li><strong>匹配规则</strong>：<ul><li>*：匹配单个字母或数字</li><li>#：匹配0~多个字母或数字</li><li>比如：*.stock.#与usd.stock、eur.stock.db匹配；但与stock.nasdaq不匹配<br><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/640" alt="img"></li></ul></li></ul><p><strong>Headers Exchange</strong>：比较队列上带有的Headers的键值对是否和发送的消息Message对象带的message是否匹配，通过Headers上的键值对判断是使用全匹配还是包含匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headerMap.put(<span class="string">&quot;x-match&quot;</span>, (matchAll ? <span class="string">&quot;all&quot;</span> : <span class="string">&quot;any&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h2><ul><li>存放消息</li><li>消息消费监听，监听的是队列，和其它如交换机没有关联</li></ul><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><ul><li>生产者指定Message的routing key，并指定Message发送到哪个Exchange</li><li>Queue会通过binding key绑定到指定的Exchange</li><li>Exchange根据对比Message的routing key和Queue的binding key，然后按一定的分发路由规则，决定Message发送到哪个Queue</li></ul><h2 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h2><p>​    监听指定队列，消息push到消费者端。spring的监听注解会自动创建不存在的交换机，队列，及绑定key。</p><h3 id="消息队列有两种工作方式"><a href="#消息队列有两种工作方式" class="headerlink" title="消息队列有两种工作方式"></a>消息队列有两种工作方式</h3><ul><li><p>轮询分发(默认)默认Spring是获取250个数据，RabbitMQ官方建议是30</p></li><li><p>公平分发即当某个消费者没有消费完成之前不用再分发消息。当执行时间增长的时候验证是否正确</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者每次从队列获取的消息数量。此属性当不设置时为：轮询分发，设置为1为：公平分发</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;direct.queue&quot;), exchange = @Exchange(value = &quot;direct.exchange&quot;), key = &quot;HelloWorld&quot;)&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDirectMessage</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 模拟异常</span></span><br><span class="line">            String is = <span class="keyword">null</span>;</span><br><span class="line">            is.toString();</span><br><span class="line">            <span class="comment">// 确认收到消息，false只确认当前consumer一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已重复处理失败,拒绝再次接收&quot;</span> + user.getName());</span><br><span class="line">                <span class="comment">// 拒绝消息，requeue=false 表示不再重新入队，如果配置了死信队列则进入死信队列</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息即将再次返回队列处理&quot;</span> + user.getName());</span><br><span class="line">                <span class="comment">// requeue为是否重新回到队列，true重新入队</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDirectMessageCopy</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;--jxb--MQConsumer--getDirectMessageCopy：&quot;</span> + user.toString());</span><br><span class="line">            <span class="comment">// 确认收到消息，false只确认当前consumer一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已重复处理失败,拒绝再次接收！&quot;</span>);</span><br><span class="line">                <span class="comment">// 拒绝消息，requeue=false 表示不再重新入队，如果配置了死信队列则进入死信队列</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息即将再次返回队列处理！&quot;</span>);</span><br><span class="line">                <span class="comment">// requeue为是否重新回到队列，true重新入队</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h2><p>​    主动拉取队列里的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(ConnectionUtils.QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h2 id="基本AIPI"><a href="#基本AIPI" class="headerlink" title="基本AIPI"></a>基本AIPI</h2><p><strong>channel.exchangeDeclare()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type：有direct、fanout、topic三种</span><br><span class="line">durable：true：服务器重启会保留下来Exchange。警告：仅设置此选项，不代表消息持久化。即不保证重启后消息还在。</span><br><span class="line">autoDelete: true:当已经没有消费者时，服务器是否可以删除该Exchange。</span><br></pre></td></tr></table></figure><p><strong>chanel.exchangeBind()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);</span><br><span class="line">用于通过绑定bindingKey将queue到Exchange，之后便可以进行消息接收</span><br></pre></td></tr></table></figure><p><strong>channel.queueDeclare(QUEUE_NAME, false, false, false, null);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">durable：true：在服务器重启时，能够存活</span><br><span class="line">exclusive ：是否为当前连接的专用队列，在连接断开后，会自动删除该队列，生产环境中应该很少用到吧。</span><br><span class="line">autodelete：当没有任何消费者使用时，自动删除该队列。this means that the queue will be deleted when there are no more processes consuming messages from it.</span><br></pre></td></tr></table></figure><p><strong>chanel.basicQos()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prefetchSize：0 目前好像没有作用，至少rabbitmq3.8.5不能使用，报错</span><br><span class="line">prefetchCount：会告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack。是服务端属性，通过rpc方法调用，存在服务端，客户端不需要使用</span><br><span class="line">global：true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别的还是consumer级别。如果true并且prefetchCount为4，有二个消费者，此时每个消费者可以读取到二条。如果为fasle，每个消费者获取到4条数据</span><br></pre></td></tr></table></figure><p><strong>channel.basicPublish()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routingKey：路由键，#匹配0个或多个单词，*匹配一个单词，在topic exchange做消息转发用</span><br><span class="line">mandatory：true：如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue，那么会调用basic.return方法将消息返还给生产者。false：出现上述情形broker会直接将消息扔掉</span><br><span class="line">immediate：true：如果exchange在将消息route到queue(s)时发现对应的queue上没有消费者，那么这条消息不会放入队列中。当与消息routeKey关联的所有queue(一个或多个)都没有消费者时，该消息会通过basic.return方法返还给生产者。</span><br><span class="line">BasicProperties ：需要注意的是BasicProperties.deliveryMode，0:不持久化 1：持久化 这里指的是消息的持久化，配合channel(durable&#x3D;true),queue(durable)可以实现，即使服务器宕机，消息仍然保留</span><br><span class="line">简单来说：mandatory标志告诉服务器至少将该消息route到一个队列中，否则将消息返还给生产者；immediate标志告诉服务器如果该消息关联的queue上有消费者，则马上将消息投递给它，如果所有queue都没有消费者，直接把消息返还给生产者，不用将消息入队列等待消费者了。</span><br></pre></td></tr></table></figure><p><strong>channel.basicAck();</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息。</span><br></pre></td></tr></table></figure><p><strong>channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">multiple：是否批量.true:将一次性拒绝所有小于deliveryTag的消息。</span><br><span class="line">requeue：被拒绝的是否重新入队列</span><br></pre></td></tr></table></figure><p><strong>channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">requeue：被拒绝的是否重新入队列</span><br><span class="line">channel.basicNack 与 channel.basicReject 的区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</span><br></pre></td></tr></table></figure><p><strong>channel.basicConsume(QUEUE_NAME, true, consumer);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</span><br></pre></td></tr></table></figure><p><strong>channel.basicGet(ConnectionUtils.QUEUE_NAME, false);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><strong>Connection与Channel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createChannel();</span><br></pre></td></tr></table></figure><p>一个连接可以创建多个Channel</p><p><strong>Channel与消费者Consume</strong></p><p>一个Channel上可以设置多个Consume,因此可以设置最大值，Spring中通过设置concurrency和max-concurrency配置消费者个数</p><p><strong>prefetchSize、prefetchCount、Global</strong></p><p>spring中有prefetch即prefetchCount，batch-size。取最大值设置为prefetchCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue</span><br><span class="line"><span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">InternalConsumer consumer = <span class="keyword">new</span> InternalConsumer(<span class="keyword">this</span>.channel, queue);</span><br><span class="line">String consumerTag = <span class="keyword">this</span>.channel.basicConsume(queue, <span class="keyword">this</span>.acknowledgeMode.isAutoAck(),</span><br><span class="line">                                               (<span class="keyword">this</span>.tagStrategy != <span class="keyword">null</span> ? <span class="keyword">this</span>.tagStrategy.createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="keyword">this</span>.noLocal,</span><br><span class="line">                                               <span class="keyword">this</span>.exclusive, <span class="keyword">this</span>.consumerArgs,</span><br><span class="line">                                               consumer);</span><br></pre></td></tr></table></figure><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（三）之数据结构总章</title>
      <link href="2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/"/>
      <url>2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><p>数组（数组、循环数组）查找、更新可以通过下标，时间复杂度为O(1);插入、删除需要移动数据在数组的位置O(n)</p><p><strong>基本操作</strong>：读取元素，更新元素，插入元素，删除元素（涉及数组元素移动位置，取巧方式：将最后一个元素更新删除元素）</p></li><li><p>链表（单向链表、双向链表、循环链表）查找需要一直向下查找，时间复杂度为O(n);插入、删除、更新指针变动即可O(1)</p><p><strong>基本操作</strong>：查找节点，更新节点，插入节点，删除节点</p><p><img src="/2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/image-20201201102615715.png" alt="image-20201201102615715"></p></li><li><p>栈（Stack）：FILO（First In Last Out，先入后出），最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作栈顶（top）。可以使用数组或链表来实现。时间复杂度都是O(1)</p><p><strong>基本操作</strong>：入栈push（从栈顶压入元素），出栈pop（从栈顶弹出元素）</p></li><li><p>队列（queue，单向队列，双端队列，优先队列，堵塞队列）：FIFO（First In First Out，先进先出），队列的出口端叫作队头（front），队列的入口端叫作队尾（rear）。可以使用数组或链表来实现。时间复杂度都是O(1)。数组实现队列会导致空间越来越小，可以使用循环数组。</p><p><strong>基本操作</strong>：入队enqueue（从队尾插入元素），出队dequeue（从对头移出元素）</p><table><thead><tr><th>对比项</th><th>作用及示例</th></tr></thead><tbody><tr><td>栈的应用</td><td>栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。<br>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。<br>栈还有一个著名的应用场景是面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面。</td></tr><tr><td>队列的应用</td><td>队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。<br>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。<br>再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的</td></tr></tbody></table><p><font color="red"><strong>双端队列（deque）</strong></font>：既可以先入先出，也可以先入后出。从队头一端可以入队或出队，从队尾一端也可以入队或出队</p><p><font color="red"><strong>优先队列</strong></font>：它遵循的不是先入先出，而是谁的优先级最高，谁先出队。优先队列已经<strong>不属于线性数据结构的范畴</strong>了，它是<strong>基于二叉堆来实现的</strong></p></li><li><p>散列表：也叫哈希表（Hash table），提供了键（Key）和值（Value）的映射关系,只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于O(1)。<font color="red">散列表可以说是数组和链表的结合。</font></p><p><strong>基本操作</strong>：写操作put,读操作get,扩容resize</p><p><strong>哈希冲突（哈希碰撞）</strong>解决方法：</p><p>​        <strong>开放寻址法</strong>：当一个Key通过哈希函数获得对应的数组下标已被占用时，我们可以“另谋高就”，寻找下一个空档位置，一直向下找。在Java中，ThreadLocal所使用的就是开放寻址法</p><p>​        <strong>链表法</strong>：应用在了Java的集合类HashMap当中，数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可</p></li><li><p>树（tree,二叉树、二叉查找树（排序树）、平衡二叉树、红黑树、B-树、B+树）是n（n≥0）个节点的有限集。当n=0时，称为空树。</p><p>树–&gt;二叉树–&gt;完全二叉树–&gt;满二叉树–&gt;二叉堆–&gt;二叉查找树（排序树）</p></li><li><p>图（？）</p></li></ul><h2 id="java数据结构"><a href="#java数据结构" class="headerlink" title="java数据结构"></a>java数据结构</h2><p>见java集合文章</p><h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序 存储，访问方式是随机访问。利用下标查找数组元素的时间复杂度是O(1)，中间插入、删除数组元素的时间复杂度是O(n)。 </p><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查找链表节点的时间 复杂度是O(n)，中间插入、删除节点的时间复杂度是O(1)。 </p><h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p>栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和 出栈操作，遵循先入后出的原则（FILO）。 </p><h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。 </p><h2 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h2><p>散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作。散列表通过哈希函数实现Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突</p><h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><p>树是n个节点的有限集，有且仅有一个特定的称为根的节点。当n&gt;1时，其余节点可分为m个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 </p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点。二叉树包含完全二叉树和满二叉树两种特殊形式。 </p><h2 id="二叉树的遍历方式有几种"><a href="#二叉树的遍历方式有几种" class="headerlink" title="二叉树的遍历方式有几种"></a>二叉树的遍历方式有几种</h2><p>根据遍历节点之间的关系，可以分为前序遍历、中序遍历、后序遍历、层序遍历这4种方式；从更宏观的角度划分，可以划分为深度优先遍历和广度优先遍历两大类。</p><h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。<br>在最大堆中，任何一个父节点的值，都大于或等于它左、右孩子节点的值。<br>在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的值。 </p><h2 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h2><p>优先队列分为最大优先队列和最小优先队列。<br>在最大优先队列中，无论入队顺序如何，当前最大的元素都会优先出队，这是基于最大堆实现的。<br>在最小优先队列中，无论入队顺序如何，当前最小的元素都会优先出队，这是基于最小堆实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（二）</title>
      <link href="2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211111476.png" alt="img" style="zoom: 67%;"><h2 id="数据结构内容"><a href="#数据结构内容" class="headerlink" title="数据结构内容"></a>数据结构内容</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211129378.png" alt="img" style="zoom: 67%;"><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/201901212111451.png" alt="img" style="zoom: 67%;"><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201124212642358.png" alt="image-20201124212642358" style="zoom:50%;"><h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><p>大多数以数组和链表作为存储方式，因此物理结构为：</p><ul><li>顺序存储结构 （一段连续的内存空间。随机访问效率高；插入删除效率低，大小固定，可以扩容）</li><li>链式存储结构（不连续的内存空间。大小动态扩展，插入删除效率高；不能随机访问）</li><li>散列存储结构（为了方便查找，整体无序，但索引块之间有序，需要额外空间，存储索引表。对顺序查找的一种改进，查找效率高；需额外空间存储索引）</li><li>索引存储结构（选取某个函数，数据元素根据函数计算存储位置可能存在多个数据元素存储在同一位置，引起地址冲。查找基于数据本身即可找到，查找效率高，存取效率高。存取随机，不便于顺序查找）</li></ul><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是抽象的概念，它依赖于物理结构而存在。是对数据元素之间存在的逻辑关系的描述。分为二大类：线性结构和非线性结构。细分为四种：</p><ul><li><p>线性结构（线性结构中的数据元素之间是一对一的关系。注意：<font color="red">重点在一对一</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103023829.png" alt="image-20201125103023829" style="zoom: 33%;"></li><li><p>集合结构（就是数据元素同属一个集合，单个数据元素之间<font color="red">没有任何关系</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125102951179.png" alt="image-20201125102951179" style="zoom: 33%;"></li><li><p>树形结构（树形结构中的数据元素之间存在一对多的关系。各元素及元素关系所组成图形类似于树状图。注意：<font color="red">关系为一对多</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103039123.png" alt="image-20201125103039123" style="zoom: 33%;"></li><li><p>图形结构（数据元素之间是<font color="red">多对多的关系</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103056213.png" alt="image-20201125103056213" style="zoom: 33%;"></li></ul><p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211307827.png" alt="img"></p><p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211350180.png" alt="img"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_39385118/article/details/80835048">数据结构之逻辑结构与物理结构（存储结构）</a></p><p><a href="https://blog.csdn.net/qq_41523096/article/details/86566982">《数据结构》| 第一章 绪论 知识梳理</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（一）</title>
      <link href="2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>在数学领域里，算法是用于解决某一类问题的公式和思想。</li><li>在计算机科学领域，算法的本质是一系列程序指令，用于解决特定的运算和逻辑问题。是对特定问题求解方法（步骤）的一种描述，是指令的有限序列，其中每一条指令表示一个或多个操作。</li></ul><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125100745940.png" alt="image-20201125100745940"></p><h2 id="算法的设计目标"><a href="#算法的设计目标" class="headerlink" title="算法的设计目标"></a>算法的设计目标</h2><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125101019149.png" alt="image-20201125101019149"></p><h2 id="算法标准"><a href="#算法标准" class="headerlink" title="算法标准"></a>算法标准</h2><p>在计算机领域，我们同样会遇到各种高效和拙劣的算法。衡量算法好坏的重要标准有两个。 </p><ul><li>时间复杂度</li><li>空间复杂度</li></ul><h2 id="算法的应用领域"><a href="#算法的应用领域" class="headerlink" title="算法的应用领域"></a>算法的应用领域</h2><p>算法可以应用在很多不同的领域中，其应用场景更是多种多样。</p><ul><li>运算（如最大公约数）</li><li>查找（搜索引擎，Mysql查询）</li><li>排序（电商商品排序，排名）。排序算法是实现诸多复杂程序的基石</li><li>最优决策（如找出最佳路线，有限背包存价值最高物品使用动态规划算法）</li><li>面试（主要时为了它，不然学它干嘛）</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构，对应的英文单词是data structure，是数据的组织、管理和存储格式， 其使用目的是为了高效地访问和修改数据。</p><h2 id="数据结构组成方式"><a href="#数据结构组成方式" class="headerlink" title="数据结构组成方式"></a>数据结构组成方式</h2><ul><li>线性结构（最简单的数据结构，包含数组，链表及由它们衍生的栈、队列、哈希表）</li><li>树（树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构）</li><li>图（图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系）</li><li>其他数据结构（除上述基本数据结构外，还有其它千奇百怪的数据结构。由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等）</li></ul><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>有了数据结构这个舞台，算法才可以尽情舞蹈。在解决问题时，不同的算法会选用不同的数据结构。例如排序算法中的堆排序，利用的就是二叉堆这样一种数据结构；再如缓存淘汰算法LRU（Least Recently Used，最近最少使用），利用的就是特殊数据结构哈希链表。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>基本操作执行次数的函数T(n),若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。 <font color="red">因为渐进时间复杂度用大写O来表示，所以也被称为大O表示法。</font> </p><p>直白地讲，时间复杂度就是把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是n、n2、n3等。</p><p>时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作T(n)=O(f(n))。</p><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125101210140.png" alt="image-20201125101210140"></p><h2 id="推导出时间复杂度原则"><a href="#推导出时间复杂度原则" class="headerlink" title="推导出时间复杂度原则"></a>推导出时间复杂度原则</h2><ul><li><p>如果运行时间是常数量级，则用常数1表示 </p></li><li><p>只保留时间函数中的最高阶项 </p></li><li><p>如果最高阶项存在，则省去最高阶项前面的系数</p></li></ul><h2 id="不同时间复杂度"><a href="#不同时间复杂度" class="headerlink" title="不同时间复杂度"></a>不同时间复杂度</h2><ul><li><p>多项式时间算法的时间复杂度：O(1)&lt;O(log<del>2</del>n)&lt;O(n)&lt;O(nlog<del>2</del>n)&lt;O(n^2^) &lt;O(n^3^)</p></li><li><p>指数时间算法的时间复杂度：O(2^n^)&lt;O(n!)&lt;O(n^n^)</p></li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中<font color="red"><strong>临时占用存储空间大小的量度</strong></font>，它同样使用了大O表示法。程序占用空间大小的计算公式记作S(n)=O(f(n))，其中n为问题的规模，f(n)为算法所占存储空间的函数。 <font color="red">空间复杂度就离不开数据结构。</font></p><h2 id="不同空间复杂度"><a href="#不同空间复杂度" class="headerlink" title="不同空间复杂度"></a>不同空间复杂度</h2><ul><li><p>常量空间（当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1)）</p></li><li><p>线性空间（当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];&#125;</span><br></pre></td></tr></table></figure></li><li><p>二维空间（当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n^2^)）</p></li><li><p>递归空间（递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。空间复杂度就是O(n)）</p></li></ul><h2 id="时间与空间的取舍"><a href="#时间与空间的取舍" class="headerlink" title="时间与空间的取舍"></a>时间与空间的取舍</h2><p>在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间，也要提升程序的执行速度。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataSource介绍及对比</title>
      <link href="2020/11/23/JDBC%E4%B9%8BDataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/"/>
      <url>2020/11/23/JDBC%E4%B9%8BDataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>DriverManager通过getConnection方法获取的连接，<font color="red">是建立与数据库的连接</font>。但是建立与数据库的连接是一项较耗资源的工作，频繁的进行数据库连接建立操作会产生较大的系统开销。</p><p>随着企业级应用复杂度的提升以及对性能要求的提高，这一点是难以接受的。</p><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p><strong>既然每次使用时都重新建立与数据库之间的连接，会产生较大的系统开销。是否可以事先创建一些连接备用，当需要时，从这些连接中选择一个提供出去；当连接使用完毕后，并不是真正的关闭，而是将这些数据状态还原，然后继续等待下一个人使用</strong></p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>DriverManager只是建立与数据库之间的连接，如何才能将连接池的概念应用其中？</p><p><strong>一种很自然的方式就是提供一个薄层的封装，建立一个中间层，这个中间层将DriverManager生成的连接，组织到连接池中，然后从池中提供连接</strong></p><p><img src="/2020/11/23/JDBC%E4%B9%8BDataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/897393-20190125140250476-31357459.png" alt="img"></p><p><strong>Data Source就是DriverManager的一种替代角色，对外呈现就类似于一个DriverManager，拥有对外提供连接的能力</strong></p><p>直接使用DriverManager，驱动程序与管理器是“服务者—管理者”的形式，借助于管理者才能提供服务。</p><p>Data Source将驱动程序的概念淡化了，突出驱动程序能够提供的服务与能力，将驱动程序提供的服务与能力抽象为Data Source数据源这一角色。</p><p><img src="/2020/11/23/JDBC%E4%B9%8BDataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/897393-20190125140251236-665240055.png" alt="img"></p><p><strong>DataSource中获取的连接来自于连接池中，而池中的连接根本也还是从DriverManager获取而来</strong></p><p>有了数据源这一中间层，就可以实现连接池和分布式事务的管理。</p><p><strong>对外呈现DataSource就是类似于DriverManager的一个存在。</strong></p><p><strong>DataSource的形式是JNDI （Java Naming Directory Interface）</strong></p><p>DataSource是JNDI资源的一种，那么到底什么是JNDI呢</p><p>此处不过多解释，可以简单认为JNDI是类似这样一个东西：</p><p>一个哈希表，类型为&lt;String，Object&gt;</p><p>JNDI的两个最主要操作：bind和lookup。bind操作负责往哈希表里存对象，lookup则根据这个键值字符串往外取对象。</p><p>开发人员可以使用键值——也就是一个字符串名称——来获取某个对象。</p><p><strong>简言之就是可以给一个对象命名，然后可以通过名称找到这个对象。</strong></p><p><strong>数据源的概念在应用程序与数据库连接之间插入了一个中间层，进而可以实现连接池以及事务管理，并且以JNDI的形式，也能够以非常方便的形式使用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> DataSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC原理分析</title>
      <link href="2020/11/20/JDBC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>2020/11/20/JDBC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JDBC（Java Database Connection）,java提供的一套操作数据库的api。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><strong>java.sql包主要接口</strong></p><ul><li>DriverManager ：驱动管理，可以加载驱动，获取Connection（通过Driver），高版本自动加载驱动Driver</li><li>Driver ：获取Connection</li><li>Connection: 创建Statement </li><li>Statement: Statement为一条Sql语句生成执行计划</li><li>PreparedStatement: 预编译sql语句，更安全，字符串参数会自动被驱动器忽略；PreparedStatement用于使用绑定变量重用执行计划，对于批量处理可以大大提高效率，但是如果是一次性存取操作性能开销更大。</li><li>ResultSet：Statement调用执行方法返回的结果</li><li><font color="red">Warapper</font>: 重点，<strong>适配器类</strong>，提供的扩展接口，方法unwrap返回未适配的对象， 方法isWrapperFor返回是否适配 。Connetion，Statement，ResultSet都继承Warapper接口。把一个由第三方供应商提供的、非 JDBC 标准的接口包装成标准接口</li></ul><p><strong>javax.sql包主要接口</strong></p><ul><li>DataSource：基本数据源接口，返回普通Connection</li><li>ConnectionPoolDataSource：连接池数据源接口，返回连接池连接（PooledConnection）</li><li>XADataSource：XA事务数据源，分布式事务，返回XA事务连接池连接（XAConnection 继承PooledConnection）</li><li>PooledConnection：连接池连接</li><li>XAConnection：XA事务连接池连接</li><li>RowSet：继承ResultSet</li><li>RowSetEvent，RowSetListener</li><li>StatementEvent,StatementEventListener</li><li>ConnectionEvent,ConnectionEventListener</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Driver loaded&quot;</span>);</span><br><span class="line">        Connection connection = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost/javabook&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Databases connected&quot;</span>);</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(</span><br><span class="line">                <span class="string">&quot;select ?, ?, ? from Student where lastName = ?&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;firstName&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, <span class="string">&quot;mi&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">3</span>, <span class="string">&quot;lastName&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">4</span>, <span class="string">&quot;Smith&quot;</span>);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="number">1</span>) + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                    resultSet.getString(<span class="number">2</span>) + <span class="string">&quot;\t&quot;</span> + resultSet.getString(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> DataSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java获取ip地址</title>
      <link href="2020/11/19/java%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80/"/>
      <url>2020/11/19/java%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="获取服务器本地ip"><a href="#获取服务器本地ip" class="headerlink" title="获取服务器本地ip"></a>获取服务器本地ip</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getHostAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String hostAddress = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">      hostAddress = address.getHostAddress();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hostAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Enumeration&lt;NetworkInterface&gt; allNetInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">      InetAddress ip = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (allNetInterfaces.hasMoreElements()) &#123;</span><br><span class="line">        NetworkInterface netInterface = allNetInterfaces.nextElement();</span><br><span class="line">        <span class="keyword">if</span> (netInterface.isLoopback() || netInterface.isVirtual() || !netInterface.isUp()) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Enumeration&lt;InetAddress&gt; addresses = netInterface.getInetAddresses();</span><br><span class="line">        <span class="keyword">while</span> (addresses.hasMoreElements()) &#123;</span><br><span class="line">          ip = addresses.nextElement();</span><br><span class="line">          <span class="keyword">if</span> (ip != <span class="keyword">null</span> &amp;&amp; ip <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">            <span class="keyword">return</span> ip.getHostAddress();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;IP地址获取失败&quot;</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取http请求的ip地址"><a href="#获取http请求的ip地址" class="headerlink" title="获取http请求的ip地址"></a>获取http请求的ip地址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIpAddr</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String ipAddress = request.getHeader(<span class="string">&quot;x-forwarded-for&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getRemoteAddr();</span><br><span class="line">      <span class="keyword">if</span> (ipAddress.equals(<span class="string">&quot;127.0.0.1&quot;</span>) || ipAddress.equals(<span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//根据网卡取本机配置的IP</span></span><br><span class="line">        InetAddress inet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inet = InetAddress.getLocalHost();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ipAddress = inet.getHostAddress();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割</span></span><br><span class="line">    <span class="keyword">if</span> (ipAddress != <span class="keyword">null</span> &amp;&amp; ipAddress.length() &gt; <span class="number">15</span>) &#123; <span class="comment">//&quot;***.***.***.***&quot;.length() = 15</span></span><br><span class="line">      <span class="keyword">if</span> (ipAddress.indexOf(<span class="string">&quot;,&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipAddress = ipAddress.substring(<span class="number">0</span>, ipAddress.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ipAddress;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon自定义负载规则</title>
      <link href="2020/11/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99/"/>
      <url>2020/11/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="配置Ribbon，指定每个服务使用的配置"><a href="#配置Ribbon，指定每个服务使用的配置" class="headerlink" title="配置Ribbon，指定每个服务使用的配置"></a>配置Ribbon，指定每个服务使用的配置</h2><p>java注解方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(value = &#123;</span></span><br><span class="line"><span class="meta">    @RibbonClient(name = &quot;order-service&quot;,configuration = RibbonLoadbalancerConfiguration.class)</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">,defaultConfiguration = RibbonLoadbalancerConfiguration.class)</span></span><br></pre></td></tr></table></figure><p>也可以使用配置文件，相比java配置，优先级更高</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">order-service:</span> <span class="comment">#指定服务配置</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NIWSServerListClass:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span> <span class="comment">#指定ServerList的实现类</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#指定IRule的实现类</span></span><br><span class="line"><span class="attr">ribbon:</span> <span class="comment">#全局配置</span></span><br><span class="line"><span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">RibbonLoadbalancerConfiguration</span> <span class="comment">#指定IRule的实现类</span></span><br></pre></td></tr></table></figure><h2 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeRibbonRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">        <span class="comment">// 获取所有的服务</span></span><br><span class="line">        List&lt;Server&gt; servers = lb.getAllServers();</span><br><span class="line">        servers.forEach(server -&gt; logger.info(<span class="string">&quot;服务器端口号：&#123;&#125;&quot;</span>,server.getHostPort()));</span><br><span class="line">        String host = getIpAddress(); <span class="comment">//本机ip</span></span><br><span class="line">        <span class="keyword">return</span> servers.stream().filter(server -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> server.getHost().equals(host);</span><br><span class="line">        &#125;).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora高亮及快捷键设置</title>
      <link href="2020/11/19/typora%E9%AB%98%E4%BA%AE%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE/"/>
      <url>2020/11/19/typora%E9%AB%98%E4%BA%AE%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Typora的高亮模式默认是关闭的（需手动打开）"><a href="#1、Typora的高亮模式默认是关闭的（需手动打开）" class="headerlink" title="1、Typora的高亮模式默认是关闭的（需手动打开）"></a>1、Typora的高亮模式默认是关闭的（需手动打开）</h2><p>打开方式：文件 &gt; 偏好设置 &gt; Markdown &gt; Markdown扩展语法中把 <strong>高亮</strong> 选中 &gt; <strong>重启Typora</strong><br><img src="https://img-blog.csdnimg.cn/20200920101054257.gif#pic_left" alt="在这里插入图片描述"></p><h2 id="2、如何更改高亮配色？（高亮默认颜色是黄色-D3D40E）"><a href="#2、如何更改高亮配色？（高亮默认颜色是黄色-D3D40E）" class="headerlink" title="2、如何更改高亮配色？（高亮默认颜色是黄色#D3D40E）"></a>2、如何更改高亮配色？（高亮默认颜色是黄色#D3D40E）</h2><p>打开方式：文件 &gt; 偏好设置 &gt; 外观 &gt; 打开主题文件夹 &gt; <em>night.css</em>文件 &gt; Ctrl+F 搜索 mark &gt; 修改喜欢的 background(背景颜色) 和 color(字体颜色) 保存<br><img src="https://img-blog.csdnimg.cn/20200920104332324.gif#pic_left" alt="在这里插入图片描述"></p><h2 id="3、如何设置高亮快捷键"><a href="#3、如何设置高亮快捷键" class="headerlink" title="3、如何设置高亮快捷键"></a>3、如何设置高亮快捷键</h2><p>设置方式：文件 &gt; 偏好设置 &gt; 通用 &gt; 打开高级设置 &gt; 会看到两个<em>json</em>文件，打开其中一个 &gt; 在 “keyBinding” 中添加 <strong>“Highlight”:“Ctrl+Shift+H”</strong>&gt; 保存 &gt; 另一个json文件也在 “keyBinding” 中添加 <strong>“Highlight”:“Ctrl+Shift+H”</strong> &gt; 保存<br><img src="https://img-blog.csdnimg.cn/20200920110453114.gif#pic_left" alt="在这里插入图片描述"></p><h2 id="typora使用文档"><a href="#typora使用文档" class="headerlink" title="typora使用文档"></a>typora使用文档</h2><p><a href="https://blog.dontjudge.cn/post/%E5%9F%BA%E4%BA%8E-typora-%E7%9A%84-markdown-%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/#%E5%9F%BA%E4%BA%8E-typora-%E7%9A%84-markdown-%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99">基于 Typora 的 Markdown 文档编写</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora字体设置颜色</title>
      <link href="2020/11/19/typora%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/"/>
      <url>2020/11/19/typora%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://ispotu.blog.csdn.net/">ispotu</a></p><p>出处：<a href="https://blog.csdn.net/superit401/article/details/106344453/">https://blog.csdn.net/superit401/article/details/106344453/</a></p><p>typora没有直接设置字体颜色的功能，不能像word一样，选中字体直接设置想要的颜色。</p><p>下面第一种方法需安装软件AutoHotKey，操作还算简单；后两种方法都是偏技术的，对于非技术的小白可能有点困难。</p><h2 id="方案一：安装软件AutoHotKey（较简单）"><a href="#方案一：安装软件AutoHotKey（较简单）" class="headerlink" title="方案一：安装软件AutoHotKey（较简单）"></a>方案一：安装软件AutoHotKey（较简单）</h2><p>AutoHotKey是一款著名的windows系统快捷键设置的软件，轻便小巧。</p><p>官方下载: <a href="https://autohotkey.com/download/ahk-install.exe">https://autohotkey.com/download/ahk-install.exe</a></p><p> （1）先安装AutoHotKey</p><p>（2）打开记事本，把如下内容复制粘贴进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; Typora</span><br><span class="line">; 快捷增加字体颜色</span><br><span class="line">; SendInput &#123;Text&#125; 解决中文输入法问题</span><br><span class="line"></span><br><span class="line">#IfWinActive ahk_exe Typora.exe&#123;</span><br><span class="line">    ; Ctrl+Alt+O 橙色</span><br><span class="line">    ^!o::addFontColor(&quot;orange&quot;)</span><br><span class="line">    ; Ctrl+Alt+R 红色</span><br><span class="line">    ^!r::addFontColor(&quot;red&quot;)</span><br><span class="line">    ; Ctrl+Alt+B 浅蓝色</span><br><span class="line">    ^!b::addFontColor(&quot;cornflowerblue&quot;)</span><br><span class="line">&#125;</span><br><span class="line">; 快捷增加字体颜色</span><br><span class="line">addFontColor(color)&#123;</span><br><span class="line">    clipboard :&#x3D; &quot;&quot; ; 清空剪切板</span><br><span class="line">    Send &#123;ctrl down&#125;c&#123;ctrl up&#125; ; 复制</span><br><span class="line">    SendInput &#123;TEXT&#125;&lt;font color&#x3D;&#39;%color%&#39;&gt;</span><br><span class="line">    SendInput &#123;ctrl down&#125;v&#123;ctrl up&#125; ; 粘贴</span><br><span class="line">    If(clipboard &#x3D; &quot;&quot;)&#123;</span><br><span class="line">        SendInput &#123;TEXT&#125;&lt;&#x2F;font&gt; ; Typora 在这不会自动补充</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        SendInput &#123;TEXT&#125;&lt;&#x2F; ; Typora中自动补全标签</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）将文件保存为ahk后缀的文件，如TyporaHotKey.ahk</p><p>(4)双击运行</p><p>（5）在Typora软件里就可以使用快捷键：如按<code>Ctrl+Alt+O</code>添加橙色，Ctrl+Alt+R 红色，按<code>Ctrl+\</code>取消样式！</p><p>也可以右键 <code>MyHotkeyScript.ahk</code> 脚本文件，点击<code>Compile Script</code>编译脚本成<code>exe</code>程序，就可以不用下载<code>Autohotkey</code>在其他电脑上运行了。</p><p>上面脚本只写了橙色、红色、浅蓝三种颜色，你可以按需照例增加其他颜色或快捷方式！</p><h2 id="方案二：改html代码（懂前端技术超简单）"><a href="#方案二：改html代码（懂前端技术超简单）" class="headerlink" title="方案二：改html代码（懂前端技术超简单）"></a>方案二：改html代码（懂前端技术超简单）</h2><p>视图——开发者工具（Shift+F12），打开html代码调试模式</p><p> 按快捷键Shift+F12（可能还需要同时按住Fn）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;&quot;</span>&gt;</span>你要改色的文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照这个模板，改字体的style属性即可。</p><p>示例：</p><p>style=”color:red”</p><p>style=”color:maroon”</p><p>style=”color:fuchsia”</p><p>style=”color:brown”</p><p>style=”color:blue”</p><p>style=”color:aqua”</p><p>style=”color:green”</p><p>style=”color:orange”</p><p>style=”color:purple”</p><p>style=”color:white;background:black;”</p><p>style=”background:yellow”</p><p>style=”background:red”</p><p>style=”background:orange”</p><p>style=”color:white;background:green”</p><p>style=”color:white;background:blue”</p><p><img src="https://img-blog.csdnimg.cn/20200525225939274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyaXQ0MDE=,size_16,color_FFFFFF,t_70" alt="img"></p><h1 id="方案三：使用内联公式（复杂）"><a href="#方案三：使用内联公式（复杂）" class="headerlink" title="方案三：使用内联公式（复杂）"></a>方案三：使用内联公式（复杂）</h1><p><strong>1.开启使用内联公式</strong></p><p>文件——偏好设置（Ctrl+逗号）——Markdown——勾选“内联公式”——重启Typora</p><p><img src="https://img-blog.csdnimg.cn/20200525230147618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyaXQ0MDE=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>2.输入公式代码设置颜色</strong></p><p>输入$，按Esc键会自动在后面加上一个$，然后在这两个$之间输入公式。</p><p>如：</p><p><img src="https://img-blog.csdnimg.cn/20200525231636600.png" alt="img"></p><p>直接在typora里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;Magenta&#125;&#123;洋红色&#125; $:设置颜色为$\textcolor&#123;RedOrange&#125;&#123;橙红色&#125; $，设置字体颜色为$\textcolor&#123;Blue&#125;&#123;蓝色&#125; $。数学公式里各元素也能分别设置颜色：</span><br><span class="line">$\textcolor&#123;red&#125;&#123;\int_a^b&#125;\textcolor&#123;blue&#125;&#123;f(x)&#125;\textcolor&#123;green&#125;&#123;dx&#125;\textcolor&#123;brown&#125;&#123;&#x3D;c&#125;$</span><br></pre></td></tr></table></figure><p>文本颜色设置公式：</p><p><font color="red"><strong>$\textcolor{red}{这里输入你要改变颜色的文字} $</strong></font></p><h3 id="颜色公式代码大全："><a href="#颜色公式代码大全：" class="headerlink" title="颜色公式代码大全："></a>颜色公式代码大全：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;GreenYellow&#125;&#123;GreenYellow&#125; $</span><br><span class="line">$\textcolor&#123;Yellow&#125;&#123;Yellow&#125;$</span><br><span class="line">$\textcolor&#123;Goldenrod&#125;&#123;Goldenrod&#125; $</span><br><span class="line">$\textcolor&#123;Dandelion&#125;&#123;Dandelion&#125;$</span><br><span class="line">$\textcolor&#123;Apricot&#125;&#123;Apricot&#125; $</span><br><span class="line">$\textcolor&#123;Peach&#125;&#123;Peach&#125;$</span><br><span class="line">$\textcolor&#123;Melon&#125;&#123;Melon&#125; $</span><br><span class="line">$\textcolor&#123;YellowOrange&#125;&#123;YellowOrange&#125;$</span><br><span class="line">$\textcolor&#123;Orange&#125;&#123;Orange&#125; $</span><br><span class="line">$\textcolor&#123;BurntOrange&#125;&#123;BurntOrange&#125;$</span><br><span class="line">$\textcolor&#123;Bittersweet&#125;&#123;Bittersweet&#125;$</span><br><span class="line">$\textcolor&#123;RedOrange&#125;&#123;RedOrange&#125; $</span><br><span class="line">$\textcolor&#123;Mahogany&#125;&#123;Mahogany&#125;$</span><br><span class="line">$\textcolor&#123;Maroon&#125;&#123;Maroon&#125; $</span><br><span class="line">$\textcolor&#123;BrickRed&#125;&#123;BrickRed&#125;$</span><br><span class="line">$\textcolor&#123;Red&#125;&#123;Red&#125; $</span><br><span class="line">$\textcolor&#123;OrangeRed&#125;&#123;OrangeRed&#125;$</span><br><span class="line">$\textcolor&#123;RubineRed&#125;&#123;RubineRed&#125;$</span><br><span class="line">$\textcolor&#123;WildStrawberry&#125;&#123;WildStrawberry&#125;$</span><br><span class="line">$\textcolor&#123;Salmon&#125;&#123;Salmon&#125;$</span><br><span class="line">$\textcolor&#123;CarnationPink&#125;&#123;CarnationPink&#125;$</span><br><span class="line">$\textcolor&#123;Magenta&#125;&#123;Magenta&#125; $</span><br><span class="line">$\textcolor&#123;VioletRed&#125;&#123;VioletRed&#125;$</span><br><span class="line">$\textcolor&#123;Rhodamine&#125;&#123;Rhodamine&#125; $</span><br><span class="line">$\textcolor&#123;Mulberry&#125;&#123;Mulberry&#125;$</span><br><span class="line">$\textcolor&#123;RedViolet&#125;&#123;RedViolet&#125; $</span><br><span class="line">$\textcolor&#123;Fuchsia&#125;&#123;Fuchsia&#125;$</span><br><span class="line">$\textcolor&#123;Lavender&#125;&#123;Lavender&#125; $</span><br><span class="line">$\textcolor&#123;Thistle&#125;&#123;Thistle&#125;$</span><br><span class="line">$\textcolor&#123;Orchid&#125;&#123;Orchid&#125; $</span><br><span class="line">$\textcolor&#123;DarkOrchid&#125;&#123;DarkOrchid&#125;$</span><br><span class="line">$\textcolor&#123;Purple&#125;&#123;Purple&#125; $</span><br><span class="line">$\textcolor&#123;Plum&#125;&#123;Plum&#125;$</span><br><span class="line">$\textcolor&#123;Violet&#125;&#123;Violet&#125; $</span><br><span class="line">$\textcolor&#123;RoyalPurple&#125;&#123;RoyalPurple&#125;$</span><br><span class="line">$\textcolor&#123;BlueViolet&#125;&#123;BlueViolet&#125;$</span><br><span class="line">$\textcolor&#123;Periwinkle&#125;&#123;Periwinkle&#125;$</span><br><span class="line">$\textcolor&#123;CadetBlue&#125;&#123;CadetBlue&#125;$</span><br><span class="line">$\textcolor&#123;CornflowerBlue&#125;&#123;CornflowerBlue&#125;$</span><br><span class="line">$\textcolor&#123;MidnightBlue&#125;&#123;MidnightBlue&#125;$</span><br><span class="line">$\textcolor&#123;NavyBlue&#125;&#123;NavyBlue&#125; $</span><br><span class="line">$\textcolor&#123;RoyalBlue&#125;&#123;RoyalBlue&#125;$</span><br><span class="line">$\textcolor&#123;Blue&#125;&#123;Blue&#125; $</span><br><span class="line">$\textcolor&#123;Cerulean&#125;&#123;Cerulean&#125;$</span><br><span class="line">$\textcolor&#123;Cyan&#125;&#123;Cyan&#125; $</span><br><span class="line">$\textcolor&#123;ProcessBlue&#125;&#123;ProcessBlue&#125;$</span><br><span class="line">$\textcolor&#123;SkyBlue&#125;&#123;SkyBlue&#125; $</span><br><span class="line">$\textcolor&#123;Turquoise&#125;&#123;Turquoise&#125;$</span><br><span class="line">$\textcolor&#123;TealBlue&#125;&#123;TealBlue&#125; $</span><br><span class="line">$\textcolor&#123;Aquamarine&#125;&#123;Aquamarine&#125;$</span><br><span class="line">$\textcolor&#123;BlueGreen&#125;&#123;BlueGreen&#125; $</span><br><span class="line">$\textcolor&#123;Emerald&#125;&#123;Emerald&#125;$</span><br><span class="line">$\textcolor&#123;JungleGreen&#125;&#123;JungleGreen&#125;$</span><br><span class="line">$\textcolor&#123;SeaGreen&#125;&#123;SeaGreen&#125; $</span><br><span class="line">$\textcolor&#123;Green&#125;&#123;Green&#125;$</span><br><span class="line">$\textcolor&#123;ForestGreen&#125;&#123;ForestGreen&#125;$</span><br><span class="line">$\textcolor&#123;PineGreen&#125;&#123;PineGreen&#125; $</span><br><span class="line">$\textcolor&#123;LimeGreen&#125;&#123;LimeGreen&#125;$</span><br><span class="line">$\textcolor&#123;YellowGreen&#125;&#123;YellowGreen&#125;$</span><br><span class="line">$\textcolor&#123;SpringGreen&#125;&#123;SpringGreen&#125;$</span><br><span class="line">$\textcolor&#123;OliveGreen&#125;&#123;OliveGreen&#125;$</span><br><span class="line">$\textcolor&#123;RawSienna&#125;&#123;RawSienna&#125; $</span><br><span class="line">$\textcolor&#123;Sepia&#125;&#123;Sepia&#125;$</span><br><span class="line">$\textcolor&#123;Brown&#125;&#123;Brown&#125; $</span><br><span class="line">$\textcolor&#123;Tan&#125;&#123;Tan&#125;$</span><br><span class="line">$\textcolor&#123;Gray&#125;&#123;Gray&#125; $</span><br><span class="line">$\textcolor&#123;Black&#125;&#123;Black&#125;$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用next主题</title>
      <link href="2020/11/17/hexo%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98/"/>
      <url>2020/11/17/hexo%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="主题next"><a href="#主题next" class="headerlink" title="主题next"></a>主题next</h2><p><strong>下载next主题</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p><strong>根据要求修改主题下_config.yml配置</strong></p><p><a href="https://theme-next.js.org/docs/theme-settings/">next文档</a></p><h2 id="更复杂的自定义优化可以参考如下文章"><a href="#更复杂的自定义优化可以参考如下文章" class="headerlink" title="更复杂的自定义优化可以参考如下文章"></a>更复杂的自定义优化可以参考如下文章</h2><p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">Hexo博客优化之Next主题美化</a></p><p><a href="https://theme-next.js.org/docs/tag-plugins/mermaid.html">可以生成图形</a></p><p><a href="https://www.cnblogs.com/whiremapple/p/12419097.html">Hexo博客主题安装和优化（一）</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql进阶操作</title>
      <link href="2020/11/17/mysql%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/17/mysql%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="转储操作"><a href="#转储操作" class="headerlink" title="转储操作"></a>转储操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE table t_a (SELECT * from o_order limit 10);</span><br><span class="line">INSERT into t_a SELECT *,5 FROM o_order limit 10;</span><br></pre></td></tr></table></figure><p><strong>区别</strong></p><ol><li>第一个sql执行的时候，表t_a不能存在</li><li>第二个sql执行时，表必须存在，可以设置指定常量字段即二个表字段有差异</li></ol><h2 id="插入操作（可忽略或更新已存在）"><a href="#插入操作（可忽略或更新已存在）" class="headerlink" title="插入操作（可忽略或更新已存在）"></a>插入操作（可忽略或更新已存在）</h2><p><strong>1. insert into</strong>表示插入数据，数据库会检查主键（PrimaryKey）或者unique索引，如果出现重复会报错；</p><p><strong>2. insert ignore into</strong> table(name)  select  name from table2; 根据主键（PrimaryKey）或者unique索引判断，如果已存在则忽略数据，否则插入数据</p><p><strong>3. replace into</strong>表示插入替换数据，需求表中有PrimaryKey，或者unique索引的话，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样；</p><p>REPLACE语句会返回一个数，来指示受影响的行的数目。该数是被删除和被插入的行数的和。如果对于一个单行REPLACE该数为1，则一行被插入，同时没有行被删除。<br>如果该数大于1，则在新行被插入前，有一个或多个旧行被删除。如果表包含多个唯一索引，并且新行复制了在不同的唯一索引中的不同旧行的值，则有可能是一个单一行替换了多个旧行</p><p><strong>4. insert into … ON DUPLICATE KEY UPDATE</strong></p><p><strong>如果你插入的记录导致一个UNIQUE索引或者primary key(主键)出现重复，那么就会认为该条记录存在，则执行update语句而不是insert语句，反之，则执行insert语句而不是更新语句</strong></p><p>如果行作为新记录被插入，则受影响行的值为1；如果原有的记录被更新，则受影响行的值为2，如果更新的数据和已有的数据一模一样，则受影响的行数是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table testtb(</span><br><span class="line">  id int not null primary key,</span><br><span class="line">  name varchar(50),</span><br><span class="line">  age int</span><br><span class="line">);</span><br><span class="line">insert into testtb(id,name,age)values(1,&quot;bb&quot;,13);</span><br><span class="line">select * from testtb;</span><br><span class="line">insert ignore into testtb(id,name,age)values(1,&quot;aa&quot;,13);</span><br><span class="line">select * from testtb;&#x2F;&#x2F;仍是1，“bb”,13，因为id是主键，出现主键重复但使用了ignore则错误被忽略</span><br><span class="line">replace into testtb(id,name,age)values(1,&quot;aa&quot;,12);</span><br><span class="line">select * from testtb; &#x2F;&#x2F;数据变为1,&quot;aa&quot;,12</span><br><span class="line">insert into testtb(id, name, age) values (1,&#39;hui&#39;,30) ON DUPLICATE KEY UPDATE age &#x3D; age + 50; </span><br><span class="line">select * from testtb; &#x2F;&#x2F;数据变成1,&quot;aa&quot;,62</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本操作</title>
      <link href="2020/11/17/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/17/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h2><p>是一个代码审查管理工具，可以进行代码走读，审核入库，基于Git</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>开发人员和管理人员只需操作gerrit 就能完成所有的代码管理，提高开发和上线效率</p><h2 id="用户组分类"><a href="#用户组分类" class="headerlink" title="用户组分类"></a>用户组分类</h2><ul><li>backend-developers</li><li>backend-leaders</li></ul><blockquote><p>backend-developers组用户权限：<br>1, master分支代码查看，push, review +1 -2, abandon 自己的review。<br>2，自己定义分支全部控制权限</p></blockquote><blockquote><p>backend-leaders组用户权限：<br>1 ,master分支代码查看，push, review +2 -2, abandon , submit,<br>2, release 分支代码查看，push,  review +2 , -2, abandon, push merge, push without review<br>3，自己定义分支全部控制权限</p></blockquote><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><ul><li>master分支</li><li>release分支</li><li>个人分支或者长期功能开发分支</li></ul><ol><li>master分支主要作为代码review, 代码开发主分支</li><li>release分支只对leaders可见，里面包含敏感的配置文件信息，release分支同时作为一个长期稳定的上线版本分支，每一次上线后都需要打一个tag</li><li>一般开发任务不需要在gerrit上创建自己的分支，除非有长期的协同大功能开发。</li></ol><h3 id="开发人员前期环境准备"><a href="#开发人员前期环境准备" class="headerlink" title="开发人员前期环境准备"></a>开发人员前期环境准备</h3><blockquote><p>这里假定大家对git 常用命令 已经熟悉，这里只做gerrit部分的设置步骤</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">假定developer有了gerrit账号并设置了免密ssh,登录gerrit ，</span><br><span class="line"></span><br><span class="line">1, 找到Projects-&gt;List-&gt;BKD_quixmart2 , 复制 项目clone命令：</span><br><span class="line">&gt; git clone ssh:&#x2F;&#x2F;xxxx@192.168.16.81:29418&#x2F;BKD_quixmart2 &amp;&amp; scp -p -P 29418 xxxx@192.168.16.81:hooks&#x2F;commit-msg BKD_quixmart2&#x2F;.git&#x2F;hooks&#x2F;</span><br><span class="line">&gt; cd BKD_quixmart2</span><br><span class="line">&gt; git remote update</span><br><span class="line"></span><br><span class="line">clone下来的项目普通开发人员只能看到一个master分支，leaders可以看到master 和 relase分支.</span><br><span class="line"></span><br><span class="line">2, 设置Alas</span><br><span class="line">在~&#x2F;.gitconfig文件中添加：</span><br><span class="line">[alias]</span><br><span class="line">push-release &#x3D; push origin HEAD:refs&#x2F;for&#x2F;release</span><br><span class="line">push-review &#x3D; push origin HEAD:refs&#x2F;for&#x2F;master</span><br><span class="line">unpushed &#x3D; lo --branches --not --remotes --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative</span><br><span class="line">lg &#x3D; log --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative</span><br><span class="line">ca &#x3D; commit -a</span><br><span class="line">ci &#x3D; commit</span><br><span class="line">st &#x3D; status</span><br><span class="line">co &#x3D; checkout</span><br><span class="line">br &#x3D; branch </span><br></pre></td></tr></table></figure><h3 id="commit-message-格式"><a href="#commit-message-格式" class="headerlink" title="commit message 格式"></a>commit message 格式</h3><p>所有commit 格式都应该如下：</p><p>QUIX2-12: quixmart2.0 后台系统设备管理，设备监控开发</p><p>Change-Id: I6be1be65a4d9839555a7c27a217cdd063d1ad99b</p><h3 id="开发人员代码review步骤"><a href="#开发人员代码review步骤" class="headerlink" title="开发人员代码review步骤"></a>开发人员代码review步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">开发人员：</span><br><span class="line">&gt;git remote update</span><br><span class="line">&gt;git co master</span><br><span class="line">&gt;git fetch &amp;&amp; git rebase master     (不要用git pull)</span><br><span class="line">&gt;git checkout -b bugfix-QUIX2-12</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx1.java</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx2.java</span><br><span class="line">&gt;git commit -m &quot;QUIX2-12: quixmart2.0 后台系统设备管理，设备监控开发&quot;</span><br><span class="line">&gt;git push-review     （会自动提到gerrit的master分支）</span><br><span class="line">如果有修改内容</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx2.java</span><br><span class="line">&gt;git commit --amend</span><br><span class="line">&gt;git push-review</span><br><span class="line"></span><br><span class="line">到gerrit web 界面要求相关开发进行代码review,也可以自己-2，这样可以不被submit. review完成后leader可以进行submit</span><br><span class="line"></span><br><span class="line">如果是紧急hotfix, 在开发人员 master gerrit submit成功后，leader需要将这个commit 在gerrit上cherry-pick到release 分支并完成上线</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="稳定master代码同步到release分支"><a href="#稳定master代码同步到release分支" class="headerlink" title="稳定master代码同步到release分支"></a>稳定master代码同步到release分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;git co master</span><br><span class="line">&gt;git fetch &amp;&amp; git rebase</span><br><span class="line">&gt;git co release</span><br><span class="line">&gt;git merge master</span><br><span class="line">&gt;git push-release</span><br><span class="line">添加相关人员代码review,然后submit到gitlab仓库</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>禁止用  ‘git add .’   ， 必须用’git add src/xxx/xxx.xxx’</li><li>要修改新的代码前先更新master分支，然后通过master分支checkout 一个其他分支</li><li>尽量不要在本地的master上直接改代码，每次在改代码之前先更新本地master分支，然后  git checkout -b featrure-QUIX2-xxx, 在本地的feature-QUIX2-xxx 改完后再merge 到master 分支，如果在feature-QUIX2-xxx 分支有多次commit, merge 时如果想把所有commit 变成一个commit, 用git merge –squash feature-QUIX2-xxx , 否则正常merge 用 git merge –no-ff -m “merge with no-ff” feature-QUIX2-xxx ，或者直接在当前分支用git push-review 会自动推到gerrit 的master分支</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>git st 查看当前git 仓库状态</li><li>git lg 查看commit  (经常用，结合git reset 来回切换历史commit)</li><li>git unpushed 查看哪些还没有push到gitlab仓库,(用之前应该更新代码)</li><li>git fetch &amp;&amp; git rebase  master 更新代码及分支信息</li><li>git reset –hard origin 还原成远端git库最新代码</li><li>git reset –hard xxx 还原到指定commit </li><li>git branch</li><li>git clone</li></ul><h3 id="本地目录到暂存区操作"><a href="#本地目录到暂存区操作" class="headerlink" title="本地目录到暂存区操作"></a>本地目录到暂存区操作</h3><ul><li>git restore file|.   将不在暂存区的文件撤销更改</li><li>git restore –staged 将文件从暂存区撤出，但不会撤销文件的更改</li><li>git add 命令可将该本地区下文件添加到暂存区</li></ul><h3 id="暂存区到本地版本库操作"><a href="#暂存区到本地版本库操作" class="headerlink" title="暂存区到本地版本库操作"></a>暂存区到本地版本库操作</h3><ul><li>git commit 主要是将暂存区里的改动给提交到本地的版本库</li><li>git commit –amend 继续提交</li></ul><h3 id="本地版本库到远程库操作-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt"><a href="#本地版本库到远程库操作-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt" class="headerlink" title="本地版本库到远程库操作(git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;)"></a>本地版本库到远程库操作(git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;)</h3><ul><li>git push origin HEAD:refs/for/release</li><li>git push origin HEAD:refs/for/master</li><li>refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要</li></ul><h3 id="远程库到本地版本库操作"><a href="#远程库到本地版本库操作" class="headerlink" title="远程库到本地版本库操作"></a>远程库到本地版本库操作</h3><ul><li><p>git revert  commit-id-a  归还，复原，回退，这个操作是会改变分支记录的，因为产生了新的提交。git revert 是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西</p></li><li><p>git reset –hard origin 还原成远端git库最新代码，之后的日志记录被删除</p></li><li><p>git reset –hard xxx 还原到指定commit</p></li><li><p>git reset –soft 被回退的那些版本的修改会被放在暂存区，可以再次提交</p></li><li><p>git reset –mixed 默认选项，被回退的那些版本的修改会放在工作目录，可以先加到暂存区，然后再提交。</p></li><li><p>git cherry-pick</p></li><li><p>git checkout</p></li></ul><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><ul><li>git reset HEAD^ –soft         –soft 表示保留当前commit，重新commit</li><li>git reset HEAD^ –hard       –hard 表示丢弃当前add，重新add、commit</li><li>git reset –hard HEAD~x解决，x表示的就是在这之前已经有多少次的提交，这句命令的意思就是直接回退到x 个commit之前</li></ul><h2 id="git-fork"><a href="#git-fork" class="headerlink" title="git fork"></a>git fork</h2><p><strong>git remote -v</strong> 先clone项目到本地，此时查看项目的远程信息<br><strong>git remote add upstream</strong>  [fork的远程地址]   添加远程地址<br><strong>git pull|fetch upstream master</strong>  从fork远程更新<br><strong>git merge upstream/master</strong>  合并到本地master分支<br><strong>git push origin master</strong>  上传到自己git上</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin异常处理</title>
      <link href="2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFegin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFegin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/xiaominmin">xiaomin0322</a></p><p>出处：<a href="https://my.oschina.net/xiaominmin/blog/2986631">https://my.oschina.net/xiaominmin/blog/2986631</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近在项目开发中，使用 Feign 调用服务，当触发熔断机制时，遇到了以下问题：</p><ul><li>异常信息形如：<code>TestService#addRecord(ParamVO) failed and no fallback available.</code>；</li><li>获取不到服务提供方抛出的原始异常信息；</li><li>实现某些业务方法不进入熔断，直接往外抛出异常；</li></ul><p>接下来将一一解决上述问题。</p><p>对于<code>failed and no fallback available.</code>这种异常信息，是因为项目开启了熔断：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">feign.hystrix.enabled</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><p>当调用服务时抛出了异常，却没有定义<code>fallback</code>方法，就会抛出上述异常。由此引出了第一个解决方式。</p><h3 id="FeignClient加上fallback方法，并获取异常信息"><a href="#FeignClient加上fallback方法，并获取异常信息" class="headerlink" title="@FeignClient加上fallback方法，并获取异常信息"></a><code>@FeignClient</code>加上<code>fallback</code>方法，并获取异常信息</h3><p>为<code>@FeignClient</code>修饰的接口加上<code>fallback</code>方法有两种方式，由于要获取异常信息，所以使用<code>fallbackFactory</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;serviceId&quot;, fallbackFactory = TestServiceFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">Result <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>@FeignClient</code>注解中指定<code>fallbackFactory</code>，上面例子中是<code>TestServiceFallback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceFallback</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">TestService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(TestServiceFallback.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERR_MSG = <span class="string">&quot;Test接口暂时不可用: &quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        String msg = throwable == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : throwable.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(msg)) &#123;</span><br><span class="line">            LOG.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ResultBuilder.unsuccess(ERR_MSG + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现<code>FallbackFactory</code>,可以在<code>create</code>方法中获取到服务抛出的异常。但是请注意，这里的异常是被<code>Feign</code>封装过的异常，不能直接在异常信息中看出原始方法抛出的异常。这时得到的异常信息形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">status 500 reading TestService#addRecord(ParamVO); content:</span><br><span class="line">&#123;<span class="string">&quot;success&quot;</span>:<span class="keyword">false</span>,<span class="string">&quot;resultCode&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;/ by zero&quot;</span>,<span class="string">&quot;model&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;models&quot;</span>:[],<span class="string">&quot;pageInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;timelineInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;extra&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;validationMessages&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;valid&quot;</span>:<span class="keyword">false</span>&#125;</span><br></pre></td></tr></table></figure><p>说明一下，本例子中，服务提供者的接口返回信息会统一封装在自定义类<code>Result</code>中，内容就是上述的<code>content</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;success&quot;</span>:<span class="keyword">false</span>,<span class="string">&quot;resultCode&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;/ by zero&quot;</span>,<span class="string">&quot;model&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;models&quot;</span>:[],<span class="string">&quot;pageInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;timelineInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;extra&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;validationMessages&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;valid&quot;</span>:<span class="keyword">false</span>&#125;</span><br></pre></td></tr></table></figure><p>因此，异常信息我希望是<code>message</code>的内容：<code>/ by zero</code>，这样打日志时能够方便识别异常。</p><h3 id="保留原始异常信息"><a href="#保留原始异常信息" class="headerlink" title="保留原始异常信息"></a>保留原始异常信息</h3><p>当调用服务时，如果服务返回的状态码不是200，就会进入到<code>Feign</code>的<code>ErrorDecoder</code>中，因此如果我们要解析异常信息，就要重写<code>ErrorDecoder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> feign.Util;</span><br><span class="line"><span class="keyword">import</span> feign.codec.ErrorDecoder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: CipherCui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 保留 feign 服务异常信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 1:29 2018/6/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepErrMsgConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorDecoder <span class="title">errorDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserErrorDecoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserErrorDecoder</span> <span class="keyword">implements</span> <span class="title">ErrorDecoder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Exception <span class="title">decode</span><span class="params">(String methodKey, Response response)</span> </span>&#123;</span><br><span class="line">            Exception exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取原始的返回内容</span></span><br><span class="line">                String json = Util.toString(response.body().asReader());</span><br><span class="line">                exception = <span class="keyword">new</span> RuntimeException(json);</span><br><span class="line">                <span class="comment">// 将返回内容反序列化为Result，这里应根据自身项目作修改</span></span><br><span class="line">                Result result = JsonMapper.nonEmptyMapper().fromJson(json, Result.class);</span><br><span class="line">                <span class="comment">// 业务异常抛出简单的 RuntimeException，保留原来错误信息</span></span><br><span class="line">                <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">                    exception = <span class="keyword">new</span> RuntimeException(result.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                logger.error(ex.getMessage(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个例子，原理是根据<code>response.body()</code>反序列化为自定义的<code>Result</code>类，提取出里面的<code>message</code>信息，然后抛出<code>RuntimeException</code>，这样当进入到熔断方法中时，获取到的异常就是我们处理过的<code>RuntimeException</code>。</p><p>注意上面的例子并不是通用的，但原理是相通的，大家要结合自身的项目作相应的修改。</p><p>要使上面代码发挥作用，还需要在<code>@FeignClient</code>注解中指定<code>configuration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;serviceId&quot;, fallbackFactory = TestServiceFallback.class, configuration = &#123;KeepErrMsgConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不进入熔断，直接抛出异常"><a href="#不进入熔断，直接抛出异常" class="headerlink" title="不进入熔断，直接抛出异常"></a>不进入熔断，直接抛出异常</h3><p>有时我们并不希望方法进入熔断逻辑，只是把异常原样往外抛。这种情况我们只需要捉住两个点：<strong>不进入熔断</strong>、<strong>原样</strong>。</p><p>原样就是获取原始的异常，上面已经介绍过了，而不进入熔断，需要把异常封装成<code>HystrixBadRequestException</code>，对于<code>HystrixBadRequestException</code>，<code>Feign</code>会直接抛出，不进入熔断方法。</p><p>因此我们只需要在上述<code>KeepErrMsgConfiguration</code>的基础上作一点修改即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: CipherCui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: feign 服务异常不进入熔断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 1:29 2018/6/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotBreakerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorDecoder <span class="title">errorDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserErrorDecoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserErrorDecoder</span> <span class="keyword">implements</span> <span class="title">ErrorDecoder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Exception <span class="title">decode</span><span class="params">(String methodKey, Response response)</span> </span>&#123;</span><br><span class="line">            Exception exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String json = Util.toString(response.body().asReader());</span><br><span class="line">                exception = <span class="keyword">new</span> RuntimeException(json);</span><br><span class="line">                Result result = JsonMapper.nonEmptyMapper().fromJson(json, Result.class);</span><br><span class="line">                <span class="comment">// 业务异常包装成 HystrixBadRequestException，不进入熔断逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">                    exception = <span class="keyword">new</span> HystrixBadRequestException(result.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                logger.error(ex.getMessage(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了更好的达到熔断效果，我们应该为每个接口指定<code>fallback</code>方法。而根据自身的业务特点，可以灵活的配置上述的<code>KeepErrMsgConfiguration</code>和<code>NotBreakerConfiguration</code>，或自己编写<code>Configuration</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fegin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin与Hystrix及Ribbon关系</title>
      <link href="2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFegin%E4%B8%8EHystrix%E5%8F%8ARibbon%E5%85%B3%E7%B3%BB/"/>
      <url>2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFegin%E4%B8%8EHystrix%E5%8F%8ARibbon%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/crazymakercircle/">疯狂创客圈</a><br>出处：<a href="https://www.cnblogs.com/crazymakercircle/p/11664812.html">https://www.cnblogs.com/crazymakercircle/p/11664812.html</a></p><h3 id="Springcloud-高并发-配置-简介"><a href="#Springcloud-高并发-配置-简介" class="headerlink" title="Springcloud 高并发 配置 简介"></a>Springcloud 高并发 配置 简介</h3><p>在微服务架构的应用中， Feign、Hystrix，Ribbon三者都是必不可少的，可以说已经成为铁三角。</p><p><strong>疯狂创客圈</strong>（笔者尼恩创建的高并发研习社群）中，有不少小伙伴问到尼恩，关于Feign、Hystrix，Ribbon三者之间的关系，以及三者的超时配置。截止目前，全网没有篇文章介绍清楚的，故，尼恩特写一篇详细一点的文章，剖析一下。</p><h3 id="Feign介绍"><a href="#Feign介绍" class="headerlink" title="Feign介绍"></a>Feign介绍</h3><p>Feign是一款Java语言编写的HttpClient绑定器，在Spring Cloud微服务中用于实现微服务之间的声明式调用。Feign 可以定义请求到其他服务的接口，用于微服务间的调用，不用自己再写http请求，在客户端实现，调用此接口就像远程调用其他服务一样，当请求出错时可以调用接口的实现类来返回</p><p>Feign是一个声明式的web service客户端，它使得编写web service客户端更为容易。创建接口，为接口添加注解，即可使用Feign。Feign可以使用Feign注解或者JAX-RS注解，还支持热插拔的编码器和解码器。Spring Cloud为Feign添加了Spring MVC的注解支持，并整合了Ribbon和Eureka来为使用Feign时提供负载均衡。</p><p>feign源码的github地址：</p><p><a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><h3 id="Ribbon介绍"><a href="#Ribbon介绍" class="headerlink" title="Ribbon介绍"></a>Ribbon介绍</h3><p>Ribbon 作为负载均衡，在客户端实现，服务段可以启动两个端口不同但servername一样的服务</p><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。简单地说，Ribbon是一个客户端负载均衡器。</p><p>Ribbon工作时分为两步：第一步先选择 Eureka Server, 它优先选择在同一个Zone且负载较少的Server；第二步再根据用户指定的策略，在从Server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略，例如轮询、随机、根据响应时间加权等。</p><p>ribbon源码的github地址：</p><p><a href="https://github.com/Netflix/ribbon">https://github.com/Netflix/ribbon</a></p><h3 id="Hystrix介绍"><a href="#Hystrix介绍" class="headerlink" title="Hystrix介绍"></a>Hystrix介绍</h3><p>Hystrix作为熔断流量控制，在客户端实现，在方法上注解，当请求出错时可以调用注解中的方法返回</p><p>Hystrix熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。</p><p>Hystrix源码的github地址：</p><p><a href="https://github.com/Netflix/hystrix">https://github.com/Netflix/hystrix</a></p><h3 id="重点：-三者之间的关系图"><a href="#重点：-三者之间的关系图" class="headerlink" title="重点： 三者之间的关系图"></a>重点： 三者之间的关系图</h3><p>如果微服务项目加上了spring-cloud-starter-netflix-hystrix依赖，那么，feign会通过代理模式， 自动将所有的方法用 hystrix 进行包装。</p><p>在Spring Cloud微服务体系下，微服务之间的互相调用可以通过Feign进行声明式调用，在这个服务调用过程中Feign会通过Ribbon从服务注册中心获取目标微服务的服务器地址列表，之后在网络请求的过程中Ribbon就会将请求以负载均衡的方式打到微服务的不同实例上，从而实现Spring Cloud微服务架构中最为关键的功能即服务发现及客户端负载均衡调用。</p><p>另一方面微服务在互相调用的过程中，为了防止某个微服务的故障消耗掉整个系统所有微服务的连接资源，所以在实施微服务调用的过程中我们会要求在调用方实施针对被调用微服务的熔断逻辑。而要实现这个逻辑场景在Spring Cloud微服务框架下我们是通过Hystrix这个框架来实现的。</p><p>调用方会针对被调用微服务设置调用超时时间，一旦超时就会进入熔断逻辑，而这个故障指标信息也会返回给Hystrix组件，Hystrix组件会根据熔断情况判断被调微服务的故障情况从而打开熔断器，之后所有针对该微服务的请求就会直接进入熔断逻辑，直到被调微服务故障恢复，Hystrix断路器关闭为止。</p><p>三者之间的关系图，大致如下：</p><p><img src="/2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFegin%E4%B8%8EHystrix%E5%8F%8ARibbon%E5%85%B3%E7%B3%BB/20191012221343851.png" alt="在这里插入图片描述"></p><h3 id="Feign典型配置说明"><a href="#Feign典型配置说明" class="headerlink" title="Feign典型配置说明"></a>Feign典型配置说明</h3><p>Feign自身可以支持多种HttpClient工具包，例如OkHttp及Apache HttpClient，针对Apache HttpClient的典型配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment">#替换掉JDK默认HttpURLConnection实现的 Http Client</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">       <span class="comment">#连接超时时间</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">       <span class="comment">#读取超时时间</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="Hystrix配置说明"><a href="#Hystrix配置说明" class="headerlink" title="Hystrix配置说明"></a>Hystrix配置说明</h3><p>在Spring Cloud微服务体系中Hystrix主要被用于实现实现微服务之间网络调用故障的熔断、过载保护及资源隔离等功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">propagate:</span></span><br><span class="line">    <span class="attr">request-attribute:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="comment">#全局默认配置</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="comment">#线程隔离相关</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">timeout:</span></span><br><span class="line">          <span class="comment">#是否给方法执行设置超时时间，默认为true。一般我们不要改。</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="comment">#配置请求隔离的方式，这里是默认的线程池方式。还有一种信号量的方式semaphore，使用比较少。</span></span><br><span class="line">          <span class="attr">strategy:</span> <span class="string">threadPool</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="comment">#方式执行的超时时间，默认为1000毫秒，在实际场景中需要根据情况设置</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">10000</span></span><br><span class="line">            <span class="comment">#发生超时时是否中断方法的执行，默认值为true。不要改。</span></span><br><span class="line">            <span class="attr">interruptOnTimeout:</span> <span class="literal">true</span></span><br><span class="line">            <span class="comment">#是否在方法执行被取消时中断方法，默认值为false。没有实际意义，默认就好！</span></span><br><span class="line">            <span class="attr">interruptOnCancel:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">circuitBreaker:</span>   <span class="comment">#熔断器相关配置</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#是否启动熔断器，默认为true，false表示不要引入Hystrix。</span></span><br><span class="line">    <span class="attr">requestVolumeThreshold:</span> <span class="number">20</span>     <span class="comment">#启用熔断器功能窗口时间内的最小请求数，假设我们设置的窗口时间为10秒，</span></span><br><span class="line">    <span class="attr">sleepWindowInMilliseconds:</span> <span class="number">5000</span>    <span class="comment">#所以此配置的作用是指定熔断器打开后多长时间内允许一次请求尝试执行，官方默认配置为5秒。</span></span><br><span class="line">    <span class="attr">errorThresholdPercentage:</span> <span class="number">50</span>   <span class="comment">#窗口时间内超过50%的请求失败后就会打开熔断器将后续请求快速失败掉,默认配置为50</span></span><br></pre></td></tr></table></figure><h3 id="Ribbon配置说明"><a href="#Ribbon配置说明" class="headerlink" title="Ribbon配置说明"></a>Ribbon配置说明</h3><p>Ribbon在Spring Cloud中对于支持微服之间的通信发挥着非常关键的作用，其主要功能包括客户端负载均衡器及用于中间层通信的客户端。在基于Feign的微服务通信中无论是否开启Hystrix，Ribbon都是必不可少的，Ribbon的配置参数主要如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#说明：同一台实例的最大自动重试次数，默认为1次，不包括首次</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment">#说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment">#说明：是否所有的操作都重试，默认为true</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒</span></span><br><span class="line">  <span class="attr">ServerListRefreshInterval:</span> <span class="number">2000</span></span><br><span class="line">  <span class="comment">#说明：使用Apache HttpClient连接超时时间，单位为毫秒</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">3000</span> <span class="comment"># 默认为1s</span></span><br><span class="line">  <span class="comment">#说明：使用Apache HttpClient读取的超时时间，单位为毫秒</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">3000</span> <span class="comment">#默认为1s</span></span><br></pre></td></tr></table></figure><p>如上图所示，在Spring Cloud中使用Feign进行微服务调用分为两层：<strong>Hystrix的调用和Ribbon的调用，Feign自身的配置会被覆盖</strong>。</p><p>而如果<strong>开启了Hystrix，那么Ribbon的超时时间配置与Hystrix的超时时间配置则存在依赖关系</strong>，因为涉及到Ribbon的重试机制，所以一般情况下都是Ribbon的超时时间小于Hystrix的超时时间，否则会出现以下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">20</span>,<span class="number">208</span>   <span class="number">111231</span> [http-nio-<span class="number">8084</span>-exec-<span class="number">2</span>] WARN    o.s.c.n.z.f.r.s.AbstractRibbonCommand - The Hystrix timeout of <span class="number">10000</span>ms   <span class="keyword">for</span> the command operation is set lower than the combination of the Ribbon   read and connect timeout, <span class="number">24000</span>ms. </span><br></pre></td></tr></table></figure><h3 id="Ribbon和Hystrix的超时时间配置的关系"><a href="#Ribbon和Hystrix的超时时间配置的关系" class="headerlink" title="Ribbon和Hystrix的超时时间配置的关系"></a>Ribbon和Hystrix的超时时间配置的关系</h3><p><strong>那么Ribbon和Hystrix的超时时间配置的关系具体是什么呢？如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hystrix的超时时间=Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout)</span><br></pre></td></tr></table></figure><p><strong>而Ribbon的重试次数的计算方式为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ribbon重试次数(包含首次)= <span class="number">1</span> + ribbon.MaxAutoRetries  +  ribbon.MaxAutoRetriesNextServer  +  (ribbon.MaxAutoRetries * ribbon.MaxAutoRetriesNextServer)</span><br></pre></td></tr></table></figure><p>以上图中的Ribbon配置为例子，Ribbon的重试次数=1+(1+1+1)=4，所以Hystrix的超时配置应该&gt;=4*(3000+3000)=24000毫秒。在Ribbon超时但Hystrix没有超时的情况下，Ribbon便会采取重试机制；而重试期间如果时间超过了Hystrix的超时配置则会立即被熔断（fallback）。</p><p>如果不配置Ribbon的重试次数，则Ribbon默认会重试一次，加上第一次调用Ribbon，总的的重试次数为2次，以上述配置参数为例，Hystrix超时时间配置为2*6000=12000，由于很多情况下，大家一般不会主动配置Ribbon的重试次数，所以这里需要注意下！强调下，以上超时配置的值只是示范，超时配置有点大不太合适实际的线上场景，大家根据实际情况设置即可！</p><p>说明下，<strong>如果不启用Hystrix，Feign的超时时间则是Ribbon的超时时间，Feign自身的配置也会被覆盖</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fegin </tag>
            
            <tag> Hystrix </tag>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin</title>
      <link href="2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFegin/"/>
      <url>2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFegin/</url>
      
        <content type="html"><![CDATA[<h2 id="Fegin客户端"><a href="#Fegin客户端" class="headerlink" title="Fegin客户端"></a>Fegin客户端</h2><p>使用普通对象传递参数时，不管是get或post方式，需要使用注解<font color="red">@SpringQueryMap</font><br>feign是支持对象传递的，但是得是Map形式</p><p><strong>GET：</strong></p><ol><li>客户端对象不加@RequesetParam,控制类使用对象接收，时间格式会出现转换失败【string转date异常】</li><li>客户端对象不增加@RequesetParam，控制类使用@RequesetParam对象接收，参数miss【orderSource=TAKEGO&amp;logicDelete=0&amp;pageSize=20&amp;startTime=2020-11-04T16:00:00.000+0000&amp;<br>  endTime=2020-11-05T15:59:59.059+0000&amp;pageNum=1 】</li><li>客户端对象增加@RequesetParam,控制类使用对象接收，【consumerOrderSearchVO=ConsumerOrderSearchVO%28startTime%3DThu%20Nov%2005%2000%3A00%3A00%20CST%202020%2C%20endTime%3DThu%20Nov%2005%2023%3A59%3A59%20CST%202020%2C%20orderSource%3DTAKEGO%2C%20logicDelete%3D0%29 】</li><li>客户端对象增加@RequesetParam，控制类也使用@RequesetParam对象接收，异常【Cannot convert value of type ‘java.lang.String’ to required type ‘io.deepblueai.order.api.vo.ConsumerOrderSearchVO’】</li><li>客户端对象使用@RequestBody,控制类使用@RequestBody，【Required request body is missing】</li></ol><p><strong>POST:</strong> </p><p>​    使用@RequestBody</p><p><strong>List 数组</strong></p><pre><code>1. @RequestParam(&quot;ids&quot;); 2. 使用json</code></pre><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>@RequesetParam(name=”vo”) 把参数转换成了vo=””格式,{对象传递不应该增加此注解}，用于当key名称不对应时指定key名称，或者指定value是否为空，默认不为空</p><h2 id="Fegin使用GET方法，Body请求异常"><a href="#Fegin使用GET方法，Body请求异常" class="headerlink" title="Fegin使用GET方法，Body请求异常"></a>Fegin使用GET方法，Body请求异常</h2><p>HttpClientFeignLoadBalancedConfiguration&gt;OkHttpFeignLoadBalancedConfiguration&gt;DefaultFeignLoadBalancedConfiguration,对应的底层http工具：httpclient&gt;okhttp&gt;HttpURLConnection</p><p>根据http协议定义是支持@RequestBody+ RequestMethod.GET的，那么具体就得看工具包实现的不同的，查看源码发现<strong>okhttp和HttpURLConnection都不支持（报错），只有httpclient支持。（默认走HttpURLConnection会报错）</strong></p><p>我们知道只有httpclient支持@RequestBody+ RequestMethod.GET，所以我们必须满足条件走HttpClientFeignLoadBalancedConfiguration才行 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p> 依赖包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>10.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>没有降级处理-》feign的ErrorDecoder（status不为200则处理，返回exception，最终返回异常会被HystrixRuntimeException包装）</p><p>进行降级处理-》如果使用fallback类 -》feign的ErrorDecoder抛出的异常，没办法捕获异常，直接返回降级的返回值</p><p>进行降级处理-》如果使用factoryfallback类-》feign的ErrorDecoder抛出的异常，可以捕获到异常，返回降级的返回值<br>                                                    异常（ClientException：实例不存在，loadbalancer）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fegin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archaius配置中心客户端</title>
      <link href="2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BArchaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BArchaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Archaius"><a href="#Archaius" class="headerlink" title="Archaius"></a>Archaius</h2><p>Netflix只是开源了其配置中心（Archaius变色龙）的客户端部分，没有开源配套的服务器端。Archaius其实是配置源实现无关的，可以对接各种配置中心作为数据源。</p><h2 id="Archaius在Netflix的用例场景"><a href="#Archaius在Netflix的用例场景" class="headerlink" title="Archaius在Netflix的用例场景"></a>Archaius在Netflix的用例场景</h2><ul><li>根据请求上下文开启或关闭某项功能。</li><li>某个页面缺省显示10个商品，在某些情况下，可以通过Archaius调整配置，只显示5个商品。</li><li>动态调整Hystrix熔断器的行为。</li><li>调整服务调用客户端的连接和请求超时参数。</li><li>如果某个线上服务产生出错告警，可以动态调整日志输出级别(粒度可以细到包或者组件级别)，这样可以通过详细日志排查问题。问题定位以后，再将日志输出级别恢复到默认级别。</li><li>对于多区域或者多国家部署的应用，通过动态配置，可以根据不同区域和国家开启不同的功能。</li><li>可以根据用户的实际访问模式动态调整一些基础中间件的配置，例如缓存的存活时间TTL(Time To Live)。</li><li>数据库访问客户端的连接池配置，可以对不同服务配不同的值。例如，一个请求频率RPS(Request Per Second)小的服务，可以配置较小的连接数，而一个请求频率大的服务，可以配置较大的连接数。</li><li>运行期配置的变更可以在不同维度生效，例如集群中的单个实例维度，多区域部署下的某个区域维度，某个服务栈维度，或者某个应用集群维度。</li><li>功能开关(Feature Flag)发布，有些功能虽然上线，但是并不马上启用，而是通过配置开关动态启用，这样可以根据情况灵活开启或者关闭某项线上功能。</li><li>金丝雀发布(Canary Release)，新功能上线时，让新老集群同时并存一段时间，通过配置将到老集群的流量逐步动态调整到新集群，如果监控显示无异常，则完成新集群的上线，如异常，则快速切回老集群。</li></ul><h2 id="Archaius的特性和设计"><a href="#Archaius的特性和设计" class="headerlink" title="Archaius的特性和设计"></a>Archaius的特性和设计</h2><p>Archaius实际上是对Apache Common Configuration Library的一个封装和扩展，提供了一组基于Java的配置API，主要的特性包括：</p><ul><li>配置可动态调整。</li><li>配置支持类型(Int, Long, Boolean等)。</li><li>高性能和线程安全。</li><li>提供一个拉(pulling)配置的框架，可以从配置源动态拉取变更的配置。</li><li>支持回调(callback)机制，在配置变更时自动调用。</li><li>支持JMX MBean，可以通过JConsole查看配置和修改配置。</li></ul><p>下图是Archaius的总体设计：</p><p><img src="/2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BArchaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><p>Achaius的核心是一个称为**组合配置(Composite Configuration)**的概念，简单可以理解为一个分层级的配置，层级有优先级，高优先级的层级的配置会覆盖低优先级的配置。每一个层级可以从某个配置源获取配置，例如本地配置文件，JDBC数据源，远程REST API等。配置源还可以在运行时动态拉取变更，例如在上图中，持久化数据库配置(Persisted DB Configuration)是指将配置存在关系数据库中，相应的配置源会定期从数据库拉取变更)。配置的最终值由顶级配置决定，例如，如果多个层级都含有某个配置项，那么应用最终见到的值是配置层级中最顶层的值。配置分层的顺序是可以调整的。</p><h2 id="分级配置案例"><a href="#分级配置案例" class="headerlink" title="分级配置案例"></a>分级配置案例</h2><p>假设你开发了一个叫myapp的应用，在本地开发环境，一般你希望用本地配置，不依赖于远程的配置中心，这个时候你只需为应用写一个本地配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myapp.properties</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这个配置文件里头包含myapp的所有缺省配置。</p><p>当你的应用开发完成，需要分别部署到测试TEST, UAT和生产PROD环境，如果你希望在不同的环境重载某些缺省值，那么你可以为不同环境分别添加本地配置文件，在相关文件中重载缺省值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myapp-test.properties</span><br><span class="line">myapp-uat.properties</span><br><span class="line">myapp-prod.properties</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>例如，在<code>myapp.properties</code>中<code>timeout</code>配置值是<code>500</code>，在<code>myapp-prod.properties</code>中<code>timeout</code>配置值是<code>200</code>，那么应用在生产环境中将使用重载值<code>timeout=200</code>，其它没有重载则使用<code>myapp.properties</code>中的缺省值。</p><p>在Archaius中，可以通过设置<code>archaius.deployment.environment</code>启动参数，来激活不同环境的配置。</p><p>如果你还希望应用上线后，可以通过配置中心动态调整配置值，那么你可以将Achaius和某个配置中心(比如Apollo)进行对接，对接后配置中心中的配置具有最高优先级，其中的配置可以覆盖应用本地配置文件中的配置。例如，应用上线后你发现<code>timeout=200</code>设置太小了，想调大到<code>timeout=1000</code>，可以通过配置中心一键搞定。</p><h2 id="Archaius和Apollo配置中心集成"><a href="#Archaius和Apollo配置中心集成" class="headerlink" title="Archaius和Apollo配置中心集成"></a>Archaius和Apollo配置中心集成</h2><p>Archaius是一款非常优秀的生产级配置客户端组件，比较可惜的是Netflix没有开源它的配置中心的服务器端，幸好业界已经有Apollo这样优秀的配置中心开源产品。Archaius本身是配置源无关的，它提供的拉(pulling)框架可以支持对接各种数据源，而Apollo本身也正好提供基于HTTP REST的配置拉取接口，使得Archaius和Apollo的对接非常简单。</p><p>另外，当你想要使用某些Netflix的组件，比如Zuul网关，它原生是支持Archaius进行动态配置的，如果你又想要使用Apollo配置中心支持集中式动态配置，这个时候你用Apollo客户端去改造Zuul的话，工作量不小。其实不需要这么麻烦，这三者可以简单完美实现集成，如下图所示：</p><p><img src="/2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BArchaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/%E9%9B%86%E6%88%90%E5%9B%BE.png"></p><p>集成要点：</p><ul><li>通过设置<code>archaius.configurationSource.additionalUrls</code>启动参数，设置为Apollo的配置文件拉取端点，激活Archaius的远程配置数据源。</li><li>Apollo的配置文件拉取端点为：<code>&#123;config_server_url&#125;/configfiles/&#123;appId&#125;/&#123;clusterName&#125;/&#123;namespaceName&#125;</code>，其中：<code>config_server_url</code>是配置中心地址，<code>appId</code>是应用(例如Zuul)在Apollo中的唯一标识，<code>clusterName</code>是应用在Apollo中的集群名，一般用缺省<code>default</code>，<code>namespaceName</code>是应用在Apollo中的名字空间，一般用缺省<code>application</code>。</li><li>注意，对于不同的环境(TEST，UAT，PROD等)，Apollo配置中心的地址一般不同</li><li>Archaius动态拉取配置的周期缺省是60秒，可以调整。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>根据不同上下文动态调整应用的行为逻辑，是现代互联网应用的刚需，配置中心应运而生，它是微服务架构必不可少的组件。</li><li>Archaius是Netflix开源的生产级配置中心客户端组件，它的亮点是支持多维度、分层级的和动态的配置。</li><li>Archaius可以和Apollo配置中可以简单无缝集成，让很多Netflix的开源组件(Zuul，Hystrix，Ribbon等)可以简单接入Apollo。波波2018年在极客时间上的课程《微服务架构和实践160讲》，7月份推出了第3模块：《微服务网关Zuul架构和实践》，其中会通过实验详细分析Archaius和Apollo的集成，通过Apollo+Archaius实现Zuul网关的动态配置，欢迎大家关注。</li><li>关于Archaius的更多技术细节，可以参考其在github上的站点[附录1]，另外拍拍贷框架团队的技术专家<strong>尹作龙</strong>也写了一篇文章《微服务动态配置组件netflix archaius》[附录2]，对Archaius的实现细节、使用案例以及如何与Spring Boot集成进行了深入细致的剖析，欢迎大家学习。</li></ol><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>Archaius 包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等等功能。</p><h2 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h2><p>Archaius 支持配置源包括：文件、URLs、JDBC 以及 Amazon DynamoDB</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a property whose value is type long and use 1000 as the default </span></span><br><span class="line">  <span class="comment">// if the property is not defined</span></span><br><span class="line">  DynamicLongProperty timeToWait = </span><br><span class="line">      DynamicPropertyFactory.getInstance().getLongProperty(<span class="string">&quot;lock.waitTime&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ReentrantLock lock = ...;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  lock.tryLock(timeToWait.get(), TimeUnit.MILLISECONDS); <span class="comment">// timeToWait.get() returns up-to-date value of the property</span></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li><a href="https://github.com/netflix/archaius">Netflix Archaius</a></li><li><a href="http://techblog.ppdai.com/2018/05/08/20180508/">微服务动态配置组件netflix archaius</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> Archaius </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置中心对比</title>
      <link href="2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/"/>
      <url>2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式配置中心技术"><a href="#分布式配置中心技术" class="headerlink" title="分布式配置中心技术"></a>分布式配置中心技术</h1><p>配置中心分为二部分，Server服务端及Client客户端。服务端提供数据配置存储；客户端和应用集成，通过通信协议与服务端进行交互，获取服务端数据。</p><h2 id="主流分布式配置中心"><a href="#主流分布式配置中心" class="headerlink" title="主流分布式配置中心"></a>主流分布式配置中心</h2><p>现在比较流行的分布式配置中心如下：</p><ul><li><strong>Nacos</strong> 阿里开源的配置中心，也可以做DNS和RPC的服务发现</li><li><strong>spring cloud config</strong>(借助其它存储服务实现服务端如git)</li><li><strong>Apollo</strong> 携程开源的配置管理中心，具备规范的权限、流程治理等特性</li><li><strong>Disconf</strong> 百度开源的配置管理中心，<strong>目前已经不维护了</strong></li><li><strong>Archaius</strong> Netflix未开源的配置中，其它组件(例如Zuul, Hystrix, Eureka, Ribbon等)都依赖于Archaius</li></ul><h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><p><img src="/2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%941-1605244589166.jpeg"></p><p><img src="/2020/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%942.jpeg"></p><p><strong>说明：</strong></p><p>压测环境：Nacos和Apollo使用同样的数据库（32C128G）部署Server服务的机器使用的8C16G配置的容器，磁盘是100G SSD。</p><p>Spring Cloud Config使用2.0.0.M9版本，Apollo使用1.2.0 release版本，Nacos使用0.5版本。</p><p>Spring Cloud Config 依赖git，使用局限性较大。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题</title>
      <link href="2020/11/17/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>2020/11/17/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="http://atecher.com/">Atecher</a></p><p>出处：<a href="http://atecher.com/2018/04/11/Java-Algorithms-Problem/">http://atecher.com/2018/04/11/Java-Algorithms-Problem/</a></p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</p><p>1.程序分析：这个是典型的<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波那契数列</a>，兔子的规律为数列1,1,2,3,5,8,13,21….</p><p>具体分析如下：</p><blockquote><p>f(1) = 1(第1个月有一对兔子）<br>f(2) = 1(第2个月还是一对兔子）<br>f(3) = 2(原来有一对兔子，第3个开始，每个月生一对兔子）<br>f(4) = 3(原来有两对兔子，有一对可以生育）<br>f(5) = 5(原来有3对兔子，第3个月出生的那对兔子也可以生育了，那么现在有两对兔子可以生育）<br>f(6) = 8(原来有5对兔子，第4个月出生的那对兔子也可以生育了，那么现在有3对兔子可以生育）<br>…………..<br>由以上可以看出，第n个月兔子的对数为<br>f(n) = f(n - 1) + f(n - 2);<br>f(n-1)是上个月的兔子数量，是原来有的。<br>f(n-2)是可以生育的兔子数，即多出来的数量。第n-2个月开始后的第3个月是第n个月，此时第n-2个月时的兔子都可以生育了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">            System.out.println(f(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>||x == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> f(x - <span class="number">1</span>) + f(x - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断101-200之间有多少个素数，并输出所有素数"><a href="#判断101-200之间有多少个素数，并输出所有素数" class="headerlink" title="判断101-200之间有多少个素数，并输出所有素数"></a>判断101-200之间有多少个素数，并输出所有素数</h2><p>1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出所有的“水仙花数”"><a href="#打印出所有的“水仙花数”" class="headerlink" title="打印出所有的“水仙花数”"></a>打印出所有的“水仙花数”</h2><p>所谓水仙花数是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 水仙花数 ，因为153=1的三次方＋5的三次方＋3的三次方。</p><p>1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        math mymath = <span class="keyword">new</span> math();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (mymath.shuixianhua(i) == <span class="keyword">true</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shuixianhua</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        i = x/<span class="number">100</span>;</span><br><span class="line">        j = (x % <span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">        k = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == i*i*i + j*j*j + k*k*k)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一个正整数分解质因数。例如：输入90-打印出90-233-5。"><a href="#将一个正整数分解质因数。例如：输入90-打印出90-233-5。" class="headerlink" title="将一个正整数分解质因数。例如：输入90,打印出90=233*5。"></a>将一个正整数分解质因数。例如：输入90,打印出90=2<em>3</em>3*5。</h2><p>1.程序分析：对n进行分解质因数，应先找到一个最小的质数i，然后按下述步骤完成：<br>(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。<br>(2)如果n &gt; i，但n能被i整除，则应打印出i的值，并用n除以i的商,作为新的正整数你,重复执行第一步。<br>(3)如果n不能被i整除，则用i+1作为i的值,重复执行第一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeFactorization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeFactorization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factorization</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                <span class="keyword">if</span>(n!=i)&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                fenjie(n/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入N的值：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        System.out.print( <span class="string">&quot;分解质因数：&quot;</span> + N +<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> PrimeFactorization().factorization(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用条件运算符的嵌套来完成此题：学习成绩-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"><a href="#利用条件运算符的嵌套来完成此题：学习成绩-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。" class="headerlink" title="利用条件运算符的嵌套来完成此题：学习成绩=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"></a>利用条件运算符的嵌套来完成此题：学习成绩=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。</h2><p>1.程序分析：(a&gt;b)?a:b这是条件运算符的基本例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcademicRecord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入N的值：&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        System.out.println(N &gt;= <span class="number">90</span> ?<span class="string">&quot;A&quot;</span>: (N &gt;= <span class="number">60</span> ? <span class="string">&quot;B&quot;</span>:<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入两个正整数m和n，求其最大公约数和最小公倍数。"><a href="#输入两个正整数m和n，求其最大公约数和最小公倍数。" class="headerlink" title="输入两个正整数m和n，求其最大公约数和最小公倍数。"></a>输入两个正整数m和n，求其最大公约数和最小公倍数。</h2><p>1.程序分析：利用辗除法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,m,n;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个正整数：&quot;</span>);</span><br><span class="line">        a=in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;再输入一个正整数：&quot;</span>);</span><br><span class="line">        b=in.nextInt();</span><br><span class="line">        commonDivisor use=<span class="keyword">new</span> commonDivisor();</span><br><span class="line">        m=use.commonDivisor(a,b);</span><br><span class="line">        n=a*b/m;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大公约数：&quot;</span>+m);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小公倍数：&quot;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">commonDivisor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commonDivisor</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=x;</span><br><span class="line">            x=y;</span><br><span class="line">            y=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k=x%y;</span><br><span class="line">                x=y;</span><br><span class="line">                y=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"><a href="#输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。" class="headerlink" title="输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"></a>输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</h2><p>1.程序分析：利用for循环语句,if条件语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串;&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str=in.nextLine();</span><br><span class="line">        <span class="keyword">char</span>[] ch=str.toCharArray();</span><br><span class="line">        count use=<span class="keyword">new</span> count();</span><br><span class="line">        use.count(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">count</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digital,character,blank,other;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">char</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                digital++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((arr[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;z&#x27;</span>)||(arr[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;Z&#x27;</span>))&#123;</span><br><span class="line">                character++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                blank++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                other++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数字个数：&quot;</span>+digital);</span><br><span class="line">        System.out.println(<span class="string">&quot;英文字母个数：&quot;</span>+character);</span><br><span class="line">        System.out.println(<span class="string">&quot;空格个数：&quot;</span>+blank);</span><br><span class="line">        System.out.println(<span class="string">&quot;其他字符个数：&quot;</span>+other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。"><a href="#求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。" class="headerlink" title="求s = a + aa + aaa + aaaa + aa…a的值，其中a是一个数字。"></a>求s = a + aa + aaa + aaaa + aa…a的值，其中a是一个数字。</h2><p>例如2 + 22 + 222 + 2222 + 22222(此时共有5个数相加)，几个数相加有键盘控制。</p><p>1.程序分析：关键是计算出每一项的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(请输入a的值);</span><br><span class="line">        int a &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(请输入n个数);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        int s &#x3D; 0,t&#x3D;0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            t +&#x3D; a;</span><br><span class="line">            a &#x3D; a*10;</span><br><span class="line">            s +&#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个数如果恰好等于它的因子之和，这个数就称为”完数”。"><a href="#一个数如果恰好等于它的因子之和，这个数就称为”完数”。" class="headerlink" title="一个数如果恰好等于它的因子之和，这个数就称为”完数”。"></a>一个数如果恰好等于它的因子之和，这个数就称为”完数”。</h2><p>例如6=1＋2＋3。编程找出1000以内的所有完数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int s;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">            s &#x3D; 0;</span><br><span class="line">            for (int j &#x3D; 1; j &lt; i; j++)</span><br><span class="line">                if (i % j &#x3D;&#x3D; 0)</span><br><span class="line">                    s &#x3D; s + j;</span><br><span class="line">            if (s &#x3D;&#x3D; i)</span><br><span class="line">                System.out.print(i + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo09&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i,j,sum;</span><br><span class="line">        for(i&#x3D;1;i&lt;1000;i++)&#123;</span><br><span class="line">            sum &#x3D; 0;</span><br><span class="line">            for(j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)&#123;</span><br><span class="line">                if(i%j&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    sum+&#x3D;j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum&#x3D;&#x3D;i)&#123;</span><br><span class="line">                System.out.print(i+&quot; its factors are:   &quot;);</span><br><span class="line">                for(j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)&#123;</span><br><span class="line">                    if(i%j&#x3D;&#x3D;0)</span><br><span class="line">                        System.out.print(j+&quot;, &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？"><a href="#一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？" class="headerlink" title="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？"></a>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double s &#x3D; 0;</span><br><span class="line">        double h &#x3D; 100;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;</span><br><span class="line">            s +&#x3D; h;</span><br><span class="line">            h &#x3D; h&#x2F;2;</span><br><span class="line">            s +&#x3D; h;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;经过路程：&quot;+s);</span><br><span class="line">        System.out.println(&quot;反弹高度：&quot;+h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h2><p>1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; k++)</span><br><span class="line">                    <span class="keyword">if</span> (i != j &amp;&amp; j != k &amp;&amp; i != k) &#123;</span><br><span class="line">                        count += <span class="number">1</span>;</span><br><span class="line">                        System.out.println(i*<span class="number">100</span> + j*<span class="number">10</span> + k);</span><br><span class="line">                    &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;共&quot;</span> + count + <span class="string">&quot;个三位数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="企业发放的奖金根据利润提成。"><a href="#企业发放的奖金根据利润提成。" class="headerlink" title="企业发放的奖金根据利润提成。"></a>企业发放的奖金根据利润提成。</h2><p>利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润lirun，求应发放奖金总数sum？</p><p>1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double sum;</span><br><span class="line">        System.out.println(&quot;输入当月利润：(万元)&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        double lirun &#x3D; in.nextDouble();</span><br><span class="line">        if (lirun &lt;&#x3D; 10) &#123;</span><br><span class="line">            sum &#x3D; lirun * 0.1;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 20) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + (lirun - 10) * 0.075;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 40) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + (lirun - 20) * 0.05;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 60) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + (lirun - 40) * 0.03;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 100) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + 10*0.03 + (lirun - 60) * 0.015;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + 10*0.03 + 10*0.015 + (lirun - 100) * 0.01;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;应发的奖金是：&quot;+sum+&quot;(万元)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"><a href="#一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？" class="headerlink" title="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"></a>一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？</h2><p>1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上168后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo13 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int x&#x3D;1;x&lt;100000;x++)&#123;</span><br><span class="line">          if(Math.sqrt(x+100)%1&#x3D;&#x3D;0)</span><br><span class="line">          if(Math.sqrt(x+100+168)%1&#x3D;&#x3D;0)</span><br><span class="line">            System.out.println(x+&quot;加上100后是一个完全平方数，加上168又是一个完全平方数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入某年某月某日，判断这一天是这一年的第几天？"><a href="#输入某年某月某日，判断这一天是这一年的第几天？" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天？"></a>输入某年某月某日，判断这一天是这一年的第几天？</h2><p>1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本月的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入年,月,日：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int year &#x3D; in.nextInt();</span><br><span class="line">        int month &#x3D; in.nextInt();</span><br><span class="line">        int day &#x3D; in.nextInt();</span><br><span class="line">        Calendar cal &#x3D; Calendar.getInstance();</span><br><span class="line">        cal.set(year, month - 1, day);</span><br><span class="line">        int sum &#x3D; cal.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(&quot;这一天是这一年的第&quot; + sum +&quot;天&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int year,month,day,sum&#x3D;0;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入年：&quot;);</span><br><span class="line">        year&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入月：&quot;);</span><br><span class="line">        month&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入日：&quot;);</span><br><span class="line">        day&#x3D;in.nextInt();</span><br><span class="line"></span><br><span class="line">        switch(month)&#123;</span><br><span class="line">        case 1:</span><br><span class="line">            sum&#x3D;0;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            sum&#x3D;31;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            sum&#x3D;59;</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            sum&#x3D;90;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">            sum&#x3D;120;</span><br><span class="line">            break;</span><br><span class="line">        case 6:</span><br><span class="line">            sum&#x3D;151;</span><br><span class="line">            break;</span><br><span class="line">        case 7:</span><br><span class="line">            sum&#x3D;181;</span><br><span class="line">            break;</span><br><span class="line">        case 8:</span><br><span class="line">            sum&#x3D;212;</span><br><span class="line">            break;</span><br><span class="line">        case 9:</span><br><span class="line">            sum&#x3D;243;</span><br><span class="line">            break;</span><br><span class="line">        case 10:</span><br><span class="line">            sum&#x3D;273;</span><br><span class="line">            break;</span><br><span class="line">        case 11:</span><br><span class="line">            sum&#x3D;304;</span><br><span class="line">            break;</span><br><span class="line">        case 12:</span><br><span class="line">            sum&#x3D;334;</span><br><span class="line">            break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;wrong input!&quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum&#x3D;sum+day;</span><br><span class="line">        boolean leap;</span><br><span class="line">        if(year%400&#x3D;&#x3D;0||(year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0))&#123;</span><br><span class="line">            leap&#x3D;true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            leap&#x3D;false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(leap&amp;&amp;month&gt;2)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;It is the &quot;+sum+&quot;th day.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;请输入年 月 日：&quot;);</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        int year&#x3D;in.nextInt();</span><br><span class="line">        int month&#x3D;in.nextInt();</span><br><span class="line">        int day&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;是该年的第&quot;+count(year,month,day)+&quot;天&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int count(int year,int month,int day)&#123;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        int days&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;month;i++)&#123;</span><br><span class="line">            switch(i)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">            case 3:</span><br><span class="line">            case 5:</span><br><span class="line">            case 7:</span><br><span class="line">            case 8:</span><br><span class="line">            case 10:</span><br><span class="line">            case 12:</span><br><span class="line">                days&#x3D;31;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">            case 6:</span><br><span class="line">            case 9:</span><br><span class="line">            case 11:</span><br><span class="line">                days&#x3D;30;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                if(year%400&#x3D;&#x3D;0||year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)&#123;</span><br><span class="line">                    days&#x3D;29;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    days&#x3D;28;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+&#x3D;days;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+&#x3D;day;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入三个整数x-y-z，请把这三个数由小到大输出。"><a href="#输入三个整数x-y-z，请把这三个数由小到大输出。" class="headerlink" title="输入三个整数x,y,z，请把这三个数由小到大输出。"></a>输入三个整数x,y,z，请把这三个数由小到大输出。</h2><p>1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt;y则将x与y的值进行交换，然后再用x与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(&quot;请输入三个数:&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] arr &#x3D; new int[3];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x &gt; y) &#123; int t &#x3D; x; x &#x3D; y; y &#x3D; t; &#125; if(x &gt; z) &#123; int t &#x3D; x; x &#x3D; z; z &#x3D; t; &#125; if(y &gt; z) &#123; int t &#x3D; y; y &#x3D; z; z &#x3D; t; &#125;</span><br></pre></td></tr></table></figure><h2 id="输出9-9口诀乘法表。"><a href="#输出9-9口诀乘法表。" class="headerlink" title="输出9*9口诀乘法表。"></a>输出9*9口诀乘法表。</h2><p>1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。<br>出现重复的乘积（全矩形）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; 9; j++)</span><br><span class="line">                System.out.print(i + &quot;*&quot; + j + &quot;&#x3D;&quot; + (i*j) + &quot;\\t&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不现重复的乘积(下三角)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; i; j++)</span><br><span class="line">                System.out.print(i + &quot;*&quot; + j + &quot;&#x3D;&quot; + (i*j) + &quot;\\t&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴子吃桃问题"><a href="#猴子吃桃问题" class="headerlink" title="猴子吃桃问题"></a>猴子吃桃问题</h2><p>猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。<br>1.程序分析：采取逆向思维的方法，从后往前推断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo17 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int sum &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 9; i++) &#123;</span><br><span class="line">            sum &#x3D; (sum + 1) * 2;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第一天共摘&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乒乓球比赛"><a href="#乒乓球比赛" class="headerlink" title="乒乓球比赛"></a>乒乓球比赛</h2><p>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Demo18 &#123;</span><br><span class="line">    static char[] m &#x3D; &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;;</span><br><span class="line">    static char[] n &#x3D; &#123; &#39;x&#39;, &#39;y&#39;, &#39;z&#39; &#125;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n.length; j++) &#123;</span><br><span class="line">                if (m[i] &#x3D;&#x3D; &#39;a&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;x&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if (m[i] &#x3D;&#x3D; &#39;a&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;y&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if ((m[i] &#x3D;&#x3D; &#39;c&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;x&#39;)</span><br><span class="line">                        || (m[i] &#x3D;&#x3D; &#39;c&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;z&#39;)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if ((m[i] &#x3D;&#x3D; &#39;b&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;z&#39;)</span><br><span class="line">                        || (m[i] &#x3D;&#x3D; &#39;b&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;y&#39;)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else</span><br><span class="line">                    System.out.println(m[i] + &quot; vs &quot; + n[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Demo18 &#123;</span><br><span class="line">    public String a, b, c;</span><br><span class="line">    public Demo18(String a, String b, String c) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">        this.b &#x3D; b;</span><br><span class="line">        this.c &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo18 arr_a &#x3D; new Demo18(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">        String[] b &#x3D; &#123; &quot;x&quot;, &quot;y&quot;, &quot;z&quot; &#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">                 Demo18 arr_b &#x3D; new Demo18(b[i], b[j], b[k]);</span><br><span class="line">                    if (!arr_b.a.equals(arr_b.b) &amp; !arr_b.b.equals(arr_b.c)</span><br><span class="line">                            &amp; !arr_b.c.equals(arr_b.a) &amp; !arr_b.a.equals(&quot;x&quot;)</span><br><span class="line">                            &amp; !arr_b.c.equals(&quot;x&quot;) &amp; !arr_b.c.equals(&quot;z&quot;)) &#123;</span><br><span class="line">                        System.out.println(arr_a.a + &quot;--&quot; + arr_b.a);</span><br><span class="line">                        System.out.println(arr_a.b + &quot;--&quot; + arr_b.b);</span><br><span class="line">                        System.out.println(arr_a.c + &quot;--&quot; + arr_b.c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出如下图案（三角形-菱形）"><a href="#打印出如下图案（三角形-菱形）" class="headerlink" title="打印出如下图案（三角形\菱形）"></a>打印出如下图案（三角形\菱形）</h2><p>1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重for循环，第一层控制行，第二层控制列。</p><p><strong>三角形：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">***</span><br><span class="line">******</span><br><span class="line">********</span><br><span class="line">******</span><br><span class="line">***</span><br><span class="line">*</span><br><span class="line">public class Demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        for ( i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">            for ( j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        for ( i &#x3D; 3; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">            for ( j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>菱形：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   *</span><br><span class="line">  ***</span><br><span class="line"> *****</span><br><span class="line">*******</span><br><span class="line"> *****</span><br><span class="line">  ***</span><br><span class="line">   *</span><br><span class="line">public class Demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        for (i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; 4 - i; k++)</span><br><span class="line">                System.out.print( &quot; &quot; );</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 3; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; 4 - i; k++)</span><br><span class="line">                System.out.print( &quot; &quot; );</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。"><a href="#有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。" class="headerlink" title="有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。"></a>有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。</h2><p>1.程序分析：请抓住分子与分母的变化规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo20 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float fm &#x3D; 1.0f;</span><br><span class="line">        float fz &#x3D; 1.0f;</span><br><span class="line">        float temp;</span><br><span class="line">        float sum &#x3D; 0f;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            temp &#x3D; fm;</span><br><span class="line">            fm &#x3D; fz;</span><br><span class="line">            fz &#x3D; fz + temp;</span><br><span class="line">            System.out.println((int) fz + &quot;&#x2F;&quot; + (int) fm);</span><br><span class="line">            sum +&#x3D; fz &#x2F; fm;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求1-2-3-…-20-的和"><a href="#求1-2-3-…-20-的和" class="headerlink" title="求1+2!+3!+…+20!的和"></a>求1+2!+3!+…+20!的和</h2><p>1.程序分析：此程序只是把累加变成了累乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo21 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long sum &#x3D; 0;</span><br><span class="line">        long fac &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 20; i++) &#123;</span><br><span class="line">            fac &#x3D; fac * i;</span><br><span class="line">            sum +&#x3D; fac;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用递归方法求5"><a href="#利用递归方法求5" class="headerlink" title="利用递归方法求5!"></a>利用递归方法求5!</h2><p>1.程序分析：递归公式：f(n)=f(n-1)*4!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo22 &#123;</span><br><span class="line">    public static long fac(int n) &#123;</span><br><span class="line">        long value &#x3D; 0;</span><br><span class="line">        if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            value &#x3D; 1;</span><br><span class="line">        &#125; else if (n &gt; 1) &#123;</span><br><span class="line">            value &#x3D; n * fac(n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入一个数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(n + &quot;的阶乘为：&quot; + fac(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算年龄"><a href="#计算年龄" class="headerlink" title="计算年龄"></a>计算年龄</h2><p>有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？</p><p>1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10岁），再往回推。</p><p>直接求解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n &#x3D; 10;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">            n &#x3D; n + 2;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第五个人&quot; + n + &quot;岁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归求解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo23 &#123;</span><br><span class="line">    public static int getAge(int n) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return 2 + getAge(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;第五个的年龄为&quot; + getAge(5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"><a href="#给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。" class="headerlink" title="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"></a>给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。</h2><p>本题原方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo24 use &#x3D; new Demo24();</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        long a &#x3D; in.nextLong();</span><br><span class="line">        if (a &lt; 0 || a &gt;&#x3D; 100000) &#123;</span><br><span class="line">            System.out.println(&quot;Error Input, please run this program Again!&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a &gt;&#x3D; 0 &amp;&amp; a &lt;&#x3D; 9) &#123;</span><br><span class="line">            System.out.println(a + &quot;是一位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;  + a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 10 &amp;&amp; a &lt;&#x3D; 99) &#123;</span><br><span class="line">            System.out.println(a + &quot;是二位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 100 &amp;&amp; a &lt;&#x3D; 999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是三位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 1000 &amp;&amp; a &lt;&#x3D; 9999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是四位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 10000 &amp;&amp; a &lt;&#x3D; 99999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是五位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void converse(long l) &#123;</span><br><span class="line">        String s &#x3D; Long.toString(l);</span><br><span class="line">        char[] ch &#x3D; s.toCharArray();</span><br><span class="line">        for (int i &#x3D; ch.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.print(ch[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人版方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        if (str.matches(&quot;\\\\d+&quot;)) &#123; &#x2F;&#x2F;正则表达式</span><br><span class="line">            System.out.println(&quot;输入的是&quot; + str.length() + &quot;位数&quot;);</span><br><span class="line">            StringBuffer buf &#x3D; new StringBuffer(str);</span><br><span class="line">            System.out.println(buf.reverse());&#x2F;&#x2F;字符串反转</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"><a href="#一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。" class="headerlink" title="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"></a>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</h2><p>原方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Palindrom &#123;</span><br><span class="line">    static int[] a &#x3D; new int[5];</span><br><span class="line">    static int[] b &#x3D; new int[5];</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        boolean is &#x3D; false;</span><br><span class="line">        System.out.println(&quot;Please input：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        long l &#x3D; in.nextLong();</span><br><span class="line">        if (l &gt; 99999 || l &lt; 10000) &#123;</span><br><span class="line">            System.out.println(&quot;Input error, please input again!&quot;);</span><br><span class="line">            l &#x3D; in.nextLong();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 4; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            a[i] &#x3D; (int) (l &#x2F; (long) Math.pow(10, i));</span><br><span class="line">            l &#x3D; (l % (long) Math.pow(10, i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 0; i &lt; 5; i++, j++) &#123;</span><br><span class="line">            b[j] &#x3D; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 4; i &lt; 5; i++, j--) &#123;</span><br><span class="line">            if (a[i] !&#x3D; b[j]) &#123;</span><br><span class="line">                is &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                is &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (is &#x3D;&#x3D; false) &#123;</span><br><span class="line">            System.out.println(&quot;is not a Palindrom!&quot;);</span><br><span class="line">        &#125; else if (is &#x3D;&#x3D; true) &#123;</span><br><span class="line">            System.out.println(&quot;is a Palindrom!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Palindrom &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        int l &#x3D; Integer.parseInt(str);&#x2F;&#x2F;转换成整数</span><br><span class="line">        if (l &lt; 10000 || l &gt; 99999) &#123;</span><br><span class="line">            System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean is&#x3D;false;</span><br><span class="line">        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">        for(int i&#x3D;0;i&lt;ch.length&#x2F;2;i++)&#123;</span><br><span class="line">            if(ch[i]!&#x3D;ch[ch.length-i-1])&#123;</span><br><span class="line">                is&#x3D;false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                is&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(is)&#123;</span><br><span class="line">            System.out.println(&quot;这是一个回文!&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;不是一个回文!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。"><a href="#请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。" class="headerlink" title="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。"></a>请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。</h2><p>1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo26 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char weekSecond;&#x2F;&#x2F;保存第二字母</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);&#x2F;&#x2F;接收用户输入</span><br><span class="line">        System.out.println(&quot;请输入星期的第一个字母：&quot;);</span><br><span class="line">        String letter &#x3D; in.next();</span><br><span class="line">        if (letter.length() &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;判断用户控制台输入字符串长度是否是一个字母</span><br><span class="line">            char weekFirst &#x3D; letter.charAt(0);&#x2F;&#x2F;取第一个字符</span><br><span class="line">            switch (weekFirst) &#123;</span><br><span class="line">            case &#39;m&#39;:</span><br><span class="line">            case &#39;M&#39;:</span><br><span class="line">                System.out.println(&quot;星期一(Monday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;t&#39;:</span><br><span class="line">            case &#39;T&#39;:</span><br><span class="line">                System.out.print(&quot;由于星期二(Tuesday)与星期四(Thursday)均以字母T开头，故需输入第二个字母才能正确判断：&quot;);</span><br><span class="line">                letter &#x3D; in.next();</span><br><span class="line">                if (letter.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    weekSecond &#x3D; letter.charAt(0);</span><br><span class="line">                    if (weekSecond &#x3D;&#x3D; &#39;U&#39; || weekSecond &#x3D;&#x3D; &#39;u&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期二(Tuesday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else if (weekSecond &#x3D;&#x3D; &#39;H&#39; || weekSecond &#x3D;&#x3D; &#39;h&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期四(Thursday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;Error!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case &#39;w&#39;:</span><br><span class="line">            case &#39;W&#39;:</span><br><span class="line">                System.out.println(&quot;星期三(Wednesday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;f&#39;:</span><br><span class="line">            case &#39;F&#39;:</span><br><span class="line">                System.out.println(&quot;星期五(Friday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;s&#39;:</span><br><span class="line">            case &#39;S&#39;:</span><br><span class="line">                System.out.print(&quot;由于星期六(Saturday)与星期日(Sunday)均以字母S开头，故需输入第二个字母才能正确判断：&quot;);</span><br><span class="line">                letter &#x3D; in.next();</span><br><span class="line">                if (letter.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    weekSecond &#x3D; letter.charAt(0);</span><br><span class="line">                    if (weekSecond &#x3D;&#x3D; &#39;A&#39; || weekSecond &#x3D;&#x3D; &#39;a&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期六(Saturday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else if (weekSecond &#x3D;&#x3D; &#39;U&#39; || weekSecond &#x3D;&#x3D; &#39;u&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期日(Sunday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;Error!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;输入错误，不能识别的星期值第一个字母，程序结束！&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求100之内的素数"><a href="#求100之内的素数" class="headerlink" title="求100之内的素数"></a>求100之内的素数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo27 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int sum, i;</span><br><span class="line">        for (sum &#x3D; 2; sum &lt;&#x3D; 100; sum++) &#123;</span><br><span class="line">            for (i &#x3D; 2; i &lt;&#x3D; sum &#x2F; 2; i++) &#123;</span><br><span class="line">                if (sum % i &#x3D;&#x3D; 0)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt; sum &#x2F; 2)</span><br><span class="line">                System.out.println(sum + &quot;是素数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo27&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        int w&#x3D;1;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;100;i++)&#123;</span><br><span class="line">            for(int j&#x3D;2;j&lt;i;j++)&#123;</span><br><span class="line">                w&#x3D;i%j;</span><br><span class="line">                if(w&#x3D;&#x3D;0)break;</span><br><span class="line">                &#125;</span><br><span class="line">            if(w!&#x3D;0)</span><br><span class="line">                System.out.println(i+&quot;是素数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对10个数进行排序。"><a href="#对10个数进行排序。" class="headerlink" title="对10个数进行排序。"></a>对10个数进行排序。</h2><p>1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，下次类推，即用第二个元素与后8个进行比较，并进行交换。<br>本例代码为生成随机10个数排序，并输入1个数，插入重排序输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo28 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] &#x3D; new int[11];</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; r.nextInt(100) + 1; &#x2F;&#x2F;得到10个100以内的整数</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] +&quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;\nPlease Input a int number:&quot; );</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        arr[10] &#x3D; in.nextInt();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] +&quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo28 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入10个数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] arr &#x3D; new int[10];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原数组为：&quot;);</span><br><span class="line">        for (int x : arr) &#123;&#x2F;&#x2F;foreach遍历</span><br><span class="line">            System.out.print( x + &quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;排序后为：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求一个3-3矩阵主对角线元素之和"><a href="#求一个3-3矩阵主对角线元素之和" class="headerlink" title="求一个3*3矩阵主对角线元素之和"></a>求一个3*3矩阵主对角线元素之和</h2><p>1.程序分析：利用双重for循环控制输入二维数组，再将a[i][i]累加后输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo29 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double sum &#x3D; 0;</span><br><span class="line">        int array[][] &#x3D; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 7, 8 &#125; &#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)</span><br><span class="line">                    sum &#x3D; sum + array[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主负对角线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        for(j&#x3D;0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           if(i&#x3D;&#x3D;j) sum1+&#x3D;a[i][j];</span><br><span class="line">           if(i+j&#x3D;&#x3D;n-1) sum2+&#x3D;a[i][j];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>##有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。</p><p>1.程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，插入后此元素之后的数，依次后移一个位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">public class Demo30 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        int arr[] &#x3D; new int[12];</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)</span><br><span class="line">            arr[i] &#x3D; r.nextInt(1000);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)</span><br><span class="line">            System.out.print(arr[i] + &quot;\\t&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 9; i++)</span><br><span class="line">            for (int k &#x3D; i + 1; k &lt;&#x3D; 10; k++)</span><br><span class="line">                if (arr[i] &gt; arr[k]) &#123;</span><br><span class="line">                    temp &#x3D; arr[i];</span><br><span class="line">                    arr[i] &#x3D; arr[k];</span><br><span class="line">                    arr[k] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 10; k++)</span><br><span class="line">            System.out.print(arr[k] + &quot;\\t&quot;);</span><br><span class="line">        arr[11] &#x3D; r.nextInt(1000);</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 10; k++)</span><br><span class="line">            if (arr[k] &gt; arr[11]) &#123;</span><br><span class="line">                temp &#x3D; arr[11];</span><br><span class="line">                for (int j &#x3D; 11; j &gt;&#x3D; k + 1; j--)</span><br><span class="line">                    arr[j] &#x3D; arr[j - 1];</span><br><span class="line">                    arr[k] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 11; k++)</span><br><span class="line">            System.out.print(arr[k] + &quot;\\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一个数组逆序输出"><a href="#将一个数组逆序输出" class="headerlink" title="将一个数组逆序输出"></a>将一个数组逆序输出</h2><p>程序分析：用第一个与最后一个交换。</p><p>用逆序循环控制变量输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo31 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 &#125;;</span><br><span class="line">        for (int i &#x3D; a.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取一个整数a从右端开始的第4～7位数字。"><a href="#取一个整数a从右端开始的第4～7位数字。" class="headerlink" title="取一个整数a从右端开始的第4～7位数字。"></a>取一个整数a从右端开始的第4～7位数字。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo32 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个7位以上的正整数：&quot;);</span><br><span class="line">        long l &#x3D; in.nextLong();</span><br><span class="line">        String str &#x3D; Long.toString(l);</span><br><span class="line">        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">        int j&#x3D;ch.length;</span><br><span class="line">        if (j&lt;7)&#123;System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;截取从右端开始的4～7位是：&quot;+ch[j-7]+ch[j-6]+ch[j-5]+ch[j-4]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo32&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a &#x3D; 0;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        long b &#x3D; s.nextLong();</span><br><span class="line">        a &#x3D; (int) (b % 10000000 &#x2F; 1000);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出杨辉三角形（要求打印出10行如下图）"><a href="#打印出杨辉三角形（要求打印出10行如下图）" class="headerlink" title="打印出杨辉三角形（要求打印出10行如下图）"></a>打印出杨辉三角形（要求打印出10行如下图）</h2><p>1.程序分析：<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo33 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        int a[][];</span><br><span class="line">        int n &#x3D; 10;</span><br><span class="line">        a &#x3D; new int[n][n];</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            a[i][i] &#x3D; 1;</span><br><span class="line">            a[i][0] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 2; i &lt; n; i++) &#123;</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; i - 1; j++) &#123;</span><br><span class="line">                a[i][j] &#x3D; a[i - 1][j - 1] + a[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt;&#x3D; i; j++) &#123;</span><br><span class="line">                System.out.printf(a[i][j] + &quot;\\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入3个数a-b-c，按大小顺序输出。"><a href="#输入3个数a-b-c，按大小顺序输出。" class="headerlink" title="输入3个数a,b,c，按大小顺序输出。"></a>输入3个数a,b,c，按大小顺序输出。</h2><p>（也可互相比较交换排序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Demo34 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arrays &#x3D; &#123; 800, 56, 500 &#125;;</span><br><span class="line">        Arrays.sort(arrays);</span><br><span class="line">        for (int n &#x3D; 0; n &lt; arrays.length; n++)</span><br><span class="line">            System.out.println(arrays[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x &gt; y) &#123; int t &#x3D; x; x &#x3D; y; y &#x3D; t; &#125; if(x &gt; z) &#123; int t &#x3D; x; x &#x3D; z; z &#x3D; t; &#125; if(y &gt; z) &#123; int t &#x3D; y; y &#x3D; z; z &#x3D; t; &#125;</span><br></pre></td></tr></table></figure><h2 id="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。"><a href="#输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。" class="headerlink" title="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。"></a>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo35 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i, min&#x3D;0, max&#x3D;0, n, temp1, temp2;</span><br><span class="line">        int a[];</span><br><span class="line">        System.out.println(&quot;定义数组的长度:&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        n &#x3D; in.nextInt();</span><br><span class="line">        a &#x3D; new int[n];</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(&quot;输入第&quot; + (i + 1) + &quot;个数据:&quot;);</span><br><span class="line">            a[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            if (a[i] &gt; a[max])</span><br><span class="line">                max &#x3D; i;</span><br><span class="line">            if (a[i] &lt; a[min])</span><br><span class="line">                min &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp1 &#x3D; a[0];</span><br><span class="line">        a[0] &#x3D; a[max];</span><br><span class="line">        a[max] &#x3D; temp1;</span><br><span class="line"></span><br><span class="line">        temp2 &#x3D; a[min];</span><br><span class="line"></span><br><span class="line">        if (min !&#x3D; 0) &#123; &#x2F;&#x2F; 如果最小值不是a[0]，执行下面</span><br><span class="line">            a[min] &#x3D; a[n - 1];</span><br><span class="line">            a[n - 1] &#x3D; temp2;</span><br><span class="line">        &#125; else &#123;  &#x2F;&#x2F;如果最小值是a[0],执行下面</span><br><span class="line">            a[max] &#x3D; a[n - 1];</span><br><span class="line">            a[n - 1] &#x3D; temp1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数"><a href="#有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数" class="headerlink" title="有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数"></a>有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo36 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入数字个数n：&quot;);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入后移位数m：&quot;);</span><br><span class="line">        int m &#x3D; in.nextInt();</span><br><span class="line">        LinkedList&lt;Integer&gt; list &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个数:&quot;);</span><br><span class="line">            list.add(in.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原数据排序为：&quot;);</span><br><span class="line">        for (int t : list) &#123;</span><br><span class="line">            System.out.print(t + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;Integer&gt; temp1 &#x3D; list.subList(list.size() - m, list.size());</span><br><span class="line">        List&lt;Integer&gt; temp2 &#x3D; list.subList(0, list.size() - m);</span><br><span class="line">        temp2.addAll(0, temp1);</span><br><span class="line">        System.out.println(&quot;移动后排序为;&quot;);</span><br><span class="line">        for (int t : temp2) &#123;</span><br><span class="line">            System.out.print(t + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo36&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请定义数组的长度：&quot;);</span><br><span class="line">        int n&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;请输入移动的位数：&quot;);</span><br><span class="line">        int m&#x3D;in.nextInt();</span><br><span class="line">        int [] arr&#x3D;new int [n];</span><br><span class="line">        int [] brr&#x3D;new int [n];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个数：&quot;);</span><br><span class="line">            arr[i]&#x3D;in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序前：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            brr[i]&#x3D;arr[n-m+i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n-m;i++)&#123;</span><br><span class="line">            arr[m+i]&#x3D;arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i]&#x3D;brr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序后：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。</p><p>（约瑟夫环问题，百度百科有时间复杂度最简单的数学方法）</p><p>原例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输人数n：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        boolean[] arr &#x3D; new boolean[n];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; true; &#x2F;&#x2F;下标为TRUE时说明还在圈里</span><br><span class="line">        &#125;</span><br><span class="line">        int leftCount &#x3D; n;</span><br><span class="line">        int countNum &#x3D; 0;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (leftCount &gt; 1) &#123;</span><br><span class="line">            if (arr[index] &#x3D;&#x3D; true) &#123; &#x2F;&#x2F;当在圈里时</span><br><span class="line">                countNum++;  &#x2F;&#x2F;报数递加</span><br><span class="line">                if (countNum &#x3D;&#x3D; 3) &#123; &#x2F;&#x2F;报数为3时</span><br><span class="line">                    countNum &#x3D; 0; &#x2F;&#x2F;从零开始继续报数</span><br><span class="line">                    arr[index] &#x3D; false; &#x2F;&#x2F;此人退出圈子</span><br><span class="line">                    leftCount--; &#x2F;&#x2F;剩余人数减一</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++; &#x2F;&#x2F;每报一次数，下标加一</span><br><span class="line">            if (index &#x3D;&#x3D; n) &#123; &#x2F;&#x2F;是循环数数，当下标大于n时，说明已经数了一圈，</span><br><span class="line">                index &#x3D; 0; &#x2F;&#x2F;将下标设为零重新开始。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (arr[i] &#x3D;&#x3D; true) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入人数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] a &#x3D; new int[in.nextInt()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int left &#x3D; a.length;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        while (left &gt; 1) &#123;</span><br><span class="line">            if (a[j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (num &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                a[j] &#x3D; 0;</span><br><span class="line">                num &#x3D; 0;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            if (j &#x3D;&#x3D; a.length) &#123;</span><br><span class="line">                j &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                System.out.println(&quot;最后留下的人是&quot;+ (i + 1) + &quot;号&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; l &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        System.out.println(&quot;请输入人数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int len &#x3D; in.nextInt();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            l.add(i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; sum !&#x3D; len - 1;) &#123;</span><br><span class="line">            if (l.get(i) !&#x3D; 0) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                l.remove(i);</span><br><span class="line">                l.add(i, 0);</span><br><span class="line">                temp &#x3D; 0;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            if (i &#x3D;&#x3D; l.size()) &#123;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int t : l) &#123;</span><br><span class="line">            if (t !&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(&quot;最后留下的人是&quot; + t + &quot;号&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。"><a href="#写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。" class="headerlink" title="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。"></a>写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo38 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String mys &#x3D; in.next();</span><br><span class="line">        System.out.println(str_len(mys));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int str_len(String x) &#123;</span><br><span class="line">        return x.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo38 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String mys &#x3D; in.next();</span><br><span class="line">        System.out.println(mys.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写一个函数，输入n为偶数时，调用函数求1-2-1-4-…-1-n-当输入n为奇数时，调用函数1-1-1-3-…-1-n"><a href="#编写一个函数，输入n为偶数时，调用函数求1-2-1-4-…-1-n-当输入n为奇数时，调用函数1-1-1-3-…-1-n" class="headerlink" title="编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n"></a>编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo39 &#123;</span><br><span class="line">    public static double ouShu(int n) &#123;</span><br><span class="line">        double result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; n; i &#x3D; i + 2) &#123;</span><br><span class="line">            result +&#x3D;  1 &#x2F; (double) i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public static double jiShu(int n) &#123;</span><br><span class="line">        double result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i &#x3D; i + 2) &#123;</span><br><span class="line">            result +&#x3D; 1 &#x2F; (double) i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入n的值：&quot;);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        if (n % 2 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;偶数，1&#x2F;2+1&#x2F;4+...+1&#x2F;n</span><br><span class="line">            System.out.println(ouShu(n));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;奇数，1&#x2F;1+1&#x2F;3+...+1&#x2F;n</span><br><span class="line">            System.out.println(jiShu(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><p>（利用容器类中的sort方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo40 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(&quot;010102&quot;);</span><br><span class="line">        list.add(&quot;010003&quot;);</span><br><span class="line">        list.add(&quot;010201&quot;);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Demo40 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请定义字符串的个数：&quot;);</span><br><span class="line">        int n&#x3D;in.nextInt();</span><br><span class="line">        String[] str&#x3D;new String[n];</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.length;i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;字符串：&quot;);</span><br><span class="line">            str[i]&#x3D;in.next();</span><br><span class="line">        &#125;</span><br><span class="line">        strSort(n,str);</span><br><span class="line">        System.out.println(&quot;字符串排序后：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.length;i++)&#123;</span><br><span class="line">            System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void strSort(int n,String[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++) &#123;</span><br><span class="line">            for(int j&#x3D;i+1; j&lt;n; j++) &#123;</span><br><span class="line">                if(compare(arr[i], arr[j]) &#x3D;&#x3D; false) &#123;</span><br><span class="line">                    String temp &#x3D; arr[i]; arr[i] &#x3D; arr[j]; arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static boolean compare(String s1, String s2) &#123;</span><br><span class="line">        boolean result &#x3D; true;</span><br><span class="line">        for(int i&#x3D;0; i&lt;s1.length() &amp;&amp; i&lt;s2.length(); i++) &#123;</span><br><span class="line">            if(s1.charAt(i) &gt; s2.charAt(i)) &#123;</span><br><span class="line">                result &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if(s1.charAt(i) &lt;s2.charAt(i)) &#123;</span><br><span class="line">                result &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(s1.length() &lt; s2.length()) &#123;</span><br><span class="line">                    result &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴子分桃"><a href="#猴子分桃" class="headerlink" title="猴子分桃"></a>猴子分桃</h2><p>海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？</p><p>本题源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Demo41 &#123;</span><br><span class="line">    static int ts &#x3D; 0;&#x2F;&#x2F; 桃子总数</span><br><span class="line">    int fs &#x3D; 1;&#x2F;&#x2F; 记录分的次数</span><br><span class="line">    static int hs &#x3D; 5;&#x2F;&#x2F; 猴子数</span><br><span class="line">    int tsscope &#x3D; 5000;&#x2F;&#x2F; 桃子数的取值范围，太大容易溢出。</span><br><span class="line">    public int fT(int t) &#123;</span><br><span class="line">        if (t &#x3D;&#x3D; tsscope) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当桃子数到了最大的取值范围时取消递归</span><br><span class="line">            System.out.println(&quot;结束&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ((t - 1) % hs &#x3D;&#x3D; 0 &amp;&amp; fs &lt;&#x3D; hs) &#123;</span><br><span class="line">                if (fs &#x3D;&#x3D; hs) &#123;</span><br><span class="line">                    System.out.println(&quot;桃子数&#x3D;&quot; + ts + &quot;时满足分桃条件&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                fs +&#x3D; 1;</span><br><span class="line">                return fT((t - 1) &#x2F; 5 * 4);&#x2F;&#x2F; 返回猴子拿走一份后的剩下的总数</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 没满足条件</span><br><span class="line">                fs &#x3D; 1;&#x2F;&#x2F; 分的次数重置为1</span><br><span class="line">                return fT(ts +&#x3D; 1);&#x2F;&#x2F; 桃子数加+1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Demo41().fT(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo41 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 6;; i++) &#123;&#x2F;&#x2F; 最少6个分最后一次</span><br><span class="line">            sum &#x3D; i;&#x2F;&#x2F; 桃子数</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 5; j++) &#123;&#x2F;&#x2F; 分的次数循环</span><br><span class="line">                if ((sum - 1) % 5 &#x3D;&#x3D; 0 &amp;&amp; j &lt; 5) &#123;&#x2F;&#x2F; 如果扔一个后能均分5份，继续分</span><br><span class="line">                    sum &#x3D; (sum - 1) &#x2F; 5 * 4;&#x2F;&#x2F; 每分一次剩余桃子数</span><br><span class="line">                    if (j &#x3D;&#x3D; 4) &#123;&#x2F;&#x2F; 如果已分5次，且仍能除尽，输出，退出程序</span><br><span class="line">                        System.out.println(i);</span><br><span class="line">                        System.exit(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="809-800-9-1。其中-代表的两位数-8-的结果为两位数，9-的结果为3位数。求-代表的两位数，及809-后的结果。"><a href="#809-800-9-1。其中-代表的两位数-8-的结果为两位数，9-的结果为3位数。求-代表的两位数，及809-后的结果。" class="headerlink" title="809*??=800*??+9*??+1。其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。"></a>809*??=800*??+9*??+1。其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。</h2><p>（本题为无解，去掉1有解）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo42 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 10; i &lt; 100; i++) &#123;</span><br><span class="line">            if (809 * i &#x3D;&#x3D; (800 * i + 9 * i + 1) &amp;&amp; 8 * i &gt;&#x3D; 10 &amp;&amp; 8 * i &lt; 100</span><br><span class="line">                    &amp;&amp; 9 * i &gt;&#x3D; 100 &amp;&amp; 9 * i &lt; 1000) &#123;</span><br><span class="line">                System.out.println(&quot;?? &#x3D;&quot; + i);</span><br><span class="line">                System.out.println(&quot;809*??&#x3D;&quot;+ 809 * i);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求0—7所能组成的奇数个数"><a href="#求0—7所能组成的奇数个数" class="headerlink" title="求0—7所能组成的奇数个数"></a>求0—7所能组成的奇数个数</h2><p>暴力算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static boolean isJiShu(int n) &#123;</span><br><span class="line">        if (n % 2 !&#x3D; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean fun(char c) &#123;</span><br><span class="line">        if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;7&#39;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        String s;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">            s &#x3D; &quot;&quot; + i;</span><br><span class="line">            boolean flag &#x3D; true;</span><br><span class="line">            char[] c &#x3D; s.toCharArray();</span><br><span class="line">            for (int j &#x3D; 0; j &lt; c.length; j++) &#123;</span><br><span class="line">                if (!fun(c[j])) &#123;</span><br><span class="line">                    flag &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag &amp;&amp; isJiShu(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            s &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;共&quot; + count + &quot;个。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 因为是奇数，所以个位只能是1，3，5，7共4种，前面可随便排列</span><br><span class="line">        int count &#x3D; 4;&#x2F;&#x2F; 个位的4种</span><br><span class="line">        &#x2F;&#x2F; 2位时，十位有8种，个位4种，8×4</span><br><span class="line">        &#x2F;&#x2F; 3位时，8×8×4……</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 8; i++) &#123;</span><br><span class="line">            count &#x3D; 8 * count;</span><br><span class="line">            System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;组成1位数是4个。</span><br><span class="line">&#x2F;&#x2F;组成2位数是7*4个。</span><br><span class="line">&#x2F;&#x2F;组成3位数是7*8*4个。</span><br><span class="line">&#x2F;&#x2F;组成4位数是7*8*8*4个。</span><br><span class="line"></span><br><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        int sum&#x3D;4;</span><br><span class="line">        int j;</span><br><span class="line">        System.out.println(&quot;组成1位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        sum&#x3D;sum*7;</span><br><span class="line">        System.out.println(&quot;组成2位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        for(j&#x3D;3;j&lt;&#x3D;9;j++)&#123;</span><br><span class="line">            sum&#x3D;sum*8;</span><br><span class="line">            System.out.println(&quot;组成&quot;+j+&quot;位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个偶数总能表示为两个素数之和"><a href="#一个偶数总能表示为两个素数之和" class="headerlink" title="一个偶数总能表示为两个素数之和"></a>一个偶数总能表示为两个素数之和</h2><p>哥德巴赫猜想是想证明对任何大于6的自然数n之内的所有偶数可以表示为两个素数之和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo44 &#123;</span><br><span class="line">    public static boolean isSuShu(int x) &#123;</span><br><span class="line">        if (x &#x3D;&#x3D; 0 || x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; Math.sqrt(x); i++) &#123;</span><br><span class="line">            if (x % i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 求了下100以内的情况</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i &#x3D; i + 2)&#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;&#x3D; (i + 1) &#x2F; 2; j++)&#123;</span><br><span class="line">                if (isSuShu(j) &amp;&amp; isSuShu(i - j))&#123;</span><br><span class="line">                    System.out.println(i + &quot;&#x3D;&quot; + j + &quot;+&quot; + (i - j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Demo44&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for (int i&#x3D;6;i&lt;&#x3D;100 ;i+&#x3D;2 )&#123;</span><br><span class="line">            for (int j&#x3D;2;j&lt;100 ;j++ )&#123;</span><br><span class="line">                if(!isPrime(j)||!isPrime(i-j)||j&gt;&#x3D;i)</span><br><span class="line">                continue;</span><br><span class="line">                System.out.println(i+&quot;&#x3D;&quot;+j+&quot;+&quot;+(i-j));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isPrime(int n)&#123;</span><br><span class="line">        for (int i&#x3D;2;i&lt;n ;i++ )&#123;</span><br><span class="line">            if(n%i&#x3D;&#x3D;0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断几个9能被一个素数整除"><a href="#判断几个9能被一个素数整除" class="headerlink" title="判断几个9能被一个素数整除"></a>判断几个9能被一个素数整除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class Demo45&#123;</span><br><span class="line">    public static boolean isSuShu(int x)&#123;</span><br><span class="line">        if (x &#x3D;&#x3D; 0|| x &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; Math.sqrt(x); i++)&#123;</span><br><span class="line">            if (x % i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] a &#x3D; new int[100];</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 长度100的素数数组</span><br><span class="line">        while (n &lt; 100) &#123;</span><br><span class="line">            if (isSuShu(num)) &#123;</span><br><span class="line">                a[n] &#x3D; num;</span><br><span class="line">                n++;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* for (int t : a) &#123;</span><br><span class="line">         System.out.println(t);</span><br><span class="line">         &#125;*&#x2F;</span><br><span class="line">        String s &#x3D; &quot;9&quot;;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (s.length() &lt; 9) &#123;</span><br><span class="line">            if (new Integer(s).intValue() % a[index] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(s + &quot;%&quot; + a[index] + &quot;&#x3D;0&quot;);</span><br><span class="line">                if (index &lt; 100 - 1) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    index &#x3D; 0;</span><br><span class="line">                    s &#x3D; s + &quot;9&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; System.exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (index &lt; 100 - 1) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    index &#x3D; 0;</span><br><span class="line">                    s &#x3D; s + &quot;9&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）"><a href="#判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）" class="headerlink" title="判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）"></a>判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo45 &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个整数：&quot;);</span><br><span class="line">        int num &#x3D; in.nextInt();</span><br><span class="line">        int tmp &#x3D; num;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0 ; tmp%9 &#x3D;&#x3D; 0 ;)&#123;</span><br><span class="line">            tmp &#x3D; tmp&#x2F;9;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num+&quot; 能够被 &quot;+count+&quot; 个9 整除。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个字符串连接程序"><a href="#两个字符串连接程序" class="headerlink" title="两个字符串连接程序"></a>两个字符串连接程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo46 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入第一个字符串：&quot;);</span><br><span class="line">        String s1 &#x3D; in.next();</span><br><span class="line">        System.out.println(&quot;输入第一个字符串：&quot;);</span><br><span class="line">        String s2 &#x3D; in.next();</span><br><span class="line">        System.out.println(&quot;连接后：n&quot; + s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo46 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String str1 &#x3D; in.nextLine();</span><br><span class="line">        System.out.print(&quot;请再输入一个字符串：&quot;);</span><br><span class="line">        String str2 &#x3D; in.nextLine();</span><br><span class="line">        String str &#x3D; str1+str2;</span><br><span class="line">        System.out.println(&quot;连接后的字符串是：&quot;+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的-号"><a href="#读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的-号" class="headerlink" title="读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的*号"></a>读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的*号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo47 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int n&#x3D;1,num;</span><br><span class="line">        while(n&lt;&#x3D;7)&#123;</span><br><span class="line">            do&#123;</span><br><span class="line">                System.out.print(&quot;请输入一个1--50 之间的整数：&quot;);</span><br><span class="line">                num&#x3D; s.nextInt();</span><br><span class="line">            &#125;while(num&lt;1||num&gt;50);</span><br><span class="line">            for(int i&#x3D;1;i&lt;&#x3D;num;i++)</span><br><span class="line">            &#123;System.out.print(&quot;*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo47 &#123;</span><br><span class="line">    public static void print(int n) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(&quot;*&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 7; i++) &#123;</span><br><span class="line">            int temp &#x3D; in.nextInt();</span><br><span class="line">            print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"><a href="#某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。" class="headerlink" title="某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"></a>某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo48&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个4位数字：&quot;);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        if (!((str).matches(&quot;\\d&#123;4&#125;&quot;))) &#123;</span><br><span class="line">            System.out.println(&quot;输入的不是4位数字！&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        char[] c &#x3D; str.toCharArray();</span><br><span class="line">        int[] a &#x3D; new int[4];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] &#x3D; ((int) (c[i] - &#39;0&#39;) + 5) % 10;</span><br><span class="line">        &#125;</span><br><span class="line">        int t;</span><br><span class="line">        t &#x3D; a[0];</span><br><span class="line">        a[0] &#x3D; a[3];</span><br><span class="line">        a[3] &#x3D; t;</span><br><span class="line">        t &#x3D; a[1];</span><br><span class="line">        a[1] &#x3D; a[2];</span><br><span class="line">        a[2] &#x3D; t;</span><br><span class="line">        System.out.println(&quot;结果是：&quot; + a[0] + a[1] + a[2] + a[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo48 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int num&#x3D;0,temp;</span><br><span class="line">        do&#123;</span><br><span class="line">            System.out.print(&quot;请输入一个4位正整数：&quot;);</span><br><span class="line">            num &#x3D; s.nextInt();</span><br><span class="line">        &#125;while (num&lt;1000||num&gt;9999);</span><br><span class="line">        int a[]&#x3D;new int[4];</span><br><span class="line">        a[0] &#x3D; num&#x2F;1000; &#x2F;&#x2F;取千位的数字</span><br><span class="line">        a[1] &#x3D; (num&#x2F;100)%10; &#x2F;&#x2F;取百位的数字</span><br><span class="line">        a[2] &#x3D; (num&#x2F;10)%10; &#x2F;&#x2F;取十位的数字</span><br><span class="line">        a[3] &#x3D; num%10; &#x2F;&#x2F;取个位的数字</span><br><span class="line">        for(int j&#x3D;0;j&lt;4;j++) &#123;</span><br><span class="line">            a[j]+&#x3D;5; a[j]%&#x3D;10;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;&#x3D;1;j++) &#123;</span><br><span class="line">            temp &#x3D; a[j]; a[j] &#x3D; a[3-j]; a[3-j] &#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;加密后的数字为：&quot;);</span><br><span class="line">        for(int j&#x3D;0;j&lt;4;j++) System.out.print(a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符串中子串出现的次数"><a href="#计算字符串中子串出现的次数" class="headerlink" title="计算字符串中子串出现的次数"></a>计算字符串中子串出现的次数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo49 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入主串：&quot;);</span><br><span class="line">        String str1 &#x3D; in.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入子串：&quot;);</span><br><span class="line">        String str2 &#x3D; in.nextLine();</span><br><span class="line">        &#x2F;&#x2F; 生成子串长度的N个字符串数组</span><br><span class="line">        String[] sa &#x3D; new String[str1.length() - str2.length() + 1];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sa.length; i++) &#123;</span><br><span class="line">            sa[i] &#x3D; str1.substring(i, i + str2.length());</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 子串与N个拆开的子串比对</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sa.length; i++) &#123;</span><br><span class="line">            if (sa[i].equals(str2)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 成功配对，计数器+1；</span><br><span class="line">                sum++;</span><br><span class="line">                &#x2F;&#x2F; 因为不计算重叠的子串，所以跳过配对之后的部分拆分子串</span><br><span class="line">                i &#x3D; i + str2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;主串中共包含&quot; + sum + &quot;个字串&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文"><a href="#有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文" class="headerlink" title="有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文"></a>有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">class Student &#123;</span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line">    private String name &#x3D; &quot;&quot;;</span><br><span class="line">    private double[] a &#x3D; new double[3];</span><br><span class="line">    public double getAve() &#123;</span><br><span class="line">        return (a[0] + a[1] + a[2]) &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(int number, String name, double[] a) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.number &#x3D; number;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;学号：&quot; + this.number + &quot;\t姓名：&quot; + this.name + &quot;\r\n各科成绩：\r\n&quot; + a[0] + &quot;\\t&quot; + a[1] + &quot;\\t&quot; + a[2] + &quot;\r\n平均成绩：\r\n&quot;+ this.getAve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo50 &#123;</span><br><span class="line">    public static Student input() &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入学号：&quot;);</span><br><span class="line">        int num &#x3D; s.nextInt();</span><br><span class="line">        System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">        String name &#x3D; s.next();</span><br><span class="line">        System.out.println(&quot;请分别输入3门成绩：&quot;);</span><br><span class="line">        double[] a &#x3D; new double[3];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            a[i] &#x3D; s.nextDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        return new Student(num, name, a);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Student[] st &#x3D; new Student[2];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; st.length; i++) &#123;</span><br><span class="line">            st[i] &#x3D; input();</span><br><span class="line">        &#125;</span><br><span class="line">        File f &#x3D; new File(&quot;d:&quot; + File.separator + &quot;123.txt&quot;);</span><br><span class="line">        FileWriter output &#x3D; new FileWriter(f);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; st.length; i++) &#123;</span><br><span class="line">            output.write(st[i].toString() + &quot;\r\n&quot;);</span><br><span class="line">            output.write(&quot;\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon扩展点</title>
      <link href="2020/11/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%89%A9%E5%B1%95%E7%82%B9/"/>
      <url>2020/11/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%89%A9%E5%B1%95%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="7个核心接口"><a href="#7个核心接口" class="headerlink" title="7个核心接口"></a>7个核心接口</h2><table><thead><tr><th>接口</th><th>简述</th><th>默认实现</th></tr></thead><tbody><tr><td>IClientConfig</td><td>定义ribbon中管理配置的接口</td><td>DefaultClientConfigImpl</td></tr><tr><td>IRule</td><td>定义ribbon中负载均衡策略的接口</td><td>ZoneAvoidanceRule</td></tr><tr><td>IPing</td><td>定义定期ping服务，检查可用性的接口</td><td>DummyPing</td></tr><tr><td>ServerList<Server></Server></td><td>定义获取服务列表方法的接口</td><td>ConfigurationBasedServerList</td></tr><tr><td>ServerListFilter<Server></Server></td><td>定义特定场景下，获取服务列表的方法接口</td><td>ZonePreferenceServerListFilter</td></tr><tr><td>ILoadBalancer</td><td>定义负载均衡选择服务的核心方法接口</td><td>ZoneAwareLoadBalancer</td></tr><tr><td>ServerListUpdater</td><td>为DynamicServerListLoadBalancer定义动态更新服务列表的接口</td><td>PollingServerListUpdater</td></tr></tbody></table><p>Ribbon的加载策略是懒加载，即第一次请求的时候才加载对应上下文，正是这个原因，很多时候第一次调用显得很慢，甚至会超时，所以，可以通过指定ribbon具体服务名称来开启饿加载，即在工程启动的时候，加载所有的配置上下文。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: client-a, client-b, client-c</span><br></pre></td></tr></table></figure><p>ribbon在1.2.0版本以后，<font color="red"><strong>可以使用配置文件来定制ribbon客户端，这种优先级最高</strong></font>，高于使用@RibbonClient注解指定配置。</p><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td><clientName>.ribbon.NFLoadBalancerClassName</clientName></td><td>指定ILoadBalancer的实现类</td></tr><tr><td><clientName>.ribbon.NFLoadBalancerRuleClassName</clientName></td><td>指定IRule的实现类</td></tr><tr><td><clientName>.ribbon.NFLoadBalancerPingClassName</clientName></td><td>指定IPing的实现类</td></tr><tr><td><clinetName>.ribbon.NIWSServerListClassName</clinetName></td><td>指定ServerList的实现类</td></tr><tr><td><clientName>.ribbon.NIWSServerListFilterClassName</clientName></td><td>指定ServerListFilter的实现类</td></tr></tbody></table><p>可以使用ribbon的自带实现类，也可以使用我们自定义的接口实现类，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NIWSServerListClass:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span> <span class="comment">#指定ServerList的实现类</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#指定IRule的实现类</span></span><br></pre></td></tr></table></figure><p>默认情况下，ribbon客户端会从eureka注册中心获取服务注册列表，然后做负载均衡策略，但是如果想要ribbon客户端脱离eureka使用，可以为ribbon客户端指定服务的地址，如下操作：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">ribbon.eureka.enabled</span>=<span class="string">false #一定要关闭ribbon中的eureka功能</span></span><br><span class="line"><span class="meta">client.ribbon.listOfServers</span>=<span class="string">http://localhost:7070,http://localhost:7171 #指定服务地址</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon负载均衡</title>
      <link href="2020/11/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2020/11/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="ribbon负载均衡策略"><a href="#ribbon负载均衡策略" class="headerlink" title="ribbon负载均衡策略"></a>ribbon负载均衡策略</h2><p>ribbon有7种负载均衡策略可供选择：</p><table><thead><tr><th>策略类</th><th>命名</th><th>描述</th></tr></thead><tbody><tr><td>RandomRule</td><td>随机策略</td><td>随机选择server</td></tr><tr><td>RoundRobinRule</td><td>轮询策略</td><td>按照顺序选择server（ribbon默认策略）</td></tr><tr><td>RetryRule</td><td>重试策略</td><td>在一个配置时间段内，当选择server不成功，则一直尝试选择一个可用的server</td></tr><tr><td>BestAvailableRule</td><td>最低并发策略</td><td>逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server</td></tr><tr><td>AvailabilityFilteringRule</td><td>可用过滤策略</td><td>过滤掉一直失败并被标记为circuit tripped的server，过滤掉那些高并发链接的server（active connections超过配置的阈值）</td></tr><tr><td>ResponseTimeWeightedRule</td><td>响应时间加权重策略</td><td>根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间</td></tr><tr><td>ZoneAvoidanceRule</td><td>区域权重策略</td><td>综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server</td></tr></tbody></table><a id="more"></a><h2 id="配置策略"><a href="#配置策略" class="headerlink" title="配置策略"></a>配置策略</h2><ul><li><p>使用java注解配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(value = &#123;</span></span><br><span class="line"><span class="meta">    @RibbonClient(name = &quot;order-service&quot;, configuration = RoundRobinRule.class)</span></span><br><span class="line"><span class="meta">&#125;, defaultConfiguration = NativeRibbonRule.class)</span></span><br></pre></td></tr></table></figure></li><li><p>使用配置文件方式配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#针对client-a服务使用随机策略</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="重试及超时配置"><a href="#重试及超时配置" class="headerlink" title="重试及超时配置"></a>重试及超时配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment">#对第一次请求的服务的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment">#要重试的下一个服务的最大数量（不包括第一个服务）</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#说明：这里配置的ConnectTimeout和ReadTimeout是当HTTP客户端使用的是HttpClient才生效，这个时间最终会被设置到HttpClient中。</span></span><br><span class="line"><span class="comment">#在设置的时候需要结合hystrix的超时时间来综合考虑，针对使用的场景，设置太小会导致很多请求失败，设置太大会导致熔断控制变差。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github上创建hexo博客</title>
      <link href="2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装node.js </p></li><li><p>安装hexo。npm install -g hexo-cli</p></li><li><p>hexo项目初始化。hexo init &lt;新建文件夹的名称&gt;</p></li><li><p>如果是从git上下载下来的hexo项目，安装依赖包。npm install –force</p></li><li><p>创建文章。 hexo new post fileName</p></li><li><p>发布文章。hexo d (修改配置文件，安装npm install hexo-deployer-git –save)</p></li><li><p>启动。hexo s</p></li><li><p>编译。hexo g</p></li></ol><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><strong>安装插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/luckyfeing/luckyfeing.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">&#x27;发布文章&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="图片使用"><a href="#图片使用" class="headerlink" title="图片使用"></a>图片使用</h2><ul><li>图床，如七牛云，阿里云，可以借助<a href="http://markdown.xiaoshujiang.com/">小书匠在线markdown工具</a>,可以配置图片上传图床如github。</li><li>相对路径图片，选择<strong>相对路径图片解决方案</strong>，借助Typora配置</li><li>base64图片，在线编码</li></ul><p><strong>安装插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p><strong>修改插件js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">config.post_asset_folder</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>Typora配置图片设置</strong></p><p>可以配置本地图片（相对路径），也可以配置图片上传，借助PicGo工具，配置图片上传</p><p><img src="/2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/Typora%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E8%AE%BE%E7%BD%AE.jpg"></p><h2 id="创建tags"><a href="#创建tags" class="headerlink" title="创建tags"></a>创建tags</h2><p><strong>创建页面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p><strong>修改新文件内容</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tagcloud</span><br><span class="line">date: 2017-06-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>新增文章添加标签tags</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016-03-16 08:12:43</span><br><span class="line">tags:</span><br><span class="line">categories: 前端</span><br><span class="line">--- </span><br></pre></td></tr></table></figure><h2 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h2><p><strong>创建页面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p><strong>修改新文件内容</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>新增文章添加分类categories</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016-03-16 08:12:43</span><br><span class="line">tags:</span><br><span class="line">categories: 前端</span><br><span class="line">--- </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo简单命令</title>
      <link href="2020/11/13/hexo%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
      <url>2020/11/13/hexo%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
