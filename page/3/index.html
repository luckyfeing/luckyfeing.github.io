<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/11/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">java线程之基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-11 17:44:23" itemprop="dateCreated datePublished" datetime="2021-06-11T17:44:23+08:00">2021-06-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程状态：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED；注意点：就绪和运行状态就是RUNNABLE</p>
<ol>
<li>新建：new一个新对象</li>
<li>就绪：执行start（）方法，Java虚拟机会为其创建方法调用栈和程序计数器，该状态线程未开始运行，表示线程可以运行了，该线程何时开始运行，取决于JVM里线程调度器的调度</li>
<li>运行：处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体。<ul>
<li>抢占式调度策略：系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级</li>
<li>协作式调度策略：只有当一个线程调用了它的sleep()或yield()方法后才会放弃所占用的资源，也就是必须由该线程主动放弃所占用的资源</li>
</ul>
</li>
<li>堵塞：阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）如阻塞IO方法</li>
<li>死亡：线程结束：正常或异常<ul>
<li>run()或call()方法执行完成，线程正常结束</li>
<li>线程抛出一个未捕获的Exception或Error</li>
<li>直接调用该线程stop()方法来结束该线程——该方法容易导致死锁</li>
</ul>
</li>
</ol>
<h2 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h2><ul>
<li>Thread implements Runnable{} private Runnable target; 核心是:target.run()</li>
<li>Runnable 接口</li>
<li>Callable 接口</li>
<li>Future 接口</li>
<li>FutureTask-&gt;RunnableFuture extends Runnable, Future</li>
</ul>
<h2 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FutureTask futureCallable = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;futureTask call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">String result = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">FutureTask futureRunnable = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;futureTask run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,result);</span><br><span class="line"></span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(futureCallable);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(futureRunnable);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(futureCallable.get());</span><br><span class="line">    System.out.println(futureRunnable.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sleep与wait区别"><a href="#sleep与wait区别" class="headerlink" title="sleep与wait区别"></a>sleep与wait区别</h2><ul>
<li>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的</li>
<li>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态</li>
<li>在调用sleep()方法的过程中，线程不会释放对象锁而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</li>
</ul>
<h2 id="Java中实现线程阻塞的方法："><a href="#Java中实现线程阻塞的方法：" class="headerlink" title="Java中实现线程阻塞的方法："></a>Java中实现线程阻塞的方法：</h2><p>（1）线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p>
<p>（2）线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的notify()唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用wait()一样。wait()和notify()方法：两个方法配套使用，wait()使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify()被调用.</p>
<p>（3）线程礼让，Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield()使得线程放弃当前分得的CPU时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用yield()的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</p>
<p>（4）线程自闭，join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
<p>（5）suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。典型地，suspend()和resume()被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用resume()使其恢复。Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p>
<h2 id="堵塞和非堵塞"><a href="#堵塞和非堵塞" class="headerlink" title="堵塞和非堵塞"></a>堵塞和非堵塞</h2><p>阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p>
<p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<h2 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h2><p>多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果线程A持有锁L并且想获得锁M，线程B持有锁M并且想获得锁L，那么这两个线程将永远等待下去，这种情况就是最简单的死锁形式</p>
<h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><ol>
<li>系统资源的竞争<br>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的</li>
<li>进程推进顺序非法<br>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞</li>
</ol>
<h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ol>
<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有</li>
</ol>
<h2 id="避免死锁的方式"><a href="#避免死锁的方式" class="headerlink" title="避免死锁的方式"></a>避免死锁的方式</h2><ol>
<li>让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实</li>
<li>设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量</li>
<li>既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后变回返回一个失败信息（超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题）</li>
<li>死锁检测 每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</li>
</ol>
<ul>
<li>释放所有锁，回退，并且等待一段随机的时间后重试，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁</li>
<li>给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁，如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级</li>
</ul>
<h2 id="java-栈信息"><a href="#java-栈信息" class="headerlink" title="java 栈信息"></a>java 栈信息</h2><ol>
<li>jps获得当前Java虚拟机进程的pid</li>
<li>jstack pid</li>
</ol>
<h2 id="栈信息解读"><a href="#栈信息解读" class="headerlink" title="栈信息解读"></a>栈信息解读</h2><ul>
<li>“Thread-1”表示线程名称</li>
<li>“prio=6”表示线程优先级</li>
<li>“tid=00000000497cec00”表示线程Id</li>
<li>nid=0x219c线程对应的本地线程Id。因为Java线程是依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码，只有本地线程才是真正的线程实体。Java代码中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体。Linux环境下可以使用”top -H -p JVM进程Id”来查看JVM进程下的本地线程（也被称作LWP）信息，注意这个本地线程是用十进制表示的，nid是用16进制表示的，转换一下就好了</li>
<li>“ [0x000000000c9ff000]”表示线程占用的内存地址</li>
<li>“java.lang.Thread.State：BLOCKED”表示线程的状态</li>
</ul>
<hr>
<p>死锁下，看下Thread-1处于BLOCKED状态，Thread-0处于BLOCKED状态。对这两个线程分析一下：</p>
<ol>
<li>Thread-1获得了锁&lt;0x00000007d5d19c60&gt;，在等待锁&lt;0x00000007d5d19c50&gt;</li>
<li>Thread-0获得了锁&lt;0x00000007d5d19c50&gt;，在等待锁&lt;0x00000007d5d19c60&gt;</li>
</ol>
<p>由于两个线程都在等待获取对方持有的锁，所以就这么永久等待下去了。</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span>  <span class="comment">//如果被标记了则返回true表示当前已经被中断，否则返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> <span class="comment">//该方法用于判断当前线程是否被中断，并且该方法调用结束的时候会清空中断标识位</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>; <span class="comment">//主要使用本地方法，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> <span class="comment">//该方法用于设置当前线程对象的中断标识位。	</span></span></span><br><span class="line"><span class="function">线程状态：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED</span></span><br><span class="line"><span class="function">线程中断状态state：	线程状态new	| TERMINATED ——》中断操作，中断状态为flase，对这两种状态下的线程是无效的	   </span></span><br><span class="line"><span class="function">线程状态RUNNABLE	| BLOCKED ——》中断操作，设置中断状态为<span class="keyword">true</span>，线程继续执行，也只会设置中断标志位并不会实际中断线程运行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exit MyThread&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">线程状态WAITING	| TIMED_WAITING ——》中断操作，中断状态为<span class="keyword">false</span>，线程对于中断操作是敏感的，会抛出异常并清空中断标志位</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am waiting but facing interruptexception now&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程都一个状态位用于标识当前线程对象是否是中断状态，中断状态有六种：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED</p>
<ul>
<li>new：还未调用start方法，线程还未真正启动</li>
<li>RUNNABLE:线程处于运行状态</li>
<li>BLOCKED阻塞：synchronized同步方法死循环</li>
<li>WAITING，TIMED_WAITING：使用wait（）时的中断状态</li>
<li>TERMINATED 线程已经运行终止</li>
</ul>
<ol>
<li>NEW和TERMINATED对于中断操作几乎是屏蔽的</li>
<li>RUNNABLE和BLOCKED类似，对于中断操作只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中if(Thread.currentThread().isInterrupted())成立则退出</li>
<li>WAITING/TIMED_WAITING状态下的线程对于中断操作是敏感的，他们会抛出异常并清空中断标志位，线程中自己捕获异常InterruptedException</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例方法，返回是否中断，不清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//实例方法，设置线程中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//静态方法，返回当前线程是否中断，清除中断状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangming1996/p/7612653.html">线程中断文章</a></p>
<h2 id="线程副本"><a href="#线程副本" class="headerlink" title="线程副本"></a>线程副本</h2><h6 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h6><p>每个线程Thread类都有一个ThreadLocalMap属性，ThreadLocal.ThreadLocalMap threadLocals = null;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        </span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap</p>
<p>ThreadLocalRandom</p>
<h2 id="并行流（parallel-streams）"><a href="#并行流（parallel-streams）" class="headerlink" title="并行流（parallel streams）"></a>并行流（parallel streams）</h2><h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h2 id="线程面试："><a href="#线程面试：" class="headerlink" title="线程面试："></a>线程面试：</h2><ol>
<li>现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？</li>
</ol>
<ul>
<li> 使用Thread的join方法</li>
</ul>
<ol>
<li>Java 中新的 Lock 接口相对于同步代码块（synchronized block）有什么优势？如果让你实现一个高性能缓存，支持并发读取和单一写入，你如何保证数据完整性</li>
</ol>
<ul>
<li> lock 接口的最大优势是它为读和写提供两个单独的锁，可以让你构建高性能数据结构，比如 ConcurrentHashMap 和条件阻塞</li>
</ul>
<ol>
<li>Java 中 wait 和 sleep 方法有什么区别</li>
</ol>
<ul>
<li> 主要的区别就是等待释放锁和监视器。sleep方法在等待时不会释放任何锁或监视器。wait方法多用于线程间通信，而sleep只是在执行时暂停</li>
</ul>
<ol>
<li>如何在 Java 中实现一个阻塞队列</li>
</ol>
<ul>
<li> 如果用wait()和notify()方法成功实现了阻塞队列，可以让他用Java 5的并发类重新实现一次</li>
</ul>
<ol>
<li>如何在Java中编写代码解决生产者消费者问题</li>
</ol>
<ul>
<li> 用Java中 BlockingQueue 的解决方案</li>
</ul>
<ol>
<li>写一段死锁代码。你在Java中如何解决死锁</li>
</ol>
<ul>
<li> 有 N个资源和N个线程去执行某个操作</li>
</ul>
<ol>
<li>什么是原子操作？Java中有哪些原子操作</li>
</ol>
<ul>
<li>[x]</li>
</ul>
<ol>
<li>Java中volatile关键字是什么？你如何使用它？它和Java中的同步方法有什么区别</li>
</ol>
<ul>
<li> volatile变量在并发环境中如何确保可见性、有序性和一致性</li>
</ul>
<ol>
<li>什么是竞态条件？你如何发现并解决竞态条件</li>
</ol>
<ul>
<li>竞态条件是指同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件，代码区成为临界区。最常见的竞态条件为：先检测后执行。<strong>使用synchronized</strong>  <strong>使用CAS中的AtomicInteger</strong></li>
</ul>
<ol>
<li>在 Java 中你如何转储线程（thread dump）？如何分析它</li>
</ol>
<ul>
<li>jstack pid | grep -A 200(16进制线程id)   线程id  线程state</li>
</ul>
<ol>
<li>既然 start() 方法会调用 run() 方法，为什么我们调用 start() 方法，而不直接调用 run() 方法</li>
</ol>
<ul>
<li> 当你调用 start() 方法时，它会新建一个线程然后执行 run() 方法中的代码。如果直接调用 run() 方法，并不会创建新线程，方法中的代码会在当前调用者的线程中执行</li>
</ul>
<ol>
<li>Java 中你如何唤醒阻塞线程</li>
</ol>
<ul>
<li> 有很多原因会导致阻塞，如果是 IO 阻塞，我认为没有方式可以中断线程（如果有的话请告诉我）。另一方面，如果线程阻塞是由于调用了 wait()，sleep() 或 join() 方法，你可以中断线程，通过抛出 InterruptedException 异常来唤醒该线程</li>
</ul>
<ol>
<li>Java 中 CyclicBarriar 和 CountdownLatch 有什么区别</li>
</ol>
<ul>
<li> CyclicBarrier 在屏障打开之后（所有线程到达屏障点），可以重复使用。而 CountDownLatch 不行</li>
</ul>
<ol>
<li>什么是不可变类？它对于编写并发应用有何帮助</li>
</ol>
<ul>
<li>[x]</li>
</ul>
<ol>
<li>你在多线程环境中遇到的最多的问题是什么？你如何解决的？</li>
</ol>
<ul>
<li> 内存干扰、竞态条件、死锁、活锁、线程饥饿是多线程和并发编程中比较有代表性的问题。这类问题无休无止，而且难于定位和调试。 这是基于经验给出的 Java 面试题。你可以看看Java 并发实战课程来了解现实生活中高性能多线程应用所面临的问题。</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>Java 中绿色线程和本地线程的区别？</li>
<li>线程和进程的区别？答案</li>
<li>多线程的上下文切换是什么？</li>
<li>死锁和活锁的区别？死锁和饥饿的区别？</li>
<li>Java 中使用什么线程调度算法？</li>
<li>Java 中线程调度是什么？</li>
<li>线程中如何处理某个未处理异常？</li>
<li>什么是线程组？为什么 Java 中不建议使用线程组？</li>
<li>为什么使用 Executor 框架比直接创建线程要好？</li>
<li>Java 中 Executor 和 Executors 的区别？答案</li>
<li>在 windows 和 linux 系统上分别如何找到占用 CPU 最多的线程？</li>
</ul>
<h2 id="线程池数量"><a href="#线程池数量" class="headerlink" title="线程池数量"></a>线程池数量</h2><ol>
<li><p>CPU 密集型应用，线程池大小设置为 N + 1</p>
</li>
<li><p>IO 密集型应用，线程池大小设置为 2N </p>
</li>
<li><p><em>线程池大小 = （（线程 IO time + 线程 CPU time ）/线程 CPU time ）</em> CPU数目</p>
<ol>
<li><em>线程 IO time + 线程 CPU time</em>为请求总耗时，可以通过拦截器获取</li>
<li>CPU 计算时间 = 请求总耗时 - CPU IO time，只需要知道IO 耗时就可以知道CPU耗时</li>
<li>CPU数目可以通过系统函数获取</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/11/java%E7%BA%BF%E7%A8%8B%E4%B9%8BFuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/java%E7%BA%BF%E7%A8%8B%E4%B9%8BFuture/" class="post-title-link" itemprop="url">java线程之Future</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-11 16:33:34" itemprop="dateCreated datePublished" datetime="2021-06-11T16:33:34+08:00">2021-06-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><ul>
<li><strong>Callable</strong></li>
<li><strong>FutureTask implements</strong> <strong>RunnableFuture</strong></li>
<li><strong>RunnableFuture</strong>&lt;**V**&gt; <strong>extends</strong> <strong>Runnable</strong>, <strong>Future</strong>&lt;**V**&gt;</li>
<li><strong>Future</strong></li>
</ul>
<p>既然 RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 又实现了 RunnableFuture 接口，所以 FutureTask 既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(task);</span><br><span class="line">        <span class="keyword">new</span> Thread(integerFutureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task运行结果：&quot;</span>+integerFutureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程正在计算&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程池</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task(); </span><br><span class="line"><span class="comment">// 提交任务并获得Future: </span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task); </span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果: </span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>
<h2 id="Future方法及作用"><a href="#Future方法及作用" class="headerlink" title="Future方法及作用"></a>Future方法及作用</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>返回值</th>
<th>入参</th>
<th>备注</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>boolean</td>
<td>（boolean mayInterruptIfRunning）</td>
<td>用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</td>
<td>也就是说Future提供了三种功能：判断任务是否完成，能够中断任务，能够获取任务执行结果</td>
</tr>
<tr>
<td>isCancelled</td>
<td>boolean</td>
<td>无</td>
<td>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</td>
<td></td>
</tr>
<tr>
<td>isDone</td>
<td>boolean</td>
<td>无</td>
<td>方法表示任务是否已经完成，若任务完成，则返回true；</td>
<td></td>
</tr>
<tr>
<td>get</td>
<td>V</td>
<td>无</td>
<td>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回</td>
<td></td>
</tr>
<tr>
<td>get</td>
<td>V</td>
<td>（long timeout, TimeUnit unit）</td>
<td>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/11/java%E5%B9%B6%E5%8F%91%E4%B9%8BCAS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/java%E5%B9%B6%E5%8F%91%E4%B9%8BCAS/" class="post-title-link" itemprop="url">java之并发CAS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-11 14:16:46" itemprop="dateCreated datePublished" datetime="2021-06-11T14:16:46+08:00">2021-06-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h2><ul>
<li>AtomicInteger  使用自旋的方式，先获取原始值，再进行比较设置CompareAndSwap,当线程竞争激烈时，可能有很多线程会不停的自旋，进入一个无限重复的循环中。导致大量线程空循环，自旋转，性能和效率都不是特别好。<ul>
<li>解决方式是使用LongAdder、DoubleAdder，原理是base+cell数组，分段处理机制</li>
</ul>
</li>
<li>ABA问题：<ul>
<li>解决方式是使用AtomicMarkableReference<V>、可以给一个引用标记上一个标记位，来保证原子性。AtomicStampedReference<V>可以给一个引用标记上一个整型的版本戳，来保证原子性。</V></V></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">JVM之类加载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-11 10:01:58" itemprop="dateCreated datePublished" datetime="2021-06-11T10:01:58+08:00">2021-06-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JVM类加载过程原理"><a href="#JVM类加载过程原理" class="headerlink" title="JVM类加载过程原理"></a>JVM类加载过程原理</h2><p>类加载:Java命令的作用是启动虚拟机，虚拟机通过输入流，从磁盘上将字节码文件(.class文件)中的内容读入虚拟机，并保存起来的过程就是类加载。</p>
<p><img src="/2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20210611101027635.png" alt="image-20210611101027635"></p>
<h2 id="加载-load"><a href="#加载-load" class="headerlink" title="加载(load)"></a>加载(load)</h2><p>通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成一个代表这个类的Java.lang.Class对象；</p>
<h2 id="链接（link）"><a href="#链接（link）" class="headerlink" title="链接（link）"></a>链接（link）</h2><ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题（文件格式验证，元数据验证，字节码验证，符号引用验证）。</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配（由于还没有产生对象，实例变量将不再此操作范围内）</li>
<li>解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法）；</li>
</ul>
<h2 id="初始化-Initialize"><a href="#初始化-Initialize" class="headerlink" title="初始化(Initialize)"></a>初始化(Initialize)</h2><p>激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value1  = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value2  = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    value2 = <span class="number">66</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="何时触发初始化"><a href="#何时触发初始化" class="headerlink" title="何时触发初始化"></a>何时触发初始化</h2><ol>
<li>为一个类型创建一个新的对象实例时（比如new、反射、序列化）</li>
<li>调用一个类型的静态方法时（即在字节码中执行invokestatic指令）</li>
<li>调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式</li>
<li>调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）</li>
<li>初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）</li>
<li>JVM启动包含main方法的启动类时。</li>
</ol>
<h2 id="类加载特性"><a href="#类加载特性" class="headerlink" title="类加载特性"></a>类加载特性</h2><p>在虚拟机的生命周期中一个类只被加载一次。<br>类加载的原则：延迟加载，能少加载就少加载，因为虚拟机的空间是有限的。<br>类加载的时机：<br>  1）第一次创建对象要加载类.<br>  2）调用静态方法时要加载类,访问静态属性时会加载类。<br>  3）加载子类时必定会先加载父类。<br>  4）创建对象引用不加载类.<br>  5) 子类调用父类的静态方法时<br>      (1)当子类没有覆盖父类的静态方法时，只加载父类，不加载子类<br>      (2)当子类有覆盖父类的静态方法时，既加载父类，又加载子类<br>  6）访问静态常量，如果编译器可以计算出常量的值，则不会加载类,例如:public static final int a =123;否则会加载类,例如:public static final int a = math.PI。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器的<strong>作用</strong>：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区中数据的访问入口。 类加载器主要分为三层：</p>
<ul>
<li><strong>引导类加载器<code>BootstrapClassLoader</code>：</strong> 用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取 <code>Java\jdk1.8\jre\lib\rt.jar</code>，通过<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>可以获取加载的路径。可以通过使用参数添加自己的类，如<code>java -Xbootclasspath/a:/D:/test/tes  HelloWorld</code></li>
<li><strong>扩展类加载器<code>ExtClassLoader</code>：</strong> 负责<code>jre/lib/ext</code>目录下的jar包或 <code>-D java.ext.dirs</code> 指定目录下的jar包装入工作库</li>
<li><strong>系统类加载器<code>AppClassLoader</code>：</strong> 负责<code>java -classpath</code> 或 <code>-D java.class.path</code> 所指目录下的类与jar包装入工作，是最常用的加载器</li>
</ul>
<p><img src="/2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20210611112354965.png" alt="image-20210611112354965"></p>
<p><strong>类缓存：</strong> 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间，不过JVM垃圾回收机制可以回收这些Class对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类的加载器</span></span><br><span class="line">        ClassLoader loader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(loader);  <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载的父类加载器--&gt;扩展类加载器</span></span><br><span class="line">        ClassLoader parent = loader.getParent();</span><br><span class="line">        System.out.println(parent);  <span class="comment">//sun.misc.Launcher$ExtClassLoader@74a14482</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）</span></span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1);  <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试当前类是哪个加载器加载的</span></span><br><span class="line">        ClassLoader classLoader = Class.forName(<span class="string">&quot;com.dbright.Test.Test02&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);  <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试JDK内部类是谁加载的</span></span><br><span class="line">        classLoader = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);  <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何获取系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双亲委派机制：如果上层加载器存在不会使用下层定义类</strong><br>ClassLoader是基类，类加载器继承它。其它类寄存器是Launcher启动类的静态类，继承URLClassLoader类，使用模板方法设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; loadClass(String name)  <span class="comment">//使用双亲委派机制，加载类</span></span><br><span class="line">Class&lt;?&gt; findClass(String name)  <span class="comment">//自定义类加载器，不打破双亲委派机制，重写这个方法即可</span></span><br></pre></td></tr></table></figure>

<h2 id="类中代码加载顺序"><a href="#类中代码加载顺序" class="headerlink" title="类中代码加载顺序"></a>类中代码加载顺序</h2><ol>
<li>父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</li>
<li>子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</li>
<li>父类非静态代码块(包括非静态初始化块，非静态属性 )</li>
<li>父类构造方法</li>
<li>子类非静态代码块(包括非静态初始化块，非静态属性 )</li>
<li>子类构造方法</li>
</ol>
<p>==静态块==：用static声明，JVM加载类时执行，仅执行一次。有多个静态变量或块时，按声明顺序加载<br>==构造块==：类中直接用{}定义，每一次创建对象时执行<br>==执行顺序优先级==：静态块&gt;main()&gt;构造块&gt;构造方法</p>
<h2 id="Tomcat类加载"><a href="#Tomcat类加载" class="headerlink" title="Tomcat类加载"></a>Tomcat类加载</h2><img src="/2021/06/11/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20210624151753640.png" alt="image-20210624151753640" style="zoom:67%;">

<p>在Java的内存分配中，总共3种常量池：</p>
<h2 id="字符串常量池-String-Constant-Pool"><a href="#字符串常量池-String-Constant-Pool" class="headerlink" title="字符串常量池(String Constant Pool)"></a>字符串常量池(String Constant Pool)</h2><p>1.1:字符串常量池在Java内存区域的哪个位置？<br>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；<br>在JDK7.0版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。<br>1.2:字符串常量池是什么？<br>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。<br>在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；<br>在JDK7.0中，StringTable的长度可以通过参数指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize&#x3D;66666</span><br></pre></td></tr></table></figure>

<p>1.3:字符串常量池里放的是什么？<br>在JDK6.0及之前版本中，String Pool里放的都是字符串常量；<br>在JDK7.0中，由于String#intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用。关于String在内存中的存储和String#intern()方法的说明，可以参考我的另外一篇博客：<br>需要说明的是：字符串常量池中的字符串只存在一份！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;hello,world!&quot;;</span><br><span class="line">String s2 &#x3D; &quot;hello,world!&quot;;</span><br></pre></td></tr></table></figure>


<p>即执行完第一行代码后，常量池中已存在 “hello,world!”，那么 s2不会在常量池中申请新的空间，而是直接把已存在的字符串内存地址返回给s2。(这里具体的字符串如何分配就不细说了，可以看我的另一篇博客)</p>
<p>即执行完第一行代码后，常量池中已存在 “hello,world!”，那么 s2不会在常量池中申请新的空间，而是直接把已存在的字符串内存地址返回给s2。(这里具体的字符串如何分配就不细说了，可以看我的另一篇博客)</p>
<h2 id="class常量池-Class-Constant-Pool"><a href="#class常量池-Class-Constant-Pool" class="headerlink" title="class常量池(Class Constant Pool)"></a>class常量池(Class Constant Pool)</h2><p>2.1:class常量池简介：<br>我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)；<br>每个class文件都有一个class常量池。<br>2.2:什么是字面量和符号引用：<br>字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;<br>符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。</p>
<h2 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h2><p>运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用<br>JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/09/java%E5%B9%B6%E5%8F%91%E4%B9%8BLongAdder%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/09/java%E5%B9%B6%E5%8F%91%E4%B9%8BLongAdder%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java并发之LongAdder详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-09 13:26:43" itemprop="dateCreated datePublished" datetime="2021-06-09T13:26:43+08:00">2021-06-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3OTc1MDM1Mg==&mid=2247503711&idx=2&sn=e6e18d492dac91ec195ac3768549ac83&chksm=fd63dfe0ca1456f6dc9a06f8c4c23850c002d4c62b22d29d756d051ba24c99b77b4f2b37d56d&scene=178&cur_album_id=1709316523971887110#rd">巧妙使用LongAdder替换AtomicLong</a></p>
<p>LongAdder性能高的原因是通过使用Cell数组，以空间换效率避免共享变量的竞争，在LongAdder中内部使用base变量保存Long值 ，当没有线程冲突时，使用CAS更新base的值，而存在线程冲突时，没有执行CAS成功的线程将CAS操作Cell数组，将数组中的元素置为1，即cell[i]=1，最后获取计数时会计算cell[i]的总和在加base，即为最后的计数结果。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/d7YzaYDnrxFeoicR91WjOEdnuDcibsUicADoJdjTdkA7THMoayv22nb4F81LibrnnK0ntlfkSC4fEcvCdQhhWgNafQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/d7YzaYDnrxFeoicR91WjOEdnuDcibsUicADImAFeVB4IrzktumC8oV2LMG0UiayiaHNWBJ7LQqWRkODY5xYe08jSucg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/" class="post-title-link" itemprop="url">限流-总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-07 11:39:18" itemprop="dateCreated datePublished" datetime="2021-06-07T11:39:18+08:00">2021-06-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><ul>
<li>固定窗口</li>
<li>滑动窗口</li>
<li>漏桶算法</li>
<li>令牌桶算法</li>
<li>信号量</li>
<li>线程池隔离</li>
</ul>
<h3 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h3><p>为一定时间段的流量设置一个阈值，超过则触发限流策略（丢弃或者停留），然后直到下一个时间段重新置零开始计数。</p>
<p><strong>弊端</strong>：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为<font color="red">突刺现象</font></p>
<p>可以使用AtomicLong#incrementAndGet()，Redis中的String类型的原子操作并设置过期时间<br>可以使用Redis，key 为当前秒的时间戳，value 就是访问次数的累加，当次数超出了我们限制的范围内，直接拒绝即可</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>以当前时间为截止时间，往前取一定的时间，比如取60s的时间，在这60s时间内最大的访问数为100。此时算法的执行逻辑为，先清除这60s 之前的所有请求记录，再计算当前集合内请求数是否大于设定的最大请求数100，如果大于100则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。</p>
<p><strong>实现方式</strong>：借助Redis的有序集合ZSet来实现时间窗口算法限流，实现的过程是：</p>
<p>第一步：先使用ZSet的key存储限流的ID，score用来存储请求的时间。</p>
<p>第二步：每次有请求访问来了之后，先清空之前时间窗口的访问量，统计目前时间窗口的个数与最大允许访问量对比。</p>
<p>第三步：如果大于等于最大访问量则返回 false 执行限流操策略，负责允许执行业务逻辑，并且在 ZSet 中添加一条有效的访问记录。</p>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>可以准备一个队列，用来保存请求，另外通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。弊端：无法应对短时间的突发流量<br><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/漏桶.jpg" alt="2021-01-2120-56-37.png" style="zoom: 50%;"></p>
<p><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/image-20210607132324808.png" alt="image-20210607132324808"></p>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行<br><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%99%90%E6%B5%81/令牌桶.png" alt="2021-01-2120-59-20.png" style="zoom: 80%;"></p>
<h2 id="限流用法"><a href="#限流用法" class="headerlink" title="限流用法"></a>限流用法</h2><ul>
<li>单节点限流： 可以在网关层添加（网关服务限流）或者在对应的服务端添加拦截（应用服务限流），如Gateway中自定义限流规则。使用某种限流算法，使用Guava包中的限流算法，将数据统计保存在对应的节点</li>
<li>集群限流：     可以在网关层添加（网关服务限流）或者在对应的服务端添加拦截（应用服务限流），如Gateway中自定义限流规则。指定访问的服务集群使用某种限流算法，使用Redis记录集群的限流统计情况</li>
<li>具体服务限流：服务端提供的API中会指定serviceId，如FeignClient注解里的，服务隔离如Hystrix使用信号量或线程池；Sentinel使用线程量进行隔离，使用QPS和调用关系进行限流，支持集群流量控制，热点参数限流，系统自适应保护</li>
<li>具体接口限流：服务端提供的Controller类的接口，可以在方法上增加自定义注解，使用AOP的方式和限流算法实现具体接口服务的限流，比如可以使用信号量</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">网关-API-Gateway详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-07 10:30:01" itemprop="dateCreated datePublished" datetime="2021-06-07T10:30:01+08:00">2021-06-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在 Spring Cloud Gateway 中有如下几个核心概念需要我们了解：</p>
<p>1）Route</p>
<p>Route 是网关的基础元素，由 ID、目标 URI、断言、过滤器组成。当请求到达网关时，由 Gateway Handler Mapping 通过断言进行路由匹配（Mapping），当断言为真时，匹配到路由。</p>
<p>2）Predicate</p>
<p>Predicate 是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 8 中提供的一个函数。输入类型是 Spring Framework ServerWebExchange。它允许开发人员匹配来自 HTTP 的请求，例如请求头或者请求参数。简单来说它就是匹配条件。</p>
<p>3）Filter</p>
<p>Filter 是 Gateway 中的过滤器，可以在请求发出前后进行一些业务上的处理。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>客户端向 Spring Cloud Gateway 发出请求，如果请求与网关程序定义的路由匹配，则该请求就会被发送到网关 Web 处理程序，此时处理程序运行特定的请求过滤器链。</p>
<p>过滤器之间用虚线分开的原因是过滤器可能会在发送代理请求的前后执行逻辑。所有 pre 过滤器逻辑先执行，然后执行代理请求；代理请求完成后，执行 post 过滤器逻辑。<br><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/5-1ZR6093952150.png" alt="Spring Cloud Gateway工作原理" style="zoom:80%;"></p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>启动服务发现，从注册中心加载注册的服务，路由的uri: lb://user-service，网关会替换成对应的服务ip：port</p>
<h2 id="路由断言工厂"><a href="#路由断言工厂" class="headerlink" title="路由断言工厂"></a>路由断言工厂</h2><ul>
<li>Path 路由断言工厂 predicates:下添加，可添加多个  - Path=/blog/detail/{segment}  测试地址：<a target="_blank" rel="noopener" href="http://localhost:2001/blog/detail/36185">http://localhost:2001/blog/detail/36185</a></li>
<li>Query 路由断言工厂  - Query=foo, ba.    测试链接：<a target="_blank" rel="noopener" href="http://localhost:2001/?foo=baz">http://localhost:2001/?foo=baz</a></li>
<li>Method 路由断言工厂 - Method=GET</li>
<li>Header 路由断言工厂  - Header=X-Request-Id, \d+ 请求中带有请求头名为 x-request-id，其值与 \d+ 正则表达式匹配（值为一个或多个数字）</li>
<li>自定义路由断言工厂  继承 AbstractRoutePredicateFactory 类，重写 apply 方法的逻辑，命名需要以RoutePredicateFactory结尾</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//CheckAuth 就是这个路由断言工厂的名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckAuthRoutePredicateFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractRoutePredicateFactory</span>&lt;<span class="title">CheckAuthRoutePredicateFactory</span>.<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckAuthRoutePredicateFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="title">apply</span><span class="params">(Config config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;进入了CheckAuthRoutePredicateFactory\t&quot;</span> + config.getName());</span><br><span class="line">            <span class="keyword">if</span> (config.getName().equals(<span class="string">&quot;zhangsan&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      	<span class="bullet">-</span> <span class="attr">id:</span> <span class="string">customer_route</span></span><br><span class="line">      	<span class="attr">uri:</span> <span class="string">http://c.biancheng.net</span></span><br><span class="line">      	<span class="attr">predicates:</span>   <span class="comment">#CheckAuth就是这个路由断言工厂的名称</span></span><br><span class="line">      	    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CheckAuth</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zhangsan</span></span><br></pre></td></tr></table></figure>

<h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><ul>
<li>AddRequestHeader 过滤器工厂  filters: - AddRequestHeader=X-Request-Foo, Bar</li>
<li>RemoveRequestHeader 过滤器工厂 - RemoveRequestHeader=X-Request-Foo</li>
<li> SetStatus 过滤器工厂   - SetStatus=401</li>
<li> RedirectTo过滤器工厂   - RedirectTo=302, <a target="_blank" rel="noopener" href="http://baidu.com/">http://baidu.com</a></li>
<li>自定义过滤器工厂，继承 AbstractGatewayFilterFactory 类，重写 apply 方法的逻辑，命名需要以 GatewayFilterFactory 结尾</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckAuth2GatewayFilterFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractGatewayFilterFactory</span>&lt;<span class="title">CheckAuth2GatewayFilterFactory</span>.<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckAuth2GatewayFilterFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Config config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;进入了CheckAuth2GatewayFilterFactory&quot;</span> + config.getName());</span><br><span class="line">      ServerHttpRequest request = exchange.getRequest().mutate()</span><br><span class="line">      .build();</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      chain.filter(exchange.mutate().request(request).build());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CheckAuth2</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">张三</span></span><br></pre></td></tr></table></figure>

<p>如果你的配置是 Key、Value 这种形式的，那么可以不用自己定义配置类，直接继承 AbstractNameValueGatewayFilterFactory 类即可。</p>
<p>AbstractNameValueGatewayFilterFactory 类继承了 AbstractGatewayFilterFactory，定义了一个 NameValueConfig 配置类，NameValueConfig 中有 name 和 value 两个字段。</p>
<h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>全局过滤器作用于所有的路由，不需要单独配置，可以用它来实现很多统一化处理的业务需求，比如权限认证、IP 访问限制等。接口定义类 org.springframework.cloud.gateway.filter.GlobalFilter，具体代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">  <span class="function">Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有转发、路由、负载等相关的 GlobalFilter,通过 @Order 来指定执行的顺序，数字越小，优先级越高。<br><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/5-1ZR61152494J.png" alt="框架自带全局过滤器"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// IP 的访问限制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPCheckFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = exchange.getRequest().getHeaders();</span><br><span class="line">        <span class="comment">// 此处写得非常绝对, 只作演示用, 实际中需要采取配置的方式</span></span><br><span class="line">        <span class="keyword">if</span> (getIp(headers).equals(<span class="string">&quot;127.0.0.1&quot;</span>)) &#123;</span><br><span class="line">            ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">            ResponseData data = <span class="keyword">new</span> ResponseData();</span><br><span class="line">            data.setCode(<span class="number">401</span>);</span><br><span class="line">            data.setMessage(<span class="string">&quot;非法请求&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] datas = JsonUtils.toJson(data).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            DataBuffer buffer = response.bufferFactory().wrap(datas);</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里从请求头中获取用户的实际IP,根据Nginx转发的请求头获取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getIp</span><span class="params">(HttpHeaders headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gateway 的 Filter 只有 pre 和 post 两种,使用<font color="red">GatewayFilterChain</font>过滤器链，先执行所有的pre方法，再执行过滤器链，之后执行post方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GlobalFilter <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;first pre filter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;third post filter&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>Spring Cloud Gateway内置的 <font color="red">RequestRateLimiterGatewayFilterFactory</font> 提供限流的能力，基于令牌桶算法实现。目前，它内置的 <code>RedisRateLimiter</code> ，依赖Redis存储限流配置，以及统计数据。当然你也可以实现自己的RateLimiter，只需实现 <code>org.springframework.cloud.gateway.filter.ratelimit.RateLimiter</code> 接口，或者继承 <code>org.springframework.cloud.gateway.filter.ratelimit.AbstractRateLimiter</code>。</p>
<blockquote>
<p><strong>漏桶算法</strong>：流量突发问题</p>
<p>想象有一个水桶，水桶以一定的速度出水（以一定速率消费请求），当水流速度过大水会溢出（访问速率超过响应速率，就直接拒绝）。</p>
<p>漏桶算法的两个变量：</p>
<ul>
<li>水桶漏洞的大小：rate</li>
<li>最多可以存多少的水：burst</li>
</ul>
<p><strong>令牌桶算法</strong>：</p>
<p>系统按照恒定间隔向水桶里加入令牌（Token），如果桶满了的话，就不加了。每个请求来的时候，会拿走1个令牌，如果没有令牌可拿，那么就拒绝服务。</p>
<p><strong>TIPS</strong></p>
<ul>
<li>Redis Rate Limiter的实现基于这篇文章： <a target="_blank" rel="noopener" href="https://stripe.com/blog/rate-limiters">Stripe</a></li>
<li>Spring官方引用的令牌桶算法文章： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Token_bucket">Token Bucket Algorithm</a> ，有兴趣可以看看。</li>
</ul>
</blockquote>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-center</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">TimeBetween=上午0:00,下午11:59</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-Foo,</span> <span class="string">Bar</span></span><br><span class="line">            <span class="comment"># 必须是RequestRateLimiter,表示请求限流拦截器</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span> </span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="comment"># 令牌桶每秒填充平均速率(允许用户每秒处理多少个请求)</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">1</span></span><br><span class="line">                <span class="comment"># 令牌桶的上限(最大请求量)</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">2</span></span><br><span class="line">                <span class="comment"># 使用SpEL表达式从Spring容器中获取Bean对象</span></span><br><span class="line">                <span class="attr">key-resolver:</span> <span class="string">&quot;#&#123;@pathKeyResolver&#125;&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Raonfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照Path限流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">pathKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(</span><br><span class="line">            exchange.getRequest().getPath().toString()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对用户限流</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">userKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对ip限流</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">ipKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(</span><br><span class="line">            exchange.getRequest().getHeaders().getFirst(<span class="string">&quot;X-Forwarded-For&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;request_rate_limiter.&#123;localhost&#125;.timestamp&quot;</span></span><br><span class="line">2) <span class="string">&quot;request_rate_limiter.&#123;localhost&#125;.tokens&quot;</span></span><br></pre></td></tr></table></figure>

<p>大括号中就是我们的限流 Key，这里是 IP，本地的就是 localhost。</p>
<ul>
<li>timestamp：存储的是当前时间的秒数，也就是 System.currentTimeMillis()/1000 或者 Instant.now().getEpochSecond()。</li>
<li>tokens：存储的是当前这秒钟对应的可用令牌数量。</li>
</ul>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>内置了 <font color="red">HystrixGatewayFilterFactory </font>来实现路由级别的熔断，配置了一个 Hystrix 过滤器，该过滤器会使用 Hystrix 熔断与回退，原理是将请求包装成 RouteHystrixCommand 执行，RouteHystrixCommand 继承于 com.netflix.hystrix.HystrixObservableCommand。</p>
<p>fallbackUri 是发生熔断时回退的 URI 地址，目前只支持 forward 模式的 URI。如果服务被降级，该请求会被转发到该 URI 中。在网关中创建一个回退的接口，用于熔断时处理返回给调用方的信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line"><span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/user-service/**</span></span><br><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hystrix</span></span><br><span class="line"><span class="attr">args:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fallbackcmd</span></span><br><span class="line"><span class="attr">fallbackUri:</span> <span class="string">forward:/fallback</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/fallback&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fallback&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跨域实战"><a href="#跨域实战" class="headerlink" title="跨域实战"></a>跨域实战</h2><p>在 Spring Cloud Gateway 中配置跨域有两种方式，分别是代码配置方式和配置文件方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ServerWebExchange ctx, WebFilterChain chain) -&gt; &#123;</span><br><span class="line">            ServerHttpRequest request = ctx.getRequest();</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">                HttpHeaders requestHeaders = request.getHeaders();</span><br><span class="line">                ServerHttpResponse response = ctx.getResponse();</span><br><span class="line">                HttpMethod requestMethod = requestHeaders.getAccessControlRequestMethod();</span><br><span class="line">                HttpHeaders headers = response.getHeaders();</span><br><span class="line">                headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, requestHeaders.getOrigin());</span><br><span class="line">                headers.addAll(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS,</span><br><span class="line">                        requestHeaders.getAccessControlRequestHeaders());</span><br><span class="line">                <span class="keyword">if</span> (requestMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestMethod.name());</span><br><span class="line">                &#125;</span><br><span class="line">                headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (request.getMethod() == HttpMethod.OPTIONS) &#123;</span><br><span class="line">                    response.setStatusCode(HttpStatus.OK);</span><br><span class="line">                    <span class="keyword">return</span> Mono.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(ctx);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//应该使用这种</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsWebFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        config.addAllowedMethod(CorsConfiguration.ALL);</span><br><span class="line">        config.addAllowedOrigin(CorsConfiguration.ALL);</span><br><span class="line">        config.addAllowedHeader(CorsConfiguration.ALL);</span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;OPTIONS&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PATCH&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source =</span><br><span class="line">            <span class="keyword">new</span> UrlBasedCorsConfigurationSource(<span class="keyword">new</span> PathPatternParser());</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="attr">exposedHeaders:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">content-type</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">content-type</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">allowedMethods:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">OPTIONS</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">POST</span></span><br></pre></td></tr></table></figure>

<h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>网关是给接口做代理转发的，后端对应的是 REST API，返回数据格式是 JSON。如果不做处理，当发生异常时，Gateway 默认给出的错误信息是页面，不方便前端进行异常处理。所以需要对异常信息进行处理，并返回 JSON 格式的数据给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonExceptionHandler</span> <span class="keyword">extends</span> <span class="title">DefaultErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes, ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">            ErrorProperties errorProperties, ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorAttributes, resourceProperties, errorProperties, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取异常属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(ServerRequest request, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> code = <span class="number">500</span>;</span><br><span class="line">        Throwable error = <span class="keyword">super</span>.getError(request);</span><br><span class="line">        <span class="keyword">if</span> (error <span class="keyword">instanceof</span> org.springframework.cloud.gateway.support.NotFoundException) &#123;</span><br><span class="line">            code = <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response(code, <span class="keyword">this</span>.buildMessage(request, error));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定响应处理方法为JSON处理的方法， 默认返回html页面</span></span><br><span class="line"><span class="comment">     * protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(ErrorAttributes errorAttributes) &#123;</span></span><br><span class="line"><span class="comment">     *  return RouterFunctions.route(acceptsTextHtml(), this::renderErrorView).andRoute(RequestPredicates.all(),      	*  this::renderErrorResponse);</span></span><br><span class="line"><span class="comment">	 * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(RequestPredicates.all(), <span class="keyword">this</span>::renderErrorResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据code获取对应的HttpStatus，原始int statusCode = (int) errorAttributes.get(&quot;status&quot;);</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorAttributes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpStatus <span class="title">getHttpStatus</span><span class="params">(Map&lt;String, Object&gt; errorAttributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> statusCode = (<span class="keyword">int</span>) errorAttributes.get(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildMessage</span><span class="params">(ServerRequest request, Throwable ex)</span> </span>&#123;</span><br><span class="line">        StringBuilder message = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Failed to handle request [&quot;</span>);</span><br><span class="line">        message.append(request.methodName());</span><br><span class="line">        message.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        message.append(request.uri());</span><br><span class="line">        message.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            message.append(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">            message.append(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建返回的JSON数据格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status       状态码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorMessage 异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">response</span><span class="params">(<span class="keyword">int</span> status, String errorMessage)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, status);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>, errorMessage);</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; ServerProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorHandlerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerProperties serverProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorHandlerConfiguration</span><span class="params">(ServerProperties serverProperties, ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">            ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer,</span></span></span><br><span class="line"><span class="function"><span class="params">            ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverProperties = serverProperties;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">        <span class="keyword">this</span>.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);</span><br><span class="line">        <span class="keyword">this</span>.serverCodecConfigurer = serverCodecConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorWebExceptionHandler <span class="title">errorWebExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line">        JsonExceptionHandler exceptionHandler = <span class="keyword">new</span> JsonExceptionHandler(errorAttributes, </span><br><span class="line">            <span class="keyword">this</span>.resourceProperties,<span class="keyword">this</span>.serverProperties.getError(), <span class="keyword">this</span>.applicationContext);</span><br><span class="line">        exceptionHandler.setViewResolvers(<span class="keyword">this</span>.viewResolvers);</span><br><span class="line">        exceptionHandler.setMessageWriters(<span class="keyword">this</span>.serverCodecConfigurer.getWriters());</span><br><span class="line">        exceptionHandler.setMessageReaders(<span class="keyword">this</span>.serverCodecConfigurer.getReaders());</span><br><span class="line">        <span class="keyword">return</span> exceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>RetryGatewayFilter 是 Spring Cloud Gateway 对请求重试提供的一个 GatewayFilter Factory。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">zuul-encrypt-service</span></span><br><span class="line">      	 <span class="attr">uri:</span> <span class="string">lb://zuul-encrypt-service</span></span><br><span class="line">         <span class="attr">predicates:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">Path=/data/**</span></span><br><span class="line">         <span class="attr">filters:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Retry</span></span><br><span class="line">         <span class="attr">args:</span></span><br><span class="line">         <span class="attr">retries:</span> <span class="number">3</span>  <span class="comment">#重试次数，默认值是 3 次。</span></span><br><span class="line">         <span class="attr">series:</span> <span class="string">SERVER_ERROR</span> <span class="comment">#状态码配置（分段），符合某段状态码才会进行重试逻辑，默认值是 SERVER_ERROR，值是 5，也就是 5XX（5 开头的状态码）。INFORMATIONAL(1), SUCCESSFUL(2), REDIRECTION(3), CLIENT_ERROR(4), SERVER_ERROR(5);</span></span><br><span class="line">         <span class="attr">statuses:</span> <span class="comment">#状态码配置，和series不同的是这里是具体状态码的配置，取值请参考org.springframework.http.HttpStatus</span></span><br><span class="line">         	 <span class="bullet">-</span> <span class="string">NOT_FOUND</span></span><br><span class="line">             <span class="bullet">-</span> <span class="string">REQUEST_TIMEOUT</span>              </span><br><span class="line">             <span class="bullet">-</span> <span class="string">BAD_GATEWAY</span></span><br><span class="line">         <span class="attr">methods:</span> <span class="comment">#指定哪些方法的请求需要进行重试逻辑，默认值是 GET 方法</span></span><br><span class="line">         	 <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">		<span class="attr">exceptions:</span> <span class="comment">#指定哪些异常需要进行重试逻辑。默认值是java.io.IOException和 								  org.springframework.cloud.gateway.support.TimeoutException。</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">org.springframework.cloud.gateway.support.TimeoutException</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">java.io.IOException</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">java.util.concurrent.TimeoutException</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">com.netflix.hystrix.exception.HystrixRuntimeException</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring-Cloud-Gateway-工作原理"><a href="#Spring-Cloud-Gateway-工作原理" class="headerlink" title="Spring Cloud Gateway 工作原理"></a>Spring Cloud Gateway 工作原理</h2><p><img src="/2021/06/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BAPI%E7%BD%91%E5%85%B3%E4%B9%8BGateway%E8%AF%A6%E8%A7%A3/image-20210715141646667.png" alt="image-20210715141646667"><br>当客户端向 Spring Cloud Gateway 发起请求，该请求会被 HttpWebHandlerAdapter 获取，并且对请求进行提取，从而组装成网关上下文。</p>
<p>将组成的上下文信息传递到 DispatcherHandler 组件。DispatcherHandler 作为请求分发处理器，主要负责将请求分发到对应的处理器进行处理。这里请求的处理器包括 RoutePredicate HandlerMapping (路由断言处理映射器) 。</p>
<p>路由断言处理映射器用于路由的查找，以及找到 路由后返回对应的 FilteringWebHandler。 </p>
<p>其负责组装 Filter 链表并执行过滤处理，之后再将请求转交给应用服务，应用服务处理完后，最后返回 Response 给客户端 。</p>
<p>其中 FilteringWebHandler 处理请求的时候会交给 Filter 进行过滤的处理。这里需要注意的是由于 Filter 是双向的所以，当客户端请求服务的时候，会通过 Pre Filter 中的 Filter 处理请求。当服务处理完请求以后返回客户端的时候，会通过 Post Filter 再进行一次处理。 </p>
<h2 id="Gateway详解"><a href="#Gateway详解" class="headerlink" title="Gateway详解"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xs8Ls_Lgd7uigGSYG0gGBQ">Gateway详解</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Feign之加载原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-03 11:29:36" itemprop="dateCreated datePublished" datetime="2021-06-03T11:29:36+08:00">2021-06-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者： 吉姆餐厅ak</p>
<p>地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUwOTk1MTE5NQ==&mid=2247483724&idx=1&sn=03b5193f49920c1d286b56daff8b1a09&chksm=f90b2cf8ce7ca5ee6b56fb5e0ffa3176126ca3a68ba60fd8b9a3afd2fd1a2f8a201a2b765803&token=302932053&lang=zh_CN&scene=21#wechat_redirect">【Feign终极解析】</a></p>
<p><strong>概述</strong></p>
<blockquote>
<p>Feign是SpringCloud对底层通信组件封装后，暴露的一种声明式的客户端。本篇从源码角度带你过一遍装配流程，揭开feign的底层面纱。<br>主要包括feign整合ribbon，hystrix，sleuth，以及生成的代理类最终注入到spring容器的过程。篇幅略长，耐心读完，相信你会有所收获。</p>
</blockquote>
<hr>
<h2 id="Feign架构图-地址"><a href="#Feign架构图-地址" class="headerlink" title="Feign架构图 地址"></a>Feign架构图 地址</h2><p>一些核心类及大致流程：</p>
<p><img src="/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="图片"></p>
<p><strong>大体步骤：</strong><br><strong>一、注册FeignClient配置类和FeignClient BeanDefinition</strong></p>
<p><strong>二、实例化Feign上下文对象FeignContext</strong></p>
<p><strong>三、创建 Feign.builder 对象</strong> </p>
<p><strong>四、生成负载均衡代理类</strong></p>
<p><strong>五、生成默认代理类</strong> </p>
<p><strong>六、注入到spring容器</strong></p>
<hr>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>主要围绕上面六个步骤详细分析。</p>
<hr>
<h3 id="一、注册FeignClient配置类和FeignClient-BeanDefinition"><a href="#一、注册FeignClient配置类和FeignClient-BeanDefinition" class="headerlink" title="一、注册FeignClient配置类和FeignClient BeanDefinition"></a>一、注册FeignClient配置类和FeignClient BeanDefinition</h3><p>从启动类注解开始，来看下<code>@EnableFeignClients</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在启动类开启feign装配的注解，跟进该注解，看看做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patterned after Spring Integration IntegrationComponentScanRegistrar</span></span><br><span class="line">    <span class="comment">// and RibbonClientsConfigurationRegistgrar</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FeignClientsRegistrar.class);</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeignClientsRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、先注册默认配置</span></span><br><span class="line">        registerDefaultConfiguration(metadata, registry);</span><br><span class="line">        <span class="comment">//2、注册所有的feignClient beanDefinition</span></span><br><span class="line">        registerFeignClients(metadata, registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们分别来看一下上面<code>registerBeanDefinitions</code>中的两个方法：</strong><br>1） 注册默认配置方法：<code>registerDefaultConfiguration</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">            .getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">            name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// name 默认以 default 开头，后续会根据名称选择配置</span></span><br><span class="line">        registerClientConfiguration(registry, name,</span><br><span class="line">                defaultAttrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法为读取启动类上面<code>@EnableFeignClients</code>注解中声明feign相关配置类，默认name为default，一般情况下无需配置。用默认的<code>FeignAutoConfiguration</code>即可。<br>上面有个比较重要的方法：注册配置<code>registerClientConfiguration</code>，启动流程一共有两处读取feign的配置类，这是第一处。根据该方法看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object configuration)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">            .genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">    builder.addConstructorArgValue(name);</span><br><span class="line">    builder.addConstructorArgValue(configuration);</span><br><span class="line">    registry.registerBeanDefinition(</span><br><span class="line">            name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">            builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面将bean配置类包装成<code>FeignClientSpecification</code>，注入到容器。该对象非常重要，包含FeignClient需要的重试策略，超时策略，日志等配置，如果某个服务没有设置，则读取默认的配置。</p>
<p>2、扫描FeignClient</p>
<p>该方法主要是扫描类路径，对所有的FeignClient生成对应的<code>BeanDefinition</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//获取扫描目录下面所有的bean deanDefinition</span></span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">                    .findCandidateComponents(basePackage);</span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">                    AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">                    Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                            <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                            .getAnnotationAttributes(</span><br><span class="line">                                    FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">                    String name = getClientName(attributes);</span><br><span class="line">                    <span class="comment">//这里是第二处</span></span><br><span class="line">                    registerClientConfiguration(registry, name,</span><br><span class="line">                            attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//注册feignClient</span></span><br><span class="line">                    registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到上面又调用了<code>registerClientConfiguration</code>注册配置的方法，这里是第二处调用。这里主要是将扫描的目录下，每个项目的配置类加载的容器当中。</strong><br>注册到容器中，什么时候会用到呢？具体又如何使用呢？别着急，后面会有介绍。</p>
<p>我们先会回到继续主流程，继续看注册feignClient的方法，跟进<code>registerFeignClient</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        String className = annotationMetadata.getClassName();</span><br><span class="line">        <span class="comment">//声明代理类名称</span></span><br><span class="line">        BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">                .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">        <span class="comment">//logger.info(&quot;TEX do some replacement&quot;);</span></span><br><span class="line">            <span class="comment">//attributes.put(&quot;value&quot;, ((String)attributes.get(&quot;value&quot;)).replace(&#x27;_&#x27;,&#x27;-&#x27;));</span></span><br><span class="line">        validate(attributes);</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;url&quot;</span>, getUrl(attributes));</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;path&quot;</span>, getPath(attributes));</span><br><span class="line">        String name = getName(attributes);</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;type&quot;</span>, className);</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;decode404&quot;</span>, attributes.get(<span class="string">&quot;decode404&quot;</span>));</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;fallback&quot;</span>, attributes.get(<span class="string">&quot;fallback&quot;</span>));</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">        String alias = name + <span class="string">&quot;FeignClient&quot;</span>;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line">        beanDefinition.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">        BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">                <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">        <span class="comment">//将bean definition加入到spring容器</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>划重点，上面出现了一行相当关键代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class);</span><br></pre></td></tr></table></figure>

<p>springCloud FeignClient其实是利用了spring的代理工厂来生成代理类，所以这里将所有的<code>feignClient</code>的描述信息<code>BeanDefinition</code>设定为<code>FeignClientFactoryBean</code>类型，该类又继承<code>FactoryBean</code>,很明显，这是一个代理类。<br>在spring中，<code>FactoryBean</code>是一个工厂bean，用作创建代理bean，所以得出结论，feign将所有的feignClient bean包装成<code>FeignClientFactoryBean</code>。扫描方法到此结束。</p>
<p><strong>代理类什么时候会触发生成呢？ 在spring刷新容器时，当实例化我们的业务service时，如果发现注册了FeignClient，spring就会去实例化该FeignClient，同时会进行判断是否是代理bean，如果为代理bean，则调用<code>FeignClientFactoryBean</code>的<code>T getObject() throws Exception;</code>方法生成代理bean。</strong></p>
<hr>
<p><strong>先来隆重介绍一下FeignClientFactoryBean，后面四步都基于此类。</strong></p>
<p>先看一下代理feignClient代理生成入口：<code>getObject</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 二、实例化Feign上下文对象FeignContext</span></span><br><span class="line">        FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">        <span class="comment">// 三、生成builder对象，用来生成feign</span></span><br><span class="line">        Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断生成的代理对象类型，如果url为空，则走负载均衡，生成有负载均衡功能的代理类</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">            String url;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">                url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                url = <span class="keyword">this</span>.name;</span><br><span class="line">            &#125;</span><br><span class="line">            url += cleanPath();</span><br><span class="line">            <span class="comment">// 四、生成负载均衡代理类</span></span><br><span class="line">            <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">                    <span class="keyword">this</span>.name, url));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果指定了url，则生成默认的代理类</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">        &#125;</span><br><span class="line">        String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">        <span class="comment">// 五、生成默认代理类</span></span><br><span class="line">        <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">                <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>getObject()</code>逻辑比较多，每一行都会做一些初始化配置，来逐步分析。</p>
<h3 id="二、实例化Feign上下文对象FeignContext"><a href="#二、实例化Feign上下文对象FeignContext" class="headerlink" title="二、实例化Feign上下文对象FeignContext"></a>二、实例化Feign上下文对象FeignContext</h3><p>上述方法中第一行便是实例化<code>FeignContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FeignContext context = applicationContext.getBean(FeignContext.class);</span><br></pre></td></tr></table></figure>

<p>获取<code>FeignContext</code>对象，如果没有实例化，则主动实例化，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Feign.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;FeignClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HasFeatures <span class="title">feignFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">&quot;Feign&quot;</span>, Feign.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignContext <span class="title">feignContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FeignContext context = <span class="keyword">new</span> FeignContext();</span><br><span class="line">        <span class="comment">//将feign的配置类设置到feign的容器当中</span></span><br><span class="line">        context.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到feign的配置类设置到feign的容器当中，而集合中的元素 正是上面我们提到的两处调用<code>registerClientConfiguration</code>方法添加进去的，前后呼应。</p>
<p>然而，当我们引入了<code>sleuth</code>之后，获取的<code>feignContext</code>确是<code>TraceFeignClientAutoConfiguration</code>中配置的实例<code>sleuthFeignContext</code>:</p>
<p><img src="/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/FeignContext.jpg" alt="图片"></p>
<p>可以看到上面创建了一个<code>TraceFeignContext</code>实例，因为该对象继承<code>FeignContext</code>，同时又加了<code>@Primary</code>注解，所以在上面第2步中通过类型获取:<br><code>applicationContext.getBean(FeignContext.class);</code>，最终拿到的是<code>TraceFeignContext</code>。</p>
<hr>
<h3 id="三、构造FeignBuilder"><a href="#三、构造FeignBuilder" class="headerlink" title="三、构造FeignBuilder"></a>三、构造FeignBuilder</h3><p>继续跟进该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Feign.Builder builder = feign(context);</span><br><span class="line"><span class="keyword">protected</span> Feign.<span class="function">Builder <span class="title">feign</span><span class="params">(FeignContext context)</span> </span>&#123;</span><br><span class="line">        Logger logger = getOptional(context, Logger.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger = <span class="keyword">new</span> Slf4jLogger(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、构造 Feign.Builder</span></span><br><span class="line">        Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">                <span class="comment">// required values</span></span><br><span class="line">                .logger(logger)</span><br><span class="line">                .encoder(get(context, Encoder.class))</span><br><span class="line">                .decoder(get(context, Decoder.class))</span><br><span class="line">                .contract(get(context, Contract.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、设置重试策略，log等组件</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//设置log级别</span></span><br><span class="line">        Logger.Level level = getOptional(context, Logger.Level.class);</span><br><span class="line">        <span class="keyword">if</span> (level != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.logLevel(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置重试策略</span></span><br><span class="line">        Retryer retryer = getOptional(context, Retryer.class);</span><br><span class="line">        <span class="keyword">if</span> (retryer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.retryer(retryer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//feign的错误code解析接口</span></span><br><span class="line">        ErrorDecoder errorDecoder = getOptional(context, ErrorDecoder.class);</span><br><span class="line">        <span class="keyword">if</span> (errorDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.errorDecoder(errorDecoder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超时时间设置，连接超时时间：connectTimeout默认10s，请求请求超时时间：readTimeout默认60s</span></span><br><span class="line">        Request.Options options = getOptional(context, Request.Options.class);</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.options(options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拦截器设置，可以看出拦截器也是可以针对单独的feignClient设置</span></span><br><span class="line">        Map&lt;String, RequestInterceptor&gt; requestInterceptors = context.getInstances(</span><br><span class="line">                <span class="keyword">this</span>.name, RequestInterceptor.class);</span><br><span class="line">        <span class="keyword">if</span> (requestInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.requestInterceptors(requestInterceptors.values());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (decode404) &#123;</span><br><span class="line">            builder.decode404();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码有两处逻辑，分别来看：</p>
<p>1、<code>Feign.Builder builder = get(context, Feign.Builder.class)</code> ，又会有以下三种情况：</p>
<p>1）单独使用Feign，没有引入 <code>sleuth</code>、<code>hystrix</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">(Retryer retryer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Feign.builder().retryer(retryer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）引入了<code>hystrix</code>,没有引入<code>sleuth</code>:<br>通过加载<code>FeignClientsConfiguration</code>的配置创建<code>HystrixFeign</code>的静态内部类：<code>HystrixFeign.Builder</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line">    <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）同时引入<code>hystrix</code> 和 <code>sleuth</code>:<br>加载<code>TraceFeignClientAutoConfiguration</code>的配置创建：<code>HystrixFeign.Builder</code>：</p>
<p><img src="/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/HystrixFeign.Builder.jpg" alt="图片"></p>
<p>注意：</p>
<ul>
<li><p><code>TraceFeignClientAutoConfiguration</code>的配置类加载一定是在<code>FeignClientsConfiguration</code>之前（先加载先生效），而<code>FeignClientsConfiguration</code>加载是通过<code>FeignAutoConfiguration</code>完成的，所以上图中引入了条件注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureBefore(&#123;FeignAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建创建的<code>builder</code>对象和第二种情况一下，只是做了一层包装：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SleuthFeignBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SleuthFeignBuilder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Feign.<span class="function">Builder <span class="title">builder</span><span class="params">(Tracer tracer, HttpTraceKeysInjector keysInjector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HystrixFeign.builder()</span><br><span class="line">                <span class="comment">//各组件`client，retryer，decoder`进行增强，装饰器模式。</span></span><br><span class="line">                .client(<span class="keyword">new</span> TraceFeignClient(tracer, keysInjector))</span><br><span class="line">                .retryer(<span class="keyword">new</span> TraceFeignRetryer(tracer))</span><br><span class="line">                .decoder(<span class="keyword">new</span> TraceFeignDecoder(tracer))</span><br><span class="line">                .errorDecoder(<span class="keyword">new</span> TraceFeignErrorDecoder(tracer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、设置重试策略，log等组件<br>Feign.builder在获取之后又分别指定了重试策略，日志级别，错误代码code等，在上一步中调用<code>SleuthFeignBuilder.build()</code>时已经设置过默认值了，这里为什么要重复设置呢？</p>
<p>我们跟进去get()方法，一探究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(FeignContext context, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据name，也就是服务名称来生成builder</span></span><br><span class="line">    T instance = context.getInstance(<span class="keyword">this</span>.name, type);</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No bean found of type &quot;</span> + type + <span class="string">&quot; for &quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里获取AnnotationConfigApplicationContext容器</span></span><br><span class="line">    AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">            type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getBean(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">                <span class="comment">//这里创建容器createContext(name)</span></span><br><span class="line">                <span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点来了，上述代码将FeignContext做了缓存，每个服务对应一个FeignContext，服务名作为key。<br>继续跟进<code>createContext(name)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意：这里的容器并不是spring的容器，而是每次都重新创建一个</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">//加载每个服务对应的配置类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">                    .getConfiguration()) &#123;</span><br><span class="line">                context.register(configuration);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加载启动类@EnableFeignClients注解指定的配置类</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">                    context.register(configuration);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注册默认的配置类：FeignClientsConfiguration</span></span><br><span class="line">        context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line">                <span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">        context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line">                <span class="keyword">this</span>.propertySourceName,</span><br><span class="line">                Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">            context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//刷新容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上述AnnotationConfigApplicationContext容器并非spring容器，只是利用了spring刷新容器的方法来实例化配置类，以服务名作为key，配置隔离。</p>
<p><strong>重点来了，上面加载配置的顺序为：先加载每个服务的配置类，然后加载启动类注解上的配置类，最后加载默认的配置类。这样做有什么好处？ spring刷新容器的方法也是对所有的bean进行了缓存，如果已经创建，则不再实例化。所以优先选取每个FeignClient的配置类，最后默认的配置类兜底。</strong></p>
<p>所以这也证明了<code>sleuth</code>的配置一定在<code>feign</code>的配置类之前加载。<br>至此，<code>FeignBuilder</code>构造流程结束。</p>
<hr>
<h3 id="四、生成负载均衡代理类"><a href="#四、生成负载均衡代理类" class="headerlink" title="四、生成负载均衡代理类"></a>四、生成负载均衡代理类</h3><p>再贴一下生成代理类的入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断url是否为空 </span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">        <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br></pre></td></tr></table></figure>

<p>这里有个重要判断：判断FeignClient声明的url是否为空，来判断具体要生成的代理类。如下：<br>这么做有什么意义？<br>1）如果为空，则默认走Ribbon代理，也就是这个入口，会有加载ribbon的处理。<br><code>@FeignClient(&quot;MyFeignClient&quot;)</code><br>2）如果不为空，指定url，则走默认生成代理类的方式，也就是所谓的硬编码。<br><code>@FeignClient(value = &quot;MyFeignClient&quot;,url = &quot;http://localhost:8081&quot;)</code><br>这样处理方便开发人员进行测试，无需关注注册中心，直接http调用，是个不错的开发小技巧。</p>
<blockquote>
<p>生产环境也可以用上述第二种方式，指定域名的方式。</p>
</blockquote>
<p>我们跟进<code>loadBalance</code>方法：</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得FeignClient</span></span><br><span class="line">    Client client = getOptional(context, Client.class);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.client(client);</span><br><span class="line">        <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-ribbon?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Client client = getOptional(context, Client.class);</code>这里会从<code>FeignContext</code>上下文中获取<code>Client</code>对象，该对象有三种实例，具体是哪个实现呢？</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uFNav9vzn7gzOXibHkfzwkMFkb2WACcAtDssEL4PwBbMShJicYrbcTCFK6SoEbLReSkpX1ps3ibJOME2R8mC5lYIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里又会有三种情况：<br>1）没有整合<code>ribbon</code>、<code>sleuth</code>：<br>获取默认的<code>Client</code>：<code>Default</code>实例。</p>
<p>2）整合了<code>ribbon</code>,没有整合<code>sleuth</code>:<br>获取<code>LoadBalanceFeignClient</code>实例。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uFNav9vzn7gzOXibHkfzwkMFkb2WACcAt2iaJ6lJiadicjp2vYuaQiblfFuztibNBTqMVPJcvt4RKvSicl5BkibPHZO2mA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3）整合了<code>ribbon</code> 和 <code>sleuth</code>:<br>会获取<code>TraceFeignClient</code>实例，该实例是对<code>LoadBalanceFeignClient</code>的一种包装，实现方式通过<code>BeanPostProcessor</code>实现：<code>FeignBeanPostProcessor</code>中定义了包装逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.traceFeignObjectWrapper.wrap(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>wrap</code>方法最终返回<code>TraceFeignClient</code>实例。</p>
<p>继续回到主流程，先来看下<code>Targeter</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line">        &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                HardCodedTarget&lt;T&gt; target)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该对象定义在<code>FeignClientFactoryBean</code>静静态代码块中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Targeter targeter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Targeter targeterToUse;</span><br><span class="line">    <span class="comment">//判断类路径是否引入了hystrixFeign</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;feign.hystrix.HystrixFeign&quot;</span>,</span><br><span class="line">            FeignClientFactoryBean.class.getClassLoader())) &#123;</span><br><span class="line">        targeterToUse = <span class="keyword">new</span> HystrixTargeter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        targeterToUse = <span class="keyword">new</span> DefaultTargeter();</span><br><span class="line">    &#125;</span><br><span class="line">    targeter = targeterToUse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会初始化<code>Targeter</code>，该类是生成feign代理类的工具类，有两种实现，正是上面的<code>HystrixTargeter</code>,<code>DefaultTargeter</code>。<br>因为我们引入了<code>hystrix</code>，所以<code>Targeter</code>实现类为<code>HystrixTargeter</code>。我们继续跟进<code>targeter.target</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面通过<code>build()</code>方法获取生成代理类的工具类<code>ReflectiveFeign</code>，再通过<code>newInstance</code>正式创建代理类。<br>继续跟进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">      <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                           logLevel, decode404);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">      <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder,</span><br><span class="line">                              errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会创建Feign的方法工厂<code>synchronousMethodHandlerFactory</code>,<code>Feign</code>通过该工厂为每个方法创建一个<code>methodHandler</code>，每个<code>methodHandler</code>中包含Feign对应的配置：<code>retryer</code>、<code>requestInterceptors</code>等。</p>
<p>继续跟进<code>newInstance</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建所有的 MethodHandler</span></span><br><span class="line">   Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">   Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">   List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">     <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//判断是否启用默认handler</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">       DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">       defaultMethodHandlers.add(handler);</span><br><span class="line">       methodToHandler.put(method, handler);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建InvocationHandler，接收请求，转发到methodHandler</span></span><br><span class="line">   InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">   <span class="comment">//生成代理类</span></span><br><span class="line">   T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将默认方法绑定到代理类</span></span><br><span class="line">   <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">     defaultMethodHandler.bindTo(proxy);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> proxy;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>InvocationHandler</code>最终创建的实例为<code>HystrixInvocationHandler</code>，核心方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(setter) &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> HystrixInvocationHandler.<span class="keyword">this</span>.dispatch.get(method).invoke(args);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (Error) t;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>整个流程：Feign调用方发起请求，发送至hystrix的HystrixInvocationHandler，通过服务名称，找到对应方法的methodHandler，methodHandler中封装了loadBalanceClient、retryer、RequestInterceptor等组件，如果引入了sleuth,这几个组件均是sleuth的包装类。然后通过以上组件构造<code>http</code>请求完成整个过程。</p>
<hr>
<h3 id="五、生成默认代理类"><a href="#五、生成默认代理类" class="headerlink" title="五、生成默认代理类"></a>五、生成默认代理类</h3><p>理解了第四步的逻辑，生成默认代理类就很容易理解了，唯一不同点就是<code>client</code>的实现类为<code>loadBalanceClient</code>。</p>
<blockquote>
<p>注意：不管是哪种代理类，最终发起请求还是由<code>Feign.Default</code>中的<code>execute</code>方法完成，默认使用<code>HttpUrlConnection</code>实现。</p>
</blockquote>
<hr>
<h3 id="六、注入spring容器"><a href="#六、注入spring容器" class="headerlink" title="六、注入spring容器"></a>六、注入spring容器</h3><p>总结：通过<code>spring refresh()</code>方法，触发<code>FeignClientFactoryBean.getObject()</code>方法获得了代理类，然后完成注入<code>spring</code>容器的过程。该实现方式同<code>Dubbo</code>的实现方式类似，有兴趣的可以自行研究噢。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/02/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">性能相关知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 10:39:08" itemprop="dateCreated datePublished" datetime="2021-06-02T10:39:08+08:00">2021-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="如何获取VU和TPS"><a href="#如何获取VU和TPS" class="headerlink" title="如何获取VU和TPS"></a>如何获取VU和TPS</h2><ul>
<li><p>VU获取方式：</p>
<p>已有系统：可选取高峰时刻，在一定时间内使用系统的人数，这些人数可认为是在线用户数，并发用户数可以取10%，例如在半个小时内，使用系统的用户数为10万，那么取10%（即1万）作为并发用户数基本就够了。</p>
<p>新系统：没有历史数据作参考，建议通过业务部门进行评估。</p>
</li>
<li><p>TPS获取方式：</p>
<p>已有系统：可选取高峰时刻，在一定时间内（如3分钟<del>10分钟），获取系统总业务量，计算单位时间（秒）内完成的笔数，乘以2</del>5倍作为峰值的TPS，例如峰值3分钟内处理订单18万笔，平均TPS是1000，峰值TPS可以是2000~5000。</p>
<p>新系统：没有历史数据作参考，建议通过业务部门进行评估。</p>
</li>
</ul>
<h2 id="如何评价系统的性能"><a href="#如何评价系统的性能" class="headerlink" title="如何评价系统的性能"></a>如何评价系统的性能</h2><p>针对服务器端的性能，以TPS为主来衡量系统的性能，并发用户数为辅来衡量系统的性能，如果必须要用并发用户数来衡量的话，需要一个前提，那就是交易在多长时间内完成，因为在系统负载不高的情况下，将思考时间（思考时间的值等于交易响应时间）加到串联链路中，并发用户数基本可以增加一倍，因此用并发用户数来衡量系统的性能没太大的意义。同样的，如果系统间的吞吐能力差别很大，那么同样的并发下TPS差距也会很大。</p>
<ul>
<li>系统的性能由TPS决定，跟并发用户数没有多大关系。</li>
<li>系统的最大TPS是一定的（在一个范围内），但并发用户数不一定，可以调整。</li>
<li>建议性能测试的时候，不要设置过长的思考时间，以最坏的情况下对服务器施压。</li>
<li>一般情况下，大型系统（业务量大、机器多）做压力测试，10000~50000个用户并发，中小型系统做压力测试，5000个用户并发比较常见。</li>
</ul>
<h2 id="软件性能的关注点"><a href="#软件性能的关注点" class="headerlink" title="软件性能的关注点"></a>软件性能的关注点</h2><p>用户关注的是用户操作的相应时间。</p>
<p><strong>管理员的角度考虑</strong></p>
<p>1、 响应时间<br>2、 服务器资源使用情况是否合理<br>3、 应用服务器和数据库资源使用是否合理<br>4、 系统能否实现扩展<br>5、 系统最多支持多少用户访问、系统最大业务处理量是多少<br>6、 系统性能可能存在的瓶颈在哪里<br>7、 更换那些设备可以提高性能<br>8、 系统能否支持7×24小时的业务访问</p>
<p><strong>开发（设计）人员角度考虑</strong></p>
<p>1、 架构设计是否合理<br>2、 数据库设计是否合理<br>3、 代码是否存在性能方面的问题<br>4、 系统中是否有不合理的内存使用方式<br>5、 系统中是否存在不合理的线程同步方式<br>6、 系统中是否存在不合理的资源竞争</p>
<h2 id="容量规划步骤"><a href="#容量规划步骤" class="headerlink" title="容量规划步骤"></a>容量规划步骤</h2><h3 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h3><p>一般每个服务都有对外承诺的服务质量，那么我们就需要根据这个目标来做容量规划及硬件方面的投入。</p>
<p>比如 A 网站能承受 3000 QPS，响应时间小于 200 ms。SLA（服务等级协议）</p>
<h3 id="收集指标"><a href="#收集指标" class="headerlink" title="收集指标"></a>收集指标</h3><p>我们需要通过测试来了解当前服务的数据指标。没有测试出你的服务上限的话，规划出来也是没有效果的。</p>
<p>测试主要分为下面 2 个步骤</p>
<ul>
<li>测试服务器的主要功能 ：业务维度 QPS、TPS</li>
<li>测试服务器硬件资源 ： CPU、内存、硬盘、网络</li>
</ul>
<h3 id="趋势预测"><a href="#趋势预测" class="headerlink" title="趋势预测"></a>趋势预测</h3><p>整体过程如下</p>
<ul>
<li>首先确定资源度量指标 ：比如内存消耗、硬盘消耗、CPU 消耗</li>
<li>其实对拥有的资源确定约束访问 : 比如 总内存大小、总硬盘大小等</li>
<li>最后根据监控趋势图（ Zabbix 、Metrics）算出具体容量超出时间点 ： 比如内存何时会耗尽</li>
</ul>
<h3 id="容量部署"><a href="#容量部署" class="headerlink" title="容量部署"></a>容量部署</h3><p>一旦确定未来需要多少容量才能满足业务需求，就可以着手新的设备，并进行部署。</p>
<p>通过自动化部署工具（ Ansible、 Salt ） 最大限度的减少部署时间</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/19/%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/19/%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">重点理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-19 15:25:52" itemprop="dateCreated datePublished" datetime="2021-05-19T15:25:52+08:00">2021-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="运行时区域"><a href="#运行时区域" class="headerlink" title="运行时区域"></a>运行时区域</h3><ul>
<li><strong>程序计数器</strong>是jvm执行程序的流水线，存放一些跳转指令。</li>
<li><strong>本地方法栈</strong>是jvm调用操作系统方法所使用的栈。</li>
<li><strong>虚拟机栈</strong>是jvm执行java代码所使用的栈。</li>
<li><strong>方法区</strong>存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</li>
<li><strong>虚拟机堆</strong>是jvm执行java代码所使用的堆。<h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3></li>
<li>方法区中类静态属性引用的对象（static声明的引用类型字段）</li>
<li>方法区中常量引用的对象（final声明的引用类型字段）</li>
<li>栈中引用的对象</li>
<li>本地方法栈中引用的对象<h3 id="方法区（永久代）包含哪些内容"><a href="#方法区（永久代）包含哪些内容" class="headerlink" title="方法区（永久代）包含哪些内容"></a>方法区（永久代）包含哪些内容</h3></li>
<li>运行时常量池</li>
<li>字段和方法数据</li>
<li>构造函数和普通方法的字节码内容</li>
<li>一些特殊方法</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/aaqian1/article/details/113771134">方法区中一个模块：静态区，用于存放静态变量和静态代码块，JDK1.7开始类的静态变量(class statics)转移到了java heap</a><h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3>在JDK1.8中，使用元空间代替永久代来实现方法区，但是方法区并没有改变。变动的只是方法区中内容的物理存放位置。<font color="red">类型信息（元数据信息）等其他信息被移动到了元空间中；但是运行时常量池和字符串常量池被移动到了堆中。但是不论它们物理上如何存放，逻辑上还是属于方法区的。</font></li>
</ul>
<p>使用本地内存，不在虚拟机中。默认仅受本地内存限制。测试可以使用String类型的intern()方法，</p>
<p>运行时常量池（字面量），JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中。</p>
<blockquote>
<p>JDK1.7中永久代逻辑属于方法区，实际物理上还是放在堆区内，所以方法区内的运行时常量池、类信息都在堆内</p>
<p>JDK1.8中方法区实现改成了元空间，直接放到了直接内存，但是运行时常量池物理上还是在堆区，虽然物理存放的地方变了，逻辑上看元空间、运行时常量池还是属于方法区</p>
</blockquote>
<h3 id="为什么移除永久代"><a href="#为什么移除永久代" class="headerlink" title="为什么移除永久代"></a>为什么移除永久代</h3><ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
<li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul>
<li>静态常量池（*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间）<br>主要用于存放两大类常量：<strong>字面量</strong>(Literal)和<strong>符号引用量</strong>(Symbolic References)</li>
<li>运行时常量池（jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在<strong>方法区</strong>中，常说的常量池，就是指方法区中的运行时常量池。）</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zm13007310400/article/details/77534349?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">常量池</a></li>
</ul>
<h3 id="字面量-Literal"><a href="#字面量-Literal" class="headerlink" title="字面量(Literal)"></a><strong>字面量</strong>(Literal)</h3><p>相当于Java语言层面常量的概念，如1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等</p>
<h3 id="符号引用量-Symbolic-References"><a href="#符号引用量-Symbolic-References" class="headerlink" title="符号引用量(Symbolic References)"></a><strong>符号引用量</strong>(Symbolic References)</h3><p>符号引用则属于编译原理方面的概念，包括了如下三种类型的常量</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段名称和描述符</li>
<li>方法名称和描述符</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是<strong>具备动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String类的intern()**方法。</p>
<p>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p>
<p>运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用</p>
<p>JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。</p>
<h3 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a><strong>常量池的好处</strong></h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。<br>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><ul>
<li><p>修饰方法时（字节码文件方法使用flags: ACC_SYNCHRONIZED）</p>
</li>
<li><p>修饰对象时（字节码文件中使用monitorenter，monitorexit）</p>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>无锁</li>
<li>偏向锁（当有一个线程使用时，使用cas由无锁升级为偏向锁）</li>
<li>轻量级锁（当再有线程使用时，使用cas由偏向锁升级为轻量级锁）</li>
<li>重量级锁（操作系统的互斥锁，此时先进行自旋，之后再升级为重量级锁）</li>
</ul>
<h3 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h3><p>对象由对象头、数据实例、对齐填充组成</p>
<p>对象头由markword、类型指针、数组长度组成</p>
<p>markword组成是核心：是否偏向锁标识位，锁类型标识位</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul>
<li>锁粗化</li>
<li>锁消除</li>
<li>自适应自旋</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><code>RabbitMQ</code>延时队列问题：当过期时间不一致时，前面过期时间长的数据会堵塞后面过期时间短的数据-》可以使用延时插件，解决。<br>目前采用的是定时任务处理的方式，时效性要求不是那么高，可以通过减少任务执行间隔时间，减少延时。<br>当数据量大时 1）可以使用任务分片 2）多线程处理</p>
<h2 id="EMQ"><a href="#EMQ" class="headerlink" title="EMQ"></a>EMQ</h2><p>企业级：千万级并发连接，百万级消息吞吐，毫秒级消息时延。大规模分布式，高可用集群架构，弹性伸缩部署，5G 时代大型物联网应用首选技术方案。企业版支持通过规则引擎，无需编写代码即可以将消息持久化到各类型数据库中，如 MySQL、PostgreSQL、InfluxDB、ClickHouse 等。也可以通过规则配置，将消息流转至其他消息服务器，如 Kafka、RabbitMQ、Pulsar 等。</p>
<p>开源版本：支持分布式集群架构。EMQ X 3.0 单集群可支持千万级别的 MQTT 并发连接。</p>
<ol>
<li>稳定承载大规模的 MQTT 客户端连接，单服务器节点支持50万到100万连接。</li>
<li>分布式节点集群，快速低延时的消息路由，单集群支持1000万规模的路由。</li>
<li>消息服务器内扩展，支持定制多种认证方式、高效存储消息到后端数据库。</li>
<li>完整物联网协议支持，MQTT、MQTT-SN、CoAP、LwM2M、WebSocket 或私有协议支持。</li>
</ol>
<h2 id="获取数据方式"><a href="#获取数据方式" class="headerlink" title="获取数据方式"></a>获取数据方式</h2><ul>
<li>轮询（减少时间间隔，减少延时）</li>
<li>长连接（减少连接，一直持有连接）</li>
<li>长轮询（一次请求，比如连接时间为30s，前25s等待数据响应，最后5s）</li>
</ul>
<h2 id="Feign实战"><a href="#Feign实战" class="headerlink" title="Feign实战"></a>Feign实战</h2><h3 id="启动扫描"><a href="#启动扫描" class="headerlink" title="启动扫描"></a>启动扫描</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &#123;&quot;com.hf&quot;&#125;)</span>   <span class="comment">//可以配置configuration</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Feign客户端"><a href="#配置Feign客户端" class="headerlink" title="配置Feign客户端"></a>配置Feign客户端</h3><ul>
<li>name:注册的服务名</li>
<li>configuration：配置信息，可以@Bean，</li>
<li><code>fallback</code>：降级返回,实现接口类，可以对每个方法进行返回，并需注入到Spring中，</li>
<li><code>fallbackFactory</code>: 降级工厂。可以返回匿名内部类的对象，对方法进行个性化返回，也可以设置成默认返回对象，如JsonResult。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;order-service&quot; configuration = SSOFeignConfig.class, fallbackFactory = OAuthTokenClientFallBackFactory.class,fallback=xxx.class)</span></span><br></pre></td></tr></table></figure>

<h4 id="fallback和fallbackFactory区别"><a href="#fallback和fallbackFactory区别" class="headerlink" title="fallback和fallbackFactory区别"></a><code>fallback</code>和<code>fallbackFactory</code>区别</h4><p>1）<code>fallbackFactory</code>可捕获到<code>Throwable throwable</code>对象，此处异常是Feign包装后的异常，如要抛出未封装的异常，可以使用<code>ErrorDecoder</code>返回异常<br>2）<code>fallbackFactory</code>可返回共用降级返回值</p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>可以给请求增加些共用的参数，如：传递<code>traceId</code>，传递Authorization=Basic xxxssasefwxxa，传递token，可以通过拦截器拦截请求，将GET请求且body不为空的情况，转换成body参数放在url后</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestInterceptor#apply(RequestTemplate template)</span><br></pre></td></tr></table></figure>

<h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>Encoder  -》new SpringFormEncoder(new SpringEncoder(messageConverters));</p>
<h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>Decoder  -》SpringDecoder</p>
<h3 id="统一异常处理器"><a href="#统一异常处理器" class="headerlink" title="统一异常处理器"></a>统一异常处理器</h3><p><strong>默认情况下,GET方式请求无论是连接异常还是读取异常,都会进行重试</strong>。<strong>非GET方式请求,只有连接异常时,才会进行重试</strong></p>
<p>当请求之后，返回的status不为200的时候，通过response.body()获取返回的数据，之后可以返回一个统一的异常。方法的返回值是Exception对象</p>
<p>当出现异常时不处理，使用<code>HystrixBadRequestException</code>异常，此时就不会走降级处理（不走fallback或fallbackFactory逻辑）。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ErrorDecoder#decode(String s,Response response)</span><br></pre></td></tr></table></figure>

<h3 id="Feign配置"><a href="#Feign配置" class="headerlink" title="Feign配置"></a>Feign配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">logger-level:</span> <span class="string">basic</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">2048</span> <span class="comment">#最小压缩文件，调大点，可以减少CPU压力</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color="red">配置超时时间，但是它的配置会被Ribbon和Hystrix的超时时间所覆盖，配置Feign超时时间即是否开启重试和Hystrix </font></p>
</blockquote>
<h2 id="Fegin集成Hystrix和Ribbon原理"><a href="#Fegin集成Hystrix和Ribbon原理" class="headerlink" title="Fegin集成Hystrix和Ribbon原理"></a>Fegin集成Hystrix和Ribbon原理</h2><p>扫描FeignClient注解的包下的类，注册FeignClientFactoryBean，getObject获取代理对象，通过注入的Targeter，生成代理对象。http请求调用时，会走<font color="red">HystrixInvocationHandler</font>里的invoke方法，实现了InvocationHandler类，使用的是jdk的动态代理。<br>构建了HystrixCommand对象<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/songhaifengshuaige/article/details/80489460">Feign集成Hystrix源码分析以及扩展</a></p>
<p>Ribbon</p>
<p>Hystrix</p>
<p>Nacos</p>
<p>Zookeeper  -&gt; </p>
<p>Redis  -&gt;  Redisson</p>
<p>ES   -&gt; high-level  low-level</p>
<p>Kafka  -&gt;</p>
<h2 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h2><p><a target="_blank" rel="noopener" href="https://github.com/youngperson/blog/issues/41">全链路压测相关知识点</a><br><a target="_blank" rel="noopener" href="https://tech.youzan.com/stress_testing/">有赞全链路压测</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30511486?from=timeline&isappinstalled=0">饿了么全链路压测平台的实现与原理</a><br><a target="_blank" rel="noopener" href="https://my.oschina.net/cctester/blog/994727">阿里巴巴的全链路压测</a><br><a target="_blank" rel="noopener" href="https://github.com/yonyou-auto-dev/TITAN">开源压测系统</a></p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h3><p>第一范式：每一列原子不可再分<br>第二范式：满足第一范式，每一列与主键都相关，没有部分依赖<br>第三范式：满足第二范式，每一列与主键直接相关，不能间接相关，没有传递依赖</p>
<p>范式的目的在于：</p>
<ul>
<li>减少冗余，冗余会带来存储空间增加</li>
<li>减少异常（delete，update，insert），如果数据冗余之后，修改时需要也更新，否则会导致数据异常</li>
<li>让数据组织的更加和谐（使结构更清晰，但是对于人操作更麻烦）</li>
</ul>
<p>反范式：核心是增加冗余而提高性能</p>
<p>范式等级与复杂度是递进的。通过范式的不断升级，我们会发现应用的范式等级越高，则表越多。表多会带来很多问题：</p>
<ul>
<li>查询时要连接多个表，增加了查询的复杂度</li>
<li>查询时需要连接多个表，降低了数据库查询性能</li>
</ul>
<p>而现在的情况，磁盘空间成本基本可以忽略不计，所以数据冗余所造成的问题也并不是应用数据库范式的理由。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li>读未提交</li>
<li>读已提交</li>
<li>可重复读</li>
<li>串行化</li>
</ul>
<h3 id="脏读、不可重复读（MVCC）、幻读（Next-Key-lock）"><a href="#脏读、不可重复读（MVCC）、幻读（Next-Key-lock）" class="headerlink" title="脏读、不可重复读（MVCC）、幻读（Next-Key lock）"></a>脏读、不可重复读（MVCC）、幻读（Next-Key lock）</h3><h3 id="MVCC实现"><a href="#MVCC实现" class="headerlink" title="MVCC实现"></a><code>MVCC</code>实现</h3><p>借助Redo log实现MVCC多版本控制，表中数据含有三个隐藏字段：事务id，回滚指针，自增id</p>
<h3 id="快照读、当前读"><a href="#快照读、当前读" class="headerlink" title="快照读、当前读"></a>快照读、当前读</h3><ul>
<li>快照读：普通的查询</li>
<li>当前读：insert、update、delete 、select *** for update 排它锁、select * form t lock in share mode 共享锁</li>
</ul>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><ul>
<li><p>表锁</p>
</li>
<li><p>行锁 （通过索引项加锁）</p>
</li>
<li><p>间隙锁（锁住间隙）</p>
</li>
<li><p>Next-Key lock （间隙锁+行锁）</p>
</li>
<li><p>意向锁：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。</p>
</li>
</ul>
<p>①在mysql中有表锁，<br>  LOCK TABLE my_tabl_name READ; 用读锁锁表，会阻塞其他事务修改表数据。<br>  LOCK TABLE my_table_name WRITe; 用写锁锁表，会阻塞其他事务读和写。<br>②Innodb引擎又支持行锁，行锁分为<br>  共享锁，一个事务对一行的共享只读锁。<br>  排它锁，一个事务对一行的排他读写锁。<br>③意向锁的作用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36748650/article/details/88033383">mysql锁的作用</a></p>
<h3 id="Bin-log"><a href="#Bin-log" class="headerlink" title="Bin log"></a>Bin log</h3><p><strong>三种数据格式</strong></p>
<ul>
<li><strong>statement</strong> 执行的SQL语句</li>
<li><strong>row</strong>  存放的数据是改变之前和之后的数据，因此日志量较大。</li>
<li><strong>mix</strong>  混合</li>
</ul>
<p><strong>日志刷盘参数</strong>：sync_binlog 值为0，1，N。0不fsync刷盘，1执行fsync刷盘，N表示N次事务提交，进行fsync刷盘</p>
<p><strong>日志逻辑</strong>：log buffer  -》 os cache  -》 磁盘 </p>
<p>Server层日志，跟Redo log结合使用，crashSafe能力，使用的二阶段提交的方式保证数据一致性</p>
<h3 id="Redo-log和Undo-log"><a href="#Redo-log和Undo-log" class="headerlink" title="Redo log和Undo log"></a>Redo log和Undo log</h3><ul>
<li>Redo log灾难恢复日志，</li>
<li>Undo log回滚日志</li>
</ul>
<p>Redo log刷盘参数：</p>
<h3 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h3><p>从库开启一个I/O线程，向主库请求<strong>Binlog</strong>日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到<strong>中继日志（Relay log）</strong>中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</p>
<h3 id="半同步复制和异步复制"><a href="#半同步复制和异步复制" class="headerlink" title="半同步复制和异步复制"></a>半同步复制和异步复制</h3><ul>
<li>异步复制：<strong>主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能会造成数据的不一致。</strong>主库提交一个事务并写入到Binlog，当日志还未传入从库时，主库宕机了或因磁盘损坏等故障导致该事务的Binlog丢失了，那从库就不会得到这个事务，也就造成了主从数据的不一致</li>
<li>半同步复制: 当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，所以这样就保证了一个事务至少有两份日志，一份保存在主库的Binlog，另一份保存在其中一个从库的Relay-log中，从而保证了数据的安全性和一致性。</li>
</ul>
<blockquote>
<p>在半同步复制时，如果主库的一个事务提交成功了，在推送到从库的过程当中，从库宕机了或网络故障，导致从库并没有接收到这个事务的Binlog，此时主库会等待一段时间（这个时间由rpl_semi_sync_master_timeout的毫秒数决定），如果这个时间过后还无法推送到从库，那MySQL会自动从半同步复制切换为异步复制，当从库恢复正常连接到主库后，主库又会自动切换回半同步复制。</p>
</blockquote>
<p>复制架构</p>
<ul>
<li>一主多从模式：当从节点变多之后，每个从库在主库上都会有一个独立的Binlog Dump线程来推送binlog日志，所以随着从库数量的增加，主库的IO压力和网络压力也会随之增加。</li>
<li>多级复制模式：主从直接，增加一个中间节点，由中间节点，进行数据同步，<strong>以此来减轻一级主库的推送压力。</strong>经过两次复制才能到达从库，增加了复制的延时。</li>
<li>双主模式：主从切换场景，可以理解为高可用。当数据未同步时，主挂了之后，从作为主节点。当从节点恢复时，二个节点数据已不一致，此时数据复制，保证数据一致。</li>
</ul>
<h3 id="MySQL相关文章"><a href="#MySQL相关文章" class="headerlink" title="MySQL相关文章"></a>MySQL相关文章</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/keil_wang/article/details/88669587">https://blog.csdn.net/keil_wang/article/details/88669587</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mao3714/p/8734838.html">https://www.cnblogs.com/mao3714/p/8734838.html</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.itpub.net/22664653/viewspace-1063134/">http://blog.itpub.net/22664653/viewspace-1063134/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010833547/article/details/109293213">https://blog.csdn.net/u010833547/article/details/109293213</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/klvchen/p/10861850.html">https://www.cnblogs.com/klvchen/p/10861850.html</a><br><a target="_blank" rel="noopener" href="https://www.xz577.com/j/22908.html">https://www.xz577.com/j/22908.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45701550/article/details/111145914">https://blog.csdn.net/weixin_45701550/article/details/111145914</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42512836/article/details/113388876">https://blog.csdn.net/weixin_42512836/article/details/113388876</a><br><a target="_blank" rel="noopener" href="https://cxyroad.blog.csdn.net/article/details/103790555">https://cxyroad.blog.csdn.net/article/details/103790555</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/z69183787/article/details/107188434">https://blog.csdn.net/z69183787/article/details/107188434</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c53c8ab650b5">https://www.jianshu.com/p/c53c8ab650b5</a></p>
<h2 id="Binlog同步（Canal）"><a href="#Binlog同步（Canal）" class="headerlink" title="Binlog同步（Canal）"></a>Binlog同步（Canal）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yehongzhi1994/article/details/107880162">Canal入门</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yehongzhi1994/article/details/108034330">Canal集成Kafka到Redis</a><br>消息顺序问题：MySQL的Binlog保证了顺序性，因此只需要使到达MQ的数据能保证顺序性即可。Kafka可以指定Partition或者Key<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fomeiherz/article/details/103054693">Canal高可用集群搭建</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/caoweixiong/p/13303862.html">Canal集群实战</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fcly2013/article/details/79430484">Canal原理及问题点</a></p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h2 id="多线程作用"><a href="#多线程作用" class="headerlink" title="多线程作用"></a>多线程作用</h2><p>接口归并处理     -》（多个查询互相不影响）<br>大数据量分段处理 -》（大任务拆成小任务）</p>
<p>并发：单核CPU并发交替处理<br>并行：多核CPU并行处理</p>
<h2 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lijing742180/article/details/81158008">https://blog.csdn.net/lijing742180/article/details/81158008</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LZHOO97/p/12689089.html">https://www.cnblogs.com/LZHOO97/p/12689089.html</a><br><a target="_blank" rel="noopener" href="https://testerhome.com/topics/26890">https://testerhome.com/topics/26890</a><br><a target="_blank" rel="noopener" href="https://testerhome.com/articles/20770">https://testerhome.com/articles/20770</a><br><a target="_blank" rel="noopener" href="https://my.oschina.net/u/3519247/blog/4448724">https://my.oschina.net/u/3519247/blog/4448724</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/imyalost/p/7733386.html">https://www.cnblogs.com/imyalost/p/7733386.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/imyalost/p/7751981.html">https://www.cnblogs.com/imyalost/p/7751981.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/paulwinflo/p/4872018.html">https://www.cnblogs.com/paulwinflo/p/4872018.html</a></p>
<p>面试突击第一季 第二季<br>面试突击系列课程笔记存放在儒猿技术窝官方码云仓库<br>链接：<a target="_blank" rel="noopener" href="https://gitee.com/shishan100/Java-Interview-Advanced">https://gitee.com/shishan100/Java-Interview-Advanced</a><br>烦请随手给一个star</p>
<p>面试突击 第三季笔记：<br>有的笔记就是跟那一讲的视频放在一起的，有的笔记是发在公众号石杉的架构笔记的，会在那一讲视频对应的笔记里说明、<br>（ 每一节课程详情点击进去，然后点击“详情” 这个tab 。往下拉，下面就是笔记了）</p>
<p>面试突击三，java高级部分资料地址<br><a target="_blank" rel="noopener" href="https://www.jianguoyun.com/p/DfTsrhgQwe6LCRjondUD">https://www.jianguoyun.com/p/DfTsrhgQwe6LCRjondUD</a></p>
<h2 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;match **&gt;</span><br><span class="line">   @type elasticsearch</span><br><span class="line">   @log_level &quot;info&quot;</span><br><span class="line">   include_tag_key true</span><br><span class="line">   hosts &quot;http:&#x2F;&#x2F;10.16.32.197:9200,http:&#x2F;&#x2F;10.16.33.39:9200,http:&#x2F;&#x2F;10.16.33.215:9200&quot;</span><br><span class="line">   logstash_format true</span><br><span class="line">   logstash_prefix &quot;order-center-prod&quot;</span><br><span class="line">   logstash_dateformat &quot;%Y.%m.%d&quot;</span><br><span class="line">   type_name &quot;fluentd&quot;</span><br><span class="line">   &lt;buffer&gt;</span><br><span class="line">     @type &quot;file&quot;</span><br><span class="line">     path &quot;&#x2F;var&#x2F;log&#x2F;fluentd-buffers&#x2F;*.buffer&quot;</span><br><span class="line">     flush_mode interval</span><br><span class="line">     retry_type exponential_backoff</span><br><span class="line">     flush_thread_count 2</span><br><span class="line">     flush_interval 5s</span><br><span class="line">     retry_forever </span><br><span class="line">     retry_max_interval 30</span><br><span class="line">     chunk_limit_size 2M</span><br><span class="line">     queue_limit_length 8</span><br><span class="line">     overflow_action block</span><br><span class="line">   &lt;&#x2F;buffer&gt;</span><br><span class="line"> &lt;&#x2F;match&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
