<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Feign之详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-25 18:14:02" itemprop="dateCreated datePublished" datetime="2021-04-25T18:14:02+08:00">2021-04-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/6271376-285b0cf66bc1b24c.png" alt="img"></p>
<h2 id="1、Feign介绍"><a href="#1、Feign介绍" class="headerlink" title="1、Feign介绍"></a>1、Feign介绍</h2><p>Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求。Spring Cloud引入 Feign并且集成了Ribbon实现客户端负载均衡调用。</p>
<h4 id="Feign解决了什么问题？"><a href="#Feign解决了什么问题？" class="headerlink" title="Feign解决了什么问题？"></a>Feign解决了什么问题？</h4><p>封装了Http调用流程，更适合面向接口化的变成习惯</p>
<h2 id="2、Feign工作原理"><a href="#2、Feign工作原理" class="headerlink" title="2、Feign工作原理"></a>2、Feign工作原理</h2><h4 id="Feign远程调用流程图"><a href="#Feign远程调用流程图" class="headerlink" title="Feign远程调用流程图"></a>Feign远程调用流程图</h4><p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/6271376-7635e2dc9b32e3ec.png" alt="img"></p>
<h4 id="1-基于面向接口的动态代理方式生成实现类"><a href="#1-基于面向接口的动态代理方式生成实现类" class="headerlink" title="(1) 基于面向接口的动态代理方式生成实现类"></a>(1) 基于面向接口的动态代理方式生成实现类</h4><p>在使用feign 时，会定义对应的接口类，在接口类上使用Http相关的注解，标识HTTP请求参数信息</p>
<p>在Feign 底层，通过基于面向接口的动态代理方式生成实现类，将请求调用委托到动态代理实现类，基本原理如下所示：</p>
<p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/14126519-4949493085b0f547.png" alt="img"></p>
<h4 id="2-根据Contract协议规则，解析接口类的注解信息，解析成内部表现："><a href="#2-根据Contract协议规则，解析接口类的注解信息，解析成内部表现：" class="headerlink" title="(2) 根据Contract协议规则，解析接口类的注解信息，解析成内部表现："></a>(2) 根据Contract协议规则，解析接口类的注解信息，解析成内部表现：</h4><p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/6271376-cebfed0fa4f18190.png" alt="img"></p>
<h4 id="3-基于-RequestBean，动态生成Request"><a href="#3-基于-RequestBean，动态生成Request" class="headerlink" title="(3) 基于 RequestBean，动态生成Request"></a>(3) 基于 RequestBean，动态生成Request</h4><p>根据传入的Bean对象和注解信息，从中提取出相应的值，来构造Http Request 对象</p>
<h4 id="4-使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）"><a href="#4-使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）" class="headerlink" title="(4) 使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）"></a>(4) 使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）</h4><p>Feign 最终会将请求转换成Http 消息发送出去，传入的请求对象最终会解析成消息体，如下所示：</p>
<p><img src="/2021/04/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BFeign%E4%B9%8B%E8%AF%A6%E8%A7%A3/14126519-b5c571b44f453707.png" alt="img"></p>
<h4 id="5-拦截器负责对请求和返回进行装饰处理"><a href="#5-拦截器负责对请求和返回进行装饰处理" class="headerlink" title="(5) 拦截器负责对请求和返回进行装饰处理"></a>(5) 拦截器负责对请求和返回进行装饰处理</h4><p>在请求转换的过程中，Feign 抽象出来了拦截器接口，用于用户自定义对请求的操作，比如，如果希望Http消息传递过程中被压缩，可以定义一个请求拦截器。</p>
<h4 id="6-日志记录"><a href="#6-日志记录" class="headerlink" title="(6) 日志记录"></a>(6) 日志记录</h4><h4 id="7-基于重试器发送HTTP请求"><a href="#7-基于重试器发送HTTP请求" class="headerlink" title="(7) 基于重试器发送HTTP请求"></a>(7) 基于重试器发送HTTP请求</h4><p>Feign 内置了一个重试器，当HTTP请求出现IO异常时，Feign会有一个最大尝试次数发送请求</p>
<h4 id="8-发送Http请求"><a href="#8-发送Http请求" class="headerlink" title="(8) 发送Http请求"></a>(8) 发送Http请求</h4><p>Feign 真正发送HTTP请求是委托给 feign.Client 来做的。</p>
<p>Feign 默认底层通过JDK 的 java.net.HttpURLConnection 实现了feign.Client接口类,<strong>在每次发送请求的时候，都会创建新的HttpURLConnection 链接</strong>，这也就是为什么默认情况下Feign的性能很差的原因。可以通过拓展该接口，使用Apache HttpClient 或者OkHttp3等基于连接池的高性能Http客户端。</p>
<p><strong>Feign 整体框架非常小巧，在处理请求转换和消息解析的过程中，基本上没什么时间消耗。真正影响性能的，是处理Http请求的环节。</strong></p>
<h2 id="3、Feign优化"><a href="#3、Feign优化" class="headerlink" title="3、Feign优化"></a>3、Feign优化</h2><h3 id="（1）GZIP压缩"><a href="#（1）GZIP压缩" class="headerlink" title="（1）GZIP压缩"></a>（1）GZIP压缩</h3><p>gzip是一种数据格式，采用deflate算法压缩数据。当Gzip压缩到一个纯文本数据时，可以减少70％以上的数据大小。</p>
<p>gzip作用：网络数据经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。</p>
<p>只配置Feign请求-应答的GZIP压缩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># feign gzip</span></span><br><span class="line"><span class="comment"># 局部配置。只配置feign技术相关的http请求-应答中的gzip压缩。</span></span><br><span class="line"><span class="comment"># 配置的是application client和application service之间通讯是否使用gzip做数据压缩。</span></span><br><span class="line"><span class="comment"># 和浏览器到application client之间的通讯无关。</span></span><br><span class="line"><span class="comment"># 开启feign请求时的压缩， application client -&gt; application service</span></span><br><span class="line">feign.compression.request.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 开启feign技术响应时的压缩，  application service -&gt; application client</span></span><br><span class="line">feign.compression.response.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置可以压缩的请求/响应的类型。</span></span><br><span class="line">feign.compression.request.mime-types=text/xml,application/xml,application/json</span><br><span class="line"><span class="comment"># 当请求的数据容量达到多少的时候，使用压缩。默认是2048字节。</span></span><br><span class="line">feign.compression.request.min-request-size=512</span><br></pre></td></tr></table></figure>

<p>配置全局的GZIP压缩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring boot gzip</span></span><br><span class="line"><span class="comment"># 开启spring boot中的gzip压缩。就是针对和当前应用所有相关的http请求-应答的gzip压缩。</span></span><br><span class="line">server.compression.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 哪些客户端发出的请求不压缩，默认是不限制</span></span><br><span class="line">server.compression.excluded-user-agents=gozilla,traviata</span><br><span class="line"><span class="comment"># 配置想压缩的请求/应答数据类型，默认是 text/html,text/xml,text/plain</span></span><br><span class="line">server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain</span><br><span class="line"><span class="comment"># 执行压缩的阈值，默认为2048</span></span><br><span class="line">server.compression.min-response-size=512</span><br></pre></td></tr></table></figure>

<h3 id="（2）替换为HttpClient客户端（使用HTTP连接池提供性能）"><a href="#（2）替换为HttpClient客户端（使用HTTP连接池提供性能）" class="headerlink" title="（2）替换为HttpClient客户端（使用HTTP连接池提供性能）"></a>（2）替换为HttpClient客户端（使用HTTP连接池提供性能）</h3><p>Feign的HTTP客户端支持3种框架，分别是；HttpURLConnection、HttpClient、OKHttp。Feign中默认使用HttpURLConnection。</p>
<ul>
<li>HttpURLConnection是JDK自带的HTTP客户端技术，并不支持连接池，如果要实现连接池的机制，还需要自己来管理连接对象。对于网络请求这种底层相对复杂的操作，如果有可用的其他方案，也没有必要自己去管理连接对象。</li>
<li>Apache提供的<strong>HttpClient</strong>框架相比传统JDK自带的HttpURLConnection，它封装了访问http的请求头，参数，内容体，响应等等；它不仅使客户端发送HTTP请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性；另外高并发大量的请求网络的时候，<strong>还是用“HTTP连接池”提升吞吐量</strong>。</li>
<li>OKHttp是一个处理网络请求的开源项目,是安卓端最火热的轻量级框架。<strong>OKHttp拥有共享Socket,减少对服务器的请求次数，通过连接池,减少了请求延迟等技术特点</strong>。</li>
</ul>
<p>本案例中，通过替换Feign底层的HTTP客户端实现为HttpClient，来提升Feign的通讯性能。</p>
<p>修改全局配置文件：开启feign技术对底层httpclient的依赖。 切换底层实现技术。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feign.httpclient.enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>作者：Finnnnnnnn<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e0218c142d03">https://www.jianshu.com/p/e0218c142d03</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>在通过Feign来实现远程服务调用时，需要提供一个本地接口来继承服务标准工程提供的服务接口。这个本地接口不需要给予任何实现，在底层Spring容器会为这个接口提供一个<strong>基于JDK实现的代理对象</strong>，这个代理对象<strong>由Feign技术提供具体的HandlerInterceptor逻辑</strong>，实现远程的调用。实现过程<strong>类似通过代码调用LoadBalancerClient实现的Rest远程访问</strong>。　　</p>
<p>而本地接口继承服务标准接口后，需要提供注解**@FeignClient<strong>，注解的属性</strong>name代表当前接口要调用的远程服务的应用命名**。</p>
<p>在Feign处理远程服务调用时，传递参数是通过HTTP协议传递的，参数存在的位置是请求头或请求体中。请求头传递的参数必须依赖@RequestParam注解来处理请求参数，请求体传递的参数必须依赖@RequestBody注解来处理请求参数。如果传递的是对象，不要使用@RequestParam注解，使用@SpringQueryMap注解，其实就是转换成立map传递</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java之Synchronized详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-23 14:06:14" itemprop="dateCreated datePublished" datetime="2021-04-23T14:06:14+08:00">2021-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h2><p>synchronized可以修饰普通方法，静态方法和代码块。<strong>当synchronized修饰一个方法或者一个代码块的时候，它能够保证在同一时刻最多只有一个线程执行该段代码。</strong></p>
<ul>
<li>对于普通同步方法，锁是当前实例对象（不同实例对象之间的锁互不影响）。字节码文件中flags为ACC_SYNCHRONIZED</li>
<li>对于静态同步方法，锁是当前类的Class对象。字节码文件中flags为ACC_SYNCHRONIZED</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。使用monitorenter和monitorexit</li>
</ul>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p>
<h2 id="满足三大特性"><a href="#满足三大特性" class="headerlink" title="满足三大特性"></a>满足三大特性</h2><p>同时满足了可见性，原子性和有序性</p>
<h2 id="synchronized实现的原理"><a href="#synchronized实现的原理" class="headerlink" title="synchronized实现的原理"></a>synchronized实现的原理</h2><p>synchronized的功能是基于monitorenter和monitorexit指令实现的。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。</p>
<p>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
<blockquote>
<p>monitorenter和monitorexit指令的底层是lock和unlock指令。</p>
</blockquote>
<h2 id="对象完整组成"><a href="#对象完整组成" class="headerlink" title="对象完整组成"></a>对象完整组成</h2><p>当线程进入synchronized方法或者代码块时需要先获取锁，退出时需要释放锁。那么这个锁信息到底存在哪里呢？其实这个锁是存在对象的对象头中的。</p>
<h3 id="对象组成"><a href="#对象组成" class="headerlink" title="对象组成"></a>对象组成</h3><ul>
<li>对象头</li>
<li>实例数据：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</li>
<li>对齐填充：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。</li>
</ul>
<h3 id="对象头组成"><a href="#对象头组成" class="headerlink" title="对象头组成"></a>对象头组成</h3><ul>
<li>Mark Word：标记字段。用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，如哈希码（HashCode）、GC分代年龄、锁状态标志位、是否是偏向锁、线程持有的锁、偏向线程ID、偏向时间戳等等</li>
<li>Klass Pointer：类型指针。是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>数组长度:只有数组才有</li>
</ul>
<p>Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。下图是Java对象头的存储结构（32位虚拟机）：Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/201812081002.png" alt="img"></p>
<p>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）：<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/1775037-20191120172456251-137179273.png"></p>
<p>其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。Epoch是指偏向锁的时间戳。</p>
<p>JDK1.6以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈，处理方式从偏向锁升级到轻量级锁，最终升级到重量级锁。</p>
<blockquote>
<p>轻量级锁中ptr_to_lock_record：指向栈中锁记录的指针。栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。</p>
<p>重量级锁中ptr_to_heavyweight_monitor：指向monitor对象（也称为管程或监视器锁）的起始地址，每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor对象可以与对象一起创建销毁或当前线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。</p>
</blockquote>
<h2 id="锁升级流程"><a href="#锁升级流程" class="headerlink" title="锁升级流程"></a>锁升级流程</h2><ul>
<li>step1:当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</li>
<li>step2:当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</li>
<li>step3:当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</li>
<li>step4:当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</li>
<li>step5:偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</li>
<li>step6:轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</li>
<li>step7:自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</li>
</ul>
<h2 id="monitor对象介绍"><a href="#monitor对象介绍" class="headerlink" title="monitor对象介绍"></a>monitor对象介绍</h2><p>在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>ObjectMonitor</code>中有两个队列，<code>_WaitSet</code> 和 <code>_EntryList</code>，用来保存<code>ObjectWaiter</code>对象列表( 每个等待锁的线程都会被封装成<code>ObjectWaiter</code>对象)</p>
<p>其中<code>_Owner</code>指向持有<code>ObjectMonitor</code>对象的线程。当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>集合，当线程获取到对象的monitor后进入 <code>_Owner</code> 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1。</p>
<p>若线程调用 wait() 方法，将释放当前持有的monitor，<code>_Owner</code>变量恢复为null，count自减1，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。</p>
<p>若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)</p>
<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/20201012143023373.png" alt="在这里插入图片描述" style="zoom: 67%;">
由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因

<p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/20201106151259493.png" alt="在这里插入图片描述" style="zoom: 50%;"><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/20201106151509444.png" alt="在这里插入图片描述" style="zoom: 50%;"></p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>乐观锁</strong>是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。数据库中的共享锁也是一种乐观锁。</p>
<p><strong>悲观锁</strong>是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中典型的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如ReentrantLock。数据库中的排他锁也是一种悲观锁。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>Java 6之前的synchronized会导致争用不到锁的线程进入阻塞状态，线程在阻塞状态和runnbale状态之间切换是很耗费系统资源的，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁。为了缓解上述性能问题，Java 6开始，引入了轻量锁与偏向锁，默认启用了自旋，他们都属于<strong>乐观锁</strong>。</p>
<p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。 何谓自旋锁？ 所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。 自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。 自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整； 如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>在方法体之外引用方法内的对象。在方法执行完毕之后，方法中创建的对象应该被 GC 回收，但由于该对象被其他变量引用，导致 GC 无法回收。这个无法回收的对象称为“逃逸”对象。Java 中的逃逸分析，就是对这种对象的分析。Java JIT 会通过逃逸分析的方式，去分析加锁的代码段/共享资源，他们是否被一个或者多个线程使用，或者等待被使用。即便开发人员对代码段/共享资源加上Synchronized（锁），只要 JIT 发现这个代码段/共享资源只被一个线程访问，也会把这个 Synchronized（锁）去掉。从而避免竞态，提高访问资源的效率。</p>
<p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。 如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。 锁粗化概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。下面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：</p>
<p> <strong>获取锁</strong></p>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li>
<li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li>执行同步代码块</li>
</ol>
<p><strong>释放锁</strong> 偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态；</li>
<li>撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态；</li>
</ol>
<hr>
<p>下图是偏向锁的获取和释放流程<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/201812081006.png"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下： </p>
<p><strong>获取锁</strong></p>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
<p><strong>释放锁</strong> 轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p>
<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
<p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；</p>
<hr>
<p>下图是轻量级锁的获取和释放过程<img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/201812081005.png" alt="img"></p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/" class="post-title-link" itemprop="url">java之并发抽象队列同步器AQS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-23 10:33:03" itemprop="dateCreated datePublished" datetime="2021-04-23T10:33:03+08:00">2021-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>静态内部类：Node   ——》构成双向链表的CLH<font color="red">同步队列</font>——》前驱节点为-1即SIGNAL时，使用LockSupport类堵塞线程</p>
<p>内部类：ConditionObject，使用Node类——》构成单链表的<font color="red">等待队列</font>——》使用LockSupport类堵塞线程</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>AbstractQueuedSynchronizer类的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;  <span class="comment">//CHM同步队列的头节点，懒加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;  <span class="comment">//CHM同步队列的尾节点，懒加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;            <span class="comment">//表示当前锁的状态，在不同的功能实现中代表不同的含义。比如在独占并且不可重入的锁实现中：0代表当前锁未被占用，1代表锁被占用；而在独占并且可重入的锁实现中：0代表当前锁未被占用，而大于0则表示被占用，且表示当前持有锁的线程重入的次数。可以通过getState、setState、compareAndSetState来检查或修改同步状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;   <span class="comment">//父类AbstractOwnableSynchronizer里的变量，当前持有独占锁的线程</span></span><br></pre></td></tr></table></figure>

<p>Node类的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;  <span class="comment">//代表此节点对应线程因超时或中断从而取消了争抢锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;  <span class="comment">//代表当本节点线程释放锁或取消争抢锁时，需要唤醒当前线程节点的后继节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;  <span class="comment">//代表当前节点正在等待一个Condition</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;  <span class="comment">//释放共享锁需要传播到其它节点   </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;          <span class="comment">//等待状态，取值为上述4个值，还有初始值为0</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;               <span class="comment">//当前节点的前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;               <span class="comment">//当前节点的后驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;           <span class="comment">//当前节点的线程</span></span><br><span class="line">Node nextWaiter;                  <span class="comment">//下一个等待Condition的node</span></span><br></pre></td></tr></table></figure>

<p>ConditionObject类的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;   <span class="comment">//等待节点的头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;    <span class="comment">//等待节点的尾节点</span></span><br></pre></td></tr></table></figure>

<h2 id="LockSupport类介绍"><a href="#LockSupport类介绍" class="headerlink" title="LockSupport类介绍"></a>LockSupport类介绍</h2><p>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程。主要是通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作的。</p>
<blockquote>
<p>每个线程都有一个许可(permit)，permit只有两个值1和0,默认是0。</p>
<ol>
<li>当调用unpark(thread)方法，就会将thread线程的许可permit设置成1(注意多次调用unpark方法，不会累加，permit值还是1)。</li>
<li>当调用park()方法，如果当前线程的permit是1，那么将permit设置为0，并立即返回。如果当前线程的permit是0，那么当前线程就会阻塞，直到别的线程将当前线程的permit设置为1.park方法会将permit再次设置为0，并返回。</li>
</ol>
<p>注意：因为permit默认是0，所以一开始调用park()方法，线程必定会被阻塞。调用unpark(thread)方法后，会自动唤醒thread线程，即park方法立即返回。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6913925439723405319">AQS基础之 CLH锁</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33330687/article/details/80676340">ConditionObject原理</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39687783/article/details/85058686">LockSupport中的park与unpark原理</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014436679">LockSupport原理分析</a></p>
<p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/image-20210721135610511.png" alt="image-20210721135610511"></p>
<p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/image-20210802113255084.png" alt="image-20210802113255084"></p>
<p><img src="/2021/04/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/image-20210802113316367.png" alt="image-20210802113316367"></p>
<p>ReetrantLock：state表示重入次数，cas获取锁<br>ReetrantReadWriteLock：state中高16位表示read数量，低16位表示write数量</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A0%B5%E5%A1%9E%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/23/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A0%B5%E5%A1%9E%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">java线程之堵塞区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-23 10:10:24" itemprop="dateCreated datePublished" datetime="2021-04-23T10:10:24+08:00">2021-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Thread-sleep-和Object-wait-的区别"><a href="#Thread-sleep-和Object-wait-的区别" class="headerlink" title="Thread.sleep()和Object.wait()的区别"></a>Thread.sleep()和Object.wait()的区别</h2><p>（1）Thread.sleep()不会释放占有的锁资源，Object.wait()会释放占有的锁资源；</p>
<p>（2）Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</p>
<p>（3）Thread.sleep()到时间了会自动唤醒，然后继续执行；</p>
<p>（4）Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；</p>
<p>（5）Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；</p>
<p>其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</p>
<h2 id="Thread-sleep-和Condition-await-的区别"><a href="#Thread-sleep-和Condition-await-的区别" class="headerlink" title="Thread.sleep()和Condition.await()的区别"></a>Thread.sleep()和Condition.await()的区别</h2><p>这个题目的回答思路跟Object.wait()是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。</p>
<p>实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程</p>
<h2 id="Object-wait-和Condition-await-的区别"><a href="#Object-wait-和Condition-await-的区别" class="headerlink" title="Object.wait()和Condition.await()的区别"></a>Object.wait()和Condition.await()的区别</h2><p>类似，都会释放锁，Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。Object.wait()是native方法</p>
<h2 id="Thread-sleep-和LockSupport-park-的区别"><a href="#Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="Thread.sleep()和LockSupport.park()的区别"></a>Thread.sleep()和LockSupport.park()的区别</h2><p>LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。</p>
<p>（1）从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；</p>
<p>（2）Thread.sleep()没法从外部唤醒，只能自己醒过来；</p>
<p>（3）LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</p>
<p>（4）Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；</p>
<p>（5）LockSupport.park()方法不需要捕获中断异常；</p>
<p>（6）Thread.sleep()本身就是一个native方法；</p>
<p>（7）LockSupport.park()底层是调用的Unsafe的native方法；</p>
<h2 id="Object-wait-和LockSupport-park-的区别"><a href="#Object-wait-和LockSupport-park-的区别" class="headerlink" title="Object.wait()和LockSupport.park()的区别"></a>Object.wait()和LockSupport.park()的区别</h2><p>二者都会阻塞当前线程的运行，他们有什么区别呢？经过上面的分析相信你一定很清楚了，真的吗？往下看！</p>
<p>（1）Object.wait()方法需要在synchronized块中执行；</p>
<p>（2）LockSupport.park()可以在任意地方执行；</p>
<p>（3）Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；</p>
<p>（4）LockSupport.park()不需要捕获中断异常【本文由公从号“彤哥读源码”原创】；</p>
<p>（5）Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；</p>
<p>（6）LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</p>
<p>（7）如果在wait()之前执行了notify()会怎样？抛出IllegalMonitorStateException异常；</p>
<p>（8）如果在park()之前执行了unpark()会怎样？线程不会被阻塞，直接跳过park()，继续执行后续内容；</p>
<h2 id="LockSupport-park-会释放锁资源吗？"><a href="#LockSupport-park-会释放锁资源吗？" class="headerlink" title="LockSupport.park()会释放锁资源吗？"></a>LockSupport.park()会释放锁资源吗？</h2><p>不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。</p>
<ul>
<li><input disabled type="checkbox"> <img src="/2021/04/23/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A0%B5%E5%A1%9E%E5%8C%BA%E5%88%AB/20191031000413242.png" alt="img"></li>
</ul>
<p><img src="/2021/04/23/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A0%B5%E5%A1%9E%E5%8C%BA%E5%88%AB/image-20210423103045076.png" alt="image-20210423103045076"></p>
<p>park()/unpark()底层原理</p>
<p>park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">缓存之Caffeine与Guava对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-22 11:18:41" itemprop="dateCreated datePublished" datetime="2021-04-22T11:18:41+08:00">2021-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Caffeine/" itemprop="url" rel="index"><span itemprop="name">Caffeine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="GuavaCache和Caffeine差异"><a href="#GuavaCache和Caffeine差异" class="headerlink" title="GuavaCache和Caffeine差异"></a>GuavaCache和Caffeine差异</h2><ol>
<li>剔除算法方面，GuavaCache采用的是<strong>「LRU」</strong>算法，而Caffeine采用的是<strong>「Window TinyLFU」</strong>算法，这是两者之间最大，也是根本的区别。</li>
<li>立即失效方面，Guava会把立即失效 (例如：expireAfterAccess(0) and expireAfterWrite(0)) 转成设置最大Size为0。这就会导致剔除提醒的原因是SIZE而不是EXPIRED。Caffiene能正确识别这种剔除原因。</li>
<li>取代提醒方面，Guava只要数据被替换，不管什么原因，都会触发剔除监听器。而Caffiene在取代值和先前值的引用完全一样时不会触发监听器。</li>
<li>异步化方方面，Caffiene的很多工作都是交给线程池去做的（默认：ForkJoinPool.commonPool()），例如：剔除监听器，刷新机制，维护工作等。</li>
</ol>
<h3 id="内存占用对比"><a href="#内存占用对比" class="headerlink" title="内存占用对比"></a>内存占用对比</h3><p>Caffeine可以根据使用情况延迟初始化，或者动态调整它内部数据结构。这样能减少对内存的占用。如下图所示，使用了gradle memoryOverhead对内存占用进行了压测。结果可能会受到JVM的指针压缩、对象Padding等影响：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/%E5%AF%B9%E6%AF%94.png" alt="img"></p>
<h2 id="LRU-P-K-W-TinyLFU"><a href="#LRU-P-K-W-TinyLFU" class="headerlink" title="LRU P.K. W-TinyLFU"></a>LRU P.K. W-TinyLFU</h2><p>缓存的驱逐策略是为了预测哪些数据在短期内最可能被再次用到，从而提升缓存的命中率。由于简洁的实现、高效的运行时表现以及在常规的使用场景下有不错的命中率，LRU（Least Recently Used）策略或许是最流行的驱逐策略,，它在保持算法简单的前提下，效果还不错。但LRU对未来的预测有明显的局限性，它会认为<strong>「最后到来的数据是最可能被再次访问」</strong>的，从而给予它最高的优先级。</p>
<p>现代缓存扩展了对历史数据的使用，结合就近程度（recency）和访问频次（frequency）来更好的预测数据。其中一种保留历史信息的方式是使用<strong>「popularity sketch」</strong>（一种压缩、概率性的数据结构）来从一大堆访问事件中定位频繁的访问者。可以参考<strong>「CountMin Sketch」</strong>算法，它由计数矩阵和多个哈希方法实现。发生一次读取时，矩阵中每行对应的计数器增加计数，估算频率时，取数据对应是所有行中计数的最小值。这个方法让我们从空间、效率、以及适配矩阵的长宽引起的哈希碰撞的错误率上做权衡：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80bzIyT0ZjbXpIbE4wbXBTQlNITGdYTUp0VWRNQmliYzFOODRiaWJPWUlvNGZ1STA1MWlhd0RwN3VzVTVra3VmSGR4TDNkM3VMWGliVXZOQWpmU3hjWTNRencvNjQw" alt="img"></p>
<p>Window TinyLFU（W-TinyLFU）算法将Sketch作为过滤器，当新来的数据比要驱逐的数据高频时，这个数据才会被缓存接纳（admission）。这个许可窗口给予每个数据项积累热度的机会，而<strong>「不是立即过滤掉」</strong>。这避免了持续的未命中，特别是在突然流量暴涨的的场景中，一些短暂的重复流量就不会被长期保留。为了刷新历史数据，一个时间衰减进程被周期性或增量的执行，给所有计数器减半：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80bzIyT0ZjbXpIbE4wbXBTQlNITGdYTUp0VWRNQmliYzEzeEY1OHVYakZ2S1FXTktRVXNhYW94UkhGbDBXRmUyaWNDemdlS05zVnlUVWo1a1EyRGFkQUFRLzY0MA" alt="img"></p>
<p>对于长期保留的数据，W-TinyLFU使用了分段LRU（Segmented LRU，缩写SLRU）策略。起初，一个数据项存储被存储在试用段（probationary segment）中，在后续被访问到时，它会被提升到保护段（protected segment）中（保护段占总容量的80%）。保护段满后，有的数据会被淘汰回试用段，这也可能级联的触发试用段的淘汰。这套机制确保了访问间隔小的热数据被保存下来，而被重复访问少的冷数据则被回收：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80bzIyT0ZjbXpIbE4wbXBTQlNITGdYTUp0VWRNQmliYzFvQjdwamJGVmc4MlFVdm9QQ1EwNVJVbVp5aEZod3ZYb05aT2pYZDk3aWJDZG9SdFlQQjJjdnBRLzY0MA" alt="img"></p>
<p>如图中数据库和搜索场景的结果展示，通过考虑就近程度和频率能大大提升LRU的表现。一些高级的策略，像ARC，LIRS和W-TinyLFU都提供了接近最理想的命中率。想看更多的场景测试，请查看相应的论文，也可以在使用simulator来测试自己的场景：<img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine%E4%B8%8EGuava%E5%AF%B9%E6%AF%94/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80bzIyT0ZjbXpIbE4wbXBTQlNITGdYTUp0VWRNQmliYzFmTFNmZlBqMDdpY2h6Znk3aWNyYTVtOWE3Z2pvMjZjcXZNcUVYcHdPNjFGcEs2THpyeVdmbWJaZy82NDA" alt="img"></p>
<h2 id="Guava迁移"><a href="#Guava迁移" class="headerlink" title="Guava迁移"></a>Guava迁移</h2><p>那么，如果我的项目之前用的是GuavaCache，如何以尽可能低的成本迁移到Caffeine上来呢？嘿嘿，Caffeine已经想到了这一点，它提供了一个适配器，让你用Guava的接口操作它的缓存。代码片段如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guava&#x27;s LoadingCache interface</span></span><br><span class="line">LoadingCache&lt;Key, Graph&gt; graphs = CaffeinatedGuava.build(</span><br><span class="line">    Caffeine.newBuilder().maximumSize(<span class="number">10_000</span>),</span><br><span class="line">    <span class="keyword">new</span> CacheLoader&lt;Key, Graph&gt;() &#123; <span class="comment">// Guava&#x27;s CacheLoader</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Graph <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> createExpensiveGraph(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine/" class="post-title-link" itemprop="url">缓存之Caffeine</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-22 10:35:07" itemprop="dateCreated datePublished" datetime="2021-04-22T10:35:07+08:00">2021-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Caffeine/" itemprop="url" rel="index"><span itemprop="name">Caffeine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/14385641.html">Caffeine</a></p>
<p>Caffeine提供了灵活的构造来创建具有以下功能组合的缓存：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Population">自动将条目自动加载</a>到缓存中，可以选择异步<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Population">加载</a></li>
<li>基于<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Efficiency">频率和新近度</a>超过最大值时<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Eviction#size-based">基于大小的逐出</a></li>
<li>自上次访问或上次写入以来测得<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Eviction#time-based">的基于时间</a>的条目<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Eviction#time-based">到期</a></li>
<li>发生第一个陈旧的条目请求时，<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Refresh">异步刷新</a></li>
<li>键自动包装在<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Eviction#reference-based">弱引用中</a></li>
<li>值自动包装在<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Eviction#reference-based">弱引用或软引用中</a></li>
<li>逐出（或以其他方式删除）条目的<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Removal">通知</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Compute">写入传播</a>到外部资源</li>
<li>缓存访问<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Statistics">统计信息的</a>累积</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前面刚说到Guava Cache，他的优点是封装了get，put操作；提供线程安全的缓存操作；提供过期策略；提供回收策略；缓存监控。当缓存的数据超过最大值时，使用LRU算法替换。这一篇我们将要谈到一个新的本地缓存框架：Caffeine Cache。它也是站在巨人的肩膀上-Guava Cache，借着他的思想优化了算法发展而来。</p>
<p>按 Caffeine Github 文档描述，Caffeine 是基于 JAVA 8 的高性能缓存库。并且在 spring5 (springboot 2.x) 后，spring 官方放弃了 Guava，而使用了性能更优秀的 Caffeine 作为默认缓存组件。</p>
<h2 id="Caffine-Cache"><a href="#Caffine-Cache" class="headerlink" title="Caffine Cache"></a>Caffine Cache</h2><p>Caffeine Cache：<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p>
<h2 id="1-缓存填充策略"><a href="#1-缓存填充策略" class="headerlink" title="1. 缓存填充策略"></a>1. 缓存填充策略</h2><p>Caffeine Cache提供了三种缓存填充策略：手动、同步加载和异步加载。</p>
<h3 id="手动加载"><a href="#手动加载" class="headerlink" title="手动加载"></a>手动加载</h3><p>在每次get key的时候指定一个同步的函数，如果key不存在就调用这个函数生成一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手动加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">manulOperator</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(<span class="number">10</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//如果一个key不存在，那么会进入指定的函数生成value</span></span><br><span class="line">    Object value = cache.get(key, t -&gt; setValue(key).apply(key));</span><br><span class="line">    cache.put(<span class="string">&quot;hello&quot;</span>,value);</span><br><span class="line">    <span class="comment">//判断是否存在如果不存返回null</span></span><br><span class="line">    Object ifPresent = cache.getIfPresent(key);</span><br><span class="line">    <span class="comment">//移除一个key</span></span><br><span class="line">    cache.invalidate(key);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Function&lt;String, Object&gt; <span class="title">setValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t -&gt; key + <span class="string">&quot;value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p>构造Cache时候，build方法传入一个CacheLoader实现类。实现load方法，通过key加载value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步加载</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">syncOperator</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">100</span>)</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .build(k -&gt; setValue(key).apply(key));</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Function&lt;String, Object&gt; <span class="title">setValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t -&gt; key + <span class="string">&quot;value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>AsyncLoadingCache是继承自LoadingCache类的，异步加载使用Executor去调用方法并返回一个CompletableFuture。异步加载缓存使用了响应式编程模型。</p>
<p>如果要以同步方式调用时，应提供CacheLoader。要以异步表示时，应该提供一个AsyncCacheLoader，并返回一个CompletableFuture。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">asyncOperator</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    AsyncLoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">100</span>)</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .buildAsync(k -&gt; setAsyncValue(key).get());</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">setAsyncValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;value&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-回收策略"><a href="#2-回收策略" class="headerlink" title="2. 回收策略"></a>2. 回收策略</h2><p>Caffeine提供了3种回收策略：基于大小回收，基于时间回收，基于引用回收。</p>
<h3 id="基于大小的过期方式"><a href="#基于大小的过期方式" class="headerlink" title="基于大小的过期方式"></a>基于大小的过期方式</h3><p>基于大小的回收策略有两种方式：一种是基于缓存大小，一种是基于权重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据缓存的计数进行驱逐</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10000</span>)</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据缓存的权重来进行驱逐（权重只是用于确定缓存大小，不会用于决定该缓存是否被驱逐）</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">    .maximumWeight(<span class="number">10000</span>)</span><br><span class="line">    .weigher(key -&gt; function1(key))</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"><span class="comment">//maximumWeight与maximumSize不可以同时使用。</span></span><br></pre></td></tr></table></figure>

<h3 id="基于时间的过期方式"><a href="#基于时间的过期方式" class="headerlink" title="基于时间的过期方式"></a>基于时间的过期方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于固定的到期策略进行退出</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line">LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于不同的到期策略进行退出</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache2 = Caffeine.newBuilder()</span><br><span class="line">    .expireAfter(<span class="keyword">new</span> Expiry&lt;String, Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterCreate</span><span class="params">(String key, Object value, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(seconds);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterUpdate</span><span class="params">(<span class="meta">@Nonnull</span> String s, <span class="meta">@Nonnull</span> Object o, <span class="keyword">long</span> l, <span class="keyword">long</span> l1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterRead</span><span class="params">(<span class="meta">@Nonnull</span> String s, <span class="meta">@Nonnull</span> Object o, <span class="keyword">long</span> l, <span class="keyword">long</span> l1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build(key -&gt; function(key));</span><br></pre></td></tr></table></figure>

<p>Caffeine提供了三种定时驱逐策略：</p>
<ul>
<li>expireAfterAccess(long, TimeUnit)：在最后一次访问或者写入后开始计时，在指定的时间后过期。假如一直有请求访问该key，那么这个缓存将一直不会过期。</li>
<li>expireAfterWrite(long, TimeUnit)：在最后一次写入缓存后开始计时，在指定的时间后过期。</li>
<li>expireAfter(Expiry)：自定义策略，过期时间由Expiry实现独自计算。</li>
</ul>
<p>缓存的删除策略使用的是惰性删除和定时删除。这两个删除策略的时间复杂度都是O(1)。</p>
<h3 id="基于引用的过期方式"><a href="#基于引用的过期方式" class="headerlink" title="基于引用的过期方式"></a>基于引用的过期方式</h3><p><img src="/2021/04/22/%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine/up-e3834f3657dfc4f839a56428067a1e346ba.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当key和value都没有引用时驱逐缓存</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .weakKeys()</span><br><span class="line">    .weakValues()</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当垃圾收集器需要释放内存时驱逐</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">    .softValues()</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：AsyncLoadingCache不支持弱引用和软引用。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Caffeine.weakKeys()： 使用弱引用存储key。如果没有其他地方对该key有强引用，那么该缓存就会被垃圾回收器回收。由于垃圾回收器只依赖于身份(identity)相等，因此这会导致整个缓存使用身份 (==) 相等来比较 key，而不是使用 equals()。</p>
<p>Caffeine.weakValues() ：使用弱引用存储value。如果没有其他地方对该value有强引用，那么该缓存就会被垃圾回收器回收。由于垃圾回收器只依赖于身份(identity)相等，因此这会导致整个缓存使用身份 (==) 相等来比较 key，而不是使用 equals()。</p>
<p>Caffeine.softValues() ：使用软引用存储value。当内存满了过后，软引用的对象以将使用最近最少使用(least-recently-used ) 的方式进行垃圾回收。由于使用软引用是需要等到内存满了才进行回收，所以我们通常建议给缓存配置一个使用内存的最大值。 softValues() 将使用身份相等(identity) (==) 而不是equals() 来比较值。</p>
<p>Caffeine.weakValues()和Caffeine.softValues()不可以一起使用。</p>
</blockquote>
<h2 id="3-移除事件监听"><a href="#3-移除事件监听" class="headerlink" title="3. 移除事件监听"></a>3. 移除事件监听</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .removalListener((String key, Object value, RemovalCause cause) -&gt;</span><br><span class="line">                     System.out.printf(<span class="string">&quot;Key %s was removed (%s)%n&quot;</span>, key, cause))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>RemovalCause枚举值:</p>
<ul>
<li><strong>「EXPLICIT」</strong>：调用方法（例如：cache.invalidate(key)、cache.invalidateAll）显示剔除数据；</li>
<li><strong>「REPLACED」</strong>：不是真正被剔除，而是用户调用一些方法（例如：put()，putAll()等）盖了之前的值；</li>
<li><strong>「COLLECTED」</strong>：表示缓存中的Key或者Value被垃圾回收掉了；</li>
<li><strong>「EXPIRED」</strong>: expireAfterWrite/expireAfterAccess约定时间内没有任何访问导致被剔除；</li>
<li><strong>「SIZE」</strong>：超过maximumSize限制的元素个数被剔除的原因；</li>
</ul>
<h2 id="4-写入外部存储"><a href="#4-写入外部存储" class="headerlink" title="4. 写入外部存储"></a>4. 写入外部存储</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheWriter 方法可以将缓存中所有的数据写入到第三方。</span></span><br><span class="line">LoadingCache&lt;String, Object&gt; cache2 = Caffeine.newBuilder()</span><br><span class="line">    .writer(<span class="keyword">new</span> CacheWriter&lt;String, Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 写入到外部存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key, Object value, RemovalCause cause)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 删除外部存储</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build(key -&gt; function(key));</span><br><span class="line"><span class="comment">//如果你有多级缓存的情况下，这个方法还是很实用。</span></span><br><span class="line"><span class="comment">//注意：CacheWriter不能与弱键或AsyncLoadingCache一起使用。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-统计"><a href="#5-统计" class="headerlink" title="5. 统计"></a>5. 统计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与Guava Cache的统计一样。</span></span><br><span class="line">Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .recordStats()</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//通过使用Caffeine.recordStats(), 可以转化成一个统计的集合. 通过 Cache.stats() 返回一个CacheStats。CacheStats提供以下统计方法：</span></span><br><span class="line"><span class="comment">//hitRate(): 返回缓存命中率</span></span><br><span class="line"><span class="comment">//evictionCount(): 缓存回收数量</span></span><br><span class="line"><span class="comment">//averageLoadPenalty(): 加载新值的平均时间</span></span><br></pre></td></tr></table></figure>

<h2 id="6-刷新机制"><a href="#6-刷新机制" class="headerlink" title="6.刷新机制"></a>6.刷新机制</h2><p>在构造Cache时通过refreshAfterWrite方法指定刷新周期，例如refreshAfterWrite(10, TimeUnit.SECONDS)表示10秒钟刷新一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里我们就可以从数据库或者其他地方查询最新的数据</span></span><br><span class="line">        <span class="keyword">return</span> getValue(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Caffeine的刷新机制是<strong>「被动」</strong>的。举个例子，假如我们申明了10秒刷新一次。我们在时间T访问并获取到值v1，在T+5秒的时候，数据库中这个值已经更新为v2。但是在T+12秒，即已经过了10秒我们通过Caffeine从本地缓存中获取到的<strong>「还是v1」</strong>，并不是v2。在这个获取过程中，Caffeine发现时间已经过了10秒，然后会将v2加载到本地缓存中，下一次获取时才能拿到v2。即它的实现原理是在get方法中，调用afterRead的时候，调用refreshIfNeeded方法判断是否需要刷新数据。这就意味着，如果不读取本地缓存中的数据的话，无论刷新时间间隔是多少，本地缓存中的数据永远是旧的数据！</p>
<h2 id="实例分享"><a href="#实例分享" class="headerlink" title="实例分享"></a>实例分享</h2><p>SpringBoot 1.x版本中的默认本地cache是Guava Cache。在2.x（Spring Boot 2.0(spring 5) ）版本中已经用Caffine Cache取代了Guava Cache。毕竟有了更优的缓存淘汰策略。</p>
<p>下面我们来说在SpringBoot2.x版本中如何使用cache。</p>
<blockquote>
<p>Caffeine常用配置说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initialCapacity&#x3D;[integer]: 初始的缓存空间大小</span><br><span class="line">maximumSize&#x3D;[long]: 缓存的最大条数</span><br><span class="line">maximumWeight&#x3D;[long]: 缓存的最大权重</span><br><span class="line">expireAfterAccess&#x3D;[duration]: 最后一次写入或访问后经过固定时间过期</span><br><span class="line">expireAfterWrite&#x3D;[duration]: 最后一次写入后经过固定时间过期</span><br><span class="line">refreshAfterWrite&#x3D;[duration]: 创建缓存或者最近一次更新缓存后经过固定的时间间隔，刷新缓存</span><br><span class="line">weakKeys: 打开key的弱引用</span><br><span class="line">weakValues：打开value的弱引用</span><br><span class="line">softValues：打开value的软引用</span><br><span class="line">recordStats：开发统计功能</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">expireAfterWrite和expireAfterAccess同时存在时，以expireAfterWrite为准。</span><br><span class="line">maximumSize和maximumWeight不可以同时使用</span><br><span class="line">weakValues和softValues不可以同时使用</span><br></pre></td></tr></table></figure>

<p>需要说明的是，使用配置文件的方式来进行缓存项配置，一般情况能满足使用需求，但是灵活性不是很高，如果我们有很多缓存项的情况下写起来会导致配置文件很长。所以一般情况下你也可以选择使用bean的方式来初始化Cache实例。</p>
</blockquote>
<p>SpringBoot 有俩种使用 Caffeine 作为缓存的方式：</p>
<ul>
<li>直接引入 Caffeine 依赖，然后使用 Caffeine 方法实现缓存。</li>
<li>引入 Caffeine 和 Spring Cache 依赖，使用 SpringCache 注解方法实现缓存。</li>
</ul>
<h2 id="1-直接引入-Caffeine-依赖"><a href="#1-直接引入-Caffeine-依赖" class="headerlink" title="1. 直接引入 Caffeine 依赖"></a>1. 直接引入 Caffeine 依赖</h2><h3 id="Pom"><a href="#Pom" class="headerlink" title="Pom"></a>Pom</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- caffeine cache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Conf"><a href="#Conf" class="headerlink" title="Conf"></a>Conf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.conf;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineCacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache&lt;String, Object&gt; <span class="title">caffeineCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">            <span class="comment">// 设置最后一次写入或访问后经过固定时间过期</span></span><br><span class="line">            .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">// 初始的缓存空间大小</span></span><br><span class="line">            .initialCapacity(<span class="number">100</span>)</span><br><span class="line">            <span class="comment">// 缓存的最大条数</span></span><br><span class="line">            .maximumSize(<span class="number">1000</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.service;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.bean.UserInfo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUserInfo</span><span class="params">(UserInfo userInfo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">UserInfo <span class="title">getByName</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Impl"><a href="#Impl" class="headerlink" title="Impl"></a>Impl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.bean.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.service.UserInfoService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟数据库存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, UserInfo&gt; userInfoMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Cache&lt;String, Object&gt; caffeineCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserInfo</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        userInfoMap.put(userInfo.getId(), userInfo);</span><br><span class="line">        <span class="comment">// 加入缓存</span></span><br><span class="line">        caffeineCache.put(String.valueOf(userInfo.getId()),userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getByName</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先从缓存读取</span></span><br><span class="line">        caffeineCache.getIfPresent(id);</span><br><span class="line">        UserInfo userInfo = (UserInfo) caffeineCache.asMap().get(String.valueOf(id));</span><br><span class="line">        <span class="keyword">if</span> (userInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, 我来自Caffeine Cache&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> userInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果缓存中不存在，则从库中查找</span></span><br><span class="line">        userInfo = userInfoMap.get(id);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, 我来自DataBase&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果用户信息不为空，则加入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (userInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            caffeineCache.put(String.valueOf(userInfo.getId()),userInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        userInfoMap.remove(id);</span><br><span class="line">        <span class="comment">// 从缓存中删除</span></span><br><span class="line">        caffeineCache.asMap().remove(String.valueOf(id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.bean.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.service.UserInfoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/caffeine&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineCacheController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userInfo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = userInfoService.getByName(id);</span><br><span class="line">        <span class="keyword">if</span> (userInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没有该用户&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/userInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        userInfo.setId(<span class="number">1</span>);</span><br><span class="line">        userInfo.setName(<span class="string">&quot;HLee&quot;</span>);</span><br><span class="line">        userInfoService.addUserInfo(userInfo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deleteUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        userInfoService.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务：</span></span><br><span class="line"><span class="comment">//localhost:2000/spring-master/caffeine/userInfo</span></span><br><span class="line"><span class="comment">//localhost:2000/spring-master/caffeine/userInfo/1</span></span><br><span class="line"><span class="comment">//localhost:2000/spring-master/caffeine/delete/1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-引入-Caffeine-和-Spring-Cache-依赖"><a href="#2-引入-Caffeine-和-Spring-Cache-依赖" class="headerlink" title="2. 引入 Caffeine 和 Spring Cache 依赖"></a>2. 引入 Caffeine 和 Spring Cache 依赖</h2><h3 id="Pom-1"><a href="#Pom-1" class="headerlink" title="Pom"></a>Pom</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Conf-1"><a href="#Conf-1" class="headerlink" title="Conf"></a>Conf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置缓存管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;caffeineCacheManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CaffeineCacheManager cacheManager = <span class="keyword">new</span> CaffeineCacheManager();</span><br><span class="line">        cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">// 设置最后一次写入或访问后经过固定时间过期</span></span><br><span class="line">                .expireAfterAccess(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">// 初始的缓存空间大小</span></span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                <span class="comment">// 缓存的最大条数</span></span><br><span class="line">                .maximumSize(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bean-1"><a href="#Bean-1" class="headerlink" title="Bean"></a>Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.master.spring.caffeine.service;</span><br><span class="line"><span class="keyword">import</span> com.spring.master.spring.caffeine.bean.UserInfo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUserInfo</span><span class="params">(UserInfo userInfo)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">UserInfo <span class="title">getByName</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Impl-1"><a href="#Impl-1" class="headerlink" title="Impl"></a>Impl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> mydlq.club.example.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> mydlq.club.example.service.UserInfoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;caffeineCacheManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟数据库存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, UserInfo&gt; userInfoMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#userInfo.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserInfo</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        userInfoMap.put(userInfo.getId(), userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getByName</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfoMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#userInfo.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">updateUserInfo</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!userInfoMap.containsKey(userInfo.getId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取旧的值</span></span><br><span class="line">        UserInfo oldUserInfo = userInfoMap.get(userInfo.getId());</span><br><span class="line">        <span class="comment">// 替换内容</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(oldUserInfo.getAge())) &#123;</span><br><span class="line">            oldUserInfo.setAge(userInfo.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(oldUserInfo.getName())) &#123;</span><br><span class="line">            oldUserInfo.setName(userInfo.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(oldUserInfo.getSex())) &#123;</span><br><span class="line">            oldUserInfo.setSex(userInfo.getSex());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的对象存储，更新旧对象信息</span></span><br><span class="line">        userInfoMap.put(oldUserInfo.getId(), oldUserInfo);</span><br><span class="line">        <span class="comment">// 返回新对象信息</span></span><br><span class="line">        <span class="keyword">return</span> oldUserInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        userInfoMap.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userInfo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = userInfoService.getByName(id);</span><br><span class="line">        <span class="keyword">if</span> (userInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没有该用户&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/userInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        userInfoService.addUserInfo(userInfo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/updateInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">updateUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        UserInfo newUserInfo = userInfoService.updateUserInfo(userInfo);</span><br><span class="line">        <span class="keyword">if</span> (newUserInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;不存在该用户&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUserInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deleteUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        userInfoService.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">设计模式之原则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-21 15:25:42" itemprop="dateCreated datePublished" datetime="2021-04-21T15:25:42+08:00">2021-04-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="原则（可读性、可维护性、可扩展性、复杂性、风险）"><a href="#原则（可读性、可维护性、可扩展性、复杂性、风险）" class="headerlink" title="原则（可读性、可维护性、可扩展性、复杂性、风险）"></a>原则（可读性、可维护性、可扩展性、复杂性、风险）</h2><h3 id="单一职责原则-降低复杂性"><a href="#单一职责原则-降低复杂性" class="headerlink" title="单一职责原则(降低复杂性)"></a>单一职责原则(降低复杂性)</h3><p>事例：设计一个视频播放系统，要求：如果是VIP用户就播放完整影片，否则只允许试看5分钟。简单的实现是，播放方法中检验是否有权限，这样会有一个问题就是，当权限判断变更时，需要调整权限方法的代码，修改了播放类。</p>
<p><font color="red">单一职责的优点</font>：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li>
<li>可读性提高。</li>
<li>可维护性提高。</li>
<li>变更引起的风险降低。</li>
</ul>
<p><font color="red">单一职责的核心就是拆分</font>，职责的拆分，它不仅适用于类，也适用于方法，每一个方法的功能都应该是相互独立，职责清晰的，这不仅提高了程序的可读性和可维护性，方法的复用性也会提高。一个功能过于“丰富”的方法，通常很难被复用。</p>
<h3 id="里氏替换原则（子类继承抽象类）"><a href="#里氏替换原则（子类继承抽象类）" class="headerlink" title="里氏替换原则（子类继承抽象类）"></a>里氏替换原则（子类继承抽象类）</h3><p><strong>所有引用基类的地方必须能透明地使用其子类的对象。</strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>事例：系统在发送短信时，需要将发送记录保存到数据库中，如果子类重写了父类的方法，修改了业务逻辑，日志记录功能将会丢失，这是非常危险的。</p>
<p><font color="red">继承的优点</font>：</p>
<ol>
<li>代码共享。</li>
<li>提高代码的复用性。</li>
<li>提高类的开放性，可以被子类增强。</li>
</ol>
<p><font color="red">继承的缺点</font>：</p>
<ol>
<li>较强的侵入性，子类必须拥有父类的所有方法和属性。</li>
<li>增加了耦合，父类的特性改变，子类也必须跟着改变。</li>
</ol>
<p>继承有它的优点，自然也有它的缺点，如果子类不能完整的实现父类的方法，或者父类的方法在子类的实现中“变味儿”了，则建议断开继承关系，采用依赖、组合等关系来代替。</p>
<h3 id="依赖倒置原则（面向接口编程）"><a href="#依赖倒置原则（面向接口编程）" class="headerlink" title="依赖倒置原则（面向接口编程）"></a>依赖倒置原则（面向接口编程）</h3><ol>
<li><strong>高层模块不依赖低层模块，而是互相依赖其抽象。</strong></li>
<li><strong>抽象不依赖细节，细节依赖于抽象。</strong></li>
</ol>
<p>通常一个业务逻辑会由N个原子逻辑组成，原子逻辑是不可分割的，也就是低层模块，由N个原子逻辑组成的业务逻辑就是高层模块。</p>
<p>事例：用户下订单是一个高层模块，下单需要发起支付，扣减库存等操作就是低层模块，订单服务应该依赖支付、库存服务的接口，而不是实现细节。当支付服务的规则有变更时，修改接口，所有的实现类都必须做相应的调整，否则编译会不通过，这就是<strong>实现依赖于抽象</strong>，低层依赖于高层，依赖倒置了。</p>
<p>为了满足依赖倒置原则，开发的时候尽量遵循如下规则：</p>
<ol>
<li>类尽量有抽象父类或接口。</li>
<li>变量、形参尽量是抽象类或接口。</li>
<li>尽量不要从具体类再派生出子类。</li>
<li>尽量不要重写基类方法，会影响依赖的稳定性。</li>
<li>结合里氏替换原则使用，可以用子类对象透明的代替基类对象。</li>
</ol>
<h3 id="接口隔离原则（降低复杂性）"><a href="#接口隔离原则（降低复杂性）" class="headerlink" title="接口隔离原则（降低复杂性）"></a>接口隔离原则（降低复杂性）</h3><ol>
<li><strong>客户端不应该依赖它不需要的接口。</strong></li>
<li><strong>类间的依赖关系应该建立在最小的接口上。</strong></li>
</ol>
<p>事例：博客系统中，普通用户只能查看博客，管理员可以增删改查，因此博客服务要分别为普通用户和管理员用户配置实现类，实现最小的接口。普通用户的博客服务类只有查询方法。</p>
<p>接口尽量细化，建立单一接口，避免定义过度“臃肿而庞大”的接口。要做到极致的接口隔离原则，就是一个接口只有一个方法，但是开发中我们绝不会这么去做，粒度太小了，导致接口数量剧增，难以开发。但是接口粒度太大灵活性会降低，所以如何定义好一个接口的粒度需要开发人员长期的实践和经验积累。</p>
<h3 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h3><p><strong>一个类应该对它<font color="red">依赖的类</font>了解的越少越好。</strong></p>
<p>迪米特法则的核心是：只与朋友交流。它的<font color="red">目的是减少类间的依赖，提高内聚，降低耦合</font>。 朋友类的定义：成员变量，方法的入参、出参属于朋友类，出现在方法体内部的则不是朋友类。一个类应该对其所依赖的类知道的越少越好，你的内部实现不管多复杂我并不关心，我只管调用你的<code>public</code>方法。</p>
<p>事例：简单工厂，通过不同的枚举类型，创建不同的产品。需要知道工厂类和枚举类，不符合最少知道原则。可使用多方法工厂模式解决，但是当需要添加新的产品的时候，需要修改工厂类，添加新的方法，因此违反了开闭原则</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>使用合成替换继承</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</strong>大白话就是：对于一个程序而言，应该通过扩展来实现需求变化，而不是修改现有的代码。</p>
<p>开闭原则的核心是：封装程序中变与不变的地方。用接口或抽象来封装规则，描述契约，这是基本稳定不变的，通过派生子类来实现细节，扩展功能，这是易变的，尽量依赖抽象，避免依赖实现。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/21/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">web基础知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-21 14:36:01" itemprop="dateCreated datePublished" datetime="2021-04-21T14:36:01+08:00">2021-04-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h2><p>1、请求次数不同；<br>2、重定向时地址栏会发生变化，而转发时地址栏不会发生变化；<br>3、重定向两次请求不共享数据，转发一次请求共享数据。<br>4、重定向方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(<span class="number">302</span>);<span class="comment">//[设置响应码为302，表示重定向]</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;http://www.baidu.com&quot;</span>);<span class="comment">//设置新请求的URL</span></span><br><span class="line"></span><br><span class="line">response.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);<span class="comment">//二种实现方式，原理一致</span></span><br></pre></td></tr></table></figure>

<h2 id="response响应正文"><a href="#response响应正文" class="headerlink" title="response响应正文"></a>response响应正文</h2><p>response是响应对象，向客户端输出响应正文（响应体）可以使用response的响应流，repsonse一共提供了两个响应流对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = response.getWriter()：<span class="comment">//获取字符流；如果响应正文内容为字符</span></span><br><span class="line">ServletOutputStream out = response.getOutputStream()：<span class="comment">//获取字节流；如果响应内容是字节，例如下载时</span></span><br></pre></td></tr></table></figure>

<p>注意，在一个请求中，不能同时使用这两个流！也就是说，要么你使用repsonse.getWriter()，要么使用response.getOutputStream()，但不能同时使用这两个流。不然会抛出IllegalStateException异常。</p>
<h2 id="字符响应流"><a href="#字符响应流" class="headerlink" title="字符响应流"></a>字符响应流</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>在使用response.getWriter()时需要注意默认字符编码为ISO-8859-1，如果希望设置字符流的字符编码为utf-8，可以使用response.setCharaceterEncoding(“utf-8”)来设置。这样可以保证输出给客户端的字符都是使用UTF-8编码的！但客户端浏览器并不知道响应数据是什么编码的！如果希望通知客户端使用UTF-8来解读响应数据，那么还是使用response.setContentType(“text/html;charset=utf-8”)方法比较好，因为这个方法不只会调用response.setCharaceterEncoding(“utf-8”)，还会设置content-type响应头，客户端浏览器会使用content-type头来解读响应数据。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>response.getWriter()是PrintWriter类型，所以它有缓冲区，缓冲区的默认大小为8KB。也就是说，在响应数据没有输出8KB之前，数据都是存放在缓冲区中，而不会立刻发送到客户端。当Servlet执行结束后，服务器才会去刷新流，使缓冲区中的数据发送到客户端。<br>如果希望响应数据马上发送给客户端：</p>
<ul>
<li>向流中写入大于8KB的数据；</li>
<li>调用response.flushBuffer()方法来手动刷新缓冲区；</li>
</ul>
<h2 id="设置响应头信息"><a href="#设置响应头信息" class="headerlink" title="设置响应头信息"></a>设置响应头信息</h2><p>可以使用response对象的setHeader()方法来设置响应头！使用该方法设置的响应头最终会发送给客户端浏览器！<br>response.setHeader(“content-type”, “text/html;charset=utf-8”)：设置content-type响应头，该头的作用是告诉浏览器响应内容为html类型，编码为utf-8。而且同时会设置response的字符流编码为utf-8，即response.setCharaceterEncoding(“utf-8”)；<br>response.setHeader(“Refresh”,”5; URL=<a href="http://www.baidu.com“)：5秒后自动跳转到百度主页。">http://www.baidu.com“)：5秒后自动跳转到百度主页。</a></p>
<h2 id="设置状态码及其他方法"><a href="#设置状态码及其他方法" class="headerlink" title="设置状态码及其他方法"></a>设置状态码及其他方法</h2><p>response.setContentType(“text/html;charset=utf-8”)：等同与调用response.setHeader(“content-type”, “text/html;charset=utf-8”)；<br>response.setCharacterEncoding(“utf-8”)：设置字符响应流的字符编码为utf-8；<br>response.setStatus(200)：设置状态码；<br>response.sendError(404, “您要查找的资源不存在”)：当发送错误状态码时，Tomcat会跳转到固定的错误页面去，但可以显示错误信息。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Elasticsearch入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 17:39:07" itemprop="dateCreated datePublished" datetime="2021-04-20T17:39:07+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ES版本"><a href="#ES版本" class="headerlink" title="ES版本"></a>ES版本</h2><h2 id="V5-x"><a href="#V5-x" class="headerlink" title="V5.x"></a><strong>V5.x</strong></h2><ul>
<li>Lucene 6.x,</li>
<li>性能提升，默认打分机制从 TF-IDF 改为 BM 25</li>
<li>支持 Ingest 节点、 Completion suggested 、Java REST 客户端</li>
<li>Type 标记成 deprecated,支持了 Keyword 的类型</li>
<li>性能优化<ul>
<li>减少了内部争竞争，防止对同一文档进行并发更新的竞争以及在同步事务日志时减少了锁定要求，索引吞吐量已得到了极大的提高</li>
<li>Instant Aggregations，在 Shard 层面提供了 Aggregation 缓存</li>
<li>新增了 Profile API</li>
</ul>
</li>
</ul>
<h2 id="V6-x"><a href="#V6-x" class="headerlink" title="V6.x"></a><strong>V6.x</strong></h2><ul>
<li>Lucene 7.x</li>
<li><strong>Removal of types，在 6.0 里面，开始不支持一个 index 里面存在多个 type</strong></li>
<li>跨多个Elasticsearch集群搜索，保留原来的索引在 5.x 群集，跨群集搜索来同时搜索 6.x 和 5.x 群集</li>
<li>跨群集复制（CCR）</li>
<li>更友好的的升级及数据迁移，在主要版本之间的迁移更为简化，体验升级</li>
<li>性能优化<ul>
<li>稀疏区域改进，降低了存储成本</li>
<li>通过索引排序，可加快排序的查询性能</li>
</ul>
</li>
</ul>
<h2 id="V7-x"><a href="#V7-x" class="headerlink" title="V7.x"></a><strong>V7.x</strong></h2><ul>
<li>Lucene 8.0</li>
<li><strong>重大改进-正式废除单个索引下多 Type 的支持（只有_doc这一个默认type）</strong></li>
<li>7.1开始，Security 功能免费使用</li>
<li>ECK，允许用户在 Kubernetes 上配置，管理和操作 Elasticsearch 集群</li>
<li>TransportClient 被废弃以至于，ES7 的 Java 代码，只能使用 restclient</li>
<li>新功能<ul>
<li>新的集群协调</li>
<li>功能更完善的 REST Client</li>
<li>Script Score Query，下一代的评分方式</li>
</ul>
</li>
<li>性能优化<ul>
<li>默认的 Primary Shard 数从 5 改为 1，避免 Over Sharding</li>
<li>性能优化，更快的 Top K 检索</li>
</ul>
</li>
</ul>
<h2 id="ES客户端"><a href="#ES客户端" class="headerlink" title="ES客户端"></a>ES客户端</h2><p>Elasticsearch(ES)有两种连接方式：TransportClient、RestClient。TransportClient通过TCP方式访问ES(只支持java),RestClient方式通过http<br>API 访问ES(没有语言限制)。</p>
<p>Elasticsearch计划在Elasticsearch<br>7.0中弃用TransportClient，在8.0中完全删除它。故在实际使用过程中建议您使用Java高级REST client。不管是transport client还是rest client都是线程安全的，都应该使用单例。</p>
<p>TransportClient: TransportClient<br>是ElasticSearch（java）客户端封装对象，使用transport远程连接到Elasticsearch集群，默认用的TCP端口是9300，该transport<br>node并不会加入集群，而是简单的向ElasticSearch集群上的节点发送请求。</p>
<p>Rest Client: Java Low Level REST Client：elasticsearch client<br>低级别客户端。它允许通过http请求与Elasticsearch集群进行通信。API本身不负责数据的编码解码，由用户去编码解码。它与所有的ElasticSearch版本兼容。</p>
<p>Java High Level REST Client：Elasticsearch<br>client官方高级客户端。基于低级客户端，它定义的API,已经对请求与响应数据包进行编码解码。</p>
<h2 id="ES索引生命周期管理"><a href="#ES索引生命周期管理" class="headerlink" title="ES索引生命周期管理"></a>ES索引生命周期管理</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6911843658006265863">索引生命周期管理方案</a><br><code>Elastic Stack 6.6</code> 版本后推出Index Lifecycle Management(索引生命周期管理)，支持针对索引的全生命周期托管管理，并且<code>Kibana</code> 上也提供了一套 UI 界面来配置策略。</p>
<h2 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h2><p> ES                       -&gt;                  数据库<br> 索引 index           -&gt;                  表<br> 文档 document    -&gt;                  行（记录）<br> 字段 fields           -&gt;                   列<br> 映射 mapping      -&gt;                  表结构<br> 近实时 NRT         -&gt;                  Near real time 近实时的搜索,从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级<br> 节点 node            -&gt;                  每一个服务器 </p>
<h3 id="集群相关概念"><a href="#集群相关概念" class="headerlink" title="集群相关概念"></a>集群相关概念</h3><p>分片（shard）：把索引库拆分为多份，分别放在不同的节点上，比如有3个节点，3个节点的所有数据内容加在一起是一个完整的索引库。分别保存到三个节点上水平扩展，提高吞吐量。每个shard都是一个lucene index。<br>备份（replica）：每个shard的备份。</p>
<p>shard = primary shard（主分片）<br>replica = replica shard（备份节点）</p>
<h3 id="倒排索引概念"><a href="#倒排索引概念" class="headerlink" title="倒排索引概念"></a>倒排索引概念</h3><p>也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。 它是文档检索系统中最常用的数据结构。<br> <strong>根据单词去搜索包含单词的文档，并且显示在文档中的词频（TF)和位置(POS)</strong></p>
<p><img src="/2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/8045c22ea2684a60aefb7871c2b37b4e~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p><img src="/2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/a03a9ef91555428fb1287d83cbf169f9~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h2 id="Elasticsearch-7-10-之-Search-shard-routing"><a href="#Elasticsearch-7-10-之-Search-shard-routing" class="headerlink" title="Elasticsearch 7.10 之 Search shard routing"></a>Elasticsearch 7.10 之 Search shard routing</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6908999948605112333">Search shard routing</a></p>
<h2 id="lucene"><a href="#lucene" class="headerlink" title="lucene"></a>lucene</h2><p>就是一个jar包，里面包含了封装好的各种建立倒排索引，以及进行搜索的代码，包括各种算法。我们就用java开发的时候，引入lucene jar，然后基于lucene的api进行去进行开发就可以了。用lucene，我们就可以去将已有的数据建立索引，lucene会在本地磁盘上面，给我们组织索引的数据结构。</p>
<p><img src="/2021/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E5%85%A5%E9%97%A8/0b9302f5543e4f1dab3ed0ab5c88fb7d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h2 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h2><p>分片机制：（我们之前随随便便就将一些document插入到es集群中去了，我们有没有care过数据怎么进行分片的，数据到哪个shard中去） </p>
<p>cluster discovery：（集群发现机制，我们再次启动一个es进程，这个进程作为一个node自动就发现了集群，并且加入了进去，还接受了部分数据，replica shard） </p>
<p>shard负载均衡：（举例，假设现在有3个节点，总共有25个shard要分配到3个节点上去，es会自动进行均匀分配，以保持每个节点的均衡的读写负载请求） </p>
<p>shard副本： 请求路由，集群扩容，shard重分配</p>
<p>增减或减少节点时的数据rebalance:保持负载均衡</p>
<p>master节点:创建或删除索引,增加或删除节点</p>
<p>节点平等的分布式架构:节点对等，每个节点都能接收所有的请求,自动请求路由,响应收集</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">订阅发布者模式和生产消费者模式区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 16:05:28" itemprop="dateCreated datePublished" datetime="2021-04-20T16:05:28+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>订阅发布者模式本质上也是一种生产者消费者模式，订阅者是消费者，发布者是生产者。如果一定要说个区别，就是抽象级别的区别吧。</p>
<p>订阅者肯定是个消费者，但消费者不一定是订阅者，发布者一定是个生产者，但生产者不一定是个发布者。</p>
<p><font color="red">订阅发布者模式有时也称为观察者模式</font>，订阅发布者（观察这和被观察者）存在着主动被动的关系，而生产者消费者比较中性吧。 订阅发布模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。而生产者消费者关系可以是1对1，1对多，多对1，多对多关系</p>
<p>补充：在23种设计模式中的观察者模式中，并没有中间介-队列的概念，但生产者消费者模式在多线程环境下好像天生就有队列的概念。在订阅发布者之间引入消息队列后，可以实现订阅者和发布者之间的解耦，任务可以很好的以异步方式进行处理，所以说是否有中间队列不是订阅发布者模式和生产者消费者模式的区别</p>
<p>那么到底什么是观察者模式呢. 先看看生活中的观察者模式。</p>
<p>好莱坞有句名言. “不要给我打电话， 我会给你打电话”. 这句话就解释了一个观察者模式的来龙去脉。 其中“我”是发布者， “你”是订阅者。</p>
<p>我来公司面试的时候，完事之后每个面试官都会对我说：“请留下你的联系方式， 有消息我们会通知你”。 在这里“我”是订阅者， 面试官是发布者。所以我不用每天或者每小时都去询问面试结果， 通讯的主动权掌握在了面试官手上。而我只需要提供一个联系方式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
