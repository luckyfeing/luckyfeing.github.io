<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/" class="post-title-link" itemprop="url">熔断限流隔离降级之Hystrix</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-19 15:25:08" itemprop="dateCreated datePublished" datetime="2021-05-19T15:25:08+08:00">2021-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/javaer_lee/article/details/87942816">Hystrix的线程池隔离和信号量隔离</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ming-blogs/p/14596721.html">Hystrix隔离区别</a></p>
<p><img src="/2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/image-20210527114240029.png" alt="image-20210527114240029"></p>
<p>信号量的调用是同步的，也就是说，每次调用都得阻塞调用方的线程，直到结果返回。这样就导致了无法对访问做超时（只能依靠调用协议超时，无法主动释放）</p>
<p><img src="/2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/image-20210527114658951.png" alt="image-20210527114658951"></p>
<p><img src="/2021/05/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BHystrix/image-20210714111632368.png" alt="image-20210714111632368"></p>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><ol>
<li>当Hystrix Command请求后端服务失败数量超过一定比例(默认50%)，断路器会切换到开路状态(Open)；此时所有请求会直接失败而不会发送到后端服务.；</li>
<li>断路器保持在开路状态一段时间后(默认5秒),，自动切换到半开路状态(HALF-OPEN)，这时熔断器只允许一个请求通过.；</li>
<li>当该请求调用成功时,，熔断器恢复到关闭状态， 若该请求失败, 熔断器继续保持打开状态,，接下来的请求被禁止通过；</li>
<li>如此循环反复</li>
</ol>
<h2 id="异步RPC"><a href="#异步RPC" class="headerlink" title="异步RPC"></a>异步RPC</h2><p>异步RPC主要目的是提高并发，比如你的接口，内部调用了3个服务，时间分别为T1, T2, T3。如果是顺序调用，则总时间是T1 + T2 + T3；如果并发调用，总时间是Max(T1,T2,T3)。</p>
<p>当然，这里有1个前提条件，这3个调用直接，互相不依赖。</p>
<p>同样，一般成熟的RPC框架，本身都提高了异步化接口，Future或者Callback形式。</p>
<p>同样，Hystrix也提高了同步调用、异步调用方式</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BSentinel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BSentinel/" class="post-title-link" itemprop="url">熔断限流隔离降级之Sentinel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-17 18:11:30" itemprop="dateCreated datePublished" datetime="2021-05-17T18:11:30+08:00">2021-05-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Sentinel 是面向分布式服务架构的高可用防护组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障微服务的稳定性。</p>
</blockquote>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。<br>在接下来的文档中，我们都会用资源来描述代码块。</p>
<p>只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p>
<h2 id="流量控制规则"><a href="#流量控制规则" class="headerlink" title="流量控制规则"></a>流量控制规则</h2><p>限流行为控制（流量控制）流量控制、整形</p>
<p><img src="/2021/05/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BSentinel/sentinel-flow-index-overview-cn.jpg" alt="img"></p>
<h3 id="流量控制有以下几个角度"><a href="#流量控制有以下几个角度" class="headerlink" title="流量控制有以下几个角度:"></a>流量控制有以下几个角度:</h3><p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；<br>运行指标，例如 QPS、线程池、系统负载等；<br>控制的效果，例如直接限流、冷启动、排队等。<br>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p>
<h2 id="隔离规则-流量控制"><a href="#隔离规则-流量控制" class="headerlink" title="隔离规则(流量控制)"></a>隔离规则(流量控制)</h2><p>服务隔离，避免影响到其它的资源，防止服务雪崩<br>隔离(流量控制)： 线程数(0: thread count)，qps(1: QPS)</p>
<ul>
<li><p>线程数（信号量）：当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p>
</li>
<li><p><code>QPS</code>（每秒请求数）：时间窗口内，请求的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rate limiter control behavior.</span></span><br><span class="line"><span class="comment"> * 0. default(reject directly), 1. warm up(冷启动), 2. rate limiter(匀速器,漏桶算法), 3. warm up + rate limiter</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/flow-control.html#%E5%9F%BA%E4%BA%8E%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">基于调用关系的流量控制</a></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flow control strategy based on invocation chain.  //流控策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RuleConstant#STRATEGY_DIRECT&#125; for direct flow control (by origin);  //调用方限流</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RuleConstant#STRATEGY_RELATE&#125; for relevant flow control (with relevant resource); //关联流量控制</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RuleConstant#STRATEGY_CHAIN&#125; for chain flow control (by entrance resource).  //链路限流</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="熔断规则"><a href="#熔断规则" class="headerlink" title="熔断规则"></a>熔断规则</h2><p>熔断降级，快速失败，避免影响到其它的资源，最终产生雪崩的效果（默认慢请求数量为5，默认最小请求数量为5）</p>
<ul>
<li>响应时间：通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</li>
<li>异常比例：</li>
<li>异常数：</li>
</ul>
<h2 id="权限规则"><a href="#权限规则" class="headerlink" title="权限规则"></a>权限规则</h2><p>AUTHORITY_WHITE  白名单规则<br>AUTHORITY_BLACK  黑名单规则</p>
<h2 id="系统负载保护规则"><a href="#系统负载保护规则" class="headerlink" title="系统负载保护规则"></a>系统负载保护规则</h2><p>Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。<br>在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p>
<p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/13/java%E4%B9%8B%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/13/java%E4%B9%8B%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">java之引用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-13 18:24:11" itemprop="dateCreated datePublished" datetime="2021-05-13T18:24:11+08:00">2021-05-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="java引用"><a href="#java引用" class="headerlink" title="java引用"></a>java引用</h2><ul>
<li>强引用：在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用：<code>SoftReference</code>用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常</li>
<li>弱引用：<code>WeakReference</code>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
<li>虚引用：<code>PhantomReference</code>也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知<br><img src="/2021/05/13/java%E4%B9%8B%E5%BC%95%E7%94%A8/647994-20170215235519441-1287012986.png" alt="img"></li>
</ul>
<h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><ul>
<li><p>弱引用的构造函数有二个，带引用队列的参数和不带引用队列的参数（<code>ReferenceQueue</code>）。如果带引用队列，当回收时，会将对象存入引用队列。</p>
</li>
<li><p>弱引用的构造函数有二个，带引用队列的参数和不带引用队列的参数（<code>ReferenceQueue</code>）。如果带引用队列，当回收时，会将对象存入引用队列。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BMicrometer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BMicrometer/" class="post-title-link" itemprop="url">监控之Micrometer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-12 15:04:02" itemprop="dateCreated datePublished" datetime="2021-05-12T15:04:02+08:00">2021-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Micrometer-简介"><a href="#Micrometer-简介" class="headerlink" title="Micrometer 简介"></a>Micrometer 简介</h2><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，它提供了多种度量指标类型（Timers、Guauges、Counters等），同时支持接入不同的监控系统，例如 Influxdb、Graphite、Prometheus 等。我们可以通过 Micrometer 收集 Java 性能数据，配合 Prometheus 监控系统实时获取数据，并最终在 Grafana 上展示出来，从而很容易实现应用的监控。</p>
<p>Micrometer 中有两个最核心的概念，分别是计量器（Meter）和计量器注册表（MeterRegistry）。计量器用来收集不同类型的性能指标信息，Micrometer 提供了如下几种不同类型的计量器：</p>
<ul>
<li>计数器（Counter）: 表示收集的数据是按照某个趋势（增加／减少）一直变化的，也是最常用的一种计量器，例如接口请求总数、请求错误总数、队列数量变化等。</li>
<li>计量仪（Gauge）: 表示搜集的瞬时的数据，可以任意变化的，例如常用的 CPU Load、Mem 使用量、Network 使用量、实时在线人数统计等，</li>
<li>计时器（Timer）: 用来记录事件的持续时间，这个用的比较少。</li>
<li>分布概要（Distribution summary）: 用来记录事件的分布情况，表示一段时间范围内对数据进行采样，可以用于统计网络请求平均延迟、请求延迟占比等。</li>
</ul>
<h2 id="MeterRegistry"><a href="#MeterRegistry" class="headerlink" title="MeterRegistry"></a>MeterRegistry</h2><p>MeterRegistry在Micrometer是一个抽象类，主要实现包括：</p>
<ul>
<li>SimpleMeterRegistry：每个Meter的最新数据可以收集到SimpleMeterRegistry实例中，但是这些数据不会发布到其他系统，也就是数据是位于应用的内存中的。</li>
<li>CompositeMeterRegistry：多个MeterRegistry聚合，内部维护了一个MeterRegistry的列表。</li>
<li>全局的MeterRegistry：工厂类io.micrometer.core.instrument.Metrics中持有一个静态final的CompositeMeterRegistry实例globalRegistry。</li>
</ul>
<blockquote>
<p>使用者也可以自行继承MeterRegistry去实现自定义的MeterRegistry。</p>
</blockquote>
<p>SimpleMeterRegistry适合做调试的时候使用，它的简单使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MeterRegistry registry = <span class="keyword">new</span> SimpleMeterRegistry();</span><br><span class="line">Counter counter = registry.counter(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">counter.increment();</span><br></pre></td></tr></table></figure>

<p>CompositeMeterRegistry实例初始化的时候，内部持有的MeterRegistry列表是空的，如果此时用它新增一个Meter实例，Meter实例的操作是无效的</p>
<p>CompositeMeterRegistry实例初始化的时候，内部持有的MeterRegistry列表是空的，如果此时用它新增一个Meter实例，Meter实例的操作是无效的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompositeMeterRegistry composite = <span class="keyword">new</span> CompositeMeterRegistry();</span><br><span class="line">Counter compositeCounter = composite.counter(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">compositeCounter.increment(); <span class="comment">// &lt;- 实际上这一步操作是无效的,但是不会报错</span></span><br><span class="line"></span><br><span class="line">SimpleMeterRegistry simple = <span class="keyword">new</span> SimpleMeterRegistry();</span><br><span class="line">composite.add(simple); <span class="comment">// &lt;- 向CompositeMeterRegistry实例中添加SimpleMeterRegistry实例</span></span><br><span class="line"></span><br><span class="line">compositeCounter.increment(); <span class="comment">// &lt;-计数成功</span></span><br></pre></td></tr></table></figure>

<p>全局的MeterRegistry的使用方式更加简单便捷，因为一切只需要操作工厂类Metrics的静态方法：</p>
<p>全局的MeterRegistry的使用方式更加简单便捷，因为一切只需要操作工厂类Metrics的静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">Counter counter = Metrics.counter(<span class="string">&quot;counter&quot;</span>, <span class="string">&quot;tag-1&quot;</span>, <span class="string">&quot;tag-2&quot;</span>);</span><br><span class="line">counter.increment();</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20161461/article/details/109049911">Micrometer集成 Prometheus 监控 Java 应用性能</a></p>
<p><img src="/2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BMicrometer/image-20210728141151918.png" alt="image-20210728141151918"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8B%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8B%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">熔断限流隔离降级之对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-12 14:54:11" itemprop="dateCreated datePublished" datetime="2021-05-12T14:54:11+08:00">2021-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Hystrix具有的功能"><a href="#Hystrix具有的功能" class="headerlink" title="Hystrix具有的功能"></a><strong>Hystrix具有的功能</strong></h2><ul>
<li>线程池隔离/信号量隔离    Sentinel 不支持线程池隔离；信号量隔离对应 Sentinel 中的线程数限流。</li>
<li>熔断器    Sentinel 支持按平均响应时间、异常比率、异常数来进行熔断降级。</li>
<li>Command 创建    直接使用 Sentinel SphU API 定义资源即可，资源定义与规则配置分离。</li>
<li>规则配置    在 Sentinel 中可通过 API 硬编码配置规则，也支持多种动态规则源</li>
<li>注解支持    Sentinel 也提供注解支持</li>
<li>开源框架支持    Sentinel 提供 Servlet、Dubbo、Spring Cloud、gRPC 的适配模块，开箱即用；若之前使用 Spring Cloud Netflix，可迁移至 Spring Cloud Alibaba</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">Sentinel</th>
<th align="left">Hystrix</th>
<th align="left">Resilience4j</th>
</tr>
</thead>
<tbody><tr>
<td align="left">隔离策略</td>
<td align="left">信号量隔离（并发线程数限流），QPS</td>
<td align="left">线程池隔离/信号量隔离</td>
<td align="left">信号量隔离/线程池</td>
</tr>
<tr>
<td align="left">熔断降级策略</td>
<td align="left">基于响应时间、异常比率、异常数</td>
<td align="left">基于异常比率</td>
<td align="left">基于异常比率、响应时间</td>
</tr>
<tr>
<td align="left">实时统计实现</td>
<td align="left">滑动窗口（LeapArray）</td>
<td align="left">滑动窗口（基于 RxJava）</td>
<td align="left">Ring Bit Buffer</td>
</tr>
<tr>
<td align="left">动态规则配置</td>
<td align="left">支持多种数据源</td>
<td align="left">支持多种数据源</td>
<td align="left">有限支持</td>
</tr>
<tr>
<td align="left">扩展性</td>
<td align="left">多个扩展点</td>
<td align="left">插件的形式</td>
<td align="left">接口的形式</td>
</tr>
<tr>
<td align="left">基于注解的支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">限流</td>
<td align="left">基于 QPS，支持基于调用关系的限流</td>
<td align="left">有限的支持</td>
<td align="left">Rate Limiter（信号量、令牌桶）</td>
</tr>
<tr>
<td align="left">流量整形</td>
<td align="left">支持预热模式、匀速器模式、预热排队模式(流量规则处可配置)</td>
<td align="left">不支持</td>
<td align="left">简单的 Rate Limiter 模式</td>
</tr>
<tr>
<td align="left">系统自适应保护</td>
<td align="left">支持</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">控制台</td>
<td align="left">提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td>
<td align="left">简单的监控查看</td>
<td align="left">不提供控制台，可对接其它监控系统</td>
</tr>
</tbody></table>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7">https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">https://github.com/Netflix/Hystrix/wiki/How-it-Works</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/Guideline:-%E4%BB%8E-Hystrix-%E8%BF%81%E7%A7%BB%E5%88%B0-Sentinel#%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94">https://github.com/alibaba/Sentinel/wiki/Guideline:-%E4%BB%8E-Hystrix-%E8%BF%81%E7%A7%BB%E5%88%B0-Sentinel#%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BResilience4j%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%9A%94%E7%A6%BB%E9%99%8D%E7%BA%A7%E4%B9%8BResilience4j%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">熔断限流隔离降级之Resilience4j入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-12 13:34:24" itemprop="dateCreated datePublished" datetime="2021-05-12T13:34:24+08:00">2021-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="重要参考资料"><a href="#重要参考资料" class="headerlink" title="重要参考资料"></a>重要参考资料</h2><p><a target="_blank" rel="noopener" href="https://resilience4j.readme.io/docs">官网</a><br><strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5531b66b777a">Resilience4j-轻量级熔断框架</a></strong> </p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><ul>
<li><strong><em>resilience4j-circuitbreaker: Circuit breaking</em></strong> 熔断器（超过故障率的熔断）</li>
<li><strong><em>resilience4j-ratelimiter: Rate limiting</em></strong>  限流（高频控制是可以限制服务调用频率）一个是基于信号量的，一个是基于令牌桶的</li>
<li><strong><em>resilience4j-bulkhead: Bulkheading</em></strong>    一种是基于信号量的*<strong>Bulkhead**<em>，另一种是基于有等待队列的固定大小的线程池</em></strong>ThreadPoolBulkhead***的（降级）</li>
<li><strong><em>resilience4j-retry: Automatic retrying (sync and async)</em></strong>   重试</li>
<li><strong><em>resilience4j-cache: Result caching</em></strong></li>
<li><strong><em>resilience4j-timelimiter: Timeout handling</em></strong>  超时控制器（）</li>
</ul>
<h2 id="监控模块"><a href="#监控模块" class="headerlink" title="监控模块"></a>监控模块</h2><ul>
<li>resilience4j-micrometer: Micrometer Metrics exporter</li>
<li>resilience4j-metrics: Dropwizard Metrics exporter</li>
<li>resilience4j-prometheus: Prometheus Metrics exporter</li>
</ul>
<h2 id="熔断-CircuitBreaker"><a href="#熔断-CircuitBreaker" class="headerlink" title="熔断 CircuitBreaker"></a>熔断 CircuitBreaker</h2><p><code>CircuitBreaker</code>通过具有三种正常状态的有限状态机实现：CLOSED，OPEN和HALF_OPEN以及两个特殊状态DISABLED和FORCED_OPEN。当熔断器关闭时，所有的请求都会通过熔断器。如果失败率超过设定的阈值，熔断器就会从关闭状态转换到打开状态，这时所有的请求都会被拒绝。当经过一段时间后，熔断器会从打开状态转换到半开状态，这时仅有一定数量的请求会被放入，并重新计算失败率，如果失败率超过阈值，则变为打开状态，如果失败率低于阈值，则变为关闭状态。</p>
<p>可以在注解上使用属性：<code>fallbackMethod = &quot;getDefaultGirlById&quot;</code>指定降级的方法</p>
<h2 id="RateLimiter、Bulkhead、Retry详解"><a href="#RateLimiter、Bulkhead、Retry详解" class="headerlink" title="RateLimiter、Bulkhead、Retry详解"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36b381e2b57e">RateLimiter、Bulkhead、Retry详解</a></h2><h3 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a><code>RateLimiter</code></h3><ul>
<li><code>SemaphoreBasedRateLimiter</code>使用一个计数信号量，当请求超过计数值，则在超时时间内等待，基于*<strong>java concurrent**<em>并发包中的</em></strong>Semaphore***实现</li>
<li><code>AtomicRateLimiter</code> 令牌桶</li>
</ul>
<p>令牌桶是*<strong>RateLimeter**<em>默认的实现，它的好处是比信号量的</em></strong>RateLimeter*<strong>更高效，因为桶中的令牌可以被减为负数，它会提前计算在限定时间内能否拿到令牌，而不是信号量为**<em>0</em></strong>之后就一直阻塞。</p>
<h3 id="Bulkhead"><a href="#Bulkhead" class="headerlink" title="Bulkhead"></a><code>Bulkhead</code></h3><ul>
<li>信号量*<strong>Bulkhead**<em>,基于</em></strong>java concurrent*<strong>并发包中的**<em>Semaphore</em></strong>实现</li>
<li>固定线程池*<em>ThreadPoolBulkhead**</em></li>
</ul>
<h3 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a><code>Retry</code></h3><p>一种实现类</p>
<h2 id="降级-Fallback"><a href="#降级-Fallback" class="headerlink" title="降级 Fallback"></a>降级 Fallback</h2><p><code>fallback</code>和前面讲解的组件不同，它不是组件，只是Resilience4j里面都会用到的方法。不管是熔断、重试、流控还是隔离等，一旦触发的限制规则，都可以降级执行我们定义好的降级方法。</p>
<p>Try 有 isFailure() 和 isSuccess() ，返回Boolean值，用来判断 Resilience4j 是否成功。</p>
<p>Try接口有个默认的方法recover，用来实现fallback，它首先判断是不是方法调用失败，如果是才执行fallback方法。例如上文的Bulkhead的代码，可以设置降级时返回错误日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try&lt;String&gt; result = Try.of(decoratedSupplier)</span><br><span class="line">               .recover(throwable -&gt; <span class="string">&quot;错误日志为：&quot;</span>+throwable.getMessage());</span><br><span class="line">       <span class="keyword">return</span> result.get();</span><br></pre></td></tr></table></figure>

<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//断路器监控</span></span><br><span class="line">CircuitBreaker.Metrics metrics = circuitBreaker.getMetrics();</span><br><span class="line"><span class="comment">// 获取故障率</span></span><br><span class="line"><span class="keyword">float</span> failureRate = metrics.getFailureRate();</span><br><span class="line"><span class="comment">// 获取调用失败次数</span></span><br><span class="line"><span class="keyword">int</span> failedCalls = metrics.getNumberOfFailedCalls();</span><br><span class="line"><span class="comment">// Returns the failure rate in percentage.</span></span><br><span class="line"><span class="keyword">float</span> failureRate = metrics.getFailureRate();</span><br><span class="line"><span class="comment">// Returns the current number of buffered calls.</span></span><br><span class="line"><span class="keyword">int</span> bufferedCalls = metrics.getNumberOfBufferedCalls();</span><br><span class="line"><span class="comment">// Returns the current number of failed calls.</span></span><br><span class="line"><span class="keyword">int</span> failedCalls = metrics.getNumberOfFailedCalls();</span><br><span class="line"><span class="comment">// Returns the current number of successed calls.</span></span><br><span class="line"><span class="keyword">int</span> successCalls = metrics.getNumberOfSuccessfulCalls();</span><br><span class="line"><span class="comment">// Returns the max number of buffered calls.</span></span><br><span class="line"><span class="keyword">int</span> maxBufferCalls = metrics.getMaxNumberOfBufferedCalls();</span><br><span class="line"><span class="comment">// Returns the current number of not permitted calls.</span></span><br><span class="line"><span class="keyword">long</span> notPermittedCalls = metrics.getNumberOfNotPermittedCalls();</span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a target="_blank" rel="noopener" href="https://github.com/wangchao1980/demo-resilience4j">基于注解实现</a></p>
<ul>
<li>@CircuitBreaker(name = “girl”, fallbackMethod = “getDefaultGirlById”)</li>
<li>@RateLimiter(name = “girl”)</li>
<li>@Bulkhead(name = “girl”)</li>
<li>@Retry(name = “girl”) 放在类上</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022908483">java编程式使用</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/07/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/07/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java之哈希冲突详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-07 10:01:18" itemprop="dateCreated datePublished" datetime="2021-05-07T10:01:18+08:00">2021-05-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="如何解决哈希冲突"><a href="#如何解决哈希冲突" class="headerlink" title="如何解决哈希冲突"></a><strong>如何解决哈希冲突</strong></h2><p><strong>1 开放寻址法</strong></p>
<p>开放寻址得核心思想是，如果出现散列冲突，我们就重新探测一个空闲位置，将其插入。</p>
<p><strong>开放寻址方法一：线性探测</strong><br><strong>开放寻址方法二：二次探测</strong><br><strong>开放寻址方法三：双重散列</strong></p>
<p><strong>2 链表法</strong></p>
<p>扩展1：word文档中单词拼写如何实现</p>
<p>常用得英文单词有20w个左右，假设单词得平均长度是10个字母，平均一个单词占用10个字节得内存空间，那20w也才2MB左右，就算扩大10倍也才20MB.对于现在得计算机来说，这个大小完全可以放在内存里面，所以我们可以用散列表来存储整个英文单词词典，当用于输入某个英文单词得时候，我们拿用户输入得单词去散列表中查找，如果查到，则说明拼写正确，如果没有查找到，则说明查找可能有误给与提示，借助散列表这种数据结构，我们就可以轻松实现快速判读是否存在拼写错误。</p>
<p>扩展2：假设我们有10w条url访问日志，如何按照访问次数给url排序</p>
<p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p>
<p>扩展3：有两个字符串数组，每个数组大约有10w条字符串，如何快速找到两个数组中相同得字符串</p>
<p>将一个字符串数组作为一个散列表，然后用另一个字符串数组得查找，如果有则找到，没有位NULL。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38635597/article/details/88692008">https://blog.csdn.net/qq_38635597/article/details/88692008</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/java%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/06/java%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java之ThreadLocal详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-06 09:54:10" itemprop="dateCreated datePublished" datetime="2021-05-06T09:54:10+08:00">2021-05-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ThreadLocal解读"><a href="#ThreadLocal解读" class="headerlink" title="ThreadLocal解读"></a><a target="_blank" rel="noopener" href="https://juejin.cn/post/6950541060892262431">ThreadLocal解读</a></h2><p>每<code>Thread</code>维护一个<code>ThreadLocal.ThreadLocalMap</code>类型的变量<code>threadLocals</code>和 <code>ThreadLocal.ThreadLocalMap inheritableThreadLocals</code>。而<code>ThreadLocalMap</code>是<code>ThreadLocal</code>内部类，<code>ThreadLocalMap</code>内部又有一个继承了<code>WeakReference</code>的内部类<code>Entry</code>，存放<code>key-valued</code>的，从继承关系看<code>key</code>是<code>ThreadLocal</code>类型的对象引用，且是弱引用（<strong>记住<code>key</code>是弱引用很关键</strong>）。ThreadLocalMap使用开放寻址的方式解决哈希冲突。</p>
<p><em>解决哈希冲突的办法：开放寻址 和链表</em></p>
<ul>
<li><code>ThreadLocal</code>让每个线程访问自己本地的变量来确保线程安全。</li>
<li>每一个线程维护一个<code>ThreadLocalMap</code>，简易版的<code>HashMap</code>，<code>key</code>为<code>ThradLocal</code>实例引用，解决哈希冲突的方式是开放寻址法，所以不适合存大量数据。</li>
<li>get和set过程中都会清理过时的数据（key=null），为了防止内存泄漏，但是不一定会清理掉所有的过时数据，不然会影响正常操作性能。</li>
<li>使用完<code>ThreadLocal</code>一定要调用<code>remove</code>，不然会内存泄漏，因为key是弱引用会被下次gc，而value的强引用会一直存在，若线程一直不销毁，value就一直不gc掉，导致内存泄漏。</li>
</ul>
<h2 id="InheritableThreadLocal源码解析"><a href="#InheritableThreadLocal源码解析" class="headerlink" title="InheritableThreadLocal源码解析"></a><a target="_blank" rel="noopener" href="https://juejin.cn/post/6950543994166181924">InheritableThreadLocal源码解析</a></h2><p>Thread初始化，会调用一个<code>init()</code>。当父类的<code>inheritableThreadLocals</code>不为null，会将父线程的map复制给子线程</p>
<ul>
<li><code>InheritableThreadLocal</code>可以实现子线程获取父线程的本地变量。</li>
<li>子线程初始化时，若父线程（当前线程）的本地变量<code>inheritableThreadLocals</code>不为null，则复制给子线程。</li>
<li><code>ThreadLocal</code>留个<code>childValue</code>的用意，就是让<code>InheritableThreadLocal</code>实现，并且可以让客户端自定义重写<code>childValue</code>对从父线程复制到子线程的值做特殊处理。</li>
<li>若父线程使用<code>InheritableThreadLocal</code>设置了自定义引用类型的值，复制给子线程时存在并发问题，需要自行实现<code>childValue</code>的深拷贝。</li>
</ul>
<p>如果使用线程池创建子线程，子线程只会初始化一次，父线程中使用<code>InheritableThreadLocal</code>设置值，因为复制机制是在线程初始化的时候，那么父线程只有在线程池初始化子线程时同步复制一次数据，后续父线程再修改值，就无法同步更新到线程池中的子线程了，这该怎么办呢？</p>
<p>只要在每次提交任务时复制就可以了，这就要对线程池以及<code>InheritableThreadLocal</code>做一些定制化处理，让复制机制放在每次提交任务的时候，阿里有一个开源项目给出了解决方案</p>
<h2 id="TransmittableThreadLocal原理"><a href="#TransmittableThreadLocal原理" class="headerlink" title="TransmittableThreadLocal原理"></a><a target="_blank" rel="noopener" href="https://github.com/alibaba/transmittable-thread-local">TransmittableThreadLocal原理</a></h2><p><code>JDK</code>的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/10/docs/api/java/lang/InheritableThreadLocal.html"><code>InheritableThreadLocal</code></a>类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong>。</p>
<p>本库提供的<a target="_blank" rel="noopener" href="https://github.com/alibaba/transmittable-thread-local/blob/master/src/main/java/com/alibaba/ttl/TransmittableThreadLocal.java"><code>TransmittableThreadLocal</code></a>类继承并加强<code>InheritableThreadLocal</code>类，解决上述的问题</p>
<p>整个<code>TransmittableThreadLocal</code>库的核心功能（用户<code>API</code>与框架/中间件的集成<code>API</code>、线程池<code>ExecutorService</code>/<code>ForkJoinPool</code>/<code>TimerTask</code>及其线程工厂的<code>Wrapper</code>）</p>
<p><code>ThreadLocal</code>的需求场景即<code>TransmittableThreadLocal</code>的潜在需求场景，如果你的业务需要『在使用线程池等会池化复用线程的执行组件情况下传递<code>ThreadLocal</code>值』则是<code>TransmittableThreadLocal</code>目标场景。</p>
<p>下面是几个典型场景例子。</p>
<ol>
<li>分布式跟踪系统 或 全链路压测（即链路打标）</li>
<li>日志收集记录系统上下文</li>
<li><code>Session</code>级<code>Cache</code></li>
<li>应用容器或上层框架跨应用代码给下层<code>SDK</code>传递信息</li>
</ol>
<p>使用类<a target="_blank" rel="noopener" href="https://github.com/alibaba/transmittable-thread-local/blob/master/src/main/java/com/alibaba/ttl/TransmittableThreadLocal.java"><code>TransmittableThreadLocal</code></a>来保存值，并跨线程池传递。</p>
<p><code>TransmittableThreadLocal</code>继承<code>InheritableThreadLocal</code>，使用方式也类似。相比<code>InheritableThreadLocal</code>，添加了</p>
<ol>
<li><code>copy</code>方法<br>用于定制 <strong>任务提交给线程池时</strong> 的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong> 的拷贝行为，缺省传递的是引用。<br>注意：如果跨线程传递了对象引用因为不再有线程封闭，与<code>InheritableThreadLocal.childValue</code>一样，使用者/业务逻辑要注意传递对象的线程安全。</li>
<li><code>protected</code>的<code>beforeExecute</code>/<code>afterExecute</code>方法<br>执行任务(<code>Runnable</code>/<code>Callable</code>)的前/后的生命周期回调，缺省是空操作。</li>
</ol>
<h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/thewindkee/article/details/89390145">为什么使用弱引用</a></h2><p>从表面上看，发生内存泄漏，是因为Key使用了弱引用类型。但其实是因为整个Entry的key为null后，没有主动清除value导致。很多文章大多分析ThreadLocal使用了弱引用会导致内存泄漏，但为什么使用弱引用而不是强引用？</p>
<p>下面我们分两种情况讨论：</p>
<ul>
<li>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li>
<li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</li>
</ul>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。</p>
<p><font color="red"><strong>当threadLocal 不为静态变量，且被回收的时候才会导致weakRef为null。</strong></font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BMESI%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BMESI%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">java之并发编程-MESI缓存一致性协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-29 14:30:19" itemprop="dateCreated datePublished" datetime="2021-04-29T14:30:19+08:00">2021-04-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6878226618318323726">https://juejin.cn/post/6878226618318323726</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanlong300/p/8986041.html?utm_source=so">https://www.cnblogs.com/yanlong300/p/8986041.html?utm_source=so</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">java之并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-29 13:24:13" itemprop="dateCreated datePublished" datetime="2021-04-29T13:24:13+08:00">2021-04-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="多任务和高并发的内存交互"><a href="#多任务和高并发的内存交互" class="headerlink" title="多任务和高并发的内存交互"></a>多任务和高并发的内存交互</h2><p>多任务和高并发是衡量一台计算机处理器的能力重要指标之一。一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。<strong>物理机</strong>的并发问题与<strong>虚拟机</strong>中的情况有很多相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p>
<h2 id="硬件内存模型"><a href="#硬件内存模型" class="headerlink" title="硬件内存模型"></a>硬件内存模型</h2><p>由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的<strong>高速缓存（cache）</strong>来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。</p>
<p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：<strong>缓存一致性（Cache Coherence）</strong>。</p>
<p>在早期通过总线上加LOCK#锁的形式来解决缓存不一致的问题。因为<font color="red">CPU和其他部件进行通信都是通过总线来进行的</font>，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。<font color="red">由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</font></p>
<p>在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、Intel 的MESI、MOSI及Dragon Protocol等。MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。<a target="_blank" rel="noopener" href="https://juejin.cn/post/6878226618318323726">MESI缓存一致性协议详解</a></p>
<p><img src="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20160507133204381" alt="物理机内存交互关系"></p>
<p>除此之外，为了使得处理器内部的运算单元能尽可能被充分利用，处理器可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）</strong>优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的<strong>指令重排序（Instruction Recorder）</strong>优化。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a><font color="red">Java内存模型</font></h2><p>内存模型可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象，不同架构下的物理机拥有不一样的内存模型，Java虚拟机也有自己的内存模型，即<strong>Java内存模型（Java Memory Model, <code>JMM</code>）</strong>。在C/C++语言中直接使用物理硬件和操作系统内存模型，导致不同平台下并发访问出错。而JMM的出现，能够屏蔽掉各种硬件和操作系统的内存访问差异，实现平台一致性，是的Java程序能够<strong>“一次编写，到处运行”。</strong></p>
<p>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题.是一个抽象的概念.</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>Java内存模型的主要目标是<strong>定义程序中各个变量的访问规则</strong>，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。</p>
<p>Java内存模型中规定了所有的变量都存储在主内存（物理内存）中，每条线程还有自己的工作内存（可以与前面讲的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。</p>
<p><img src="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20160507135725155" alt="img"></p>
<p><font color="red">注意：这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分，这两者基本上没有关系。</font></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>由上面的交互关系可知，关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述两个操作<strong>必须按顺序执行，而没有保证必须是连续执行</strong>。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。</p>
<p><font color="cornflowerblue">Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</font></p>
<ul>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<p><font color="red">这8种内存访问操作很繁琐，后文会使用一个等效判断原则，即先行发生（happens-before）原则来确定一个内存访问在并发环境下是否安全。</font></p>
<h2 id="happen-before原则"><a href="#happen-before原则" class="headerlink" title="happen-before原则"></a>happen-before原则</h2><p><font color="red">前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。</font></p>
<p><font color="red">为了解决多线程的可见性问题，就搞出了happens-before原则，让线程之间遵守这些原则。编译器还会优化我们的语句，所以等于是给了编译器优化的约束。</font></p>
<p><font color="red"><strong>JVM会对代码进行编译优化，会出现指令重排序情况</strong>，为了避免编译优化对并发编程安全性的影响，<strong>需要happens-before规则定义一些禁止编译优化的场景</strong>，保证并发编程的正确性。</font></p>
<p>熟悉 Java 并发编程的都知道，JMM(Java 内存模型) 中的 happen-before(简称 hb)规则，该规则定义了 Java 多线程操作的有序性和可见性，防止了编译器重排序对程序结果的影响。<strong>按照官方的说法：</strong></p>
<p>当一个变量被多个线程读取并且至少被一个线程写入时，如果读操作和写操作没有 HB 关系，则会产生数据竞争问题。 要想保证<code>操作 B</code> 的线程看到<code>操作 A</code> 的结果（无论 <code>A</code> 和 <code>B</code> 是否在一个线程），那么在 <code>A</code> 和 <code>B</code> 之间必须满足 HB 原则，如果没有，将有可能导致重排序。 当缺少 happen-before 关系时，就可能出现重排序问题。原则如下：</p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：在监视器锁上的解锁操作必须在同一个监视器上的加锁操作之前执行。</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li><strong>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</strong></li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ol>
<p><strong>实现可见性的原理则是 cache protocol 和 memory barrier。通过缓存一致性协议和内存屏障实现可见性。</strong></p>
<p><font color="red">happen-before 原则是 JMM 的核心所在，只有满足了 hb 原则才能保证有序性和可见性，否则编译器将会对代码重排序。hb 甚至将 lock 和 volatile 也定义了规则。</font></p>
<h2 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h2><p>关键字volatile是JVM中最轻量的同步机制。volatile变量具有2种特性：</p>
<ul>
<li>保证变量的可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入，这个新值对于其他线程来说是立即可见的。</li>
<li>屏蔽指令重排序：指令重排序是编译器和处理器为了高效对程序进行优化的手段，下文有详细的分析。</li>
</ul>
<p>volatile语义并不能保证变量的原子性。对任意单个volatile变量的读/写具有原子性，但类似于i++、i–这种复合操作不具有原子性，因为自增运算包括读取i的值、i值增加1、重新赋值3步操作，并不具备原子性。</p>
<p>由于volatile只能保证变量的可见性和屏蔽指令重排序，只有满足下面2条规则时，才能使用volatile来保证并发安全，否则就需要加锁（使用synchronized、lock或者java.util.concurrent中的Atomic原子类）来保证并发中的原子性。</p>
<ul>
<li>运算结果不存在数据依赖（重排序的数据依赖性），或者只有单一的线程修改变量的值（重排序的as-if-serial语义）</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<p>因为需要在本地代码中插入许多内存屏蔽指令在屏蔽特定条件下的重排序，volatile变量的写操作与读操作相比慢一些，但是其性能开销比锁低很多。</p>
<h2 id="long-double非原子协定"><a href="#long-double非原子协定" class="headerlink" title="long/double非原子协定"></a>long/double非原子协定</h2><p>JMM要求lock、unlock、read、load、assign、use、store、write这8个操作都必须具有原子性，但对于64为的数据类型（long和double，具有非原子协定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为2次32位操作进行。（与此类似的是，在栈帧结构的局部变量表中，long和double类型的局部变量可以使用2个能存储32位变量的变量槽（Variable Slot）来存储的，关于这一部分的详细分析，详见详见周志明著《深入理解Java虚拟机》8.2.1节）</p>
<p>如果多个线程共享一个没有声明为volatile的long或double变量，并且同时读取和修改，某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。不过这种情况十分罕见。因为非原子协议换句话说，同样允许long和double的读写操作实现为原子操作，并且目前绝大多数的虚拟机都是这样做的。</p>
<h2 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>JMM保证的原子性变量操作包括read、load、assign、use、store、write，而long、double非原子协定导致的非原子性操作基本可以忽略。如果需要对更大范围的代码实行原子性操作，则需要JMM提供的lock、unlock、synchronized等来保证。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>前面分析volatile语义时已经提到，可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。JMM在变量修改后将新值同步回主内存，依赖主内存作为媒介，在变量被线程读取前从内存刷新变量新值，保证变量的可见性。普通变量和volatile变量都是如此，只不过volatile的特殊规则保证了这种可见性是立即得知的，而普通变量并不具备这种严格的可见性。除了volatile外，synchronized和final也能保证可见性。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>JMM的有序性表现为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指“线程内表现为串行的语义”（as-if-serial），后半句值“指令重排序”和普通变量的”工作内存与主内存同步延迟“的现象。</p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。从硬件架构上来说，指令重排序是指CPU采用了允许将多条指令不按照程序规定的顺序，分开发送给各个相应电路单元处理，而不是指令任意重排。重排序分成三种类型：</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p><img src="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20160507141035261" alt="重排序"></p>
<h3 id="JMM的重排序屏障"><a href="#JMM的重排序屏障" class="headerlink" title="JMM的重排序屏障"></a>JMM的重排序屏障</h3><p>从Java源代码到最终实际执行的指令序列，会经过三种重排序。但是，为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。对于编译器的重排序，JMM会根据重排序规则禁止特定类型的编译器重排序；对于处理器重排序，JMM会插入特定类型的内存屏障，通过内存的屏障指令禁止特定类型的处理器重排序。这里讨论JMM对处理器的重排序，为了更深理解JMM对处理器重排序的处理，先来认识一下常见处理器的重排序规则：</p>
<p><img src="/2021/04/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20160507142016867" alt="重排序屏障"></p>
<p>其中的N标识处理器不允许两个操作进行重排序，Y表示允许。其中Load-Load表示读-读操作、Load-Store表示读-写操作、Store-Store表示写-写操作、Store-Load表示写-读操作。可以看出：常见处理器对写-读操作都是允许重排序的，并且常见的处理器都不允许对存在数据依赖的操作进行重排序（对应上面数据转换那一列，都是N，所以处理器不允许这种重排序）。</p>
<h4 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h4><p>那么这个结论对我们有什么作用呢？比如第一点：处理器允许写-读操作两者之间的重排序，那么在并发编程中读线程读到可能是一个未被初始化或者是一个NULL等，出现不可预知的错误，基于这点，JMM会在适当的位置插入内存屏障指令来禁止特定类型的处理器的重排序。内存屏障指令一共有4类：</p>
<ul>
<li>LoadLoad Barriers：确保Load1数据的装载先于Load2以及所有后续装载指令</li>
<li>StoreStore Barriers：确保Store1的数据对其他处理器可见（会使缓存行无效，并刷新到内存中）先于Store2及所有后续存储指令的装载</li>
<li>LoadStore Barriers：确保Load1数据装载先于Store2及所有后续存储指令刷新到内存</li>
<li>StoreLoad Barriers：确保Store1数据对其他处理器可见（刷新到内存，并且其他处理器的缓存行无效）先于Load2及所有后续装载指令的装载。该指令会使得该屏障之前的所有内存访问指令完成之后，才能执行该屏障之后的内存访问指令。</li>
</ul>
<blockquote>
<p><strong>写屏障 Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，应用所有已经在存储缓存（store buffer）中的保存的指令。</strong></p>
</blockquote>
<blockquote>
<p><strong>读屏障Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先应用所有已经在失效队列中的失效操作的指令。</strong></p>
</blockquote>
<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>根据上面的表格，处理器不会对存在数据依赖的操作进行重排序。这里数据依赖的准确定义是：如果两个操作同时访问一个变量，其中一个操作是写操作，此时这两个操作就构成了数据依赖。常见的具有这个特性的如i++、i—。如果改变了具有数据依赖的两个操作的执行顺序，那么最后的执行结果就会被改变。这也是不能进行重排序的原因。例如：</p>
<ul>
<li>写后读：<code>a = 1; b = a;</code></li>
<li>写后写：<code>a = 1; a = 2;</code></li>
<li>读后写：<code>a = b; b = 1;</code></li>
</ul>
<p>重排序遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。但是这里所说的<font color="red">数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</font>。</p>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>as-if-serial语义的意思指：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变</strong>。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p>
<p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>如果代码中存在控制依赖的时候，会影响指令序列执行的并行度（因为高效）。也是为此，编译器和处理器会采用猜测（Speculation）执行来克服控制的相关性。所以重排序破坏了程序顺序规则（该规则是说指令执行顺序与实际代码的执行顺序是一致的，但是处理器和编译器会进行重排序，只要最后的结果不会改变，该重排序就是合理的）。</p>
<p><font color="red">在单线程程序中，由于as-ifserial语义的存在，对存在控制依赖的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</font></p>
<h2 id="先行发生原则（happens-before）"><a href="#先行发生原则（happens-before）" class="headerlink" title="先行发生原则（happens-before）"></a>先行发生原则（happens-before）</h2><p>前面所述的内存交互操作必须要满足一定的规则，而happens-before就是定义这些规则的一个等效判断原则。happens-before是JMM定义的2个操作之间的次序关系：如果操作A线性发生于操作B，则A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。如果两个操作满足happens-before原则，那么不需要进行同步操作，JVM能够保证操作具有顺序性，此时不能够随意的重排序。否则，无法保证顺序性，就能进行指令的重排序。</p>
<p>happens-before原则主要包括：</p>
<ul>
<li><strong>程序次序规则：</strong>在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。</li>
<li><strong>管程锁定规则：</strong>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</li>
<li><strong>volatile变量规则：</strong>就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li>
<li><strong>线程启动规则：</strong>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li>
<li><strong>线程终止规则：</strong>在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。也称线程join()规则。</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</li>
<li><strong>传递性规则：</strong>这个简单的，就是happens-before原则具有传递性，即hb(A, B) ， hb(B, C)，那么hb(A, C)。</li>
<li><strong>对象终结规则：</strong>这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</li>
</ul>
<p><strong>注意：不同操作时间先后顺序与先行发生原则之间没有关系，二者不能相互推断，衡量并发安全问题不能受到时间顺序的干扰，一切都要以happens-before原则为准</strong></p>
<p><strong>示例代码1</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的代码，假设线程A在时间上先调用setValue(1)，然后线程B调用getValue()方法，那么线程B收到的返回值一定是1吗？</p>
<p>按照happens-before原则，两个操作不在同一个线程、没有通道锁同步、线程的相关启动、终止和中断以及对象终结和传递性等规则都与此处没有关系，因此这两个操作是不符合happens-before原则的，这里的并发操作是不安全的，返回值并不一定是1。</p>
<p>对于该问题的修复，可以使用lock或者synchronized套用“管程锁定规则”实现先行发生关系；或者将value定义为volatile变量（两个方法的调用都不存在数据依赖性），套用“volatile变量规则”实现先行发生关系。如此一来，就能保证并发安全性。</p>
<p><strong>示例代码2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下操作在同一个线程中</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码符合“程序次序规则”，满足先行发生关系，但是第2条语句完全可能由于重排序而被处理器先执行，时间上先于第1条语句。</p>
<h2 id="as-if-serial和happens-before区别"><a href="#as-if-serial和happens-before区别" class="headerlink" title="as-if-serial和happens-before区别"></a>as-if-serial和happens-before区别</h2><ul>
<li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li>
<li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li>
<li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
