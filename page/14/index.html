<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/14/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/14/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/" class="post-title-link" itemprop="url">k8s控制台Dashboard</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 13:15:52" itemprop="dateCreated datePublished" datetime="2020-11-30T13:15:52+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">运维技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://blog.51cto.com/happylab">Happy老师</a></p>
<p>出处：[<a target="_blank" rel="noopener" href="https://blog.51cto.com/happylab/2496756]">https://blog.51cto.com/happylab/2496756]</a>(</p>
<h2 id="kubernetes-dashboard简介"><a href="#kubernetes-dashboard简介" class="headerlink" title="kubernetes-dashboard简介"></a>kubernetes-dashboard简介</h2><p>kubernetes中管理集群中资源的方式通常有四种：命令行、YAML、API和图形界面，四种不同的方式适用于不同的人群和场景，对比如下：</p>
<ul>
<li>命令行kubectl，kubectl提供了命令行管理kubernetes资源<ul>
<li>优点：使用方便、便捷、快速管理集群资源</li>
<li>缺点：功能相对有限，部分操作无法支持，有一定的门槛</li>
</ul>
</li>
<li>YAML资源定义，kubernetes中最终转换形式，推荐使用方式<ul>
<li>优点：功能齐备，能够定义kubernetes的所有对象和资源</li>
<li>缺点：门槛较高，需要具备专业技术能力，使用排障难度大</li>
</ul>
</li>
<li>API管理接入，提供各种编程语言SDK接口，方便各种编程语言应用程序接入<ul>
<li>优点：适配各种编程语言，如Java，Go，Python，C等，方便开发kubernetes</li>
<li>缺点：门槛较高，适用于开发人员</li>
</ul>
</li>
<li>图形kubernetes-dashboard，提供图形化管理界面，能够利用metric-server实现node和pod的监控<ul>
<li>优点：使用简单，便捷，适合大众。</li>
<li>缺点：功能相对简单，功能原生，适用于demo</li>
</ul>
</li>
</ul>
<h2 id="kubernetes-dashboard安装"><a href="#kubernetes-dashboard安装" class="headerlink" title="**kubernetes-**dashboard安装"></a>**kubernetes-**dashboard安装</h2><p>社区提供了kubernetes-dashbaord的YAML资源定义文件，直接下载YAML文件安装即可实现dashboard的安装接入，需要准备条件如下：</p>
<ul>
<li>已安装好的kubernetes集群，本文环境为1.15.3</li>
<li>metric-server监控，node监控和pod监控视图需依赖于监控系统</li>
<li>RBAC认证授权，设置好账户并授予访问权限</li>
</ul>
<p>1、下载kubernetes-dashboard安装文件并应用YAML资源定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard configured</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard unchanged</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br></pre></td></tr></table></figure>

<p>安装文件中定义了dashboard相关的资源，可以查阅YAML文件，资源包含有：</p>
<ul>
<li>kubernetes-dashboard命名空间</li>
<li>ServiceAccount访问用户</li>
<li>Service服务访问应用，默认为ClusterIP</li>
<li>Secrets，存放有kubernetes-dashboard-certs，kubernetes-dashboard-csrf，kubernetes-dashboard-key-holder证书</li>
<li>ConfigMap配置文件</li>
<li>RBAC认证授权，包含有Role，ClusterRole，RoleBinding，ClusterRoleBinding</li>
<li>Deployments应用，kubernetes-dashboard核心镜像，还有一个和监控集成的dashboard-metrics-scraper</li>
</ul>
<p>2、校验资源的安装情况，kubernetes-dashbaord的资源都安装在kubernetes-dashboard命名空间下,包含有Deployments，Services，Secrets，ConfigMap等</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/1.gif"></p>
<p>3、kubernetes-dashbaord安装完毕后，kubernetes-dashboard默认service的类型为ClusterIP，为了从外部访问控制面板，开放为NodePort类型</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/2.gif"></p>
<p>4、此时通过https协议访问30433端口即可打开dashboard的控制台，为了保护数据安全性，集群默认开启了RBAC认证授权，需要授予权限的用户才可以访问到kubernetes集群，因此需要授权用户访问集群，集群中已定有了cluster-admin的角色和相关的Role，ClusterRole和ClusterRoleBinding角色，定义ServiceAccount将其关联即可，如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# cat dashboard-rbac.yaml </span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: happycloudlab </span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: happycloudlab</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: happycloudlab</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>5、应用RBAC规则，创建一个happycloudlab的用户，并和cluster-admin的角色关联</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# kubectl apply -f dashboard-rbac.yaml </span><br><span class="line">serviceaccount/happycloudlab created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/happylau created</span><br><span class="line">[root@node-1 ~]# kubectl get serviceaccounts -n kubernetes-dashboard </span><br><span class="line">NAME                   SECRETS   AGE</span><br><span class="line"><span class="keyword">default</span>                <span class="number">1</span>         <span class="number">114</span>m</span><br><span class="line">happycloudlab   <span class="number">1</span>         <span class="number">8</span>s</span><br><span class="line">kubernetes-dashboard   <span class="number">1</span>         <span class="number">114</span>m</span><br></pre></td></tr></table></figure>

<p>6、此时通过kubernetes-dashboard-csrf服务会自动创建一个和用户名关联的Secrets，通过token字段来登陆，token通过base64加密，解密后即可登录，如下演示登录的过程<img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/3.gif"></p>
<p>自此，kubernetes-dashboard安装完毕，通过RBAC认证授权特定用户访问集群权限，接下来一起探索dashboard带来的魔力吧。</p>
<h2 id="探索kubernetes-dashboard"><a href="#探索kubernetes-dashboard" class="headerlink" title="探索kubernetes-dashboard"></a>探索<strong>kubernetes-dashboard</strong></h2><p>kubernetes-dashboard图形工具能提供以下功能：</p>
<ul>
<li>查看kubernetes中的资源对象，包含kubernetes中各种资源<ul>
<li>Cluster 集群级别的资源，如命名空间，节点，PV，StorageClass，ClusterRole等</li>
<li>Workloads，不同类型的工作负载，包含Deployments，StatefulSets，DaemonSets，Jobs等</li>
<li>Discovery and LoadBalancing，服务发现和负载均衡，包含service和ingress</li>
<li>ConfigMap and Storage，包含ConfigMap，Secrets和PVC</li>
<li>Costom Resource Definition，自定义资源定义</li>
</ul>
</li>
<li>kubernetes资源监控，调用metric-server监控系统，实现Cluster集群，Workloads应用负载，存储等资源的监控</li>
<li>管理资源对象，包含创建，编辑yaml，删除负载等，主要是以Deployments等应用为主的管理</li>
</ul>
<p>1、查看集群整体概览资源，可以看到整体集群，应用负载，Pod资源的资源使用情况</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/4.gif" alt="资源概览"></p>
<p>2、Cluster集群资源管理，包含还有Nodes，Namespace，StorageClass等，提供在线编辑yaml方式</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/5.gif" alt="集群资源"></p>
<p>3、查看应用工作负载Workloads，包含各种不同的工作负载如Deployments，StatefulSets，Jobs等</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/6.gif" alt="工作负载"></p>
<p>4、部署Deployments工作负载，支持从YAML文件输入，YAML文件加载和图形界面部署应用</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/7.gif" alt="部署工作负载"></p>
<p>5、工作负载管理，扩展工作负载副本数目，滚动更新等</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/8.gif" alt="扩展副本+滚动更新"></p>
<p>6、远程登录容器和查看容器日志</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/9.gif" alt="登录容器和查看日志"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>kubernetes-dashboard提供了原生的k8s管理工具，提供一个便捷的可视化界面，方便使用控制台管理k8s资源，dashboard提供的功能相对原生，企业可以根据公司的需求通过api进行二次开发，以满足需求。对于k8s管理员而言，一般以使用命令行或yaml文件为主。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>dashboard安装手册：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p>
<p>RBAC认证授权：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/40c0405811ee">k8s Dashboard部署</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">k8s网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 13:15:18" itemprop="dateCreated datePublished" datetime="2020-11-30T13:15:18+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">k8s基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 13:14:55" itemprop="dateCreated datePublished" datetime="2020-11-30T13:14:55+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">运维技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://blog.51cto.com/happylab">Happy老师</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://blog.51cto.com/happylab/2496756">https://blog.51cto.com/happylab/2496756</a></p>
<h2 id="kubernetes简介与功能"><a href="#kubernetes简介与功能" class="headerlink" title="kubernetes简介与功能"></a>kubernetes简介与功能</h2><p>Kubernetes是google开源的一套微服务，容器化的编排引擎，提供容器话应用的自动化部署，横向扩展和管理，是google内部容器十多年实战沉淀的结晶，已战胜Swarm，Mesos成为容器编排的行业标准。</p>
<p>三大容器编排引擎：</p>
<ul>
<li>Swarm Docker原生提供的容器化编排引擎，随着docker支持kubernetes逐渐废弃</li>
<li>Mesos 结合Marathon提供容器调度编排的能力，还能提供其他framwork的调度</li>
<li>Kubernetes 已成为容器编排引擎的唯一标准，越来越多程序支持kubernetes。</li>
</ul>
<p>kuberntes内置有很多非常优秀的特性使开发者专注于业务本身，其包含的功能如下：</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/c23e352655b2ddd6d7e9fffd224accc9.png" alt="kubernetes入门到实战（一）初窥kubernetes全貌"></p>
<ul>
<li>Service discovery and load balancing，服务发现和负载均衡，通过DNS实现内部解析，service实现负载均衡</li>
<li>Storage orchestration，存储编排，通过plungin的形式支持多种存储，如本地，nfs，ceph，公有云快存储等</li>
<li>Automated rollouts and rollbacks，自动发布与回滚，通过匹配当前状态与目标状态一致，更新失败时可回滚</li>
<li>Automatic bin packing，自动资源调度，可以设置pod调度的所需（requests）资源和限制资源（limits）</li>
<li>Self-healing，内置的健康检查策略，自动发现和处理集群内的异常，更换，需重启的pod节点</li>
<li>Secret and configuration management，密钥和配置管理，对于敏感信息如密码，账号的那个通过secret存储，应用的配置文件通过configmap存储，避免将配置文件固定在镜像中，增加容器编排的灵活性</li>
<li>Batch execution，批处理执行，通过job和cronjob提供单次批处理任务和循环计划任务功能的实现</li>
<li>Horizontal scaling,横向扩展功能，包含有HPA和AS，即应用的基于CPU利用率的弹性伸缩和基于平台级的弹性伸缩，如自动增加node和删除nodes节点。</li>
</ul>
<h2 id="kubernetes架构解析"><a href="#kubernetes架构解析" class="headerlink" title="kubernetes架构解析"></a>kubernetes架构解析</h2><p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/9b512f2d62081a5fa35d8266f5c03a78.png" alt="kubernetes组件"></p>
<p>kubernetes包含两种角色：master节点和node节点，master节点是集群的控制管理节点，作为整个k8s集群的大脑。</p>
<ul>
<li>负责集群所有接入请求(kube-apiserver)，在整个集群的入口；</li>
<li>集群资源调度(kube-controller-scheduler)，通过watch监视pod的创建，负责将pod调度到合适的node节点；</li>
<li>集群状态的一致性(kube-controller-manager)，通过多种控制器确保集群的一致性，包含有Node Controller，Replication Controller，Endpoints Controller等；</li>
<li>元数据信息存储(etcd)，数据持久存储化，存储集群中包括node，pod，rc，service等数据；</li>
</ul>
<p>node节点是实际的工作节点，负责集群负载的实际运行，即pod运行的载体，其通常包含三个组件：Container Runtime，kubelet和kube-proxy</p>
<ul>
<li>Container Runtime是容器运行时，负责实现container生命周期管理，如docker，containerd，rktlet；</li>
<li>kubelet负责镜像和pod的管理，</li>
<li>kube-proxy是service服务实现的抽象，负责维护和转发pod的路由，实现集群内部和外部网络的访问。</li>
</ul>
<p>其他组件还包括：</p>
<ul>
<li>cloud-controller-manager，用于公有云的接入实现，提供节点管理(node)，路由管理，服务管理(LoadBalancer和Ingress)，存储管理(Volume，如云盘，NAS接入)，需要由公有云厂商实现具体的细节，kubernetes提供实现接口的接入，如腾讯云目前提供CVM的node管理，节点的弹性伸缩(AS),负载均衡的接入(CLB),存储的管理(CBS和CFS)等产品的集成；</li>
<li>DNS组件由kube-dns或coredns实现集群内的名称解析；</li>
<li>kubernetes-dashboard用于图形界面管理；</li>
<li>kubectl命令行工具进行API交互；</li>
<li>服务外部接入，通过ingress实现七层接入，由多种controller控制器组成<ul>
<li>traefik</li>
<li>nginx ingress controller</li>
<li>haproxy ingress controller</li>
<li>公有云厂商ingress controller</li>
</ul>
</li>
<li>监控系统用于采集node和pod的监控数据<ul>
<li>metric-server 核心指标监控</li>
<li>prometheus 自定义指标监控，提供丰富功能</li>
<li>heapster+influxdb+grafana 旧核心指标监控方案，现已废弃</li>
</ul>
</li>
<li>日志采集系统，用于收集容器的业务数据,实现日志的采集，存储和展示，由EFK实现<ul>
<li>Fluentd 日志采集</li>
<li>ElasticSearch 日志存储+检索</li>
<li>Kiabana 数据展示</li>
</ul>
</li>
</ul>
<h2 id="kubernetes生态"><a href="#kubernetes生态" class="headerlink" title="kubernetes生态"></a>kubernetes生态</h2><p><a target="_blank" rel="noopener" href="https://landscape.cncf.io/">https://landscape.cncf.io/</a></p>
<h2 id="kubernetes高可用架构"><a href="#kubernetes高可用架构" class="headerlink" title="kubernetes高可用架构"></a>kubernetes高可用架构</h2><p>kubernetes高可用集群通常由3或5个节点组成高可用集群，需要保障各个节点的高可用性</p>
<ul>
<li>etcd 内置集群机制，保障数据持久存储</li>
<li>kube-apiserver 无状态api服务，有负载均衡调度器做负载分发，如haproxy或nginx</li>
<li>kube-scheduler 内置选举机制，保障调度器高可用，确保同个时刻一个leader节点工作，其他处于阻塞，防止脑裂</li>
<li>kube-controller-manager 内置的选举机制保障控制器高可用，机制和kube-scheduler一致。<br><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E5%9F%BA%E7%A1%80/61235bc58859458922f5ab4f6484ed99.jpg" alt="kubernetes入门到实战（一）初窥kubernetes全貌"></li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>kubernetes功能介绍，<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></li>
<li>kubernetes组件介绍<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">docker网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 13:04:37" itemprop="dateCreated datePublished" datetime="2020-11-30T13:04:37+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">运维技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="docker网络知识"><a href="#docker网络知识" class="headerlink" title="docker网络知识"></a>docker网络知识</h2><h3 id="docker网络类型（–network指定网络）"><a href="#docker网络类型（–network指定网络）" class="headerlink" title="docker网络类型（–network指定网络）"></a>docker网络类型（–network指定网络）</h3><ul>
<li><p>bridge  默认连接到docker0这个网桥上</p>
</li>
<li><p>none 容器只能使用127.0.0.1的本机网络</p>
</li>
<li><p>host 与宿主机共享ip</p>
</li>
<li><p>link  docker run -it –name vm5 –link vm1:db1 ubuntu 创建一个容器vm5，并使用link方式连接vm1,此时的vm1的是容器名，db1是容器的别名</p>
</li>
<li><p>container 网络模式，必须同一个宿主机</p>
</li>
<li><p>自定义网络模式：</p>
<ul>
<li>bridge network  可以通过容器名互通，单一主机上运行一个相对小的网络，使用桥接网络</li>
<li>overlay network  创建一个大网络，可以通过overlay 网络来实现</li>
<li>MACVLAN network</li>
<li>network plugin</li>
<li>remote network</li>
</ul>
</li>
<li><p>跨主机docker容器通信方案介绍（就是自定义网络下的方案，除开bridge）</p>
<ul>
<li><p>隧道（Overlay Networking）方案：</p>
<ul>
<li>  Weave：UDP广播，本机建立新的BR，通过PCAP互通。</li>
<li>  Open vSwitch(OVS)：基于VxLAN和GRE协议，但是性能方面损失比较严重。</li>
<li>  Flannel：UDP广播，VxLan。  </li>
</ul>
</li>
<li><p>路由方案</p>
<ul>
<li>  Calico：基于BGP协议的路由方案，支持很细致的ACL控制，对混合云亲和度比较高。</li>
<li>  Macvlan：从逻辑和Kernel层来看隔离性和性能最优的方案，基于二层隔离，所以需要二层路由器支持，大多数云服务商不支持，所以混合云上比较难以实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>    隧道方案在IaaS层的网络中应用也比较多，大家共识是随着节点规模的增长复杂度会提升，而且出了网络问题跟踪起来比较麻烦，大规模集群情况下这是需要考虑的一个点。</code></p>
<p><code>    路由方案一般是从3层或者2层实现隔离和跨主机容器互通的，出了问题也很容易排查。</code></p>
<h5 id="bridge-模式的网络。其特点如下："><a href="#bridge-模式的网络。其特点如下：" class="headerlink" title="bridge 模式的网络。其特点如下："></a>bridge 模式的网络。其特点如下：</h5><ul>
<li>  使用一个 linux bridge，默认为 docker0</li>
<li>  使用 veth 对，一头在容器的网络 namespace 中，一头在 docker0 上</li>
<li>  该模式下Docker Container不具有一个公有IP，因为宿主机的IP地址与vethpair的 IP地址不在同一个网段内</li>
<li>  Docker采用NAT网络地址转换(Network Address Translation)方式，将容器内部的服务监听的端口与宿主机的某一个端口port 进行“绑定”，使得宿主机以外的世界可以主动将网络报文发送至容器内部</li>
<li>  外界访问容器内的服务时，需要访问宿主机的 IP 以及宿主机的端口 port</li>
<li>  NAT 模式由于是在三层网络上的实现手段，故肯定会影响网络的传输效率。</li>
<li>容器拥有独立、隔离的网络栈；让容器和宿主机以外的世界通过NAT建立通信<br>  <img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E7%BD%91%E7%BB%9C/bridge_20201013104542.png" alt="输入图片描述"></li>
</ul>
<h5 id="主要使用的网络模式"><a href="#主要使用的网络模式" class="headerlink" title="主要使用的网络模式"></a>主要使用的网络模式</h5><ul>
<li>Libnetwork 从Docker核心代码中分离出去，形成一个单独的库</li>
<li>Flannel CoreOS团队针对Kubernetes设计的一个重载网络工具，它的主要思路是：预先留出一个网段，每个主机使用其中一部分，然后每个容器被分配不同的ip；让所有的容器认为大家在同一个直连的网络，底层通过UDP/VxLAN等进行报文的封装和转发</li>
<li>Calico 是一个纯3层的数据中心网络方案，而且无缝集成像OpenStack这种IaaS云架构，能够提供可控的VM、容器、裸机之间的IP通信</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d84cdfe2ea86">详细网络知识</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dhaiuda/article/details/82824333">docker的overlay网络</a></p>
<h3 id="docker网络操作"><a href="#docker网络操作" class="headerlink" title="docker网络操作"></a>docker网络操作</h3><ul>
<li>docker network ls            查看docker网卡</li>
<li>docker network rm 网卡id    删除docker网卡</li>
<li>docker network inspect 网卡id   查看docker网卡的相关详细信息</li>
<li>创建网络，如下使用–subnet创建网络（用来指定ip段），–gateway（用来指定网关），my_net3为创建的名字：<br>docker network create –driver bridge –subnet 172.22.1.0/24 –gateway 172.22.1.1 my_net3</li>
</ul>
<h3 id="设置主机名和DNS"><a href="#设置主机名和DNS" class="headerlink" title="设置主机名和DNS"></a>设置主机名和DNS</h3><p>docker run -it –name mycon -h lion –dns=8.8.8.8 ubuntu:14.04</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">docker基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 11:18:22" itemprop="dateCreated datePublished" datetime="2020-11-30T11:18:22+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">运维技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Docker提供了一种将应用程序安全，隔离运行的一种方式，能够将应用程序依赖和库文件打包在一个容器中，后续再任何地方运行起来即可，其包含了应用程序所依赖相关环境，一次构建，任意运行（build once，run anywhere）</p>
<h2 id="Docker-包括三个基本概念"><a href="#Docker-包括三个基本概念" class="headerlink" title="Docker 包括三个基本概念"></a>Docker 包括三个基本概念</h2><ul>
<li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。<br>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li>
</ul>
<p>Docker容器通过Docker镜像来创建。</p>
<h2 id="Docker原理"><a href="#Docker原理" class="headerlink" title="Docker原理"></a>Docker原理</h2><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E5%9F%BA%E7%A1%80/6d20ecb467fa6d571d7dd74fe0187f07.png" alt="docker架构" style="zoom: 50%;">

<table>
<thead>
<tr>
<th align="left">概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker 镜像(Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td align="left">Docker 容器(Container)</td>
<td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="left">Docker Daemon</td>
<td>容器管理组件，守护进程，负载容器，镜像，存储，网络等管理</td>
</tr>
<tr>
<td align="left">Docker 客户端(Client)</td>
<td>Docker客户端通过命令行或者其他工具使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/develop/sdk/">Docker SDK </a> 与Docker的守护进程（Docker Daemon）通信</td>
</tr>
<tr>
<td align="left">Docker 主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">Docker Registry</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。容器镜像仓库，负责存储，分发，打包</td>
</tr>
<tr>
<td align="left">Docker Object</td>
<td>容器对象，主要包含container和images</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td>是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，<br>比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
<tr>
<td align="left">docker swarm</td>
<td>Swarm 集群中每台 Docker 主机称为一个节点。集群管理，容器编排项目</td>
</tr>
<tr>
<td align="left">docker compose</td>
<td>容器编排项目，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a> 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<h2 id="容器优缺点"><a href="#容器优缺点" class="headerlink" title="容器优缺点"></a>容器优缺点</h2><p>容器给应用程序开发环境带来很大的便利，从根本上解决了容器的环境依赖，打包等问题，然而，Docker带来的容器打包的便利，同时也带来了以下的挑战：</p>
<ul>
<li><p>容器如何调度，分发</p>
</li>
<li><p>多台机器如何协同工作</p>
</li>
<li><p>Docker主机故障时应用如何恢复</p>
</li>
<li><p>如何保障应用高可用，横向扩展，动态伸缩</p>
</li>
</ul>
<img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bdocker%E5%9F%BA%E7%A1%80/875f955cc9bb7b51036b58e59a2763bb.png" alt="容器挑战" style="zoom:50%;">

<h2 id="docker容器命令"><a href="#docker容器命令" class="headerlink" title="docker容器命令"></a>docker容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -q </span><br><span class="line">docker container stop|start|rm nginx</span><br></pre></td></tr></table></figure>

<h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx-test -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure>

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it nginx sh|bash</span><br></pre></td></tr></table></figure>

<h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-dockerfile.html" title="dockerfile描述文件细节">如何写dockerfile文件</a></p>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>容器编排工具 <a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-compose.html" title="docker-compose描述文件细节">如何写docker-compose.yml</a></p>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d //后台运行</span><br><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure>

<h2 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker swarm"></a>docker swarm</h2><p>Swarm 集群中每台 Docker 主机称为一个节点。其中主动初始化一个 Swarm 集群的节点称为管理节点（Manager），加入一个Swarm 集群的节点称为工作节点（Worker Node）。工作节点是任务执行节点，管理节点将任务下发至工作节点执行。管理节点默认也作为工作节点。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader</p>
<p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p>
<p>swarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。<br>work node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</p>
<h4 id="基本实用命令"><a href="#基本实用命令" class="headerlink" title="基本实用命令"></a>基本实用命令</h4><ul>
<li>docker swarm init –advertise-addr 192.168.58.144</li>
<li>docker swarm join 。。。</li>
<li>docker swarm leave –f</li>
<li>docker node ls</li>
<li>docker node ls –filter role=worker</li>
<li>docker node ls –filter role=manager</li>
<li>docker node update swarm02 –role=worker //将swarm02节点降级为worker节点</li>
<li>docker service inspect mynginx</li>
<li>docker service create –replicas 3 -p 8888:80 –name mynginx nginx</li>
<li>docker service rm mynginx</li>
<li>docker stack rm getstartedlab</li>
<li>docker stack deploy -c docker-compose.yml getstartedlab</li>
</ul>
<h4 id="docker-service"><a href="#docker-service" class="headerlink" title="docker service"></a>docker service</h4><p>与docker swarm一起使用，docker service部署的是单个服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 3 -p 8888:80 --name mynginx nginx</span><br></pre></td></tr></table></figure>

<h4 id="Docker-Stack"><a href="#Docker-Stack" class="headerlink" title="Docker Stack"></a>Docker Stack</h4><p>与docker swarm一起使用，使用docker-compose.yml配置文件，进行多服务编排部署</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stack  deploy -c docker-compose1.yml phpadmin</span><br><span class="line"></span><br><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure>

<h4 id="Swarm-Service网络模型"><a href="#Swarm-Service网络模型" class="headerlink" title="Swarm Service网络模型"></a>Swarm Service网络模型</h4><ul>
<li><strong>Overlay networks</strong> 管理 Swarm 中 Docker 守护进程间的通信。你可以将服务附加到一个或多个已存在的 overlay 网络上，使得服务与服务之间能够通信。</li>
<li><strong>ingress network</strong> 是一个特殊的 overlay 网络，用于服务节点间的负载均衡。当任何 Swarm 节点在发布的端口上接收到请求时，它将该请求交给一个名为 IPVS 的模块。IPVS 跟踪参与该服务的所有IP地址，选择其中的一个，并通过 ingress 网络将请求路由到它。<br>初始化或加入 Swarm 集群时会自动创建 ingress 网络，大多数情况下，用户不需要自定义配置，但是 docker 17.05 和更高版本允许你自定义。</li>
<li><strong>docker_gwbridge</strong>是一种桥接网络，将 overlay 网络（包括 ingress 网络）连接到一个单独的 Docker 守护进程的物理网络。默认情况下，服务正在运行的每个容器都连接到本地 Docker 守护进程主机的 docker_gwbridge 网络。<br>docker_gwbridge 网络在初始化或加入 Swarm 时自动创建。大多数情况下，用户不需要自定义配置，但是 Docker 允许自定义。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create</span><br><span class="line">docker network connect</span><br><span class="line">docker network ls</span><br><span class="line">docker network rm</span><br><span class="line">docker network disconnect</span><br><span class="line">docker network inspect</span><br><span class="line">docker run --rm --network=host alpine ifconfig</span><br></pre></td></tr></table></figure>

<h4 id="swarm编排工具的控制台docker-portainer"><a href="#swarm编排工具的控制台docker-portainer" class="headerlink" title="swarm编排工具的控制台docker portainer"></a>swarm编排工具的控制台docker portainer</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--constraint &#x27;node.role == manager&#x27; \</span><br><span class="line">--mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure>

<h2 id="docker-compose与docker-swarm区别"><a href="#docker-compose与docker-swarm区别" class="headerlink" title="docker compose与docker swarm区别"></a>docker compose与docker swarm区别</h2><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合</p>
<h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>创建Docker主机（开放远程2375端口 安装docker）</p>
<ul>
<li>docker-machine create -d hyperv –hyperv-virtual-switch “myswitch” myvm2</li>
<li>docker-machine env myvm3</li>
<li>docker-machine ssh myvm1</li>
<li>docker-machine ls</li>
<li>docker-machine stop</li>
<li>docker-machine start</li>
<li>docker-machine env</li>
<li>docker-machine regenerate-certs</li>
</ul>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p><a target="_blank" rel="noopener" href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">RabbitMQ基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-27 20:12:26" itemprop="dateCreated datePublished" datetime="2020-11-27T20:12:26+08:00">2020-11-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>消息队列可以实现流量削峰、降低系统耦合度、提高系统性能等。</p>
<p><strong>RabbitMQ</strong>是一个实现了AMQP协议（Advanced Message Queue Protocol）的消息队列。</p>
<h2 id="RabbitMQ中的概念"><a href="#RabbitMQ中的概念" class="headerlink" title="RabbitMQ中的概念"></a><strong>RabbitMQ中的概念</strong></h2><ul>
<li><strong>producer</strong>： producer 是一个发送消息的应用</li>
<li><strong>exchange</strong>：producer并不会直接将消息发送到 queue 上，而是将消息发送给exchange，由exchange按照一定规则转发给指定queue</li>
<li><strong>queue</strong>： queue 用来存储 producer 发送的消息</li>
<li><strong>consumer</strong>： consumer是接收并处理消息的应用</li>
<li><strong>routing key</strong>：发送消息时绑定的路由key</li>
<li><strong>binding key</strong>：队列与交换机绑定的key</li>
<li><strong>consumerTag</strong>: 消费者标签，同一个会话， consumerTag 是固定的 可以做此会话的名字。</li>
<li><strong>consumer</strong>：消费者，extends DefaultConsumer。一个channel上可以配置多个consumer，真正的接收消息类，有处理消息的方法</li>
<li><strong>Envelope</strong>：可以获取交换机及routingKey信息和deliveryTag</li>
<li><strong>deliveryTag</strong>： deliveryTag 每次接收消息+1，可以做此消息处理通道的名字。用来回传告诉 rabbitmq 这个消息处理成功 清除此消息</li>
<li><strong>BasicProperties</strong>：基本属性，如Header中的信息。</li>
<li><strong>Delivery</strong>：封装了Envelope，BasicProperties及字节数组消息</li>
</ul>
<h2 id="Exchanges交换机"><a href="#Exchanges交换机" class="headerlink" title="Exchanges交换机"></a>Exchanges交换机</h2><p><strong>默认Exchange(RabbitMQ自带的Direct交换机，没有名称，与所有队列相连)**：比较Message的routing key和Queue的名字，完全匹配时，Message才会发送到该Queue<br><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/1-1607999220900.gif" style="zoom:80%;"><br>**Direct Exchange</strong>：比较Message的routing key和Queue的binding key，完全匹配时，Message才会发送到该Queue<br><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/2.gif" style="zoom:80%;"><br><strong>Fanout Exchange</strong>：忽略key对比，发送Message到Exchange下游绑定的所有Queue<br><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/1.gif" style="zoom: 80%;"><br><strong>Topic Exchange</strong>：比较Message的routing key和Queue的binding key，按规则匹配成功时，Message才会发送到该Queue</p>
<ul>
<li><strong>routing key命名规则</strong>：用”.”分割的字母或数字</li>
<li><strong>匹配规则</strong>：<ul>
<li>*：匹配单个字母或数字</li>
<li>#：匹配0~多个字母或数字</li>
<li>比如：*.stock.#与usd.stock、eur.stock.db匹配；但与stock.nasdaq不匹配<br><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/640" alt="img"></li>
</ul>
</li>
</ul>
<p><strong>Headers Exchange</strong>：比较队列上带有的Headers的键值对是否和发送的消息Message对象带的message是否匹配，通过Headers上的键值对判断是使用全匹配还是包含匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headerMap.put(<span class="string">&quot;x-match&quot;</span>, (matchAll ? <span class="string">&quot;all&quot;</span> : <span class="string">&quot;any&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h2><ul>
<li>存放消息</li>
<li>消息消费监听，监听的是队列，和其它如交换机没有关联</li>
</ul>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><ul>
<li>生产者指定Message的routing key，并指定Message发送到哪个Exchange</li>
<li>Queue会通过binding key绑定到指定的Exchange</li>
<li>Exchange根据对比Message的routing key和Queue的binding key，然后按一定的分发路由规则，决定Message发送到哪个Queue</li>
</ul>
<h2 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h2><p>​    监听指定队列，消息push到消费者端。spring的监听注解会自动创建不存在的交换机，队列，及绑定key。</p>
<h3 id="消息队列有两种工作方式"><a href="#消息队列有两种工作方式" class="headerlink" title="消息队列有两种工作方式"></a>消息队列有两种工作方式</h3><ul>
<li><p>轮询分发(默认)默认Spring是获取250个数据，RabbitMQ官方建议是30</p>
</li>
<li><p>公平分发即当某个消费者没有消费完成之前不用再分发消息。当执行时间增长的时候验证是否正确</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者每次从队列获取的消息数量。此属性当不设置时为：轮询分发，设置为1为：公平分发</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;direct.queue&quot;), exchange = @Exchange(value = &quot;direct.exchange&quot;), key = &quot;HelloWorld&quot;)&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDirectMessage</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 模拟异常</span></span><br><span class="line">            String is = <span class="keyword">null</span>;</span><br><span class="line">            is.toString();</span><br><span class="line">            <span class="comment">// 确认收到消息，false只确认当前consumer一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已重复处理失败,拒绝再次接收&quot;</span> + user.getName());</span><br><span class="line">                <span class="comment">// 拒绝消息，requeue=false 表示不再重新入队，如果配置了死信队列则进入死信队列</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息即将再次返回队列处理&quot;</span> + user.getName());</span><br><span class="line">                <span class="comment">// requeue为是否重新回到队列，true重新入队</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDirectMessageCopy</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;--jxb--MQConsumer--getDirectMessageCopy：&quot;</span> + user.toString());</span><br><span class="line">            <span class="comment">// 确认收到消息，false只确认当前consumer一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已重复处理失败,拒绝再次接收！&quot;</span>);</span><br><span class="line">                <span class="comment">// 拒绝消息，requeue=false 表示不再重新入队，如果配置了死信队列则进入死信队列</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息即将再次返回队列处理！&quot;</span>);</span><br><span class="line">                <span class="comment">// requeue为是否重新回到队列，true重新入队</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h2><p>​    主动拉取队列里的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(ConnectionUtils.QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="基本AIPI"><a href="#基本AIPI" class="headerlink" title="基本AIPI"></a>基本AIPI</h2><p><strong>channel.exchangeDeclare()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type：有direct、fanout、topic三种</span><br><span class="line">durable：true：服务器重启会保留下来Exchange。警告：仅设置此选项，不代表消息持久化。即不保证重启后消息还在。</span><br><span class="line">autoDelete: true:当已经没有消费者时，服务器是否可以删除该Exchange。</span><br></pre></td></tr></table></figure>

<p><strong>chanel.exchangeBind()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);</span><br><span class="line">用于通过绑定bindingKey将queue到Exchange，之后便可以进行消息接收</span><br></pre></td></tr></table></figure>

<p><strong>channel.queueDeclare(QUEUE_NAME, false, false, false, null);</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">durable：true：在服务器重启时，能够存活</span><br><span class="line">exclusive ：是否为当前连接的专用队列，在连接断开后，会自动删除该队列，生产环境中应该很少用到吧。</span><br><span class="line">autodelete：当没有任何消费者使用时，自动删除该队列。this means that the queue will be deleted when there are no more processes consuming messages from it.</span><br></pre></td></tr></table></figure>
<p><strong>chanel.basicQos()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prefetchSize：0 目前好像没有作用，至少rabbitmq3.8.5不能使用，报错</span><br><span class="line">prefetchCount：会告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack。是服务端属性，通过rpc方法调用，存在服务端，客户端不需要使用</span><br><span class="line">global：true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别的还是consumer级别。如果true并且prefetchCount为4，有二个消费者，此时每个消费者可以读取到二条。如果为fasle，每个消费者获取到4条数据</span><br></pre></td></tr></table></figure>
<p><strong>channel.basicPublish()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routingKey：路由键，#匹配0个或多个单词，*匹配一个单词，在topic exchange做消息转发用</span><br><span class="line">mandatory：true：如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue，那么会调用basic.return方法将消息返还给生产者。false：出现上述情形broker会直接将消息扔掉</span><br><span class="line">immediate：true：如果exchange在将消息route到queue(s)时发现对应的queue上没有消费者，那么这条消息不会放入队列中。当与消息routeKey关联的所有queue(一个或多个)都没有消费者时，该消息会通过basic.return方法返还给生产者。</span><br><span class="line">BasicProperties ：需要注意的是BasicProperties.deliveryMode，0:不持久化 1：持久化 这里指的是消息的持久化，配合channel(durable&#x3D;true),queue(durable)可以实现，即使服务器宕机，消息仍然保留</span><br><span class="line">简单来说：mandatory标志告诉服务器至少将该消息route到一个队列中，否则将消息返还给生产者；immediate标志告诉服务器如果该消息关联的queue上有消费者，则马上将消息投递给它，如果所有queue都没有消费者，直接把消息返还给生产者，不用将消息入队列等待消费者了。</span><br></pre></td></tr></table></figure>

<p><strong>channel.basicAck();</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息。</span><br></pre></td></tr></table></figure>

<p><strong>channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">multiple：是否批量.true:将一次性拒绝所有小于deliveryTag的消息。</span><br><span class="line">requeue：被拒绝的是否重新入队列</span><br></pre></td></tr></table></figure>

<p><strong>channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">requeue：被拒绝的是否重新入队列</span><br><span class="line">channel.basicNack 与 channel.basicReject 的区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</span><br></pre></td></tr></table></figure>
<p><strong>channel.basicConsume(QUEUE_NAME, true, consumer);</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</span><br></pre></td></tr></table></figure>

<p><strong>channel.basicGet(ConnectionUtils.QUEUE_NAME, false);</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</span><br></pre></td></tr></table></figure>

<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><strong>Connection与Channel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createChannel();</span><br></pre></td></tr></table></figure>

<p>一个连接可以创建多个Channel</p>
<p><strong>Channel与消费者Consume</strong></p>
<p>一个Channel上可以设置多个Consume,因此可以设置最大值，Spring中通过设置concurrency和max-concurrency配置消费者个数</p>
<p><strong>prefetchSize、prefetchCount、Global</strong></p>
<p>spring中有prefetch即prefetchCount，batch-size。取最大值设置为prefetchCount</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue</span><br><span class="line"><span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">InternalConsumer consumer = <span class="keyword">new</span> InternalConsumer(<span class="keyword">this</span>.channel, queue);</span><br><span class="line">String consumerTag = <span class="keyword">this</span>.channel.basicConsume(queue, <span class="keyword">this</span>.acknowledgeMode.isAutoAck(),</span><br><span class="line">                                               (<span class="keyword">this</span>.tagStrategy != <span class="keyword">null</span> ? <span class="keyword">this</span>.tagStrategy.createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="keyword">this</span>.noLocal,</span><br><span class="line">                                               <span class="keyword">this</span>.exclusive, <span class="keyword">this</span>.consumerArgs,</span><br><span class="line">                                               consumer);</span><br></pre></td></tr></table></figure>

<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="/2020/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/" class="post-title-link" itemprop="url">算法（三）之数据结构总章</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-25 18:09:52" itemprop="dateCreated datePublished" datetime="2020-11-25T18:09:52+08:00">2020-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p>数组（数组、循环数组）查找、更新可以通过下标，时间复杂度为O(1);插入、删除需要移动数据在数组的位置O(n)</p>
<p><strong>基本操作</strong>：读取元素，更新元素，插入元素，删除元素（涉及数组元素移动位置，取巧方式：将最后一个元素更新删除元素）</p>
</li>
<li><p>链表（单向链表、双向链表、循环链表）查找需要一直向下查找，时间复杂度为O(n);插入、删除、更新指针变动即可O(1)</p>
<p><strong>基本操作</strong>：查找节点，更新节点，插入节点，删除节点</p>
<p><img src="/2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/image-20201201102615715.png" alt="image-20201201102615715"></p>
</li>
<li><p>栈（Stack）：FILO（First In Last Out，先入后出），最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作栈顶（top）。可以使用数组或链表来实现。时间复杂度都是O(1)</p>
<p><strong>基本操作</strong>：入栈push（从栈顶压入元素），出栈pop（从栈顶弹出元素）</p>
</li>
<li><p>队列（queue，单向队列，双端队列，优先队列，堵塞队列）：FIFO（First In First Out，先进先出），队列的出口端叫作队头（front），队列的入口端叫作队尾（rear）。可以使用数组或链表来实现。时间复杂度都是O(1)。数组实现队列会导致空间越来越小，可以使用循环数组。</p>
<p><strong>基本操作</strong>：入队enqueue（从队尾插入元素），出队dequeue（从对头移出元素）</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>作用及示例</th>
</tr>
</thead>
<tbody><tr>
<td>栈的应用</td>
<td>栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。<br>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。<br>栈还有一个著名的应用场景是面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面。</td>
</tr>
<tr>
<td>队列的应用</td>
<td>队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。<br>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。<br>再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的</td>
</tr>
</tbody></table>
<p><font color="red"><strong>双端队列（deque）</strong></font>：既可以先入先出，也可以先入后出。从队头一端可以入队或出队，从队尾一端也可以入队或出队</p>
<p><font color="red"><strong>优先队列</strong></font>：它遵循的不是先入先出，而是谁的优先级最高，谁先出队。优先队列已经<strong>不属于线性数据结构的范畴</strong>了，它是<strong>基于二叉堆来实现的</strong></p>
</li>
<li><p>散列表：也叫哈希表（Hash table），提供了键（Key）和值（Value）的映射关系,只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于O(1)。<font color="red">散列表可以说是数组和链表的结合。</font></p>
<p><strong>基本操作</strong>：写操作put,读操作get,扩容resize</p>
<p><strong>哈希冲突（哈希碰撞）</strong>解决方法：</p>
<p>​        <strong>开放寻址法</strong>：当一个Key通过哈希函数获得对应的数组下标已被占用时，我们可以“另谋高就”，寻找下一个空档位置，一直向下找。在Java中，ThreadLocal所使用的就是开放寻址法</p>
<p>​        <strong>链表法</strong>：应用在了Java的集合类HashMap当中，数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可</p>
</li>
<li><p>树（tree,二叉树、二叉查找树（排序树）、平衡二叉树、红黑树、B-树、B+树）是n（n≥0）个节点的有限集。当n=0时，称为空树。</p>
<p>树–&gt;二叉树–&gt;完全二叉树–&gt;满二叉树–&gt;二叉堆–&gt;二叉查找树（排序树）</p>
</li>
<li><p>图（？）</p>
</li>
</ul>
<h2 id="java数据结构"><a href="#java数据结构" class="headerlink" title="java数据结构"></a>java数据结构</h2><p>见java集合文章</p>
<h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序 存储，访问方式是随机访问。利用下标查找数组元素的时间复杂度是O(1)，中间插入、删除数组元素的时间复杂度是O(n)。 </p>
<h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查找链表节点的时间 复杂度是O(n)，中间插入、删除节点的时间复杂度是O(1)。 </p>
<h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p>栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和 出栈操作，遵循先入后出的原则（FILO）。 </p>
<h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。 </p>
<h2 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h2><p>散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作。散列表通过哈希函数实现Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突</p>
<h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><p>树是n个节点的有限集，有且仅有一个特定的称为根的节点。当n&gt;1时，其余节点可分为m个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 </p>
<h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点。二叉树包含完全二叉树和满二叉树两种特殊形式。 </p>
<h2 id="二叉树的遍历方式有几种"><a href="#二叉树的遍历方式有几种" class="headerlink" title="二叉树的遍历方式有几种"></a>二叉树的遍历方式有几种</h2><p>根据遍历节点之间的关系，可以分为前序遍历、中序遍历、后序遍历、层序遍历这4种方式；从更宏观的角度划分，可以划分为深度优先遍历和广度优先遍历两大类。</p>
<h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。<br>在最大堆中，任何一个父节点的值，都大于或等于它左、右孩子节点的值。<br>在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的值。 </p>
<h2 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h2><p>优先队列分为最大优先队列和最小优先队列。<br>在最大优先队列中，无论入队顺序如何，当前最大的元素都会优先出队，这是基于最大堆实现的。<br>在最小优先队列中，无论入队顺序如何，当前最小的元素都会优先出队，这是基于最小堆实现的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">算法（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-24 21:22:33" itemprop="dateCreated datePublished" datetime="2020-11-24T21:22:33+08:00">2020-11-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211111476.png" alt="img" style="zoom: 67%;">

<h2 id="数据结构内容"><a href="#数据结构内容" class="headerlink" title="数据结构内容"></a>数据结构内容</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211129378.png" alt="img" style="zoom: 67%;">

<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/201901212111451.png" alt="img" style="zoom: 67%;">

<img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201124212642358.png" alt="image-20201124212642358" style="zoom:50%;">

<h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><p>大多数以数组和链表作为存储方式，因此物理结构为：</p>
<ul>
<li>顺序存储结构 （一段连续的内存空间。随机访问效率高；插入删除效率低，大小固定，可以扩容）</li>
<li>链式存储结构（不连续的内存空间。大小动态扩展，插入删除效率高；不能随机访问）</li>
<li>散列存储结构（为了方便查找，整体无序，但索引块之间有序，需要额外空间，存储索引表。对顺序查找的一种改进，查找效率高；需额外空间存储索引）</li>
<li>索引存储结构（选取某个函数，数据元素根据函数计算存储位置可能存在多个数据元素存储在同一位置，引起地址冲。查找基于数据本身即可找到，查找效率高，存取效率高。存取随机，不便于顺序查找）</li>
</ul>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是抽象的概念，它依赖于物理结构而存在。是对数据元素之间存在的逻辑关系的描述。分为二大类：线性结构和非线性结构。细分为四种：</p>
<ul>
<li><p>线性结构（线性结构中的数据元素之间是一对一的关系。注意：<font color="red">重点在一对一</font>）</p>
<img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103023829.png" alt="image-20201125103023829" style="zoom: 33%;">
</li>
<li><p>集合结构（就是数据元素同属一个集合，单个数据元素之间<font color="red">没有任何关系</font>）</p>
<img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125102951179.png" alt="image-20201125102951179" style="zoom: 33%;">
</li>
<li><p>树形结构（树形结构中的数据元素之间存在一对多的关系。各元素及元素关系所组成图形类似于树状图。注意：<font color="red">关系为一对多</font>）</p>
<img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103039123.png" alt="image-20201125103039123" style="zoom: 33%;">
</li>
<li><p>图形结构（数据元素之间是<font color="red">多对多的关系</font>）</p>
<img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103056213.png" alt="image-20201125103056213" style="zoom: 33%;">



</li>
</ul>
<p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211307827.png" alt="img"></p>
<p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211350180.png" alt="img"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39385118/article/details/80835048">数据结构之逻辑结构与物理结构（存储结构）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41523096/article/details/86566982">《数据结构》| 第一章 绪论 知识梳理</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">算法（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-23 13:36:25" itemprop="dateCreated datePublished" datetime="2020-11-23T13:36:25+08:00">2020-11-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>在数学领域里，算法是用于解决某一类问题的公式和思想。</li>
<li>在计算机科学领域，算法的本质是一系列程序指令，用于解决特定的运算和逻辑问题。是对特定问题求解方法（步骤）的一种描述，是指令的有限序列，其中每一条指令表示一个或多个操作。</li>
</ul>
<h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125100745940.png" alt="image-20201125100745940"></p>
<h2 id="算法的设计目标"><a href="#算法的设计目标" class="headerlink" title="算法的设计目标"></a>算法的设计目标</h2><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125101019149.png" alt="image-20201125101019149"></p>
<h2 id="算法标准"><a href="#算法标准" class="headerlink" title="算法标准"></a>算法标准</h2><p>在计算机领域，我们同样会遇到各种高效和拙劣的算法。衡量算法好坏的重要标准有两个。 </p>
<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
<h2 id="算法的应用领域"><a href="#算法的应用领域" class="headerlink" title="算法的应用领域"></a>算法的应用领域</h2><p>算法可以应用在很多不同的领域中，其应用场景更是多种多样。</p>
<ul>
<li>运算（如最大公约数）</li>
<li>查找（搜索引擎，Mysql查询）</li>
<li>排序（电商商品排序，排名）。排序算法是实现诸多复杂程序的基石</li>
<li>最优决策（如找出最佳路线，有限背包存价值最高物品使用动态规划算法）</li>
<li>面试（主要时为了它，不然学它干嘛）</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构，对应的英文单词是data structure，是数据的组织、管理和存储格式， 其使用目的是为了高效地访问和修改数据。</p>
<h2 id="数据结构组成方式"><a href="#数据结构组成方式" class="headerlink" title="数据结构组成方式"></a>数据结构组成方式</h2><ul>
<li>线性结构（最简单的数据结构，包含数组，链表及由它们衍生的栈、队列、哈希表）</li>
<li>树（树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构）</li>
<li>图（图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系）</li>
<li>其他数据结构（除上述基本数据结构外，还有其它千奇百怪的数据结构。由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等）</li>
</ul>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>有了数据结构这个舞台，算法才可以尽情舞蹈。在解决问题时，不同的算法会选用不同的数据结构。例如排序算法中的堆排序，利用的就是二叉堆这样一种数据结构；再如缓存淘汰算法LRU（Least Recently Used，最近最少使用），利用的就是特殊数据结构哈希链表。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>基本操作执行次数的函数T(n),若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。 <font color="red">因为渐进时间复杂度用大写O来表示，所以也被称为大O表示法。</font> </p>
<p>直白地讲，时间复杂度就是把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是n、n2、n3等。</p>
<p>时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作T(n)=O(f(n))。</p>
<p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125101210140.png" alt="image-20201125101210140"></p>
<h2 id="推导出时间复杂度原则"><a href="#推导出时间复杂度原则" class="headerlink" title="推导出时间复杂度原则"></a>推导出时间复杂度原则</h2><ul>
<li><p>如果运行时间是常数量级，则用常数1表示 </p>
</li>
<li><p>只保留时间函数中的最高阶项 </p>
</li>
<li><p>如果最高阶项存在，则省去最高阶项前面的系数</p>
</li>
</ul>
<h2 id="不同时间复杂度"><a href="#不同时间复杂度" class="headerlink" title="不同时间复杂度"></a>不同时间复杂度</h2><ul>
<li><p>多项式时间算法的时间复杂度：O(1)&lt;O(log<del>2</del>n)&lt;O(n)&lt;O(nlog<del>2</del>n)&lt;O(n^2^) &lt;O(n^3^)</p>
</li>
<li><p>指数时间算法的时间复杂度：O(2^n^)&lt;O(n!)&lt;O(n^n^)</p>
</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中<font color="red"><strong>临时占用存储空间大小的量度</strong></font>，它同样使用了大O表示法。程序占用空间大小的计算公式记作S(n)=O(f(n))，其中n为问题的规模，f(n)为算法所占存储空间的函数。 <font color="red">空间复杂度就离不开数据结构。</font></p>
<h2 id="不同空间复杂度"><a href="#不同空间复杂度" class="headerlink" title="不同空间复杂度"></a>不同空间复杂度</h2><ul>
<li><p>常量空间（当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1)）</p>
</li>
<li><p>线性空间（当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维空间（当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n^2^)）</p>
</li>
<li><p>递归空间（递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。空间复杂度就是O(n)）</p>
</li>
</ul>
<h2 id="时间与空间的取舍"><a href="#时间与空间的取舍" class="headerlink" title="时间与空间的取舍"></a>时间与空间的取舍</h2><p>在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间，也要提升程序的执行速度。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/23/JDBC%E4%B9%8BDataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/23/JDBC%E4%B9%8BDataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">DataSource介绍及对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-23 09:46:35" itemprop="dateCreated datePublished" datetime="2020-11-23T09:46:35+08:00">2020-11-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JDBC/" itemprop="url" rel="index"><span itemprop="name">JDBC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>DriverManager通过getConnection方法获取的连接，<font color="red">是建立与数据库的连接</font>。但是建立与数据库的连接是一项较耗资源的工作，频繁的进行数据库连接建立操作会产生较大的系统开销。</p>
<p>随着企业级应用复杂度的提升以及对性能要求的提高，这一点是难以接受的。</p>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p><strong>既然每次使用时都重新建立与数据库之间的连接，会产生较大的系统开销。是否可以事先创建一些连接备用，当需要时，从这些连接中选择一个提供出去；当连接使用完毕后，并不是真正的关闭，而是将这些数据状态还原，然后继续等待下一个人使用</strong></p>
<h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>DriverManager只是建立与数据库之间的连接，如何才能将连接池的概念应用其中？</p>
<p><strong>一种很自然的方式就是提供一个薄层的封装，建立一个中间层，这个中间层将DriverManager生成的连接，组织到连接池中，然后从池中提供连接</strong></p>
<p><img src="/2020/11/23/JDBC%E4%B9%8BDataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/897393-20190125140250476-31357459.png" alt="img"></p>
<p><strong>Data Source就是DriverManager的一种替代角色，对外呈现就类似于一个DriverManager，拥有对外提供连接的能力</strong></p>
<p>直接使用DriverManager，驱动程序与管理器是“服务者—管理者”的形式，借助于管理者才能提供服务。</p>
<p>Data Source将驱动程序的概念淡化了，突出驱动程序能够提供的服务与能力，将驱动程序提供的服务与能力抽象为Data Source数据源这一角色。</p>
<p><img src="/2020/11/23/JDBC%E4%B9%8BDataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/897393-20190125140251236-665240055.png" alt="img"></p>
<p><strong>DataSource中获取的连接来自于连接池中，而池中的连接根本也还是从DriverManager获取而来</strong></p>
<p>有了数据源这一中间层，就可以实现连接池和分布式事务的管理。</p>
<p><strong>对外呈现DataSource就是类似于DriverManager的一个存在。</strong></p>
<p><strong>DataSource的形式是JNDI （Java Naming Directory Interface）</strong></p>
<p>DataSource是JNDI资源的一种，那么到底什么是JNDI呢</p>
<p>此处不过多解释，可以简单认为JNDI是类似这样一个东西：</p>
<p>一个哈希表，类型为&lt;String，Object&gt;</p>
<p>JNDI的两个最主要操作：bind和lookup。bind操作负责往哈希表里存对象，lookup则根据这个键值字符串往外取对象。</p>
<p>开发人员可以使用键值——也就是一个字符串名称——来获取某个对象。</p>
<p><strong>简言之就是可以给一个对象命名，然后可以通过名称找到这个对象。</strong></p>
<p><strong>数据源的概念在应用程序与数据库连接之间插入了一个中间层，进而可以实现连接池以及事务管理，并且以JNDI的形式，也能够以非常方便的形式使用。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
