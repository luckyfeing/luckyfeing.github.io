<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">监控之Skywalking的原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 15:08:56" itemprop="dateCreated datePublished" datetime="2021-04-20T15:08:56+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>SkyWalking是一款广受欢迎的国产APM（Application Performance Monitoring，应用性能监控）产品，主要针对微服务、Cloud Native和容器化（Docker、Kubernetes、Mesos）架构的应用。SkyWalking的核心是一个分布式追踪系统，目前是Apache基金会的顶级项目。</p>
<p>要通过SkyWalking将Java应用数据上报至链路追踪控制台，首先需要完成埋点工作。SkyWalking既支持自动探针（Dubbo、gRPC、JDBC、OkHttp、Spring、Tomcat、Struts、Jedis等），也支持手动埋点（OpenTracing）。<img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84%E5%8E%9F%E7%90%86/xtrace_dg_report_by_skywalking.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010928589/article/details/105343949/">agent插件加载原理</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010928589/article/details/106542794?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161890434816780261969574%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161890434816780261969574&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-106542794.nonecase&utm_term=agent&spm=1018.2226.3001.4450">agent采集trace数据</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010928589/article/details/106608864?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161890434816780261969574%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161890434816780261969574&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-106608864.nonecase&utm_term=agent&spm=1018.2226.3001.4450">agent启动服务分析以及性能影响</a></p>
<p><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84%E5%8E%9F%E7%90%86/skywalking.jpg" alt="skywalking"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">监控之Skywalking的UI详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 14:51:00" itemprop="dateCreated datePublished" datetime="2021-04-20T14:51:00+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="UI指标"><a href="#UI指标" class="headerlink" title="UI指标"></a>UI指标</h2><h3 id="cpm-每分钟请求数"><a href="#cpm-每分钟请求数" class="headerlink" title="cpm 每分钟请求数"></a>cpm 每分钟请求数</h3><p>cpm 全称 call per minutes，是吞吐量(Throughput)指标。 下图是拼接的全局、服务、实例和接口的吞吐量及平均吞吐量。<br><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/9c0da3123eb845bc8f81029b0cf86956tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="SLA-服务等级协议"><a href="#SLA-服务等级协议" class="headerlink" title="SLA 服务等级协议"></a>SLA 服务等级协议</h3><p>SLA 全称 Service-Level Agreement，直译为 “服务等级协议”，用来表示提供服务的水平。<br><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/d43aabb380f949c9b1c8892992fb4650tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>在IT中，SLA可以衡量平台的可用性，下面是N个9的计算：</p>
<ol>
<li>1年 = 365天 = 8760小时</li>
<li>99     = 8760 * 1%     =&gt; 3.65天</li>
<li>99.9   = 8760 * 0.1%   =&gt; 8.76小时</li>
<li>99.99  = 8760 * 0.01%  =&gt; 52.6分钟</li>
<li>99.999 = 8760 * 0.001% =&gt; 5.26分钟</li>
</ol>
<p>因此，全年只要发生一次较大规模宕机事故，4个9肯定没戏，一般平台3个9差不多。 但2个9就基本不可用了，相当于全年有87.6小时不可用，每周(一个月按4周算)有1.825小时不可用。 下图是服务、实例、接口的SLA，一般看年度、月度即可。</p>
<h3 id="Percent-Response-百分位数统计"><a href="#Percent-Response-百分位数统计" class="headerlink" title="Percent Response 百分位数统计"></a>Percent Response 百分位数统计</h3><p>表示采集样本中某些值的占比，Skywalking 有 <code>p50、p75、p90、p95、p99</code> 一些列值。 “p99:390” 表示 99% 请求的响应时间在390ms以内。而99%一般用于抛掉一些极端值，表示绝大多数请求。</p>
<h3 id="Slow-Endpoint-慢端点"><a href="#Slow-Endpoint-慢端点" class="headerlink" title="Slow Endpoint 慢端点"></a>Slow Endpoint 慢端点</h3><p>Endpoint 表示具体的服务，例如一个接口。全局Top N的数据，通过这个可以观测平台性能情况。</p>
<h3 id="Heatmap-热力图"><a href="#Heatmap-热力图" class="headerlink" title="Heatmap 热力图"></a>Heatmap 热力图</h3><p>Heapmap 可译为热力图、热度图都可以，途中颜色越深，表示请求数越多，这和GitHub Contributions很像，commit越多，颜色越深。 横坐标是响应时间，鼠标放上去，可以看到具体的数量。 通过热力图，一方面可以直观感受平台的整体流量，另一方面也可以感受整体性能。</p>
<h3 id="apdex（性能指数）"><a href="#apdex（性能指数）" class="headerlink" title="apdex（性能指数）"></a>apdex（性能指数）</h3><p><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/d7e83272482e42169ae7ff6e48167cd8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>是一个衡量服务器性能的标准。 apdex有三个指标：</p>
<ul>
<li>满意：请求响应时间小于等于T。</li>
<li>可容忍：请求响应时间大于T，小于等于4T。</li>
<li>失望：请求响应时间大于4T。</li>
</ul>
<p>T：自定义的一个时间值，比如：500ms。 apdex = （满意数 + 可容忍数/2）/ 总数。 例如：服务A定义T=200ms，在100个采样中，有20个请求小于200ms，有60个请求在200ms到800ms之间，有20个请求大于800ms。计算apdex = (20 + 60/2)/100 = 0.5。</p>
<h3 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h3><p><img src="/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%9A%84UI%E8%AF%A6%E8%A7%A3/ab8042af99c4472f90b567421e6bf00b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/" class="post-title-link" itemprop="url">MySQL深入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-18 14:46:41" itemprop="dateCreated datePublished" datetime="2021-03-18T14:46:41+08:00">2021-03-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>分享思路： 会先从一个简单的update语句入手，分析它在被执行时是如何与InnoDB存储引擎的各种机制结合起来的，并依次完成整个update语句的执行，在本次分享开始前可以先尝试思考如下面试题：</p>
<p>1.数据页和缓存页是什么？如何知道哪些缓存页是空闲的，哪些缓存页是可被清除的？</p>
<p>2.mysql预读机制了解过吗，什么情况下会触发它？mysql是为了应对什么样的场景才设计预读机制？</p>
<p>3.类比redis在内存中也存在冷热数据共存的场景，如何考虑利用lru链表解决预读机制的思想、来对redis缓存的设计进行优化？</p>
<p>4.内存极度不够用情况下，可能每当要加载一个数据页时就要先把一个缓存页刷到磁盘中，出现双倍IO的性能问题，对于这种现象如何考虑优化Mysql内核参数来尽量避免该情况的性能损耗？</p>
<p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144719056.png" alt="image-20210318144719056"></p>
<p>先来思考一个问题。磁盘数据如何加载到mysql中？</p>
<p>一般我们要更新一条数据，数据一开始肯定是存放在磁盘中的，用到时才会被加载到mysql，存放的数据在逻辑概念上我们称为表，物理层面上在磁盘中是按数据页形式存放的，那么加载到mysql中的就称为缓存页。</p>
<p>每个缓存页都有对应的一份描述信息，存放了缓存页的一些元数据相关的一些信息，通过描述信息可以快速定位到缓存页，最开始描述信息指向的缓存页当然都是空闲没有数据的，从磁盘加载数据页信息流程如下图所示：</p>
<img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144742613.png" alt="image-20210318144742613" style="zoom:33%;">

<p>那么从磁盘中加载一个数据页到mysql中真的就这么简单吗？<br>会不会同一份数据页加载到mysql中出现重复加载的情况？<br>如何快速知道当前数据页是否已经加载到mysql中了？</p>
<p>这时候可能很多人已经想到了：缓存。对于已经加载到mysql中的数据页，我们大可以设计一个缓存将加载过的数据页信息缓存一下，一方面可以防止同一份数据页重复加载到mysql，另一方面当我们需要使用到数据页的信息时，可以通过缓存信息快速定位mysql中对应的缓存页，没错，InnoDB存储引擎中就是按照这样的思路设计了一个数据页缓存：</p>
<p>这时候可能很多人已经想到了：缓存。对于已经加载到mysql中的数据页，我们大可以设计一个缓存将加载过的数据页信息缓存一下，一方面可以防止同一份数据页重复加载到mysql，另一方面当我们需要使用到数据页的信息时，可以通过缓存信息快速定位mysql中对应的缓存页，没错，InnoDB存储引擎中就是按照这样的思路设计了一个数据页缓存：</p>
<p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144815867.png" alt="image-20210318144815867"></p>
<p>这个时候又有一个问题，既然现在我们已经知道磁盘中的数据页是加载到buffer pool缓冲池中的，那么我们怎么样才能知道哪些缓存页是空闲的？</p>
<p>哪些缓存页是没有被加载过数据页信息的呢？毕竟加载过的数据的缓存页和没加载过数据的缓存页混在一起，倘若此时想找一个空闲的缓存页肯定也是一件很麻烦的事。InnoDB存储引擎在设计时当然也考虑到了这点，这里它引入了free链表这个数据结构，将那些还没有被使用的缓存页的描述信息用双向循环链表给组合在一起，需要用到时就卸一个节点出来存放数据页信息，如下图所示：</p>
<p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144830908.png" alt="image-20210318144830908"></p>
<p>lru链表实现的目的就是为让哪些被访问的缓存页能够尽量排到靠前位置，那么此时如果此时内存不够需要淘汰掉一些缓存页时，此时就可以到lru链表尾部，将哪些最近最少被访问的尾部节点给刷盘释放缓存页腾出内存来。</p>
<p>到这里为此，为了更新一个sql，我们已经把该sql所需要的数据、通过InnoDB存储引擎的各种底层机制，给加载到了Buffer Pool缓冲池中了，接下来就是在InnoDB中执行更新操作。</p>
<p>我们在来看看。 在InnoDB中执行更新操作是怎么回事？</p>
<p>此时我们需要的数据已经从磁盘中加载到缓冲池中了，下一步当然就是执行更新操作了：先对需要更新的那行数据加锁、原始数据写一份到redo log中便于可能的回滚操作、执行update操作，此时缓存页的数据就被更新了，当然就和磁盘中的数据页的数据就不一致了，这样的缓存页我们称之为脏页，如下图所示：</p>
<p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144904374.png" alt="image-20210318144904374"></p>
<p>那么，如何才能知道缓冲池中，那些缓存页是脏页呢？如果能把脏页和空闲缓存页分离出来，我们就可以把那些脏页的数据及时给刷到磁盘中、再释放掉脏页内存，在内存不够的情况下不就可以重复利用了吗？<br>这里InnoDB的设计方法类似free链表，设计了一个flush链表，也就是那些在缓冲池中被更新过数据的缓存页，这些缓存页的描述信息都会被添加到flush链表中（这里提到的free链表、lru链表、flush链表都是双向循环链表，且节点都为缓存页的描述信息，其中flush链表的节点同时也在lru链表中），如下图所示：</p>
<p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144925987.png" alt="image-20210318144925987"></p>
<p>然后的话。有了这种机制，会不会导致缓冲池内存不足触发脏页刷盘？</p>
<p>经过以上流程执行了一段时间后，直到InnoDB缓冲池中的内存即将不够用了，此时如果再来一条sql语句的更新操作，要想成功把磁盘中的数据加载到缓存页中，就需要先清理下内存中的缓存页了。通过之前提到的lru链表，可以找到lru链表表尾的节点，这些节点之所以在表尾，是因为基本上没什么人访问它们，那它们在内存不够用的场景下，当然要被优先给清理掉啊；</p>
<p>因为flush链表的节点也在lru链表中，此时在缓存页清理时需要做一个简单的判断：若缓存页既在lru表尾的节点同时也在flush链表中，就需要先把脏页给刷盘了，然后再释放掉缓存页的内存，保证那些事务修改的数据能够落库；若缓存页不在flush链表，那更简单直接释放缓存页内存，然后将这些释放完内存缓存页的描述信息，重现给添加到free链表中，完成一次大的循环（free链表-&gt;lru链表-&gt;flush链表-&gt;free链表），如下图所示：</p>
<p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318144959394.png" alt="image-20210318144959394"></p>
<p>最后一个就是存在的问题就是： mysql的预读机制带来的问题以及优化后的lru链表对该问题的解决方案</p>
<p>mysql预读机制可能会扰乱我们之前设想的lru链表的处理逻辑。当一个数据页被加载到缓冲池中时，可能顺带会把其他无关紧要的数据页也加载到缓冲池中，这些顺带加载到内存的数据页，它们往往被访问的频率是非常低的，但是由于lru链表的特点，新加入的总是会优先被排在lru的链表头，导致这些顺带进来的、访问频率比较低的缓存页排在比较靠前的位置，导致free链表不够时，lru链表反而会把那些本来访问频率较高、但是此时被排挤到lru链表尾的缓存页给刷盘清理了，这是很不合理的。</p>
<p>优化后的lru链表主要引入了冷热数据分离的思想解决了mysql预读机制带来的问题。把lru链表分为热数据区和冷数据区，热数据区主要存放那些访问频率高的缓存页，冷数据区存放访问频率较低的缓存页；从磁盘加载数据到lru链表时，首先会将加载到的缓存页直接先放到冷数据链的表头，如果1000ms（默认，可配置）后冷数据的缓存页又被访问了，此时就认为这些1000ms之后被访问的缓存页，在不久的未来可能还会被访问，可以认为它们是热数据了，就会把这些缓存页从冷数据区的链表给移动到热数据区链表的表头，通过该步骤可以将热数据从冷数据堆中给巧妙的分离出来，如下图所示</p>
<p><img src="/2021/03/18/MySQL%E6%B7%B1%E5%85%A5/image-20210318145057335.png" alt="image-20210318145057335"></p>
<p>此时如果要加载其他数据页发现缓冲池内存不够，实际上后台一直会有一个线程开启的一个定时任务，不断的从lru链表的尾部将缓存页给刷到磁盘中并释放缓存页，lru链表冷热数据分离的设计，确保了定时任务从lru链表尾部回收的缓存页都是访问频率很低的数据，对性能的影响也就降到了最低。</p>
<p>1.数据页和缓存页是什么？如何知道哪些缓存页是空闲的，哪些缓存页是可被清除的？</p>
<p>2.mysql预读机制了解过吗，什么情况下会触发它？mysql是为了应对什么样的场景才设计预读机制？</p>
<p>3.类比redis在内存中也存在冷热数据共存的场景，如何考虑利用lru链表解决预读机制的思想、来对redis缓存的设计进行优化？</p>
<p>4.内存极度不够用情况下，可能每当要加载一个数据页时就要先把一个缓存页刷到磁盘中，出现双倍IO的性能问题，对于这种现象如何考虑优化Mysql内核参数来尽量避免该情况的性能损耗？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/" class="post-title-link" itemprop="url">总结-面试系列文章</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-12 14:06:29" itemprop="dateCreated datePublished" datetime="2021-03-12T14:06:29+08:00">2021-03-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/101062.htm">脏页、内存映射、延迟写、sync、fsync、fdatasync</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/92f33aa0ff52">page cache</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/92f33aa0ff52">零拷贝（transferTo方法</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/193cae9cbf07">零拷贝</a><br>trasferTo方法的缺点：如果我想在传输时修改数据本身，就无能为力了。还有一种方式就是内存映射。</p>
<p>Linux 会以页为单位管理内存，无论是将磁盘中的数据加载到内存中，还是将内存中的数据写回磁盘，操作系统都会以页面为单位进行操作，哪怕我们只向磁盘中写入一个字节的数据，我们也需要将整个页面中的全部数据刷入磁盘中。</p>
<p>Linux 同时支持正常大小的内存页和大内存页（Huge Page），绝大多数处理器上的内存页的默认大小都是 4KB，虽然部分处理器会使用 8KB、16KB 或者 64KB 作为默认的页面大小，但是 4KB 的页面仍然是操作系统默认内存页配置的主流；除了正常的内存页大小之外，不同的处理器上也包含不同大小的大页面，我们在 x86 处理器上就可以使用 2MB 的内存页。</p>
<p>4KB 的内存页其实是一个历史遗留问题，在上个世纪 80 年代确定的 4KB 一直保留到了今天。虽然今天的硬件比过去丰富了很多，但是我们仍然沿用了过去主流的内存页大小。执行命令：getconf PAGE_SIZE。获取系统的page大小，一般为4096即4K。在windows上查询为65536即64K。</p>
<p>对于系统的所有文件I/O请求，操作系统都是通过page cache机制实现的，对于操作系统而言，磁盘文件都是由一系列的数据块顺序组成，数据块的大小随系统不同而不同，x86 linux系统下是4KB(一个标准页面大小)。内核在处理文件I/O请求时，首先到page cache中查找(page cache中的每一个数据块都设置了文件以及偏移信息)，如果未命中，则启动磁盘I/O，将磁盘文件中的数据块加载到page cache中的一个空闲块。之后再copy到用户缓冲区中。</p>
<p>很明显，同一块文件数据，在内存中保存了两份，这既占用了不必要的内存空间、冗余的拷贝、以及造成的CPU cache利用率不高。针对此问题，操作系统提供了<strong>内存映射</strong>机制（linux中mmap、windows中Filemapping）</p>
<p>由于页面缓存的存在，当程序调用write()写字节时，只需将其复制到页面缓存中，并将页面标记为dirty。磁盘I/O通常不会立即发生，因此你的程序不会阻塞等待磁盘。不利的一面是，如果计算机崩溃，您的写操作将永远无法完成，因此像数据库事务日志这样的关键文件必须调用fsync()立刻写入到磁盘(但是仍然需要担心驱动器控制器的缓存，也可能造成并不会立刻写入到物理磁盘)。另一方面，读取通常会阻塞程序，直到数据可用为止。内核使用<strong>预先加载技术</strong>来缓解这个问题，其中一个例子是提前读取，内核将几个页面预加载到页面缓存中，等待你的读取。你可以通过调整内核的一些选项来调整预先加载行为，可以控制<strong>顺序读取文件</strong>还是<strong>随机读取文件</strong>。Linux确实对内存映射文件进行预读，但我不确定Windows是否如此。最后，可以在Linux中使用O_DIRECT绕过页面缓存，或者在Windows中使用NO_BUFFERING绕过页面缓存，这是数据库软件经常做的事情。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6939881308114354207">内核空间和用户空间、零拷贝</a></p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6863631783028588558?utm_source=gold_browser_extension?utm_source=gold_browser_extension">Java新特性</a></p>
<p><a target="_blank" rel="noopener" href="http://www.hellojava.com/a/86057.html">Java序列化为什么要实现Serializable接口</a></p>
<p><strong>为什么要进实现Serializable接口：</strong>为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来，这是java中的提供的保存对象状态的机制—序列化。</p>
<p><strong>在什么情况下需要使用到Serializable接口呢？</strong><br>　　1、当想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>　　2、当想用套接字在网络上传送对象的时候；<br>　　3、当想通过RMI传输对象的时候；<br>　　<br><strong>serialVersionUID</strong><br>serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。<strong>如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。</strong>类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。显式地定义serialVersionUID有两种用途：<br>　　a. 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；<br>　　b. 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6939852157478764551">happens-before规则</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6939841279329042439">BIO、BIO、AIO详解</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6890377431137484807">String的hashCode详解</a></p>
<p>hash冲突解决方法是：使用链表</p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1684596804166445688&wfr=spider&for=pc">volatile是如何实现可见性和有序性的</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36759405/article/details/82856542">volatile内存屏障</a></p>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6189034c6984">懒汉双检查单例模式</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/emmmsuperdan/article/details/81564412">可见性、有序性、原子性</a></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6934866839247781919">Synchronized</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6904880910408433678">为什么推荐ReentrantLock而不是Synchronized</a></p>
<p>synchronized的锁强度依次为：无锁状态、偏向锁状态、轻量级锁、重量级锁，会随着多线程的竞争强度逐渐升级。这个是众所周知的,最近在看《并发编程的艺术》中提到了锁只能升级而无法降级，但是我记得在之前的某些资料中看到过:<strong>锁是可以降级的，只不过条件比较苛刻</strong>。不知道对于此有什么具体的权威的资料可以参考呢？</p>
<p>并没有 JDK 标准，完全看各家 JVM 是咋实现的了。</p>
<p>像 HotSpot JVM 其实就支持锁降级，但是锁升降级效率较低，如果频繁升降级的话对性能就会造成很大影响。重量级锁降级发生于 STW 阶段，降级对象为仅仅能被 VMThread 访问而没有其他 JavaThread 访问的对象。</p>
<p>被锁的对象都被垃圾回收了有没有锁还有啥关系？因此基本认为锁不可降级。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6911277200402546695">ReentrantReadWriteLock详解</a></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6939477784498716679">集合</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/72638721">集合</a></p>
<p><strong>队列Queue-》Deque</strong></p>
<ul>
<li>PriorityQueue </li>
<li>ConcurrentLinkedQueue 基于单链表实现</li>
<li>ArrayDeque</li>
<li>ConcurrentLinkedDeque 基于双链表实现</li>
</ul>
<p>堵塞队列BlockingQueue》BlockingDeque</p>
<ul>
<li><p>LinkedBlockingDeque 双端双向链表堵塞队列</p>
</li>
<li><p>LinkedBlockingQueue</p>
</li>
<li><p>ArrayBlockQueue</p>
</li>
<li><p>LinkedTransferQueue</p>
</li>
<li><p>PriorityBlockingQueue</p>
</li>
<li><p>SynchronousQueue</p>
</li>
<li><p>DelayQueue</p>
</li>
</ul>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6937266785854947358">ConcurrentHashMap</a>: key和value不能为null，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505119&idx=1&sn=f68a4c4943b13e34969c1643a3cda916&source=41#wechat_redirect">死循环</a>，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505071&idx=1&sn=5b9bbe01a71cbfae4d277dd21afd6714&source=41#wechat_redirect">为啥不能为null</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/vernonzheng/article/details/8244984">ConcurrentSkipListMap</a></li>
<li>ConcurrentSkipListSet 基于ConcurrentSkipListMap实现，key,value不能为空</li>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWriteArraySet  基于CopyOnWriteArrayList实现，添加时判断是否存在，添加时，加可重入非公平锁ReentrantLock，复制新的数组对象，进行写操作，写完之后释放锁。此时查询操作不影响。</li>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/426750225_120591934">SkipList自己实现</a> </li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd">线程池除了常见的4种拒绝策略，你还知道哪些</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6936098056299347975">源码分析</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6937121827445538847">线程及线程池</a></p>
<p><font color="red">ForkJoinPool</font>的核心是采用分治法的思想，将一个大任务拆分为若干互不依赖的子任务，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务。同时，为了最大限度地提高并行处理能力，采用了工作窃取算法来运行任务，也就是说当某个线程处理完自己工作队列中的任务后，尝试当其他线程的工作队列中窃取一个任务来执行，直到所有任务处理完毕。所以为了减少线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。<br><font color="red">parallelStream</font>是一个并行执行的流，其使用 fork/join （ForkJoinPool）并行方式来拆分任务和加速处理过程。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37896194/article/details/113125334">parallelStream问题点（线程安全和commonPool卡顿）</a></p>
<h2 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoblog/p/4729309.html">spring集成hessian</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zh350229319/article/details/71191347">spring集成hessian</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6a36dd1fcca8">java序列化之Hessian</a></p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6936524515883089950">Class文件结构</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码结构</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6938276102553108511">类加载机制</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6934124106795188238">类加载机制</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6938233964725272606">Java中的常量池</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6937494243552264200">JVM生命周期</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6931372159356895246">JVM结构</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6936390496122044423">JVM问题</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6938255230563778597">java虚拟机类型</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6938599768071340040">JVM垃圾回收</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6894500808583610382">JVM垃圾回收</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6905300467027771405">回收算法</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6926056104590278664">垃圾回收器CMS详解</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6926056104590278664">垃圾回收器G1</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6936013918212980743">JVM基本参数</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6911624328472133646">MAT深度</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6929038616417009671">JVM总结</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6911668514096955406">JVM总结</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6894398706225774606">JVM 性能调优监控工具</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6920102335582568456">JVM 性能调优监控工具</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6894500808583610382">CMS GC问题分析与解决</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6894501519001911310">CMS GC问题分析与解决</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6934218573963329549">JVM性能优化实战</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6920468146906202119">JVM性能调优实战</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6921527104009928717">JVM性能调优实战</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6921278948030709768">JVM性能调优实战</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6905172888601493517">性能</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6915648411643412488">JVM如何调优</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6913788257843019783">代码优化细节</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6927291610732429325">性能调优</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6918668597715795975">记一次线上服务器oom 排查过程</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6937652257185857566">对象的实例化与对象的访问</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6929273950438424589">hashCode()底层 JDK C++ 源码实现</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6935407834863501349">伪共享</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MoreThinking/p/9908001.html">垃圾回收算法</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zeussbook/p/12726824.html">Java垃圾回收CMS、G1、ZGC</a></p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>当bean继承spring 的FactoryBean时，使用applicationContext.getBean(beanName)得到的是bean的getObject方法的返回值，而不是bean本身。此时需要的话请用 applicationContext.getBean(‘&amp;’+beanName)将得到bean本身。</p>
<p>而且使用 applicationContext.getBean(beanName)的时候bean的getObject只会调用一次，此后都是直接返回原先的对象， 使用applicationContext.getBean(‘&amp;’+beanName)后再调用bean.getObject方法就可以多次调用bean.getObject方法体，从而改变返回对象的值</p>
<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据beanName从缓存中拿实例</span></span><br><span class="line">    <span class="comment">//先从一级缓存拿</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//从二级缓存中拿</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//如果还拿不到，并且允许bean提前暴露</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">//从三级缓存中拿到对象工厂</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//从工厂中拿到对象</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">//升级到二级缓存</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;======get instance from 3 level cache-&gt;beanName-&gt;&quot;</span> + beanName + <span class="string">&quot;-&gt;value-&gt;&quot;</span> + singletonObject );</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">//删除三级缓存</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring规范"><a href="#Spring规范" class="headerlink" title="Spring规范"></a>Spring规范</h2><ul>
<li>xxxConfigurer</li>
<li>xxxSupport</li>
<li>xxxFactoryBean   配置bean</li>
<li>xxxBuilder  建造者模式，屏蔽复制对象的构建过程</li>
<li>xxxAdapter  xxxInterceptorAdapter</li>
<li>xxxHandler  处理器</li>
<li>xxxListener</li>
<li>xxxLoader</li>
<li>Advisor 通知器可以获取Advice通知<br>PointcutAdvisor带切入点的通知器<br>Advised被增强的类——》AdvisedSupport  -&gt;ProxyCreatorSupport  -&gt;ProxyFactory<br>通过DefaultAopProxyFactory implements AopProxyFactory创建AopProxy</li>
<li>AdvisorAdapter -》getInterceptor</li>
</ul>
<h2 id="Spring校验机制"><a href="#Spring校验机制" class="headerlink" title="Spring校验机制"></a>Spring校验机制</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_mrsongyang/article/details/106115243">Validation实战</a></p>
<h2 id="Spring中Resource"><a href="#Spring中Resource" class="headerlink" title="Spring中Resource"></a>Spring中Resource</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deityjian/p/11487644.html">Resource-&gt;ResourceLoader</a></p>
<h2 id="Spring属性占位符"><a href="#Spring属性占位符" class="headerlink" title="Spring属性占位符"></a>Spring属性占位符</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;configBean&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:$&#123;collectiongaode.dir&#125;/conf/db.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul>
<li>Spring AOP</li>
<li>Spring AspectJ<ul>
<li>@Before: 前置通知, 在方法执行之前执行</li>
<li>@After: 后置通知, 在方法执行之后执行 。</li>
<li>@AfterRunning: 返回通知, 在方法返回结果之后执行</li>
<li>@AfterThrowing: 异常通知, 在方法抛出异常之后</li>
<li>@Around: 环绕通知, 围绕着方法执行</li>
</ul>
</li>
</ul>
<h2 id="Spring-transaction"><a href="#Spring-transaction" class="headerlink" title="Spring  transaction"></a>Spring  transaction</h2><p>事务隔离级别，传播行为</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44605704/article/details/108754813">事务失效</a></p>
<p>事务失效解决方法：</p>
<ul>
<li>AopContext.currentProxy(); 需要</li>
<li>getBean</li>
<li>注入自己</li>
</ul>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhao307/p/5555597.html">四种HandlerMapping</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6922276487995326472">spring mvc原理</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种方案：使用自定义类实现OncePerRequestFilter,使用ServletComponentScan,使用FilterRegistrationBean</span></span><br><span class="line"><span class="comment">//自定义拦截器可以实现OncePerRequestFilter保证一次请求只调用一次doFilterInternal方法，内部的forward不会再多执行一次</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">timeFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setEnable(<span class="keyword">false</span>); <span class="comment">//也可保证只调用一次</span></span><br><span class="line">    TimeFilter timeFilter = <span class="keyword">new</span> TimeFilter();</span><br><span class="line">    registrationBean.setFilter(timeFilter);</span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    urls.add(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    registrationBean.setUrlPatterns(urls);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Async"><a href="#Spring-Async" class="headerlink" title="Spring Async"></a>Spring Async</h2><p><a target="_blank" rel="noopener" href="https://my.oschina.net/guangshan/blog/1807721">Spring中AOP失效</a></p>
<h2 id="Spring工具类"><a href="#Spring工具类" class="headerlink" title="Spring工具类"></a>Spring工具类</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497786">AnnotationUtils、AnnotatedElementUtils、AnnotationConfigUtils</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/binarylei/p/10415585.html">注解工具类</a></p>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liaojie970/p/9395505.html">SpringBoot默认异常处理</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/myitnews/p/13548435.html">application.properties配置详解</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/myitnews/p/12329126.html">WebMvcConfigurer 与 WebMvcConfigurationSupport的坑</a></p>
<ul>
<li>WebMvcConfigurer、WebMvcConfigurationSupport、WebMvcConfigurerAdapter</li>
<li>HandlerInterceptorAdapter</li>
</ul>
<h2 id="Spring-Statemachine"><a href="#Spring-Statemachine" class="headerlink" title="Spring Statemachine"></a>Spring Statemachine</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9ee887e045dd">Spring Statemachine 概念及应用</a></p>
<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><font color="red">AuthenticationManager</font>其中可以包含多个List<AuthenticationProvider> providers，还有父类的AuthenticationManager parent对象<br>AuthenticationManager    ——》ProviderManager<br>AuthenticationManager    ——》OAuth2AuthenticationManager</AuthenticationProvider></p>
<p><font color="red">AuthenticationProvider  </font>——》主要用来进行认证操作的类 调用其中的authenticate()方法去进行认证操作<br>1、 使用AuthenticationManager的实现类里的Authentication authenticate(Authentication authentication)方法认证<br>2、 从providers中循环获取AuthenticationProvider对象，判断是否supports支持Authentication的类对象<br>3、 如果返回true就使用AuthenticationProvider实现类里的authenticate方法，返回Authentication对象。不为空，复制给最开始的Authentication对象的实例；为空，则继续循环认证。一直认证失败，则使用父类的AuthenticationManager对象进行认证</p>
<p>AuthenticationProvider ——》AbstractUserDetailsAuthenticationProvider ——》DaoAuthenticationProvider（重写retrieveUser方法，获取注入的<font color="red">UserDetailsService</font>对象，通过loadUserByUsername方法获取用户详情<font color="red">UserDetails</font>对象（可以使用User也可自己实现），之后调用createSuccessAuthentication方法，创建UsernamePasswordAuthenticationToken对象）<br>AuthenticationProvider ——》RememberMeAuthenticationProvider</p>
<p>**<font color="red">Authentication </font>**是Spring Security方式的认证主体<br>Principal ——》Authentication ——》AbstractAuthenticationToken ——》UsernamePasswordAuthenticationToken<br>Principal ——》Authentication ——》AbstractAuthenticationToken ——》OAuth2Authentication<br>Principal ——》Authentication ——》AbstractAuthenticationToken ——》RememberMeAuthenticationToken</p>
<p><font color="red">UserDetailsService </font>是Spring Security查询密码的封装服务，通过<strong>扩展这个接口来显示获取我们的用户信息</strong><br>UserDetailsService ——》UserDetailsManager ——》InMemoryUserDetailsManager （内存保存用户名和密码）<br>UserDetailsService ——》自定义数据库Service操作（从数据库获取密码）</p>
<p><font color="red">SecurityContextHolder</font><strong>持有的是安全上下文（security context）的信息</strong>。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权等等，这些都被保存。默认<strong>使用ThreadLocal 策略来存储认证信息</strong>。在web环境下，Spring Security在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。</p>
<p><font color="red">SecurityContext </font>持有Authentication对象和其他可能需要的信息<br><font color="red">GrantedAuthority </font>对认证主题的应用层面的授权<strong>，含当前用户的权限信息</strong>，通常使用角色表示<br><font color="red">AuthenticationSuccessHandler</font> 认证成功处理器<br><font color="red">AuthenticationFailureHandler</font> 认证失败处理器</p>
<h3 id="Spring-Security-内置拦截器顺序及用途-核心"><a href="#Spring-Security-内置拦截器顺序及用途-核心" class="headerlink" title="Spring Security 内置拦截器顺序及用途(核心)"></a>Spring Security 内置拦截器顺序及用途(核心)</h3><p>1、<font color="red">ChannelProcessingFilter</font>，使用它因为我们可能会指向不同的协议(如:Http,Https)<br>2、<font color="red">SecurityContextPersistenceFilter</font>，负责从SecurityContextRepository 获取或存储 SecurityContext。SecurityContext 代表了用户安全和认证过的session<br>3、<font color="red">ConcurrentSessionFilter</font>,使用SecurityContextHolder的功能，更新来自“安全对象”不间断的请求,进而更新SessionRegistry<br>4、<font color="red">认证进行机制</font>，UsernamePasswordAuthenticationFilter，CasAuthenticationFilter，BasicAuthenticationFilter等等–SecurityContextHolder可能会修改含有Authentication这样认证信息的token值<br>5、<font color="red">SecurityContextHolderAwareRequestFilter</font>,如果你想用它的话，需要初始化spring security中的HttpServletRequestWrapper到你的servlet容器中。<br>6、<font color="red">JaasApiIntegrationFilter</font>，如果JaasAuthenticationToken在SecurityContextHolder的上下文中，在过滤器链中JaasAuthenticationToken将作为一个对象。<br>7、<font color="red">RememberMeAuthenticationFilter</font>，如果还没有新的认证程序机制更新SecurityContextHolder，并且请求已经被一个“记住我”的服务替代，那么将会有一个Authentication对象将存放到这（就是 已经作为cookie请求的内容）。<br>8、<font color="red">AnonymousAuthenticationFilter</font>，如果没有任何认证程序机制更新SecurityContextHolder，一个匿名的对象将存放到这。<br>9、<font color="red">ExceptionTranslationFilter</font>，为了捕获spring security的错误，所以一个http响应将返回一个Exception或是触发AuthenticationEntryPoint。<br>10、<font color="red">FilterSecurityInterceptor</font>，当连接被拒绝时，保护web URLS并且抛出异常。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/Spring-Security.png" alt="Spring-Security"></p>
<h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p><font color="red">WebSecurityConfigurerAdapter</font>（配套的注解：@EnableWebSecurity开启Security；@EnableGlobalMethodSecurity(prePostEnabled = true)//保证post之前的注解可以使用）<br>1、configure(HttpSecurity http)：这个方法是我们配置拦截的地方，可以配置拦截器，可以配置成功处理器和失败处理器等<br>2、configure(WebSecurity web)：这个方法主要用于访问一些静态的东西控制。其中ignoring()方法可以让访问跳过filter验证<br>3、configureGlobal(AuthenticationManagerBuilder auth)：这个方法是主要进行验证的地方，配置真实认证类</p>
<p><font color="red">SecurityConfigurerAdapter</font>(配置不带web的Security)<br>1、 public void configure(HttpSecurity http) 配置拦截。。。。</p>
<p><font color="red">ResourceServerConfigurerAdapter </font>资源服务（@EnableResourceServer，@AutoConfigureAfter(AuthorizationConfig.class)）<br>1、 public void configure(HttpSecurity http) 配置拦截的地方，可以配置拦截器，可以配置成功处理器和失败处理器等<br>@EnableResourceServer注解使用@Import(ResourceServerConfiguration.class)，ResourceServerConfiguration类继承WebSecurityConfigurerAdapter类，因此，应该是可以不单独配置WebSecurityConfigurerAdapter类的。<br>可以使用http.exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint),配置异常处理，可以自定义返回值</p>
<p><font color="red">AuthorizationServerConfigurerAdapter </font>认证服务（@EnableAuthorizationServer）<br>1、public void configure(ClientDetailsServiceConfigurer clients)   配置JdbcClientDetailsService，自带表配置<br>2、public void configure(AuthorizationServerEndpointsConfigurer endpoints) 配置TokenStore。。。。<br>3、public void configure(AuthorizationServerSecurityConfigurer security)  配置allowFormAuthenticationForClients</p>
<p>@EnableOAuth2Client 启动OAuth2客户端<br>@EnableAuthorizationServer 启动OAuth2认证服务</p>
<h3 id="OAUTH2四种模式"><a href="#OAUTH2四种模式" class="headerlink" title="OAUTH2四种模式"></a>OAUTH2四种模式</h3><p>1、授权码模式：authorization_code<br>2、简单模式：implicit<br>3、密码模式：password<br>4、客户端模式：client_credentials</p>
<h3 id="OAUTH2对外暴露接口"><a href="#OAUTH2对外暴露接口" class="headerlink" title="OAUTH2对外暴露接口"></a>OAUTH2对外暴露接口</h3><p>TokenEndpoint类暴露Controller的/oauth/token请求，支持get和post方式，获取<strong>access_token</strong>，grant_type=refresh_token刷新<br>CheckTokenEndpoint类暴露/oauth/check_token请求，验证token<br>AuthorizationEndpoint类暴露/oauth/authorize请求，支持get和post方式<br>通过类FrameworkEndpointHandlerMapping，获取带@FrameworkEndpoint注解，创建RequestMappingInfo</p>
<h3 id="OAUTH2原理"><a href="#OAUTH2原理" class="headerlink" title="OAUTH2原理"></a>OAUTH2原理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bluuusea/article/details/80284458?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">获取token/刷新token流程</a></p>
<h3 id="源码解析系列"><a href="#源码解析系列" class="headerlink" title="源码解析系列"></a>源码解析系列</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Lammonpeter/article/details/100922926">源码解析</a><br><a target="_blank" rel="noopener" href="https://my.oschina.net/liuyuantao/blog/1922049?from=singlemessage">源码解析实战</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019347662">oauth2数据库版</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1c6c966c3a7">oauth_client_details表详解</a><br><a target="_blank" rel="noopener" href="https://www.andaily.com/spring-oauth-server/db_table_description.html">其它表详解</a></p>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul>
<li>SqlSession:作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li>
<li>Executor:MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li>
<li>StatementHandler:封装了JDBC  Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</li>
<li>ParameterHandler:负责对用户传递的参数转换成JDBC Statement 所需要的参数，</li>
<li>ResultSetHandler:负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</li>
<li>TypeHandler:负责java数据类型和jdbc数据类型之间的映射和转换</li>
<li>MappedStatement:MappedStatement维护了一条&lt;select|update|delete|insert&gt;节点的封装，</li>
<li>SqlSource:负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回BoundSql 表示动态生成的SQL语句以及相应的参数信息 </li>
<li>Configuration:MyBatis所有的配置信息都维持在Configuration对象之中。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7dab1e397437">MyBatis 流式查询</a></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kongtiao5/article/details/82771694">缓存三种问题及解决方案</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6934930917500649486">三个问题及解决方案</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6917577839185231879">redis使用Hash替换String</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6901951315962757134">Redisson 源码解析</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6937642117107810334">Caffeine</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangliangyu/article/details/8165644">redis数据丢失及解决</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1760408">Redis 数据持久化</a></p>
<h3 id="Redisson分布式锁中WatchDog实现机制"><a href="#Redisson分布式锁中WatchDog实现机制" class="headerlink" title="Redisson分布式锁中WatchDog实现机制"></a>Redisson分布式锁中WatchDog实现机制</h3><p>客户端加锁(lock)成功后，会启用一个watch dog后台线程，使用netty时间轮HashedWheelTimer算法，每隔delay=10秒检查如果客户端还持有锁，则重新设置锁的过期时间为lockWatchdogTimeout=30秒（默认)，其中delay = lockWatchdogTimeout/3。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延期操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//Lua脚本延期锁的过期时间</span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="comment">//延期成功</span></span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// 继续循环延期操作</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每隔10秒检查一次</span></span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p><a target="_blank" rel="noopener" href="https://developer.51cto.com/art/201904/594615.htm">倒排索引</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangfox/p/9460361.html">为什么要移除Type</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">简单部署和使用</a></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1663609942544356335&wfr=spider&for=pc">集群角色分离</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/truelove12358/article/details/105577414">倒排索引与B+Tree对比</a></p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/LBSer/p/4119841.html">FST（finite state transducers）</a></p>
<p><a target="_blank" rel="noopener" href="https://elasticsearch.cn/article/6178#tip3">Elasticsearch中数据是如何存储的（Lucene）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wx1528159409/article/details/105973336">ES的数据写入原理，refresh和flush</a></p>
<p><a target="_blank" rel="noopener" href="https://liubowen.blog.csdn.net/article/details/81950081?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">Elasticsearch原理（三）：写入流程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoyu_BD/article/details/81735473">Elasticsearch原理（一）：实时架构</a></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html">持久化变更</a></p>
<p>Master Node：主节点<br>Master eligible nodes：合格节点<br>Data Node：数据节点<br>Coordinating Node：协调节点<br>Ingest Node：ingest节点<br>machine learning：机器学习节点</p>
<p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/794174-20200508142929527-1342544356.png" alt="img"></p>
<p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/794174-20200508142947572-369187416.png" alt="img"></p>
<ul>
<li>Master Node：主节点，该节点不和应用创建连接，每个节点都保存了集群状态，master节点不占用磁盘IO和CPU，内存使用量一般。</li>
<li>Master eligible nodes：合格节点，每个节点部署后不修改配置信息，默认就是一个 eligible 节点，该节点可以参加选主流程，成为Mastere节点。该节点也保存了集群节点的状态。eligible节点比Master节点更节省资源，因为它还未成为 Master 节点，只是有资格成功Master节点。</li>
<li>Data Node：数据节点，该节点和索引应用创建连接、接收索引请求，该节点真正存储数据，ES集群的性能取决于该节点的个数（每个节点最优配置的情况下），data节点会占用大量的CPU、IO和内存。</li>
<li>Coordinating Node：协调节点，该节点和检索应用创建连接、接受检索请求，但其本身不负责存储数据，可当负责均衡节点，该节点不占用io、cpu和内存。</li>
<li>Ingest Node：ingest 节点可以看作是数据前置处理转换的节点，支持 pipeline管道 设置，可以使用 ingest 对数据进行过滤、转换等操作，类似于 logstash 中 filter 的作用，功能相当强大。</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6929795131042168846">数据一致性</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6931884966813007879?utm_source=gold_browser_extension">CAP理论</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6931144402597330951">BASE 理论</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6898288789371027470">CAP和BASE理论</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6938444096990248997">Paxos 共识算法</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6914964637478256654">Paxos算法</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903838399348749">故障恢复(重试、超时、退避)</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6886261194110271502">Basic Paxos</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6908889730843148295">浅析分布式中的 CAP、BASE、2PC、3PC、Paxos、Raft、ZAB</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6898288336906125325">Raft 协议实战系列</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6930774718114955278">Gossip协议</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6902004920543952909">Redis Cluster Gossip 协议</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/130332285">分布式一致性算法-Paxos、Raft、ZAB、Gossip</a></p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6874788280378851335">分布式事务概念详解</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6919698046628560903">最终一致性</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6899645923024355336">seata实践</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903913691283469#heading-13">seata三种模式详解</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6912462666187407367">https://juejin.cn/post/6912462666187407367</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6893927391333187597">XA事务</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6904106776925323272">Saga模型设计</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6892759955921698830">事务TCC架构设计原理</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6850418108599894023">Seata分布式事务几种常见模式分析</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6924496491960778760">分布式事务</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/107273472">探秘蚂蚁金服分布式事务 Seata 的AT、Saga和TCC模式</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4b662407c66">saga详解</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6922346183553712136">分布式事务及seata</a></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6867040340797292558">RocketMQ 和 Kafka事务消息</a></p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6865212415622823949">Zookeeper基础知识</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6934623205823315976">zookeeper选举同步</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuzhenzhao/p/9994450.html">监听源码解析NIO创建tcp连接</a><br><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/1383365-20190820101928955-908505489.png" alt="img"></p>
<h2 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903953008689165">XXL-JOB</a></p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6939881308114354207">Netty零拷贝</a></p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>Dubbo缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>
<p><strong>Transporter</strong>: mina, netty, grizzy<br><strong>Serialization</strong>: dubbo, hessian2, java, json<br><strong>Dispatcher</strong>: all, direct, message, execution, connection<br><strong>ThreadPool</strong>: fixed, cached<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010634066/article/details/80509411">connections和粘滞连接</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6907931653243568142">SPI可扩展机制</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6907932891087388679">Dubbo RPC 实现原理机制</a></p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ETTTTTSS/article/details/103792608">普通集群及镜像集群</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013905744/article/details/86736536">Spring RabbitMQ源码解析</a></p>
<p>注重类：</p>
<ul>
<li>RabbitListenerAnnotationBeanPostProcessor</li>
<li>RabbitListenerContainerFactory</li>
<li>RabbitListenerEndpointRegistrar</li>
<li>AbstractMessageListenerContainer -》MessageListenerContainer<ul>
<li>SimpleRabbitListenerContainerFactory</li>
<li>DirectRabbitListenerContainerFactory</li>
</ul>
</li>
<li>@RabbitListener</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6901905073752768526">kafka简单实战</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6922339184011280392">滴滴开源Kafka管理平台，支持分区不足扩容、分区热点迁移、topic资源治理</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lizhitao/article/details/25667831">kafka基本参数配置</a><br><a target="_blank" rel="noopener" href="https://shuyi.tech/archives/head-first-of-kafka-rebalance">重平衡</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2ca54bd7c52">partition重分配流程</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29493353/article/details/88535092">Kafka数据丢失</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuanlong122716/article/details/105160545/">springboot-kafka综合实战</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/slslslyxz/article/details/108492931">手动确认</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuanlong122716/article/details/105160545/">SpringBoot集成kafka全面实战</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43253123/article/details/82884387">Spring Cloud Stream 和 Kafka案例教程</a></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904137172189198">分布式锁实现</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6922275721431744525">Redis分布式锁演进</a></p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6905923569084006414">分库分表</a><br><a target="_blank" rel="noopener" href="http://www.2cto.com/database/201508/429967.html">锁机制</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904051453198343">幻读</a><br><a target="_blank" rel="noopener" href="http://blog.itpub.net/22664653/viewspace-750824/">next-key lock实例及问题</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanggb/p/11252966.html">回表查询和覆盖索引</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904042292838408">分库分表</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd">数据库规范</a></p>
<ul>
<li>数据库命令规范</li>
<li>数据库基本设计规范</li>
<li>数据库字段设计规范</li>
<li>索引设计规范</li>
<li>数据库 SQL 开发规范</li>
<li>数据库操作行为规范</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b3f9007be020">mysql为什么要使用自增主键</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6860252224930070536">binlog、redolog、undolog</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6865571676902391821">Explain执行计划详解</a></p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6861783980354895885">MyCat实战</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010391342/article/details/89526366">ShardingSphere实战</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xinzhifu1/article/details/109309303">ShardingSphere分片策略</a></p>
<p>标准分片策略-》包含精准（=，in分片）、范围（between and）<br>复合分片策略-》多个分片字段（如order_id,user_id）<br>行表达式分片策略-》简单的行分片<br>Hint分片策略 -》外部配置，sql执行前通过HintManager指定分库分表策略，可以在主从模式下通过hintManager.setMasterRouteOnly();指定读主库</p>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zxl315/article/details/80420688">选择HikariCP作为默认数据库连接池的五大理由</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzNTY4NTYxMA==&mid=2247483699&idx=1&sn=5efd1f9d872688eba0029c71b3668662&chksm=fa80f1b6cdf778a0bbd12ce5e97507d697058d7bc070082a8ca828c9910c1379ead43c7b9a05&scene=21#wechat_redirect">HikariCP连接池监控指标实战</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015558954">整合Druid连接池及监控</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/whb11/p/11315463.html">数据库连接池对比</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c26d1ed16bb4">合理的数据库连接数</a><br><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/caoshousong/p/10845396.html">数据库参数配置显示</a></strong></p>
<ul>
<li><p>show processlist;</p>
</li>
<li><p>show variables like ‘%max_connection%’; 查看最大连接数</p>
</li>
<li><p>set global max_connections=1000;  重新设置最大连接数</p>
</li>
<li><p>show variables like ‘thread_cache_size’;  当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)</p>
</li>
<li><p>show status like  ‘Threads%’;   show global status like <code>&#39;Thread%&#39;</code>;<br><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210316155408524.png" alt="image-20210316155408524"></p>
<p>Threads_connected ：这个数值指的是打开的连接数.</p>
<p>Threads_running ：这个数值指的是激活的连接数，这个数值一般远低于connected数值.</p>
<p>Threads_created：表示创建过的线程数，通过查看Threads_created就可以查看MySQL服务器的进程状态</p>
</li>
</ul>
<h2 id="Binlog同步"><a href="#Binlog同步" class="headerlink" title="Binlog同步"></a>Binlog同步</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c0a7850e8fe9">canal数据同步</a></p>
<img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/1939592-5a09f70e5cc0db63.png" alt="img" style="zoom:45%;">

<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6872600073843736589">redis缓存</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6931742052325523470">缓存与数据库双写不一致解决方案</a></p>
<h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6900188956525068301">幂等方法</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6870337534275256333">通用的幂等组件</a></p>
<h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/june0816/p/6474569.html">Logback异步日志</a></p>
<h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6894120291744612359">ELK实战</a></p>
<h2 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6916450426774781966">灰度发布的探索与实践</a></p>
<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/andy_zhang2007/article/details/86680622">feign原理</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/11832534.html">feign默认采用的长连接</a></p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6923333239335550983">限流的基本概念</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6922809716804419591">令牌桶限流</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6921299013769625607">分布式限流方案（gateway限流，redis+lua实现限流，nginx限流）</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6932094513292771342">分布式限流</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6870671578372423694">sentinel系列文章</a><br><a href>Hystrix</a></p>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fu_huo_1993/article/details/88350180">配置详解</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMzQ2MDIyMA==&mid=2247484653&idx=1&sn=7f098999680025413e4d2801de81b427&chksm=faa2e17ecdd56868a431e7a63b86ce74686343aff73b010b3fa3a35d48ba0915647aaa99bf18&scene=158#rd">Hystrix替代方案</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1452039">hystrix、resilience4j与sentinel的区别以及选型对比</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5531b66b777a">Resilience4j-轻量级熔断框架</a></p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p><a target="_blank" rel="noopener" href="https://www.upyun.com/tech/article/501/Apache%20APISIX%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E6%9E%81%E8%87%B4%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90.html"><strong>APISIX特点</strong></a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6882952033712734216">API 网关选型及包含 BFF 的架构设计</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/kingwinstar/article/details/105752725">灰度发布</a></p>
<p>springcloud官方推荐使用loadbalancer来代替ribbon。因为ribbon是阻塞的，但从官方的loadbalancer的负载均衡算法来看，目前loadbalancer默认只支持轮询算法，要其他算法得自己扩展实现，而ribbon默认支持7种算法，用默认的算法基本上就可以满足我们的需求了。其次ribbon支持懒加载处理，超时以及重试与断路器hystrix集成等配置，loadbalancer目前就支持重试。所以如果正式环境要自己实现灰度发布，可以考虑对ribbon进行扩展。</p>
<h2 id="Spring-Cloud-Loadbalancer"><a href="#Spring-Cloud-Loadbalancer" class="headerlink" title="Spring-Cloud-Loadbalancer"></a>Spring-Cloud-Loadbalancer</h2><ul>
<li>使用响应式编程，官方推荐</li>
<li>目前只支持轮询一种负载均衡算法</li>
</ul>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/262660637">Ribbon原理</a></p>
<ul>
<li>服务列表（配置文件，注册中心发现）</li>
<li>动态更新服务列表（主动拉取和通知）</li>
<li>心跳检测</li>
<li>路由，ServerListFilter过滤路由</li>
<li>负载均衡(7种)</li>
</ul>
<h2 id="SkyWalking"><a href="#SkyWalking" class="headerlink" title="SkyWalking"></a>SkyWalking</h2><ul>
<li>UI（数据统计展示）</li>
<li>OAP(Observability Analysis Platform，采集数据，处理数据，分析数据。config/application.yml|alarm-settings-sample.yml可以配置)链路数据收集器，对agent传过来的数据进行整合分析处理并落入相关的数据存储中。storage模块配置：Skywalking的存储，时间更迭，sw已经开发迭代到了8.x版本，支持以ElasticSearch、ElasticSearch7、Mysql、TiDB、H2、influxdb作为存储介质进行数据存储。Receiver是Skywalking在6.x提出的新的概念，负责从被监控的系统中接受指标数据。用户完全可以参照OpenTracing规范来上传自定义的监控数据。Skywalking官方提供了service-mesh、istio、zipkin的相关能力。</li>
<li>Agent(配置文件，config/agent.config,可以配置显示sql参数，默认不显示；启动时可以根据配置文件，设置参数)使用Javaagent做字节码植入，无侵入式的收集，并通过HTTP或者gRPC方式发送数据到Skywalking Collector。</li>
</ul>
<h2 id="全局唯一-ID-生成算法"><a href="#全局唯一-ID-生成算法" class="headerlink" title="全局唯一 ID 生成算法"></a>全局唯一 ID 生成算法</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6846687584324681735">薄雾算法</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6892959738670743565">分布式主键ID 生成方案</a></p>
<h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6921975658490888205">简单介绍</a></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41288743/article/details/103000406">架构设计思路</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wchukai/p/5653135.html">分布式系统的架构思路</a><br><a target="_blank" rel="noopener" href="https://wetest.qq.com/lab/view/80.html">高性能服务器架构思路【不仅是思路】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yellowzf3/article/details/103590725">电商系统微服务架构实践与优化思路</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d567ce4ade2e"></a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d3b1d4ad67a8">架构理论</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0133417bdf8">实现电商平台从业务到架构的治理体系</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903957693726727">什么是中台</a></p>
<h2 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h2><p><a target="_blank" rel="noopener" href="http://blog.yannxia.top/2018/06/26/java/spring/projectreactor/">ProjectReactor原理</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/john1337/article/details/101028908">参考</a><br><a target="_blank" rel="noopener" href="https://ifeve.com/reactive%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E7%BC%96%E7%A8%8B-reactor/">实例</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/mmlz00/article/details/86249161"><strong>Stream, RxJava, Reactor之比较</strong></a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/daniel7443/article/details/80761340">Spring Reactor 入门与实践</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95966853">Reactive Streams</a><br><a target="_blank" rel="noopener" href="https://www.immuthex.com/posts/reactor-netty-reference-guide/contents/">Reactor Netty</a></p>
<p><code>Reactor Netty</code>为<code>HTTP</code>（包括Websocket），<code>TCP</code>和<code>UDP</code>提供了支持背压的网络引擎。<br>Mono 实现了 org.reactivestreams.Publisher 接口，代表0到1个元素的发布者（Publisher）。<br>Flux 同样实现了 org.reactivestreams.Publisher 接口，代表0到N个元素的发布者（Publisher）。</p>
<h2 id="Spring-Webflux"><a href="#Spring-Webflux" class="headerlink" title="Spring Webflux"></a>Spring Webflux</h2><p><a target="_blank" rel="noopener" href="http://ddrv.cn/a/287053">介绍与使用</a><br>在Spring Webflux的函数路由中，<code>Mono&lt;ServerResponse&gt;</code>被用作返回类型，<code>Mono&lt;ResponseEntity&lt;MyPojo&gt;&gt;</code>也被用作返回类型。在@Controller中使用<code>Mono&lt;ResponseEntity&lt;MyPojo&gt;&gt;</code>，@RequestMapping（Get，Post-mappingetc…）作为返回类型。</p>
<p><code>org.springframework.http.ResponseEntity</code>来自原始的Spring Mvc Framework包，<code>org.springframework.web.reactive.function.server.ServerResponse</code>来自springReactive包。</p>
<p>reactive包有一个“兼容性”模式，允许您使用向后兼容的<code>@RestController</code>注释，它们通常会像以前一样返回<code>ResponseEntity</code>。</p>
<p>没有兼容性特性的Reactive包实现使用<code>Router</code>和<code>Handler</code>，通常返回<code>ServerResponse</code>。</p>
<h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p><a target="_blank" rel="noopener" href="http://www.54tianzhisheng.cn/2018/12/30/Flink-ElasticSearch-Sink/">flink详细资料</a></p>
<h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dtlscsl/article/details/94185614">HashedWheelTimer原理</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65835110">时间轮算法应用</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzhcoder/article/details/102575327">应用的详解</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/eryuan/p/7955677.html">延时队列</a></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6890369482758471687">算法</a><br><a target="_blank" rel="noopener" href="https://visualgo.net/zh/sorting?slide=1">算法动态网站</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）</a></p>
<h2 id="其它资料"><a href="#其它资料" class="headerlink" title="其它资料"></a>其它资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/xjjdog/bcmall">各种</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/macrozheng/mall-learning?utm_source=gold_browser_extension">商城项目实战</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes?utm_source=gold_browser_extension">题目</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangmx1993328/article/details/88598625">Jackson使用</a><br>Jackson 提供三种不同的方法来操作 JSON<br>1）<a target="_blank" rel="noopener" href="https://www.yiibai.com/jackson/jackson_streaming_api.html">流式API</a> - 使用 Stream(流) 的方式对 Json 的每一个组成部分进行最细粒度的控制，JsonParser 读取数据，JsonGenerator 写入数据。<br>2）树模型 - 将 JSON 文件在内存里以树的形式表示，通过 JsonNode 处理单个Json节点，类似于 XML 的 DOM 解析器。(常用)<br>3）databind 模块 - ObjectMapper 读/写 JSON 是 POJO 序列化与反序列化 json 最方便的方式。（常用）<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/linyifan_/article/details/83060408">fastjson的值过滤器ValueFilter</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tangjiean/article/details/51729371">okhttp连接池复用机制</a></p>
<h2 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DXDE443/p/10308059.html">从ftp取文件并http调用某接口上传此文件</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/javaguide/p/11861749.html">5种bean映射对比</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuyi13535496566/p/12634898.html">EasyExcel</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6937092573429235720">实用工具</a></p>
<h2 id="博客转PDF"><a href="#博客转PDF" class="headerlink" title="博客转PDF"></a>博客转PDF</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zqj-blog/p/10602702.html">pdfkit</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/421cc442f06c">GitBook 使用教程</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0388d8bb49a7">Gitbook教程</a></p>
<p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210319154428936.png" alt="image-20210319154428936"></p>
<p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210425163338982.png" alt="image-20210425163338982"></p>
<p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210425172859785.png" alt="image-20210425172859785"></p>
<p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210426131334386.png" alt="image-20210426131334386"></p>
<p><img src="/2021/03/12/%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/image-20210426131344665.png" alt="image-20210426131344665"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/11/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/11/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">唯一id生成方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-11 10:14:37" itemprop="dateCreated datePublished" datetime="2021-03-11T10:14:37+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ID/" itemprop="url" rel="index"><span itemprop="name">ID</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="那么分布式ID需要满足那些条件"><a href="#那么分布式ID需要满足那些条件" class="headerlink" title="那么分布式ID需要满足那些条件"></a><strong>那么分布式ID需要满足那些条件</strong></h2><ul>
<li>全局唯一：必须保证ID是全局性唯一的，基本要求</li>
<li>高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈</li>
<li>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性</li>
<li>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单</li>
<li>趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>UUID</li>
<li>数据库自增ID</li>
<li>数据库多主模式</li>
<li>号段模式</li>
<li>Redis</li>
<li>雪花算法（SnowFlake）</li>
<li>滴滴出品（TinyID）</li>
<li>百度 （Uidgenerator）</li>
<li>美团（Leaf）</li>
</ul>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>生成足够简单，本地生成无网络消耗，具有唯一性</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无序的字符串，不具备趋势自增特性</li>
<li>没有具体的业务含义</li>
<li>长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 <code>UUID</code> 的无序性会导致数据位置频繁变动，严重影响性能。</li>
</ul>
<h3 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h3><p>建一张表，插入数据，通过增长id实现</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SEQUENCE_ID(<span class="keyword">value</span>)  <span class="keyword">VALUES</span> (<span class="string">&#x27;values&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>实现简单，ID单调自增，数值类型查询速度快</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>DB单点存在宕机风险，无法扛住高并发场景</li>
<li>访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐</li>
</ul>
<h3 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h3><p>设置不同的步长</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>解决DB单点问题</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>必要时可能还需要停机修改</strong>，不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景</li>
</ul>
<h3 id="基于数据库的号段模式"><a href="#基于数据库的号段模式" class="headerlink" title="基于数据库的号段模式"></a>基于数据库的号段模式</h3><p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> id_generator (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  max_id <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;当前最大id&#x27;</span>,</span><br><span class="line">  step <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;号段的布长&#x27;</span>,</span><br><span class="line">  biz_type	<span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;业务类型&#x27;</span>,</span><br><span class="line">  <span class="keyword">version</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;版本号&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">update</span> id_generator <span class="keyword">set</span> max_id = <span class="comment">#&#123;max_id+step&#125;, version = version + 1 where version = # &#123;version&#125; and biz_type = XXX</span></span><br></pre></td></tr></table></figure>

<p>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code></p>
<p>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</p>
<h3 id="基于Redis模式"><a href="#基于Redis模式" class="headerlink" title="基于Redis模式"></a><strong>基于Redis模式</strong></h3><p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p>
<ul>
<li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>
<li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li>
</ul>
<h3 id="基于雪花算法（Snowflake）模式"><a href="#基于雪花算法（Snowflake）模式" class="headerlink" title="基于雪花算法（Snowflake）模式"></a><strong>基于雪花算法（Snowflake）模式</strong></h3><p><img src="/2021/03/11/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/v2-21c519f61a3c693c5c446aeb2af72880_720w.jpg" alt="img"></p>
<ul>
<li>1bit:一般是符号位，不做处理</li>
<li>41bit:用来记录时间戳，这里可以记录69年，如果设置好起始时间比如今年是2018年，那么可以用到2089年，到时候怎么办？要是这个系统能用69年，我相信这个系统早都重构了好多次了。</li>
<li>10bit:10bit用来记录机器ID，总共可以记录1024台机器，一般用前5位代表数据中心ID，后面5位是某个数据中心的机器ID</li>
<li>12bit:循环位，用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。</li>
</ul>
<p><strong>雪花算法问题：</strong></p>
<ul>
<li><strong>时间回拨问题</strong>：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现数据重复</li>
<li><strong>机器id分配及回收问题</strong>：目前机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果该机器宕机了，对应的workerId分配后的回收问题</li>
<li><strong>机器id上限</strong>：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li><p>时间回拨问题：</p>
<ul>
<li>采用直接抛异常方式，打日志，通知RD时钟回滚。：这种很不友好，太粗暴</li>
<li>采用等待跟上次时间的一段范围：这种算是简单解决，可以接受，但是如果等待一段时间后再出现回拨，则抛异常，可接受，但是不算彻底解决。如果时间回拨时间较短，比如配置5ms以内，那么可以直接等待一定的时间，让机器的时间追上来。</li>
<li>利用扩展位，如将12位的循环位拆分出2位，可以作为扩展位。比如当这个时间回拨比较长的时候，不需要等待，直接在扩展位加1。2位的扩展位允许我们有3次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li>
</ul>
</li>
<li><p>机器id分配及回收：</p>
<ul>
<li>采用zookeeper的顺序节点分配：解决了分配，回收可采用zookeeper临时节点回收，但是临时节点不可靠，存在无故消失问题，因此也不可靠</li>
<li>采用DB中插入数据作为节点值：解决了分配，没有解决回收</li>
<li>使用ip，需要三位，0~255</li>
</ul>
</li>
<li><p>机器id上限</p>
<p>该问题在业内都没有处理，也就是说如果采用雪花算法，则必定会存在该问题，但是该问题也只有需要大量的业务机器共享的场景才会出现，这种情况，采用客户端双Buffer+DB这种非雪花算法的方案也未尝不可。</p>
</li>
</ul>
<h3 id="其它解决方案"><a href="#其它解决方案" class="headerlink" title="其它解决方案"></a><strong>其它解决方案</strong></h3><p>分布式ID生成服务，提供服务：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45401061/article/details/108175058">Butterfly方案</a></p>
<h3 id="百度（uid-generator）"><a href="#百度（uid-generator）" class="headerlink" title="百度（uid-generator）"></a>百度（uid-generator）</h3><p><code>uid-generator</code>是由百度技术部开发，项目GitHub地址 <a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator">https://github.com/baidu/uid-generator</a></p>
<p><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的<code>snowflake</code>算法不同在于，<code>uid-generator</code>支持自<code>定义时间戳</code>、<code>工作机器ID</code>和 <code>序列号</code> 等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略。</p>
<p><code>uid-generator</code>需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的<code>workId</code>数据由host，port组成。</p>
<p><strong>对于<code>uid-generator</code> ID组成结构</strong>：</p>
<p><code>workId</code>，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的<code>snowflake</code>不太一样，时间的单位是秒，而不是毫秒，<code>workId</code>也不一样，而且同一应用每次重启就会消费一个<code>workId</code>。</p>
<blockquote>
<p>参考文献<br><a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</a></p>
</blockquote>
<h3 id="美团（Leaf）"><a href="#美团（Leaf）" class="headerlink" title="美团（Leaf）"></a>美团（Leaf）</h3><p><code>Leaf</code>由美团开发，github地址：<a target="_blank" rel="noopener" href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a></p>
<p><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用。</p>
<h5 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h5><p>先导入源码 <a target="_blank" rel="noopener" href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a> ，在建一张表<code>leaf_alloc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;leaf_alloc&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;leaf_alloc&#96; (</span><br><span class="line">  &#96;biz_tag&#96; varchar(128)  NOT NULL DEFAULT &#39;&#39; COMMENT &#39;业务key&#39;,</span><br><span class="line">  &#96;max_id&#96; bigint(20) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;当前已经分配了的最大id&#39;,</span><br><span class="line">  &#96;step&#96; int(11) NOT NULL COMMENT &#39;初始步长，也是动态调整的最小步长&#39;,</span><br><span class="line">  &#96;description&#96; varchar(256)  DEFAULT NULL COMMENT &#39;业务key的描述&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;数据库维护的更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;biz_tag&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<p>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leaf.name&#x3D;com.sankuai.leaf.opensource.test</span><br><span class="line">leaf.segment.enable&#x3D;true</span><br><span class="line">leaf.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;leaf_test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;characterSetResults&#x3D;utf8</span><br><span class="line">leaf.jdbc.username&#x3D;root</span><br><span class="line">leaf.jdbc.password&#x3D;root</span><br><span class="line"></span><br><span class="line">leaf.snowflake.enable&#x3D;false</span><br><span class="line">#leaf.snowflake.zk.address&#x3D;</span><br><span class="line">#leaf.snowflake.port&#x3D;</span><br></pre></td></tr></table></figure>

<p>启动<code>leaf-server</code> 模块的 <code>LeafServerApplication</code>项目就跑起来了</p>
<p>号段模式获取分布式自增ID的测试url ：http：//localhost：8080/api/segment/get/leaf-segment-test</p>
<p>监控号段模式：<a target="_blank" rel="noopener" href="http://localhost:8080/cache">http://localhost:8080/cache</a></p>
<h5 id="snowflake模式"><a href="#snowflake模式" class="headerlink" title="snowflake模式"></a>snowflake模式</h5><p><code>Leaf</code>的snowflake模式依赖于<code>ZooKeeper</code>，不同于<code>原始snowflake</code>算法也主要是在<code>workId</code>的生成上，<code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序Id来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaf.snowflake.enable&#x3D;true</span><br><span class="line">leaf.snowflake.zk.address&#x3D;127.0.0.1</span><br><span class="line">leaf.snowflake.port&#x3D;2181</span><br></pre></td></tr></table></figure>

<p>snowflake模式获取分布式自增ID的测试url：<a target="_blank" rel="noopener" href="http://localhost:8080/api/snowflake/get/test">http://localhost:8080/api/snowflake/get/test</a></p>
<h3 id="滴滴（Tinyid）"><a href="#滴滴（Tinyid）" class="headerlink" title="滴滴（Tinyid）"></a>滴滴（Tinyid）</h3><p><code>Tinyid</code>由滴滴开发，Github地址：<a target="_blank" rel="noopener" href="https://github.com/didi/tinyid%E3%80%82">https://github.com/didi/tinyid。</a></p>
<p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aN77sK4V1x5e5dSVZcibkzSRRKsAGqcpaauibVfY9iaOR5LFvzDPictNjHXmmdhr31153iaiaStvXIJEo2g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;">

<p>在这里插入图片描述 <code>Tinyid</code>提供<code>http</code>和<code>tinyid-client</code>两种方式接入</p>
<h5 id="Http方式接入"><a href="#Http方式接入" class="headerlink" title="Http方式接入"></a>Http方式接入</h5><p>（1）导入Tinyid源码：</p>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com/didi/tinyid.git">https://github.com/didi/tinyid.git</a></p>
<p>（2）创建数据表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tiny_id_info` (</span><br><span class="line">  `id` bigint(<span class="number">20</span>) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line">  `biz_type` varchar(<span class="number">63</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;业务类型，唯一&#x27;</span>,</span><br><span class="line">  `begin_id` bigint(<span class="number">20</span>) NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#x27;</span>,</span><br><span class="line">  `max_id` bigint(<span class="number">20</span>) NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;当前最大id&#x27;</span>,</span><br><span class="line">  `step` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;步长&#x27;</span>,</span><br><span class="line">  `delta` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL DEFAULT <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;每次id增量&#x27;</span>,</span><br><span class="line">  `remainder` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;余数&#x27;</span>,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT <span class="string">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT <span class="string">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `version` bigint(<span class="number">20</span>) NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;版本号&#x27;</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span>,</span></span><br><span class="line"><span class="function">  UNIQUE KEY `uniq_biz_type` <span class="params">(`biz_type`)</span></span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8 COMMENT <span class="string">&#x27;id信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tiny_id_token` (</span><br><span class="line">  `id` <span class="keyword">int</span>(<span class="number">11</span>) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">&#x27;自增id&#x27;</span>,</span><br><span class="line">  `token` varchar(<span class="number">255</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;token&#x27;</span>,</span><br><span class="line">  `biz_type` varchar(<span class="number">63</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;此token可访问的业务类型标识&#x27;</span>,</span><br><span class="line">  `remark` varchar(<span class="number">255</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT <span class="string">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT <span class="string">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span></span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8 COMMENT <span class="string">&#x27;token信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100000</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;2018-07-21 23:52:58&#x27;</span>, <span class="string">&#x27;2018-07-22 23:19:27&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;test_odd&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;2018-07-21 23:52:58&#x27;</span>, <span class="string">&#x27;2018-07-23 00:39:24&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;0f673adf80504e2eaa552f5d791b644c&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:46&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:48&#x27;</span>);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;0f673adf80504e2eaa552f5d791b644c&#x27;</span>, <span class="string">&#x27;test_odd&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:46&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:48&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（3）配置数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">datasource.tinyid.names&#x3D;primary</span><br><span class="line">datasource.tinyid.primary.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">datasource.tinyid.primary.url&#x3D;jdbc:mysql:&#x2F;&#x2F;ip:port&#x2F;databaseName?autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8</span><br><span class="line">datasource.tinyid.primary.username&#x3D;root</span><br><span class="line">datasource.tinyid.primary.password&#x3D;123456</span><br></pre></td></tr></table></figure>

<p>（4）启动<code>tinyid-server</code>后测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取分布式自增ID: http:&#x2F;&#x2F;localhost:9999&#x2F;tinyid&#x2F;id&#x2F;nextIdSimple?bizType&#x3D;test&amp;token&#x3D;0f673adf80504e2eaa552f5d791b644c&#39;</span><br><span class="line">返回结果: 3</span><br><span class="line"></span><br><span class="line">批量获取分布式自增ID:</span><br><span class="line">http:&#x2F;&#x2F;localhost:9999&#x2F;tinyid&#x2F;id&#x2F;nextIdSimple?bizType&#x3D;test&amp;token&#x3D;0f673adf80504e2eaa552f5d791b644c&amp;batchSize&#x3D;10&#39;</span><br><span class="line">返回结果:  4,5,6,7,8,9,10,11,12,13</span><br></pre></td></tr></table></figure>

<h5 id="Java客户端方式接入"><a href="#Java客户端方式接入" class="headerlink" title="Java客户端方式接入"></a>Java客户端方式接入</h5><p>重复Http方式的（2）（3）操作</p>
<p>引入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.xiaoju.uemc.tinyid&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;tinyid-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;tinyid.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tinyid.server &#x3D;localhost:9999</span><br><span class="line">tinyid.token &#x3D;0f673adf80504e2eaa552f5d791b644c</span><br></pre></td></tr></table></figure>

<p><code>test</code> 、<code>tinyid.token</code>是在数据库表中预先插入的数据，<code>test</code> 是具体业务类型，<code>tinyid.token</code>表示可访问的业务类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取单个分布式自增ID</span><br><span class="line">Long id &#x3D;  TinyId . nextId( &quot; test &quot; );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 按需批量分布式自增ID</span><br><span class="line">List&lt; Long &gt; ids &#x3D;  TinyId . nextId( &quot; test &quot; , 10 );</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7grafana%E4%BB%AA%E8%A1%A8%E7%9B%98%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7grafana%E4%BB%AA%E8%A1%A8%E7%9B%98%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">grafana仪表盘模板</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-04 17:42:51" itemprop="dateCreated datePublished" datetime="2021-03-04T17:42:51+08:00">2021-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>在官网<a target="_blank" rel="noopener" href="https://grafana.com/grafana/dashboards%E4%B8%8A%E6%89%BE%E9%9C%80%E8%A6%81%E7%9A%84Grafana%E4%BB%AA%E8%A1%A8%E7%9B%98%E6%A8%A1%E6%9D%BF%EF%BC%8C%E6%89%BE%E5%88%B0id">https://grafana.com/grafana/dashboards上找需要的Grafana仪表盘模板，找到id</a></p>
<h2 id="配置仪表盘"><a href="#配置仪表盘" class="headerlink" title="配置仪表盘"></a>配置仪表盘</h2><p>在Grafana上配置模板id，配置prometheus的地址</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7Prometheus%E7%AE%80%E5%8D%95demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7Prometheus%E7%AE%80%E5%8D%95demo/" class="post-title-link" itemprop="url">Prometheus简单demo</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-04 10:01:42" itemprop="dateCreated datePublished" datetime="2021-03-04T10:01:42+08:00">2021-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liangcha007/article/details/86699013">https://blog.csdn.net/liangcha007/article/details/86699013</a></p>
<h2 id="4种常用Metrics-types（指标类型）"><a href="#4种常用Metrics-types（指标类型）" class="headerlink" title="4种常用Metrics types（指标类型）"></a>4种常用Metrics <strong>types</strong>（指标类型）</h2><h3 id="Counter（计数器）"><a href="#Counter（计数器）" class="headerlink" title="Counter（计数器）"></a>Counter<strong>（计数器）</strong></h3><blockquote>
<p>连续增加不会减少的计数器，可以用于记录只增不减的类型，例如：网站访问人数，系统运行时间等。</p>
<p>对于Counter类型的指标，只包含一个inc()的方法，就是用于计数器+1.</p>
<p>一般而言，Counter类型的metric指标在冥冥中我们使用_total结束，如http_requests_total.</p>
</blockquote>
<h3 id="Gauge（计量器）"><a href="#Gauge（计量器）" class="headerlink" title="Gauge（计量器）"></a>Gauge<strong>（计量器）</strong></h3><blockquote>
<p>可增可减的仪表盘，曲线图</p>
<p>对于这类可增可减的指标，用于反应应用的当前状态。</p>
<p>例如在监控主机时，主机当前空闲的内存大小，可用内存大小等等。</p>
<p>对于Gauge指标的对象则包含两个主要的方法inc()和dec()，用于增加和减少计数。</p>
</blockquote>
<h3 id="Histogram（直方图、柱状图）"><a href="#Histogram（直方图、柱状图）" class="headerlink" title="Histogram（直方图、柱状图）"></a>Histogram<strong>（直方图、柱状图）</strong></h3><blockquote>
<p>主要用来统计数据的分布情况，这是一种特殊的metrics数据类型，代表的是一种近似的百分比估算数值，统计所有离散的指标数据在各个取值区段内的次数。例如：我们想统计一段时间内http请求响应小于0.005秒、小于0.01秒、小于0.025秒的数据分布情况。那么使用Histogram采集每一次http请求的时间，同时设置bucket。</p>
<p>Histogram会自动创建3个指标，分别为：<br>一、事件发生总次数： basename_count:<br>#实际含义： 当前一共发生了2次http请求<br>io_namespace_http_requests_latency_seconds_histogram_count{path=”/“,method=”GET”,code=”200”,} 2.0<br>二、所有事件产生值的大小的总和： basename_sum<br>#实际含义： 发生的2次http请求总的响应时间为13.107670803000001 秒<br>io_namespace_http_requests_latency_seconds_histogram_sum{path=”/“,method=”GET”,code=”200”,} 13.107670803000001<br>三、事件产生的值分布在bucket中的次数： basename_bucket{le=”上包含”}</p>
<p>在总共2次请求当中。http请求响应时间 &lt;=0.005 秒 的请求次数为0</p>
<p>io_namespace_http_requests_latency_seconds_histogram_bucket{path=”/“,method=”GET”,code=”200”,le=”0.005”,} 0.0<br>在总共2次请求当中。http请求响应时间 &lt;=0.01 秒 的请求次数为0<br>io_namespace_http_requests_latency_seconds_histogram_bucket{path=”/“,method=”GET”,code=”200”,le=”0.01”,} 0.0<br>在总共2次请求当中。http请求响应时间 &lt;=0.025 秒 的请求次数为0<br>io_namespace_http_requests_latency_seconds_histogram_bucket{path=”/“,method=”GET”,code=”200”,le=”0.025”,} 0.0</p>
</blockquote>
<h3 id="Summary（摘要）"><a href="#Summary（摘要）" class="headerlink" title="Summary（摘要）"></a>Summary<strong>（摘要）</strong></h3><blockquote>
<p>Summary和Histogram非常相似，都可以统计事件发生的次数或者大小，以及其分布情况，他们都提供了对时间的计数_count以及值的汇总_sum，也都提供了可以计算统计样本分布情况的功能，不同之处在于Histogram可以通过histogram_quantile函数在服务器计算分位数。而Sumamry的分位数则是直接在客户端进行定义的。因此对于分位数的计算，Summary在通过PromQL进行查询的时候有更好的性能表现，而Histogram则会消耗更多的资源，但是相对于客户端而言Histogram消耗的资源就更少。用哪个都行，根据实际场景自由调整即可。</p>
</blockquote>
<h2 id="exporter"><a href="#exporter" class="headerlink" title="exporter"></a>exporter</h2><p>广义上向prometheus提供监控数据的程序都可以成为一个exporter的，一个exporter的实例称为target, prometheus通过轮训的方式定时从这些target中获取监控数据。exporter来源主要2个方面，一个是社区提供的，一种是用户自定义的。</p>
<p>官方和一些社区提供好多exproter, 我们可以直接拿过来采集我们的数据。 官方的exporter地址： <a target="_blank" rel="noopener" href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></p>
<h2 id="Blackbox-Exporter"><a href="#Blackbox-Exporter" class="headerlink" title="Blackbox Exporter"></a>Blackbox Exporter</h2><p>bloackbox exporter是prometheus社区提供的黑盒监控解决方案，运行用户通过HTTP、HTTPS、DNS、TCP以及ICMP的方式对网络进行探测。这里通过blackbox对我们的站点信息进行采集。</p>
<h3 id="blackbox的安装"><a href="#blackbox的安装" class="headerlink" title="blackbox的安装"></a>blackbox的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入下载目录</span></span><br><span class="line">[root@node00 ~]# cd /usr/src/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">[root@node00 src]# wget https://github.com/prometheus/blackbox_exporter/releases/download/v0.15.1/blackbox_exporter-0.15.1.linux-amd64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">[root@node00 src]#  tar xf blackbox_exporter-0.15.1.linux-amd64.tar.gz </span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署到特定位置</span></span><br><span class="line">[root@node00 src]# mv blackbox_exporter-0.15.1.linux-amd64 /usr/local/exporter/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">[root@node00 src]# cd /usr/local/exporter/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 软连接</span></span><br><span class="line">[root@node00 exporter]# ln -s blackbox_exporter-0.15.1.linux-amd64 blackbox_exporter</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入自启目录</span></span><br><span class="line">[root@node00 exporter]#  cd /usr/lib/systemd/system</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置blackbox的开机自启文件</span></span><br><span class="line">[root@node00 system]# cat blackbox_exporter.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=blackbox_exporter</span><br><span class="line">After=network.target </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=prometheus</span><br><span class="line">Group=prometheus</span><br><span class="line">WorkingDirectory=/usr/local/exporter/blackbox_exporter</span><br><span class="line">ExecStart=/usr/local/exporter/blackbox_exporter/blackbox_exporter</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">[root@node00 system]# systemctl restart blackbox_exporter</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">[root@node00 system]# systemctl status blackbox_exporter</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启</span></span><br><span class="line">[root@node00 system]# systemctl enable blackbox_exporter</span><br></pre></td></tr></table></figure>

<h3 id="配置prometheus采集数据"><a href="#配置prometheus采集数据" class="headerlink" title="配置prometheus采集数据"></a>配置prometheus采集数据</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;blackbox&quot;</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">/probe</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">module:</span> [<span class="string">http_2xx</span>]  <span class="comment"># Look for a HTTP 200 response.</span></span><br><span class="line">    <span class="attr">file_sd_configs:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">refresh_interval:</span> <span class="string">1m</span></span><br><span class="line">      <span class="attr">files:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/usr/local/prometheus/prometheus/conf/blackbox*.yml&quot;</span></span><br><span class="line">    <span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>]</span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">__param_target</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__param_target</span>]</span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">instance</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">      <span class="attr">replacement:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.10</span><span class="string">:9115</span>  <span class="comment"># Blackbox exporter.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node00 prometheus]# cat conf/blackbox-dis.yml </span><br><span class="line">- targets:</span><br><span class="line">  - https://www.alibaba.com</span><br><span class="line">  - https://www.tencent.com</span><br><span class="line">  - https://www.baidu.com </span><br></pre></td></tr></table></figure>

<h3 id="grafana展示blackbox采集数据"><a href="#grafana展示blackbox采集数据" class="headerlink" title="grafana展示blackbox采集数据"></a>grafana展示blackbox采集数据</h3><p>重启prometheus查看数据, 可以在grafana导入dashboard id <code>9965</code> 可以看到如下数据。</p>
<h2 id="pushgateway使用"><a href="#pushgateway使用" class="headerlink" title="pushgateway使用"></a>pushgateway使用</h2><p>由于网络问题或者安全问题，可能我们的数据无法直接暴露出一个entrypoint 给prometheus采集。 这个时候可能就需要一个pushgateway来作为中间者完成中转工作。 prometheus还是采用pull方式来采集pushgateway的数据，我们的采集端通过push方式把数据push给pushgateway，来完成数据的上报。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_67_prometheus_pushgateway.html">prometheus学习系列十五： Prometheus pushgateway的使用</a></p>
<h2 id="应用集成自定义exporter"><a href="#应用集成自定义exporter" class="headerlink" title="应用集成自定义exporter"></a>应用集成自定义exporter</h2><h3 id="1-pom-xml配置如下"><a href="#1-pom-xml配置如下" class="headerlink" title="1.pom.xml配置如下"></a>1.pom.xml配置如下</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.unicom<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>exporter-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>exporter-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--普罗米修斯依赖--&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_spring_boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_hotspot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_pushgateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--springboot--&gt;</span></span><br><span class="line">​	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">​	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Application类注解"><a href="#2-Application类注解" class="headerlink" title="2.Application类注解"></a>2.Application类注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnablePrometheusEndpoint</span></span><br><span class="line"><span class="meta">@EnableSpringBootMetricsCollector</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExporterDemoApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ExporterDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加@EnableScheduling注解主要是添加了定时任务，用于动态模拟数据的变化，后面会看到应用的地方。</p>
<h3 id="3-CounterDemo"><a href="#3-CounterDemo" class="headerlink" title="3.CounterDemo"></a>3.CounterDemo</h3><p>定义一个Counter类型的metrics，一般而言，Counter类型的metrics指标在命名中我们使用_total结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  使用Counter.build()创建Counter类型的监控指标，并且通过name()方法定义监控指标的名称network_traffic_input</span></span><br><span class="line"><span class="comment">     * ，通过labelNames()定义该指标包含的标签。最后通过register()将该指标注册到Collector的defaultRegistry中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Counter counterDemo = Counter.build()</span><br><span class="line">        .name(<span class="string">&quot;counterChanger2&quot;</span>).labelNames(<span class="string">&quot;wy&quot;</span>,<span class="string">&quot;zxjr&quot;</span>,<span class="string">&quot;ocs&quot;</span>,<span class="string">&quot;xxjf&quot;</span>,<span class="string">&quot;unit&quot;</span>)</span><br><span class="line">        .help(<span class="string">&quot;Counter 实例&quot;</span>).register();</span><br><span class="line">    <span class="comment">//指标埋点，定时器会造成普罗米修斯与本地的数据时间戳不同步，尽量不要使用这种方式，实例中的定时器是为了数据演示</span></span><br><span class="line">    <span class="meta">@Scheduled(cron=&quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/changeCounter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">changeCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        counterDemo.labels(<span class="string">&quot;网元&quot;</span>,<span class="string">&quot;在线接入&quot;</span>,<span class="string">&quot;OCS&quot;</span>,<span class="string">&quot;消息计费&quot;</span>,<span class="string">&quot;seconds&quot;</span>).inc();<span class="comment">//指标值增加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里每5秒会自动执行changeCounter用于模拟数据的变化。</p>
<h3 id="4-GaugeDemo"><a href="#4-GaugeDemo" class="headerlink" title="4.GaugeDemo"></a>4.GaugeDemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GaugeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**指标注册</span></span><br><span class="line"><span class="comment">     * name设置指标名</span></span><br><span class="line"><span class="comment">     * labelNames设置各项指标名称</span></span><br><span class="line"><span class="comment">     * help设置指标描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Gauge gaugeDemo = Gauge.build()</span><br><span class="line">        .name(<span class="string">&quot;gaugeDemo&quot;</span>)</span><br><span class="line">        .labelNames(<span class="string">&quot;label1&quot;</span>,<span class="string">&quot;label2&quot;</span>,<span class="string">&quot;label3&quot;</span>,<span class="string">&quot;label4&quot;</span>,<span class="string">&quot;label5&quot;</span>)</span><br><span class="line">        .help(<span class="string">&quot;gauge 实例&quot;</span>).register();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指标埋点</span></span><br><span class="line">    <span class="meta">@Scheduled(cron=&quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/changeGauge&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">changeGauge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gaugeDemo.labels(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>).inc(); <span class="comment">//指标值加1</span></span><br><span class="line">        gaugeDemo.labels(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>).dec(); <span class="comment">//指标值减一</span></span><br><span class="line">        gaugeDemo.labels(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>).set(<span class="number">19.00</span>); <span class="comment">//指标值直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到Gauge类型的metrics可以对数据进行增加、减小和直接赋值。这种类型在实际应用中比较多。</p>
<h3 id="5-HistogramDemo"><a href="#5-HistogramDemo" class="headerlink" title="5.HistogramDemo"></a>5.HistogramDemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HistogramDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册</span></span><br><span class="line"><span class="comment">     * 注册时buckets()设置区间值，如下设置了100、200、300三个区间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Histogram histogramDemo = Histogram.build()</span><br><span class="line">        .labelNames(<span class="string">&quot;label1&quot;</span>, <span class="string">&quot;label2&quot;</span>, <span class="string">&quot;label3&quot;</span>, <span class="string">&quot;label4&quot;</span>, <span class="string">&quot;label5&quot;</span>)</span><br><span class="line">        .name(<span class="string">&quot;histogramDemo&quot;</span>)</span><br><span class="line">        .buckets(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line">        .help(<span class="string">&quot;Histogram 实例&quot;</span>)</span><br><span class="line">        .register();</span><br><span class="line">    <span class="comment">//指标埋点</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeHistogram</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 本次执行的指标值</span></span><br><span class="line"><span class="comment">         * 如下设置为150，则每次执行，小于200区间以及小于300区间加1，小于100区间不变</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        histogramDemo.labels(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>).observe(<span class="number">150</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>定义了三个区间，小于100，小于200，小于300，而changeHistogram中每次我们设置数据为150，所以最后画出来的曲线只有两条。</p>
<h3 id="6-SummaryDemo"><a href="#6-SummaryDemo" class="headerlink" title="6.SummaryDemo"></a>6.SummaryDemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SummaryDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Summary summaryDemo = Summary.build()</span><br><span class="line">        .quantile(<span class="number">0.5</span>, <span class="number">0.01</span>)   <span class="comment">// 添加50%分位数，允许有5%的误差,相当于求中位数</span></span><br><span class="line">        .quantile(<span class="number">0.9</span>, <span class="number">0.01</span>)   <span class="comment">// 添加90%分位数，允许有1%的误差</span></span><br><span class="line">        .name(<span class="string">&quot;summaryDemo&quot;</span>).labelNames(<span class="string">&quot;label1&quot;</span>,<span class="string">&quot;label2&quot;</span>,<span class="string">&quot;label3&quot;</span>,<span class="string">&quot;label4&quot;</span>,<span class="string">&quot;label5&quot;</span>)</span><br><span class="line">        .help(<span class="string">&quot;Summary 实例&quot;</span>).register();</span><br><span class="line">    <span class="comment">//指标埋点</span></span><br><span class="line">    <span class="meta">@Scheduled(cron=&quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">changeSummary</span><span class="params">()</span></span>&#123;</span><br><span class="line">        summaryDemo.labels(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>).observe(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在prometheus的Graph中通过查看summaryDemo、summaryDemo_count、summaryDemo_sum查看对应结果。</p>
<h3 id="7-关于pushgateway"><a href="#7-关于pushgateway" class="headerlink" title="7.关于pushgateway"></a>7.关于pushgateway</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrometheusConfig</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Counter counterDemo = Counter.build()</span><br><span class="line">        .name(<span class="string">&quot;push_way_counter&quot;</span>)</span><br><span class="line">        .labelNames(<span class="string">&quot;wy&quot;</span>,<span class="string">&quot;zxjr&quot;</span>,<span class="string">&quot;ocs&quot;</span>,<span class="string">&quot;xxjf&quot;</span>,<span class="string">&quot;unit&quot;</span>,<span class="string">&quot;instance&quot;</span>)</span><br><span class="line">        .help(<span class="string">&quot;Counter 实例&quot;</span>)</span><br><span class="line">        .register();</span><br><span class="line">    <span class="comment">//测试发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PushGateway prometheusPush = <span class="keyword">new</span> PushGateway(<span class="string">&quot;localhost:9091&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">                counterDemo.labels(<span class="string">&quot;网元&quot;</span>,<span class="string">&quot;在线接入&quot;</span>,<span class="string">&quot;OCS&quot;</span>,<span class="string">&quot;消息计费&quot;</span>,<span class="string">&quot;byte&quot;</span>,<span class="string">&quot;localhsot:9091&quot;</span>).inc();</span><br><span class="line">                prometheusPush.push(counterDemo,<span class="string">&quot;sp-getway&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里拿counter举一个简单的例子，其他三种度量也是一样的处理方式。</p>
<p>关于pushgateway中转数据，根据我自己实际的验证，我发现索然说数据每次都会先发送到pushgateway，但是prometheus去取的时候还是只取当前那一时间点的数据，并不会把历史的也拿过来。</p>
<h2 id="Prometheus-监控-Redis"><a href="#Prometheus-监控-Redis" class="headerlink" title="Prometheus 监控 Redis"></a><a target="_blank" rel="noopener" href="https://didispace-wx.blog.csdn.net/article/details/104352114">Prometheus 监控 Redis</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Elasticsearch总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-02 16:52:30" itemprop="dateCreated datePublished" datetime="2021-03-02T16:52:30+08:00">2021-03-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangfox/p/9460361.html">为什么要移除Type</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.51cto.com/art/201904/594615.htm">倒排索引</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">简单部署和使用</a></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1663609942544356335&wfr=spider&for=pc">集群角色分离</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/truelove12358/article/details/105577414">倒排索引与B+Tree对比</a></p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/LBSer/p/4119841.html">FST（finite state transducers）</a></p>
<p><a target="_blank" rel="noopener" href="https://elasticsearch.cn/article/6178#tip3">Elasticsearch中数据是如何存储的（Lucene）</a></p>
<p>Master Node：主节点<br>Master eligible nodes：合格节点<br>Data Node：数据节点<br>Coordinating Node：协调节点<br>Ingest Node：ingest节点<br>machine learning：机器学习节点</p>
<p><img src="/2021/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E6%80%BB%E7%BB%93/794174-20200508142929527-1342544356.png" alt="img"></p>
<p><img src="/2021/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BElasticsearch%E6%80%BB%E7%BB%93/794174-20200508142947572-369187416.png" alt="img"></p>
<ul>
<li>Master Node：主节点，该节点不和应用创建连接，每个节点都保存了集群状态，master节点不占用磁盘IO和CPU，内存使用量一般。</li>
<li>Master eligible nodes：合格节点，每个节点部署后不修改配置信息，默认就是一个 eligible 节点，该节点可以参加选主流程，成为Mastere节点。该节点也保存了集群节点的状态。eligible节点比Master节点更节省资源，因为它还未成为 Master 节点，只是有资格成功Master节点。</li>
<li>Data Node：数据节点，该节点和索引应用创建连接、接收索引请求，该节点真正存储数据，ES集群的性能取决于该节点的个数（每个节点最优配置的情况下），data节点会占用大量的CPU、IO和内存。</li>
<li>Coordinating Node：协调节点，该节点和检索应用创建连接、接受检索请求，但其本身不负责存储数据，可当负责均衡节点，该节点不占用io、cpu和内存。</li>
<li>Ingest Node：ingest 节点可以看作是数据前置处理转换的节点，支持 pipeline管道 设置，可以使用 ingest 对数据进行过滤、转换等操作，类似于 logstash 中 filter 的作用，功能相当强大。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wnOZl68GlEw34Ms9obtshw">Elasticsearch 架构原理</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/26/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/26/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Mysql主从复制及配置实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-26 14:19:38" itemprop="dateCreated datePublished" datetime="2021-02-26T14:19:38+08:00">2021-02-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MySql-主从复制及配置实现"><a href="#MySql-主从复制及配置实现" class="headerlink" title="MySql 主从复制及配置实现"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008942618">MySql 主从复制及配置实现</a></h2><p><img src="/2021/02/26/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0/1460000008942622" alt="MySQL主从复制原理及配置实现"></p>
<ul>
<li>从节点IO线程，发起请求读取主节点binlog中offset位置后的数据</li>
<li>主节点Dump线程，读取binlog中的数据，发送给从节点</li>
<li>从节点IO线程将数据写入Relay log中继日志中</li>
<li>从节点中SQL线程将Relay log 中的数据进行回放存入从库中</li>
</ul>
<h2 id="Binlog日志格式"><a href="#Binlog日志格式" class="headerlink" title="Binlog日志格式"></a>Binlog日志格式</h2><ul>
<li>Statement   真实的SQL语句</li>
<li>Row   存有before和after之后的数据</li>
<li>Mixed  DDL语句使用Statement格式，DML语句使用Row格式</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ul>
<li>同步复制：在主节点上写入的数据，在从服务器上都同步完了以后才会给客户端返回成功消息，相对来说比较安全，比较靠谱。但是返回信息的时间比较慢</li>
<li>异步复制：在主节点接收到客户端发送的数据就给客户端返回执行成功的消息。然后再开始再从上面同步，不太靠谱，因为如果我给你返回消息以后，但是我的主节点坏了，并没有在从节点上同步完成，数据就会丢失，就算给客户端返回成功消息，但是我执行是不成功的(mysql默认使用异步复制)</li>
<li>半同步复制：在接收到客户端发送的数据，主节点会将数据同步到至少一台从节点以后再给客户端发送执行成功的消息，这个以前是没有的，是谷歌贡献的一个插件才可以做，它相当于是同步和异步的一个中和的复制方式。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/26/%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/26/%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-26 10:56:52" itemprop="dateCreated datePublished" datetime="2021-02-26T10:56:52+08:00">2021-02-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul>
<li><p>存储引擎 </p>
<ul>
<li>show engines;</li>
<li>show variables like ‘%storage_engine%’;</li>
<li>show table status like “table_name” ; </li>
</ul>
</li>
<li><p>MyISAM和InnoDB区别</p>
</li>
<li><p>索引</p>
</li>
<li><p>事务</p>
<ul>
<li>四大特性</li>
<li>并发事务带来的问题：</li>
<li>隔离级别</li>
</ul>
</li>
<li><p>MVCC</p>
</li>
<li><p>查询缓存</p>
</li>
<li><p>锁机制</p>
</li>
<li><p>大表优化</p>
</li>
<li><p>数据库连接池</p>
</li>
<li><p>分库分表id处理</p>
</li>
<li><p>redolog</p>
</li>
<li><p>undolog</p>
</li>
<li><p>binlog</p>
</li>
<li><p>binlog同步中间件-阿里cancel</p>
</li>
<li><p>sql执行计划</p>
</li>
<li><p><em>页</em>(Page)是 Innodb 存储引擎用于管理数据的最小磁盘单位。常见的<em>页</em>类型有数据<em>页</em>、Undo <em>页</em>、系统<em>页</em>、事务数据<em>页</em>等</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008545713">Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型：<code>数据页（B-Tree Node）</code>，<code>Undo页（Undo Log Page）</code>，<code>系统页（System Page）</code>，<code>事务数据页（Transaction System Page）</code>等；每个数据页的大小为<code>16kb</code>，每个Page使用一个32位（一位表示的就是0或1）的int值来表示，正好对应Innodb最大64TB的存储容量(16kb * 2^32=64tib)</a></p>
</li>
<li><p>预读取</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luoyang_java/article/details/92781164">B+树存多少条数据</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MYSQLZOUQI/p/6991378.html?utm_source=itdadao&utm_medium=referral">预加载</a></p>
</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li>IOC</li>
<li>Bean初始化流程（BeanDefinition,BeanDefinitionRegistry）</li>
<li>Bean范围Scope</li>
<li>Bean生命周期(BeanFactoryPostProcessor,BeanPostProcessor)</li>
<li>循环依赖(三级缓存)</li>
<li>AOP（jdk动态代理，cglib）</li>
<li>事务（失效，隔离级别，传播行为，默认回滚事务RuntimeException）</li>
<li>BeanFactory、ApplicationContext</li>
<li>BeanFactory、FactoryBean</li>
<li>设计模式</li>
</ul>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><ul>
<li>SpirngBootApplication注解<ul>
<li>Configuration</li>
<li>EnableAutoConfiguration</li>
<li>ComponentScan</li>
</ul>
</li>
<li>简化spring开发，约定大于配置，使用默认配置，解决依赖问题</li>
<li>内置容器（tomcat,jetty,undo）</li>
</ul>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul>
<li>Near Realtime 近实时：</li>
<li>角色：{master、data、协调者、Ingest节点、machine learning}</li>
<li>集群</li>
<li>ELK</li>
<li>概念：Index、Type、document</li>
<li>优化点：预热（自检热点数据）、冷热分离、SystemFile cache需要保证内存是数据的一半以上</li>
<li>倒排索引</li>
<li>segment : lucene内部的数据是由一个个segment组成的，写入lucene的数据并不直接落盘，而是先写在内存中，经过了refresh间隔，lucene才将该时间段写入的全部数据refresh成一个segment，segment多了之后会进行merge成更大的segment。lucene查询时会遍历每个segment完成。由于lucene* 写入的数据是在内存中完成，所以写入效率非常高。但是也存在丢失数据的风险，所以Elasticsearch基于此现象实现了translog，只有在segment数据落盘后，Elasticsearch才会删除对应的translog。</li>
<li></li>
</ul>
<h2 id="登录权限"><a href="#登录权限" class="headerlink" title="登录权限"></a>登录权限</h2><h2 id="Spring-Security-Oauth2-单点登录案例实现和执行流程剖析"><a href="#Spring-Security-Oauth2-单点登录案例实现和执行流程剖析" class="headerlink" title="Spring Security Oauth2 单点登录案例实现和执行流程剖析"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xifengxiaoma/p/10043173.html">Spring Security Oauth2 单点登录案例实现和执行流程剖析</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
