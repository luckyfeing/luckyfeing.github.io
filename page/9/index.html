<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/9/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/" class="post-title-link" itemprop="url">java之并发与并行</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-23 13:36:20" itemprop="dateCreated datePublished" datetime="2020-12-23T13:36:20+08:00">2020-12-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是并发、并行？"><a href="#什么是并发、并行？" class="headerlink" title="什么是并发、并行？"></a>什么是并发、并行？</h3><p>这里引用Java8实战中的一张图片来加以说明</p>
<p><img src="/2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwrv49sw0j30fq07iwf8.jpg" alt="image.png"></p>
<p>可能从上图简单来看，并发是单处理器核心多任务的交替执行，并行是多任务多处理器核心的同时执行，由于这个问题并没有被盖棺定论规范化，导致可能不同的人有不同的理解，我也并不能给出一个严格意义上准确的定义，但是我综合他人的观点给出的自己的定义如下，<strong>并行是并发的一种表现形式</strong>，并发只强调两个任务的生命周期存在交集，即对用上面的任务1开始到结束的过程中，如果任务2也开始了，那么我们就认为任务1和任务2是并发的。但是今天想梳理的并不是严格意义上的区分这两个关联紧密的概念，而是讨论这两者能够给我们的程序带来什么？</p>
<p><strong>并发</strong>更加侧重于<strong>压榨单个CPU的性能，降低任务平均时延</strong>，对于一串任务（task1，task2，task3…）高并发并不能加快这些任务总体完成的时间，甚至由于线程切换还会延长任务总体完成的时间，所以它并不是以提高整体响应速率为目的的，而并行它使得多个任务（任务之间不相干，简化讨论，避免多核之间的一致性要求）可以在多个处理器核中得到真正的同时处理，而这个时候对于一系列的不相干任务来说，利用并行计算，就能大大缩短整体的响应时间</p>
<h3 id="单线程并发能够提高任务的总体处理速度嘛？"><a href="#单线程并发能够提高任务的总体处理速度嘛？" class="headerlink" title="单线程并发能够提高任务的总体处理速度嘛？"></a>单线程并发能够提高任务的总体处理速度嘛？</h3><p>答案是显然的，<strong>不能</strong>，而且由于线程切换带来的资源开销，单线程并发还会延长<strong>整个</strong>任务的处理时间？</p>
<h3 id="单线程并发还有必要嘛？"><a href="#单线程并发还有必要嘛？" class="headerlink" title="单线程并发还有必要嘛？"></a>单线程并发还有必要嘛？</h3><p>有必要，而且非常有必要，首先我们假定有四个任务1，2，3，4如下，每个任务的执行耗时1个单位时间，如果按照单线程串行的执行方式，它应该是这样的</p>
<p><img src="/2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwuv5cv87j30f409wmxa.jpg" alt="image.png"></p>
<p>对于task1来说，它还能接收，毕竟执行1个单位时间它就拿到了它想要的结果，但是对于后面的task来说就不满意了，特别是task4来说，执行task4的耗时为1个单位时间，但是它需要等4个单位时间才能拿到结果，如果在多线程情况下，它是如何的呢？假设每个task都另起了一个线程，且不考虑操作系统任务调度耗时等等，现在的处理情况是这样的</p>
<p><img src="/2020/12/23/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwv7rlnk4j30od0a7dg5.jpg" alt="image.png"></p>
<p>假如理想状况下，每个任务被切割得足够小，那么最终每个任务几乎是同时开始同时结束，那么每个task的用时就是总耗时的平均值也就是2.5，这下task4总算开心了，它不用等那么久了。</p>
<p>但是实际问题中，不可能把任务无限切分，操作系统的线程调度也是耗时操作，那么上面的结论就不一定那么可靠了，甚至可能每个时间都超过3了，那还不如串行呢，至少task1和task2爽了，那为什么还需要并发呢？</p>
<p>因为实际状况下，每个任务的执行速度也不可能完全相等，每个任务执行的速度有快有慢，我们现在假设task1执行用时需要1000个单位时间，如果在串行情况下，task1后面的所有任务都会被task1所拖累，需要等待的时间为1000加，而此时的并发执行策略中，虽然由于系统调度等等开销，task2，3，4仍然可以以一个与之前速度相差无几的时间响应，task1带来的恶劣影响也单单只影响到了自己。我们上面的策略也就类似于tomcat对于请求的处理策略，针对每个请求都另起一个线程（processor）来处理。</p>
<h3 id="tomcat都这么厉害了，自己的代码中还有必要多线程嘛？"><a href="#tomcat都这么厉害了，自己的代码中还有必要多线程嘛？" class="headerlink" title="tomcat都这么厉害了，自己的代码中还有必要多线程嘛？"></a>tomcat都这么厉害了，自己的代码中还有必要多线程嘛？</h3><p><strong>有必要</strong>，通常一个大任务是由多个小任务组合而成，如果按照<strong>CPU密集型和I/O密集型</strong>来划分任务类型的话，对于CPU密集型任务来说，无论我们再怎么多线程疯狂操作也好，在单核处理器中，最终都还是依靠单核来做运算，多线程的线程切换开销无疑延长了整个任务的处理时间，但是在I/O密集型任务情况下（包括磁盘IO，网络IO），假设你发起了10个不同的RPC调用，无疑多线程的方式能够让你同时发起多个请求，多个请求同时等待响应，否则你就只能按照串行的方式，每个请求都需要等一个时延，然后再处理下一个请求，这样的等待无疑延长了总体响应时间，降低CPU利用率。其实这样的并发就包含了并行，因为你发起的远程调用是远方的多个处理器去帮你处理的，我们所做的只不过是利用并发在一个请求傻等着的过程中又发起了另一个请求罢了</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行的好处是显而易见的，多个处理器干活肯定是快于一个人干活的，对于上面讨论的情况，如果在多核心的处理器下，并发之后可能整个处理过程就是并行的，小的任务可以在多个处理器核心中同时运行，在这里也不太过多讨论并发安全的问题，主要讨论如何高效并行</p>
<p>在tomcat中想要并行很简单，你并发就好，如果你有多个处理器核心它自然会并行执行，可能并不太需要我们对整个处理过程进行并行处理，关注更多的是不同请求之间的并行，但是在一些场景下，可能就需要我们关注整个任务本身的并行，这时候并行就不那么容易，假设你要计算1-1000000000的和，你当然可以选择并发执行，自己分割每个处理器计算多少到多少的和，然后自行汇总结果，就像下面的代码一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentVsParallel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//串行</span></span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> time1=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000000000L</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;串行计算结果为：&quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;串行耗时：&quot;</span>+(System.currentTimeMillis()-time1));</span><br><span class="line">        <span class="keyword">long</span> time2= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> res = concurrentCal(<span class="number">10000000000L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结果为：&quot;</span>+res);</span><br><span class="line">        System.out.println(<span class="string">&quot;并行耗时为：&quot;</span>+(System.currentTimeMillis()-time2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">concurrentCal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//4等分来处理</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">long</span> quarter=n/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> allSum=<span class="number">0</span>;</span><br><span class="line">        Future[] parts = <span class="keyword">new</span> Future[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4L</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp=i;</span><br><span class="line">            Future&lt;Long&gt; partSum = executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> j = temp * quarter + <span class="number">1</span>; j &lt;= (temp + <span class="number">1</span>) * quarter; j++) &#123;</span><br><span class="line">                    sum += j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;);</span><br><span class="line">            parts[i]=partSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.length; i++) &#123;</span><br><span class="line">            allSum+=(<span class="keyword">long</span>)parts[i].get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串行计算结果为：-5340232216128654848</span><br><span class="line">串行耗时：4617</span><br><span class="line">计算结果为：-5340232216128654848</span><br><span class="line">并行耗时为：1847</span><br></pre></td></tr></table></figure>

<p>上述的代码能够实现我们既定的目标，但是存在着<strong>可读性和可拓展性</strong>的问题，性能也存在着问题，如果需要对(2-n)求和呢，很简单，给我们的代码加入一个start即可，但是如果需要对（2-n）中所有的偶数求和呢？岂不是又需要改代码，更加严重的问题是任务规模的划分是定下来的，导致任务划分的粒度有的时候并不够，当然你也可以再添加一个参数设置任务规模的划分，但是上述这些操作都会导致代码的膨胀和难以维护，利用java8的Stream可以做如下简单实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time3=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> res = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">10000000000L</span>).parallel().sum();</span><br><span class="line">System.out.println(<span class="string">&quot;stream计算结果为：&quot;</span>+res);</span><br><span class="line">System.out.println(<span class="string">&quot;stream耗时为：&quot;</span>+(System.currentTimeMillis()-time3));</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串行计算结果为：-5340232216128654848</span><br><span class="line">串行耗时：4631</span><br><span class="line">stream计算结果为：-5340232216128654848</span><br><span class="line">stream耗时为：3605</span><br></pre></td></tr></table></figure>

<p>虽然这里的耗时可能比不过我们直接手动划分，并发的方式去进行计算，但是这里的代码可读性以及可拓展性是非常好的，如果你想过滤掉所有的奇数，加一个filter就好。诚然这个结果也受限于我仅仅只有四核的垃圾笔记本，无论如何，通过Stream的方式，Java的并行计算也变得简单！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Java8实战》</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37396742">https://www.zhihu.com/question/37396742</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33515481">https://www.zhihu.com/question/33515481</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/" class="post-title-link" itemprop="url">Redis之缓存更新</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-23 13:21:24" itemprop="dateCreated datePublished" datetime="2020-12-23T13:21:24+08:00">2020-12-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h2><p>更新缓存的时候涉及两个问题：</p>
<ul>
<li>删除（del）还是 修改（set）？</li>
<li>先操作数据库，还是 先操作缓存？</li>
</ul>
<p>组合起来就有四种情况：</p>
<p><font color="red">第一种情况：先删除缓存，后更新数据库</font></p>
<p>如果删除缓存失败，则后面的操作都不会执行，没问题；</p>
<p>如果删除缓存成功，更新数据库失败，则缓存与数据库不一致，但这种不一致会马上被修正，因而不影响，因为下一次请求缓存的时候发现缓存中没有，会从数据库重新加载；但是，又有一个问题出现了，在旧的缓存被删除后，新的缓存未写入之前，这段时间内如果有读操作，那么旧的值会被重新加载到缓存，这就相当于没更新缓存；</p>
<p><font color="red">第二种情况：先更新缓存，后更新数据库</font></p>
<p>同样，如果更新缓存成功，更新数据库失败，则出现缓存与数据库不一致，<strong>数据不一致就是问题</strong></p>
<p><font color="red">第三种情况：先更新数据库，后删除缓存</font></p>
<p>如果更新数据库成功，删除缓存失败，则出现缓存与数据库不一致，<strong>数据不一致就是问题</strong></p>
<p><font color="red">第四种情况：先更新数据库，后更新缓存</font></p>
<p>跟第三种情况一样</p>
<h2 id="单主更新缓存"><a href="#单主更新缓存" class="headerlink" title="单主更新缓存"></a>单主更新缓存</h2><p>虽然，看上去好像都有问题，但是，<strong>任何脱离实际业务的设计都是耍流氓</strong></p>
<p>既然我们把Redis当缓存，那么所有数据都要以数据库为准，像上面第二种情况（缓存中有的数据在数据库中没有）是不能容忍的，而对于第一种情况，可以采取双删的策略（删除缓存 –&gt; 更新数据库 –&gt; 再删除缓存），后面两种情况，可以用定时任务进行补偿，有些场景下我们是可以接受不一致的情况的。</p>
<p>不过，话又说回来，直接删除缓存当然是最简单的，它相当于延迟加载（第一次使用的时候发现没有才会去从数据库加载），这样可能导致第一次请求会比较慢；而采用修改缓存的方式，相当于预先加载。</p>
<p>在实际使用的时候，可以采用这两种方式：</p>
<ol>
<li>先删除缓存，再更新数据库，最后再删一次</li>
<li>先更新数据库，然后向MQ发一条消息，由专门的缓存服务去更新数据</li>
</ol>
<p><strong>上面说的是只有一个数据库实例的情况</strong>，而实际生产过程中肯定是一主多从的</p>
<h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><p>延时双删的方案的思路是，为了避免更新数据库的时候，其他线程从缓存中读取不到数据，就在更新完数据库之后，再sleep一段时间，然后再次删除缓存。</p>
<p>sleep的时间要对业务读写缓存的时间做出评估，sleep时间大于读写缓存的时间即可。</p>
<p>流程如下：</p>
<ol>
<li>线程1删除缓存，然后去更新数据库</li>
<li>线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存</li>
<li>线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除</li>
<li>如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值</li>
</ol>
<p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E6%9B%B4%E6%96%B0redis.png" alt="图片"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。</p>
<p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98.png"></p>
<p>这个解决方案其实问题更多。</p>
<ol>
<li>引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦</li>
<li>就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的</li>
</ol>
<h3 id="进阶版消息队列"><a href="#进阶版消息队列" class="headerlink" title="进阶版消息队列"></a>进阶版消息队列</h3><p>为了解决缓存一致性的问题单独引入一个消息队列，太复杂了。</p>
<p>其实，一般大公司本身都会有监听binlog消息的消息队列存在，主要是为了做一些核对的工作。</p>
<p>这样，我们可以借助监听binlog的消息队列来做删除缓存的操作。这样做的好处是，不用你自己引入，侵入到你的业务代码中，中间件帮你做了解耦，同时，中间件的这个东西本身就保证了高可用。</p>
<p>当然，这样消息延迟的问题依然存在，但是相比单纯引入消息队列的做法更好一点。</p>
<p>而且，如果并发不是特别高的话，这种做法的实时性和一致性都还算可以接受的。</p>
<p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/binlog%E7%9B%91%E5%90%AC%E6%9B%B4%E6%96%B0redis.png" alt="图片"></p>
<h3 id="设置缓存过期时间-不建议"><a href="#设置缓存过期时间-不建议" class="headerlink" title="设置缓存过期时间(不建议)"></a>设置缓存过期时间(不建议)</h3><p>每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。</p>
<p>如果对于一致性要求不是很高的情况，可以采用这种方案。</p>
<p>这个方案还会有另外一个问题，就是如果数据更新的特别频繁，不一致性的问题就很大了。</p>
<p>在实际生产中，我们有一些活动的缓存数据是使用这种方式处理的。</p>
<p>因为活动并不频繁发生改变，而且对于活动来说，短暂的不一致性并不会有什么大的问题。</p>
<h2 id="主从更新缓存"><a href="#主从更新缓存" class="headerlink" title="主从更新缓存"></a>主从更新缓存</h2><p>按照<strong>写主读从</strong>，缓存加载数据的时候应该从从库中读，而本来主从同步就有延迟，于是读从库很有可能读到的是旧数据</p>
<p>为了解决这种问题，可以考虑以下几种方案：</p>
<p><font color="red">第一种：强制缓存读主数据库</font></p>
<p>这样一来，就不必考虑主从同步的问题了，可行（PS：跟微信公众号开发的时候获取Token一样）</p>
<p><font color="red">第二种：选择性地读主数据库</font></p>
<p>之所以强制读主库，是因为再主从同步完成之前从库中的数据还是旧的，当主从同步完成后再读从库就没什么问题了，那么如果在主从同步的这段时间内如果没有请求读这个KEY就没有问题，如果这段时间内有请求读取这个KEY，那么在同步完成后要删除这个KEY</p>
<p>如何判断在主从同步这段时间内有没有请求读取这个KEY呢？</p>
<p>在更新数据库的时候，往缓存中设置一个KEY，格式是：缓存KEY+业务数据ID，其生存时间是主从延时时间</p>
<p>比如，假设主从同步延时是3秒，而有业务缓存KEY是hash类型的，更新的这条数据的ID是213，那么在更新数据库后要立即设置 set USER_213_KV 1 3</p>
<p>在读的时候，首先判断缓存中有没有这样一个KEY，如果有则从主库中重新加载数据到缓存，没有，则直接从从库中加载数据到缓存</p>
<p><font color="red">第三种：订阅从库的binlog</font></p>
<p>可以通过工具（比如，canal）订阅从库的binlog，这是比较准确的，从库数据有更新，则立即更新缓存<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h2 id="为什么是删除，而不是更新缓存？"><a href="#为什么是删除，而不是更新缓存？" class="headerlink" title="为什么是删除，而不是更新缓存？"></a>为什么是删除，而不是更新缓存？</h2><p>我们以<strong>先更新数据库，再删除缓存</strong>来举例。</p>
<p>如果是更新的话，那就是<strong>先更新数据库，再更新缓存</strong>。</p>
<p>举个例子：如果数据库1小时内更新了1000次，那么缓存也要更新1000次，但是这个缓存可能在1小时内只被读取了1次，那么这1000次的更新有必要吗？</p>
<p>反过来，如果是删除的话，就算数据库更新了1000次，那么也只是做了1次缓存删除，只有当缓存真正被读取的时候才去数据库加载。</p>
<h2 id="补充1：缓存穿透"><a href="#补充1：缓存穿透" class="headerlink" title="补充1：缓存穿透"></a>补充1：缓存穿透</h2><p><font color="red">缓存穿透</font></p>
<p>缓存穿透，指的是查询一个数据库中不存在的数据。这样的话，每次都会查询数据库，相当于缓存就没有用了。</p>
<ul>
<li>针对这种情况，可以缓存空值，并设置一个较短的生存时间，比如60秒。</li>
<li>使用布隆过滤器，存在的时候保存；有一个错误率，并且不能删除，可以使用带计数器的布隆过滤器。</li>
</ul>
<p><font color="red">缓存雪崩</font></p>
<p>缓存雪崩，指的是大量缓存在一段时间内集体失效。这样的话，短时间内大量请求会直接打到数据库。</p>
<p>针对这种情况，可以在缓存的生存时间后面再加上一个随机数，这样的话就不至于同一时刻集体过期。实际上，因为大量缓存失效意味着这些缓存在同一时刻被设置的，而这种情况不多见。</p>
<p><font color="red">缓存击穿</font></p>
<p>缓存击穿，指的是单个缓存在被高并发访问时失效了导致请求全部打到数据库。</p>
<p>针对这种情况，在加载缓存的时候要加分布式锁。</p>
<h2 id="补充2：Redis客户端工具Medis"><a href="#补充2：Redis客户端工具Medis" class="headerlink" title="补充2：Redis客户端工具Medis"></a>补充2：Redis客户端工具Medis</h2><p><a target="_blank" rel="noopener" href="https://github.com/luin/medis">https://github.com/luin/medis</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;luin&#x2F;medis.git</span><br><span class="line">cd medis</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/874963-20190422192347253-2059999245.png" alt="img"></p>
<p><img src="/2020/12/23/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BRedis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/874963-20190422192359546-1385109275.png" alt="img"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjsblog/p/10752245.html">https://www.cnblogs.com/cjsblog/p/10752245.html</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247488185&idx=1&sn=f07ee035bc8c276e4d72b4ffb9627e1e&chksm=c2b25a44f5c5d3523985e4161e42ae0d1b4c8273915760d3ec53afbbd5fe0066178d5ade1673&scene=132#wechat_redirect">缓存一致性问题怎么解决</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Redis之数据结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-23 13:21:05" itemprop="dateCreated datePublished" datetime="2020-12-23T13:21:05+08:00">2020-12-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="redis单点吞吐量"><a href="#redis单点吞吐量" class="headerlink" title="redis单点吞吐量"></a><strong>redis单点吞吐量</strong></h2><p>单点TPS达到8万/秒，QPS达到10万/秒。</p>
<h2 id="redis的5中存储类型"><a href="#redis的5中存储类型" class="headerlink" title="redis的5中存储类型"></a><strong>redis的5中存储类型</strong></h2><p>string、list、set、map（hash）、stored-set</p>
<h2 id="redis的string类型"><a href="#redis的string类型" class="headerlink" title="redis的string类型"></a><strong>redis的string类型</strong></h2><ol>
<li>能表达3中类型：字符串、整数和浮点数。根据场景相互间自动转型，并且根据需要选取底层的承载方式</li>
<li><font color="red">value内部以int、sds作为结构存储</font>。int存放整型数据，sds存放字节/字符串和浮点型数据</li>
<li>sds内部结构： <ol>
<li>用buf数组存储字符串的内容，但数组的长度会大于所存储内容的长度。会有一格专门存放”\0”（C标准库）作为结尾，还有预留多几个空的（即free区域），当append字符串的长度小于free区域，则sds不会重新申请内存，直接使用free区域</li>
<li>扩容：当对字符串的操作完成后预期的串长度小于1M时，扩容后的buf数组大小=预期长度*2+1；若大于1M，则buf总是会预留出1M的free空间</li>
<li>value对象通常具有两个内存部分：redisObject部分和redisObject的ptr指向的sds部分。创建value对象时，通常需要为redisObject和sds申请两次内存。单对于短小的字符串，可以把两者连续存放，所以可以一次性把两者的内存一起申请了</li>
</ol>
</li>
<li>使用场景<ol>
<li>分布式锁｛setnx +lua脚本 | set key value  [EX seconds] [PX milliseconds] [NX|XX] ｝</li>
<li>计数器|自增id｛incr key increment | DECRBY key decrement｝</li>
<li>Token {set key value}</li>
<li>幂等</li>
</ol>
</li>
</ol>
<h2 id="redis的list类型"><a href="#redis的list类型" class="headerlink" title="redis的list类型"></a><strong>redis的list类型</strong></h2><ol>
<li><font color="red">list类型的value对象内部以linkedlist或ziplist承载</font>。当list的元素个数和单个元素的长度较小时，redis会采用ziplist实现以减少内存占用，否则采用linkedlist结构</li>
<li>linkedlist内部实现是双向链表。在list中定义了头尾元素指针和列表的长度，是的pop/push操作、llen操作的复杂度为O(1)。由于是链表，lindex类的操作复杂度仍然是O(N)</li>
<li>ziplist的内部结构 <ol>
<li>所有内容被放置在连续的内存中。其中zlbytes表示ziplist的总长度，zltail指向最末元素，zllen表示元素个数，entry表示元素自身内容，zlend作为ziplist定界符</li>
<li>rpush、rpop、llen，复杂度为O(1);lpush/pop操作由于涉及全列表元素的移动，复杂度为O(N)</li>
</ol>
</li>
<li>使用场景<ol>
<li>消息流｛LPUSH | RPUSH key value | LRANGE key start stop｝</li>
<li>堵塞队列｛ BLPOP |  BRPOP key1 [key2 ] timeout ｝</li>
</ol>
</li>
</ol>
<h2 id="redis的map类型"><a href="#redis的map类型" class="headerlink" title="redis的map类型"></a><strong>redis的map类型</strong></h2><ol>
<li>map又叫hash。map内部的key和value不能再嵌套map了，只能是string类型：整形、浮点型和字符串</li>
<li><font color="red">map主要由hashtable和ziplist两种承载方式实现</font>，对于数据量较小的map，采用ziplist实现</li>
<li>hashtable内部结构 <ol>
<li>主要分为三层，自底向上分别是dictEntry、dictht、dict</li>
<li>dictEntry：管理一个key-value对，同时保留同一个桶中相邻元素的指针，一次维护哈希桶的内部连</li>
<li>dictht：维护哈希表的所有桶链</li>
<li>dict：当dictht需要扩容/缩容时，用于管理dictht的迁移</li>
<li>哈希表的核心结构是dictht，它的table字段维护着hash桶，它是一个数组，每个元素指向桶的第一个元素（dictEntry）</li>
<li>set值的流程：先通过MurmurHash算法求出key的hash值，再对桶的个数取模，得到key对应的桶，再进入桶中，遍历全部entry，判定是否已有相同的key，如果没有，则将新key对应的键值对插入到桶头，并且更新dictht的used数量，used表示hash表中已经存了多少元素。由于每次插入都要遍历hash桶中的全部entry，所以当桶中entry很多时，性能会线性下降</li>
<li>扩容：通过负载因子判定是否需要增加桶数。负载因子=哈希表中已有元素/哈希桶数的比值。有两个阈值，小于1一定不扩容；大于5一定扩容。扩容时新的桶数目是现有桶的2n倍</li>
<li>缩容：负载因子的阈值是0.1</li>
<li>扩/缩容通过新建哈希表的方式实现。即扩容时，会并存两个哈希表，一个是源表，一个是目标表。通过将源表的桶逐步迁移到目标表，以数据迁移的方式实现扩容，迁移完成后目标表覆盖源表。迁移过程中，首先访问源表，如果发现key对应的源表桶已完成迁移，则重新访问目标表，否则在源表中操作</li>
<li>redis是单线程处理请求，迁移和访问的请求在相同线程内进行，所以不会存在并发性问题</li>
</ol>
</li>
<li>ziplist内部结构 <ol>
<li>和list的ziplist实现类似。不同的是，map对应的ziplist的entry个数总是2的整数倍，奇数存放key，偶数存放value</li>
<li>ziplist实现下，由哈希遍历变成了链表的顺序遍历，复杂度变成O(N)</li>
</ol>
</li>
<li>使用场景<ol>
<li>对象存储，对象字段修改</li>
<li>可重入锁</li>
<li>购物车{HINCRBY key field increment}</li>
<li>幂等</li>
</ol>
</li>
</ol>
<h2 id="redis的set类型"><a href="#redis的set类型" class="headerlink" title="redis的set类型"></a><strong>redis的set类型</strong></h2><ol>
<li><font color="red">set以intset或hashtable来存储</font>。hashtable中的value永远为null，当set中只包含整数型的元素时，则采用intset</li>
<li>intset的内部结构 <ol>
<li>核心元素是一个字节数组，从小到大有序存放着set的元素</li>
<li>由于元素有序排列，所以set的获取操作采用二分查找方式实现，复杂度O(log(N))。进行插入时，首先通过二分查找得到本次插入的位置，再对元素进行扩容，再将预计插入位置之后的所有元素向右移动一个位置，最后插入元素，插入复杂度为O(N)。删除类似</li>
</ol>
</li>
<li>使用场景<ol>
<li>关注和粉丝 点赞收藏 {SREM key member1 [member2] | SADD}</li>
<li>好友推荐（集合操作）{SINTERSTORE destination key1 [key2] | SDIFFSTORE destination key1 [key2] }</li>
<li>抽奖（可以随机选择集合里的多个元素{SRANDMEMBER key [count] }，选择并删除一个元素spop key）</li>
</ol>
</li>
</ol>
<h2 id="redis的sorted-set类型"><a href="#redis的sorted-set类型" class="headerlink" title="redis的sorted-set类型"></a><strong>redis的sorted-set类型</strong></h2><ol>
<li><p>类似map是一个key-value对，但是有序的。value是一个浮点数，称为score，内部是按照score从小到大排序</p>
</li>
<li><p><font color="red">内部结构以ziplist或skiplist来实现</font></p>
<ol>
<li>ziplist 编码的 Zset 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。ziplist 内的集合元素按 score 从小到大排序，其实质是一个双向链表。<img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1637947-20200108102944037-1942746276.png" alt="img"></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyizuokan/p/11108417.html">skiplist原理</a><img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1236645-20190629233343522-1807329534.png"></li>
</ol>
</li>
<li><p>使用场景</p>
<ol>
<li>排行榜、活跃文章（对score进行累加）</li>
<li>信息流（社交类如微博）</li>
<li>限流里的滑动窗口</li>
<li>延时队列（没有 ack 机制，当消费失败的情况下队列如何处理，topic 模式，广播模式如何搞）</li>
<li>排行榜 {ZINCRBY key increment member }  月排行榜{ZINTERSTORE destination numkeys key [key …] }</li>
</ol>
</li>
</ol>
<h2 id="位图BitSet"><a href="#位图BitSet" class="headerlink" title="位图BitSet"></a>位图BitSet</h2><p>使用场景</p>
<ol>
<li>布隆过滤器 {Setbit key offset  1|0    |   Getbit key offset}</li>
<li>签到（用户id自增）{BITOP AND destkey key [key …] }</li>
<li>活跃用户统计（用户id自增）{BITOP OR destkey key [key …] }</li>
</ol>
<h2 id="redis中key和value的存储大小限制"><a href="#redis中key和value的存储大小限制" class="headerlink" title="redis中key和value的存储大小限制"></a>redis中key和value的存储大小限制</h2><p>String类型：一个String类型的value最大可以存储512M</p>
<p>List类型：list的元素个数最多为2^32-1个，也就是4294967295个。</p>
<p>Set类型：元素个数最多为2^32-1个，也就是4294967295个。</p>
<p>Hash类型：键值对个数最多为2^32-1个，也就是4294967295个。</p>
<p>Sorted set类型：跟Set类型相似。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">Redis之进阶</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-23 13:20:49" itemprop="dateCreated datePublished" datetime="2020-12-23T13:20:49+08:00">2020-12-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="redis客户端与服务器的交互模式"><a href="#redis客户端与服务器的交互模式" class="headerlink" title="redis客户端与服务器的交互模式"></a><strong>redis客户端与服务器的交互模式</strong></h2><ol>
<li>串行的请求/响应模式 <ol>
<li>每一次请求的发送都依赖于上一次请求的相应结果完全接收，同一个连接的每秒吞吐量低</li>
<li>redis对单个请求的处理时间通常比局域网的延迟小一个数量级，所以串行模式下，单链接的大部分时间都处于网络等待</li>
</ol>
</li>
<li>双工的请求/相应模式(pipeline) <ol>
<li>适用于批量的独立写入操作。即可将请求数据批量发送到服务器，再批量地从服务器连接的字节流中一次读取每个响应数据，减少了网络延迟，所以单连接吞吐量较串行会提高一个数量级</li>
</ol>
</li>
<li>原子化的批量请求/响应模式（事务） <ol>
<li>客户端通过和redis服务器两阶段的交互做到批量命令原子执行的事务效果：入队操作（即服务器端先将客户端发送过来的连接对象暂存在请求队列中）和执行阶段（依次执行请求队列中的所有请求）</li>
<li>一个连接的请求在执行批量请求的过程中，不会执行其他客户端的请求</li>
<li>redis的事务不是一致的，没有回滚机制。如果中途失败，则返回错误信息，但已经成功执行的命令不会回滚</li>
<li>事务里面有可能会带有读操作作为条件，由于批量请求只会先入队列，再批量一起执行，所以一般读操作不会跟批量写请求一起执行，这时候就有可能会导致批量写之前和之后读到的数据不一致，这种可以通过乐观锁的可串行化来解决，redis通过watch机制实现乐观锁。具体实现过程看下一题</li>
</ol>
</li>
<li>发布/订阅模式 <ol>
<li>发布端和订阅者通过channel关联</li>
<li>channel的订阅关系，维护在reids实例级别，独立于redisDB的key-value体系。所有的channel都由一个map维护，键是channel的名字，value是它所有订阅者client的指针链表</li>
</ol>
</li>
<li>脚本化的批量执行（脚本模式）</li>
</ol>
<h2 id="redis通过watch机制实现乐观锁流程"><a href="#redis通过watch机制实现乐观锁流程" class="headerlink" title="redis通过watch机制实现乐观锁流程"></a><strong>redis通过watch机制实现乐观锁流程</strong></h2><ol>
<li>将本次事务涉及的所有key注册为观察模式</li>
<li>执行只读操作</li>
<li>根据只读操作的结果组装写操作命令并发送到服务器端入队</li>
<li>发送原子化的批量执行命令EXEC试图执行连接的请求队列中的命令</li>
<li>如果前面注册为观察模式的key中有一个货多个，在EXEC之前被修改过，则EXEC将直接失败，拒绝执行；否则顺序执行请求队列中的所有请求</li>
<li>redis没有原生的悲观锁或者快照实现，但可通过乐观锁绕过。一旦两次读到的操作不一样，watch机制触发，拒绝了后续的EXEC执行</li>
</ol>
<h2 id="redis的网络协议"><a href="#redis的网络协议" class="headerlink" title="redis的网络协议"></a><strong>redis的网络协议</strong></h2><p>redis协议位于TCP层之上，即客户端和redis实例保持双工的连接，交互的都是序列化后的协议数据</p>
<h2 id="redis处理命令的主要逻辑"><a href="#redis处理命令的主要逻辑" class="headerlink" title="redis处理命令的主要逻辑"></a><strong>redis处理命令的主要逻辑</strong></h2><ol>
<li>redis服务器对命令的处理都是单线程的，但是I/O层面却面向多个客户端并发地提供服务，并发到内部单线程的转化通过多路复用框架来实现</li>
<li>首先从多路复用框架（epoll、evport、kqueue）中select出已经ready的文件描述符（fileDescriptor）</li>
<li>ready的标准是已有数据到达内核（kernel）、已准备好写入数据</li>
<li>对于上一步已经ready的fd，redis会分别对每个fd上已ready的事件进行处理，处理完相同fd上的所有事件后，再处理下一个ready的fd。有3中事件类型 <ol>
<li>acceptTcpHandler：连接请求事件</li>
<li>readQueryFromClient：客户端的请求命令事件</li>
<li>sendReplyToClient：将暂存的执行结果写回客户端</li>
</ol>
</li>
<li>对来自客户端的命令执行结束后，接下来处理定时任务（TimeEvent）</li>
<li>aeApiPoll的等待时间取决于定时任务处理（TimeEvent）逻辑</li>
<li>本次主循环完毕，进入下一次主循环的beforeSleep逻辑，后者负责处理数据过期、增量持久化的文件写入等任务</li>
</ol>
<h2 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a><strong><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1654694618189745916&wfr=spider&for=pc">Redis的持久化机制</a></strong></h2><ol>
<li>redis主要提供了两种持久化机制：RDB和AOF；</li>
<li>RDB <ol>
<li>默认开启，会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，redis启动时再恢复到内存中。</li>
<li>redis会单独创建fork()一个子进程，将当前父进程的数据的内存地址复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</li>
<li>需要注意的是，每次快照持久化都会将主进程的数据库数据内存地址复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I/O操作，严重影响性能，并且最后一次持久化后的数据可能会丢失；</li>
<li>save 900 1 表示900 秒内如果至少有 1 个 key 的值变化，则保存</li>
<li>save 300 10表示300 秒内如果至少有 10 个 key 的值变化，则保存</li>
<li>save 60 10000表示60 秒内如果至少有 10000 个 key 的值变化，则保存</li>
<li><strong>rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li>
<li><strong>rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>
<li><strong>dbfilename ：</strong>设置快照的文件名，默认是 dump.rdb</li>
<li><strong>dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名</li>
<li>命令行触发可以使用save或bgsave<img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/1.png" alt="img" style="zoom:67%;"></li>
</ol>
</li>
<li>AOF <ol>
<li>以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件，redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB也会执行。</li>
<li>主要有两种方式触发：有写操作就写、每秒定时写（也会丢数据）。</li>
<li>因为AOF采用追加的方式，所以文件会越来越大，针对这个问题，新增了重写机制，就是当日志文件大到一定程度的时候，会fork出子进程来遍历进程内存中的数据，每条记录对应一条set语句，写到临时文件中，然后再替换到旧的日志文件（类似rdb的操作方式）。默认触发是当aof文件大小是上次重写后大小的一倍且文件大于64M时触发；</li>
</ol>
</li>
<li>当两种方式同时开启时，数据恢复redis会优先选择AOF恢复。一般情况下，只要使用默认开启的RDB即可，因为相对于AOF，RDB便于进行数据库备份，并且恢复数据集的速度也要快很多。</li>
<li>开启持久化缓存机制，对性能会有一定的影响，特别是当设置的内存满了的时候，更是下降到几百reqs/s。所以如果只是用来做缓存的话，可以关掉持久化。</li>
</ol>
<h2 id="redis内存分析的设计思路"><a href="#redis内存分析的设计思路" class="headerlink" title="redis内存分析的设计思路"></a><strong>redis内存分析的设计思路</strong></h2><ol>
<li>主要有3种方式可以实现 <ol>
<li>keys命令：获取到所有的key，再根据key获取所有的内容。缺点是如果key数量特别多，则会导致redis卡住影响业务</li>
<li>aof：通过aof文件获取到所有数据。缺点是有一些redis实例写入频繁，不适合开启aof，并且文件可能特别大，传输、解析效率差</li>
<li>rdb：使用bgsave获取rdb文件，然后解析。缺点是bgsave在fork子进程时有可能会卡住主进程。当对于其他两种，在低峰期在从节点做bgsave获取rdb文件，相对安全可靠。</li>
</ol>
</li>
<li>设计思路:<ol>
<li>在访问低峰期时根据redis获取rdb文件</li>
<li>解析rdb文件根据相对应的数据结构及内容，估算内容消耗等</li>
<li>统计并生成报表</li>
</ol>
</li>
<li>开源框架：<a target="_blank" rel="noopener" href="https://github.com/xueqiu/rdr">https://github.com/xueqiu/rdr</a></li>
</ol>
<h2 id="redis内存估算"><a href="#redis内存估算" class="headerlink" title="redis内存估算"></a><strong>redis内存估算</strong></h2><ol>
<li>基础的数据类型：sds、dict、intset、zipmap、adlist、quicklist、skiplist</li>
<li>举例：以key为hello，value为world，类型是string，它的内存使用： <ol>
<li>一个dictEntry的消耗（有2个指针，一个int64的内存消耗），RedisDB就是一个大dict，每对kv都是其中的一个entry；</li>
<li>一个robj的消耗（有1指针，一个int，以及几个使用位域的字段共消耗4字节），robj是为了在同一个dict内能够存储不同类型的value，而使用的一个通用的数据结构，全名是RedisObject；</li>
<li>存储key的sds消耗（存储header以及字符串长度+1的空间，header长度根据字符串长度不同也会有所不同），sds是Redis中存储字符串使用的数据结构；</li>
<li>存储过期时间消耗（也是存储为一个dictEntry，时间戳为int64）；</li>
<li>存储value的sds消耗，根据数据结构不同而不同；</li>
<li>前四项基本是存储任何一个key都需要消耗的，最后一项根据value的数据结构不同而不同；</li>
</ol>
</li>
</ol>
<h2 id="redis-主从模式"><a href="#redis-主从模式" class="headerlink" title="redis 主从模式"></a><strong>redis 主从模式</strong></h2><p>同步主节点的数据，可以做读写分离，缺点是主从模式下，主节点挂了之后，从节点没办法自动成功主节点，需要人工设置为主节点。</p>
<h2 id="redis-sentinel（redis哨兵）"><a href="#redis-sentinel（redis哨兵）" class="headerlink" title="redis sentinel（redis哨兵）"></a><strong>redis sentinel（redis哨兵）</strong></h2><p>保证集群的高可用。作用故障发现，故障转移，通知。</p>
<p>自动故障转移就是当主节点不能正常工作时，Sentinel会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。</p>
<p>工作原理就是，当Master宕机的时候，Sentinel会选举出新的Master，并根据Sentinel中<code>client-reconfig-script</code>脚本配置的内容，去动态修改VIP(虚拟IP)，将VIP(虚拟IP)指向新的Master。我们的客户端就连向指定的VIP即可！故障发生后的转移情况，可以理解为下图</p>
<img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/725429-20190210232919215-1911685532.jpg" style="zoom:67%;">

<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷:"></a>缺陷:</h3><p>(1)主从切换的过程中会丢数据<br>(2)Redis只能单点写，不能水平扩容</p>
<p><strong>实现原理：</strong><br>三个定时监控任务<br>1）每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。<br>2）每隔2秒，每个Sentinel节点会向Redis数据节点的<strong>sentinel</strong>:hello频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。<br>3）每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。</p>
<p><strong>主观下线</strong><br>因为每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。<br><strong>客观下线</strong><br>当Sentinel主观下线的节点是主节点时，该Sentinel节点会向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，那么意味着大部分的Sentinel节点都对这个主节点的下线做了同意的判定，于是该Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定。</quorum></p>
<p><strong>领导者Sentinel节点选举</strong><br>Raft算法：假设s1(sentinel-1)最先完成客观下线，它会向其余Sentinel节点发送命令，请求成为领导者；收到命令的Sentinel节点如果没有同意过其他Sentinel节点的请求，那么就会同意s1的请求，否则拒绝；如果s1发现自己的票数已经大于等于某个值，那么它将成为领导者。</p>
<p><strong>故障转移</strong><br>1）领导者Sentinel节点在从节点列表中选出一个节点作为新的主节点<br>2）上一步的选取规则是与主节点复制相似度最高的从节点<br>3）领导者Sentinel节点让剩余的从节点成为新的主节点的从节点<br>4）Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</p>
<h2 id="redis集群（redis-cluster）"><a href="#redis集群（redis-cluster）" class="headerlink" title="redis集群（redis cluster）"></a><strong>redis集群（redis cluster）</strong></h2><ol>
<li><p>redis3以后，节点之间提供了完整的sharding（分片）、replication（主备感知能力）、failover（故障转移）的特性</p>
</li>
<li><p>配置一致性：每个节点（Node）内部都保存了集群的配置信息，存储在clusterState中，通过引入自增的epoch变量来使得集群配置在各个节点间保持一致</p>
</li>
<li><p>sharding数据分片 </p>
<ol>
<li>将所有数据划分为16384个分片（slot），每个节点会对应一部分slot，每个key都会根据分布算法映射到16384个slot中的一个，分布算法为slotId=crc16(key)%16384</li>
<li>当一个client访问的key不在对应节点的slots中，redis会返回给client一个moved命令，告知其正确的路由信息从而重新发起请求。client会根据每次请求来缓存本地的路由缓存信息，以便下次请求直接能够路由到正确的节点</li>
<li>分片迁移：分片迁移的触发和过程控制由外部系统完成，redis只提供迁移过程中需要的原语支持。主要包含两种：一种是节点迁移状态设置，即迁移前标记源、目标节点；另一种是key迁移的原子化命令</li>
</ol>
</li>
<li><p>failover故障转移 </p>
<ol>
<li>故障发现：节点间两两通过TCP保持连接，周期性进行PING、PONG交互，若对方的PONG相应超时未收到，则将其置为PFAIL状态，并传播给其他节点</li>
<li>故障确认：当集群中有一半以上的节点对某一个PFAIL状态进行了确认，则将起改为FAIL状态，确认其故障</li>
<li>slave选举：当有一个master挂掉了，则其slave重新竞选出一个新的master。主要根据各个slave最后一次同步master信息的时间，越新表示slave的数据越新，竞选的优先级越高，就更有可能选中。竞选成功之后将消息传播给其他节点。</li>
</ol>
</li>
<li><p>从节点选举<br> ①每个从节点，都根据自己对master复制数据的offset，来设置一个选举时间，offset越大的从节点，选举时间越靠前，优先进行选举。</p>
<p>②所有的master node开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node(N/2 + 1)都投票给了某个从节点，那么选举通过，那个从节点可以切换成master node。</p>
<p>③从节点执行主备切换，从节点切换为主节点。</p>
</li>
<li><p>主从同步</p>
<p><strong>2.8版本之后 同步操作PSYNC。自行判断 是全量同步 还是 增量同步 效率比较高**</strong>2.8版本之后 同步操作PSYNC。自行判断 是全量同步 还是 增量同步 效率比较高**</p>
<p><strong>部分重同步功能由下面几个部分构成：</strong><br><font color="red">主服务器的复制偏移量和从服务器的复制偏移量</font>：当主服务器在向从服务器进行命令同步时，主服务器和从服务器会各自记录一个复制偏移量，当主从服务器的数据库状态一致时这两个复制偏移量是相同的，如果这两个偏移量不一致说明当前主从服务器的状态不一致<br><font color="red">主服务器的复制积压缓冲区</font>：复制积压缓冲区是一个固定大小的FIFO队列，当队列已满时会弹出最早插入的数据，在主服务器进行命令传播时会同时把命令放到缓冲区中，缓冲区包含两部分数据，偏移量和字节。在进行复制时从服务器会将偏移量上报到主服务器，主服务检查当前偏移量是否还存在缓冲区中，如果存在进行部分重同步，如果不存在进行完整重同步。因为这个积压缓冲区是一个固定大小的队列，所以当从服务器长时间断线时，从服务器的复制偏移量很可能已不再缓冲区中，这时候只能进行完整重同步<br><font color="red">服务器的运行ID</font>：初次同步时主服务器会把ID发给从服务器，从服务器保存主服务器ID，当断线重连后，会把之前保存的主服务器ID上报给主服务器，主服务器检查从服务器之前复制的主服务器ID是否和自己的ID相同，如果相同，执行部分重同步，如果不同说明从服务器之前记录的状态不是当前主服务器，这时候需要执行完整重同步<br><strong>PSYNC命令实现</strong></p>
<p>1）初始复制或者之前执行过SLAVEOF no one命令，执行完整重同步：发送PSYNC ? -1命令到主服务器<br>2）如果从服务器已经复制过某个主服务器，在开始新复制时向主服务器发送PSYNC <runid> <offset>命令，runid是上次复制的主服务器id，offset是从服务器的复制偏移量<br>3）主服务器会根据这个两个参数来决定做哪种同步，判断服务器id是否和本机相同，复制偏移量是否在缓冲区中，主服务器有三种回复：</offset></runid></p>
<p>回复+FULLRESYNC <runid> <offset>执行完整重同步，从服务器把offset当做初始复制偏移量<br>回复+CONTINUE，表示执行部分重同步，从服务器等待主服务器发送缺少的数据<br>回复-ERR，表示主服务器版本低于2.8，不支持PSYNC命令</offset></runid></p>
<p><strong>增量同步</strong><br>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
<p><strong>Redis主从同步策略</strong><br>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。<br><strong>注意点</strong><br>如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</p>
<p><strong>无磁盘复制</strong></p>
<p>在内存中生成RDB文件内容，默认是使用RDB磁盘文件复制，可以通过配置文件修改</p>
</li>
<li><p>集群不可用的情况： </p>
<ol>
<li>集群中任意master挂掉，且当前master没有slave。</li>
<li>集群中超过半数以上master挂掉。</li>
</ol>
</li>
<li><p>一致性协议交互</p>
<ol>
<li>使用Gossip协议，节点间进行信息交换，信息包含消息头和消息体。</li>
<li>消息体无外乎是一些节点标识啊，IP啊，端口号啊，发送时间，会携带一定数量的其他节点信息用于交换，约为集群总节点数量的1/10，至少携带3个节点的信息。消息体大小是10个节点的状态信息约1kb。<font color="red">节点数量越多，消息体内容越大。</font></li>
<li>消息头主要包含字段为type表示消息类型，区分meet，ping，pong，pfail，fail类型消息，字段为myslots的char数组，长度为16383/8，一个bitmap,每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点的。myslots大小为2kb</li>
</ol>
</li>
<li><p><em>定期的频率</em></p>
<ol>
<li>每秒会随机选取5个节点，找出最久没有通信的节点发送ping消息</li>
<li>每100毫秒(1秒10次)都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout/2 则立刻发送ping消息</li>
<li>每秒单节点发出ping消息数量为 <code>数量=1+10*num（node.pong_received&gt;cluster_node_timeout/2）</code></li>
</ol>
</li>
<li><p>使用16384个槽（slot）的原因</p>
<p>(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。</p>
<p>如上所述，在消息头中，最占空间的是<code>myslots[CLUSTER_SLOTS/8]</code>。 当槽位为65536时，这块的大小是: <code>65536÷8÷1024=8kb</code> 因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。</p>
<p>(2)redis的集群主节点数量基本不可能超过1000个。</p>
<p>如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</p>
<p>(3)槽位越小，节点少的情况下，压缩比高</p>
<p>Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p>
</li>
</ol>
<h2 id="普通哈希算法和一致性哈希算法对比"><a href="#普通哈希算法和一致性哈希算法对比" class="headerlink" title="普通哈希算法和一致性哈希算法对比"></a><strong>普通哈希算法和一致性哈希算法对比</strong></h2><ol>
<li>普通哈希：也称硬哈希，采用简单取模的方式，将机器进行散列，这在cache环境不变的情况下能取得让人满意的结果，但是当cache环境动态变化时，这种静态取模的方式显然就不满足单调性的要求（当增加或减少一台机子时，几乎所有的存储内容都要被重新散列到别的缓冲区中）。</li>
<li>一致性哈希：将机器节点和key值都按照一样的hash算法映射到一个0~2^32 的圆环上。当有一个写入缓存的请求到来时，计算Key值k对应的哈希值Hash(k)，如果该值正好对应之前某个机器节点的Hash值，则直接写入该机器节点，如果没有对应的机器节点，则顺时针查找下一个节点，进行写入，如果超过2^32还没找到对应节点，则从0开始查找（因为是环状结构）。为了更可能的满足平衡性，可以引入虚拟节点，即一个实体节点映射到多个虚拟节点。</li>
<li>参考：<a target="_blank" rel="noopener" href="http://blog.huanghao.me/?p=14">http://blog.huanghao.me/?p=14</a></li>
</ol>
<h2 id="缓存雪崩，缓存穿透，缓存并发（缓存击穿），缓存预热，缓存算法"><a href="#缓存雪崩，缓存穿透，缓存并发（缓存击穿），缓存预热，缓存算法" class="headerlink" title="缓存雪崩，缓存穿透，缓存并发（缓存击穿），缓存预热，缓存算法"></a><strong>缓存雪崩，缓存穿透，缓存并发（缓存击穿），缓存预热，缓存算法</strong></h2><ol>
<li>缓存雪崩：可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。解决思路： <ol>
<li>加锁计数（即限制并发的数量，可以用semphore）或者起一定数量的队列来避免缓存失效时大量请求并发到数据库。但这种方式会降低吞吐量。</li>
<li>分析用户行为，然后失效时间均匀分布。或者在失效时间的基础上再加1~5分钟的随机数。</li>
<li>如果是某台缓存服务器宕机，则考虑做主备。</li>
</ol>
</li>
<li>缓存穿透：指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库中查询。解决思路： <ol>
<li>如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。</li>
<li>可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。</li>
</ol>
</li>
<li>缓存并发：如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。解决思路： <ol>
<li>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</li>
</ol>
</li>
<li>缓存预热：目的就是在系统上线前，将数据加载到缓存中。解决思路： <ol>
<li>数据量不大的话，在系统启动的时候直接加载。</li>
<li>自己写个简单的缓存预热程序。</li>
</ol>
</li>
<li>缓存算法： <ol>
<li>FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。</li>
<li>LFU算法：Least Frequently Used，最不经常使用算法。</li>
<li>LRU算法：Least Recently Used，近期最少使用算法。</li>
<li>LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的。</li>
</ol>
</li>
</ol>
<h2 id="用redis实现分布式锁"><a href="#用redis实现分布式锁" class="headerlink" title="用redis实现分布式锁"></a><strong>用redis实现分布式锁</strong></h2><ol>
<li><p>主要使用的命令： </p>
<ol>
<li>setnx key val。当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</li>
<li>expire key timeout。为key设置一个超时时间，单位为second，超过这个时间锁会自  动释放，避免死锁。</li>
<li>delete key。删除锁</li>
</ol>
</li>
<li><p>实现思想： </p>
<ol>
<li>使用setnx加锁，如果返回1，则说明加锁成功，并设置超时时间，避免系统挂了，锁没法释放。在finally中delete删除锁释放。</li>
<li>如果需要设置超时等待时间，则可以加个while循环，在获取不到锁的情况下，进行循环获取锁，超时了则退出。</li>
</ol>
</li>
<li><p>redis3.0以上版本支持set命令，原子性操作，可以跟过期时间，不用使用脚本的方式进行</p>
</li>
<li><p>问题点是：</p>
<ol>
<li>单点问题：当主挂了之后，设置的数据还未同步到从节点，导致其它线程加锁成功</li>
<li>续期问题：过期时间到之后但是业务还没有处理完成，此时需要续期，续租。可以使用守护线程进行续期</li>
<li>使用Redisson的红锁，使用Hash结构，实现了可重入锁，解决单节点问题，并使用watch dog（）解决续期</li>
</ol>
</li>
</ol>
<h2 id="Redis的缓存淘汰策略LRU与LFU"><a href="#Redis的缓存淘汰策略LRU与LFU" class="headerlink" title="Redis的缓存淘汰策略LRU与LFU"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c8aeb3eee6bc">Redis的缓存淘汰策略LRU与LFU</a></h2><h2 id="Redis内存不足的缓存淘汰策略"><a href="#Redis内存不足的缓存淘汰策略" class="headerlink" title="Redis内存不足的缓存淘汰策略"></a>Redis内存不足的缓存淘汰策略</h2><ul>
<li>noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键</li>
<li>volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键</li>
<li>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</li>
<li>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</li>
<li>allkeys-random：加入键的时候如果过限，从所有key随机删除</li>
<li>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</li>
<li>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</li>
<li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li>
</ul>
<h2 id="Redis缓存淘汰策略"><a href="#Redis缓存淘汰策略" class="headerlink" title="Redis缓存淘汰策略"></a>Redis缓存淘汰策略</h2><p>在Redis内存使用超过一定值的时候（一般这个值可以配置）使用的淘汰策略；</p>
<h2 id="Redis键的过期删除策略"><a href="#Redis键的过期删除策略" class="headerlink" title="Redis键的过期删除策略"></a>Redis键的过期删除策略</h2><p>通过定期删除+惰性删除两者结合的方式进行内存淘汰的。</p>
<ul>
<li>惰性删除：当某个key被设置了过期时间之后，客户端每次对该key的访问（读写）都会事先检测该key是否过期，如果过期就直接删除；</li>
<li>但有一些键只访问一次，因此需要主动删除，默认情况下redis每秒检测10次，检测的对象是所有设置了过期时间的键集合，每次从这个集合中随机检测20个键查看他们是否过期，如果过期就直接删除，如果删除后还有超过25%的集合中的键已经过期，那么继续检测过期集合中的20个随机键进行删除。这样可以保证过期键最大只占所有设置了过期时间键的25%。</li>
</ul>
<h2 id="Redis中LRU的实现"><a href="#Redis中LRU的实现" class="headerlink" title="Redis中LRU的实现"></a>Redis中LRU的实现</h2><p>Redis维护了一个24位全局时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。每个key内部也维护了一个24位的时钟，当新增key对象的时候会把系统的时钟赋值到这个内部对象时钟。比如我现在要进行LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰，这里值得注意的是全局时钟只有24位，按秒为单位来表示才能存储194天，所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。</p>
<p>Redis中的LRU与常规的LRU实现并不相同，常规LRU会准确的淘汰掉队头的元素，但是Redis的LRU并不维护队列，只是根据配置的策略要么从所有的key中随机选择N个（N可以配置）要么从所有的设置了过期时间的key中选出N个键，然后再从这N个键中选出最久没有使用的一个key进行淘汰。</p>
<h2 id="Redis中LFU的实现"><a href="#Redis中LFU的实现" class="headerlink" title="Redis中LFU的实现"></a>Redis中LFU的实现</h2><p>LFU是在Redis4.0后出现的，LRU的最近最少使用实际上并不精确，考虑下面的情况，如果在|处删除，那么A距离的时间最久，但实际上A的使用频率要比B频繁，所以合理的淘汰策略应该是淘汰B。LFU就是为应对这种情况而生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A~~A~~A~~A~~A~~A~~A~~A~~A~~A~~~|</span><br><span class="line">B~~~~~B~~~~~B~~~~~B~~~~~~~~~~~B|</span><br></pre></td></tr></table></figure>

<p>LFU把原来的key对象的内部时钟的24位分成两部分，前16位还代表时钟，后8位代表一个计数器。16位的情况下如果还按照秒为单位就会导致不够用，所以一般这里以时钟为单位。而后8位表示当前key对象的访问频率，8位只能代表255，但是redis并没有采用线性上升的方式，而是通过一个复杂的公式，通过配置两个参数来调整数据的递增速度。如果一个key经过几分钟没有被命中，那么后8位的值是需要递减几分钟。最后，redis会对内部时钟最小的key进行淘汰（最小表示最不频繁使用），注意这个过程也是根据策略随机选择键。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lfu-<span class="built_in">log</span>-factor <span class="number">10</span></span><br><span class="line">lfu-decay-time <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><p>使用多个 Redis 从服务器处理读查询时可能会遇到的最棘手的问题，就是主服务器临时下线或者永久下线。每当有从服务器尝试与主服务器建立连接的时候，主服务器就会为从服务器创建一个快照，如果在快照创建完毕之前，有多个从服务器都尝试与主服务器进行连接，那么这些从服务器将接收到同一个快照。从效率的角度来看，这种做法非常好，因为它可以避免创建多个快照。但是，<strong>同时向多个从服务器发送快照的多个副本，可能会将主服务器可用的大部分带宽消耗殆尽</strong>。使主服务器的延迟变高，甚至导致主服务器已经建立了连接的从服务器断开。</p>
<p><font color="red">解决从服务器重同步（resync）问题的其中一个方法</font>，就是<strong>减少主服务器需要传送给从服务器的数据数量，这可以通过构建树状复制中间层来完成</strong>。</p>
<p><img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/1760830-d430d0dc2cf82058"><br>从服务器树非常有用，在对不同数据中心（data center）进行复制的时候，这种从服务器树甚至是必需的：通过缓慢的广域网（WAN）连接进行重同步是一件相当耗费资源的工作，这种工作应该交给位于中间层的从服务器去做，而不必劳烦最顶层的主服务器。但是另一方面，构建从服务器树也会带来复杂的网络拓扑结构（topology），这增加了手动和自动处理故障转移的难度。</p>
<p><font color="red">解决从服务器重同步问题的<strong>另一个方法就是对网络连接进行压缩</strong></font>，从而减少需要传送的数据量。一些 Redis 用户就发现使用带压缩的 SSH 隧道（tunnel）进行连接可以明显地降低带宽占用，比如某个公司就曾经使用这种方法，将复制单个从服务器所需的带宽从原来的 21Mbit 降低为 1.8Mbit（<a target="_blank" rel="noopener" href="http://mng.bz/2ivv%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E8%AF%BB%E8%80%85%E4%B9%9F%E6%89%93%E7%AE%97%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%9D%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%B7%E8%AE%B0%E5%BE%97%E4%BD%BF%E7%94%A8">http://mng.bz/2ivv）。如果读者也打算使用这个方法的话，那么请记得使用</a> SSH 提供的选项来让 SSH 连接在断线后自动重连。</p>
<h2 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a><strong>Redis Sentinel</strong></h2><p>Redis Sentinel 可以配合 Redis 的复制功能使用，并对下线的主服务器进行故障转移。Sentinel 会监视一系列主服务器以及这些主服务器的从服务器，通过向主服务器发送<em>PUBLISH</em>命令和SUBSCRIBE命令，并向主服务器和从服务器发送<em>PING</em>命令，各个 Sentinel 进程可以自主识别可用的从服务器和其他 Sentinel。</p>
<p>当主服务器失效的时候，监视这个主服务器的所有 Sentinel 就会基于彼此共有的信息选出一个 Sentinel，并从现有的从服务器当中选出一个新的主服务器。当被选中的从服务器转换成主服务器之后，那个被选中的 Sentinel 就会让剩余的其他从服务器去复制这个新的主服务器（在默认设置下，Sentinel 会一个接一个地迁移从服务器，但这个数量可以通过配置选项进行修改）。</p>
<p>一般来说，使用 Redis Sentinel 的目的就是为了向主服务器属下的从服务器提供自动故障转移服务。此外，Redis Sentinel 还提供了可选的故障转移通知功能，这个功能可以通过调用用户提供的脚本来执行配置更新等操作。</p>
<h3 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h3><p>• 性能指标：Performance</p>
<p>•内存指标: Memory</p>
<p>•基本活动指标：Basic activity</p>
<p>•持久性指标: Persistence</p>
<p>•错误指标：Error</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>问题1:懂Redis事务么？<br><code>正常版</code>：Redis事务是一些列redis命令的集合,blabla…<br><code>高调版</code>: 我们在生产上采用的是Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效的。其次，Redis事务不支持回滚操作，简直是鸡肋！所以基本不用！</p>
<p>问题2:Redis的多数据库机制，了解多少？<br><code>正常版</code>：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，单机下的redis可以支持16个数据库（db0 ~ db15）<br><code>高调版</code>: 在Redis Cluster集群架构下只有一个数据库空间，即db0。因此，我们没有使用Redis的多数据库功能！</p>
<p>问题3:Redis集群机制中，你觉得有什么不足的地方吗？<br><code>正常版</code>: 不知道<br><code>高调版</code>: 假设我有一个key，对应的value是Hash类型的。如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上！还有就是做批量操作比较麻烦！</p>
<p>问题4:懂Redis的批量操作么？<br><code>正常版</code>: 懂一点。比如mset、mget操作等，blabla<br><code>高调版</code>: 我们在生产上采用的是Redis Cluster集群架构，不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通的。</p>
<p>问题5:那在Redis集群模式下，如何进行批量操作？</p>
<p>如果执行的key数量比较少，就不用mget了，就用串行get操作。如果真的需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。简单来说语法如下</p>
<blockquote>
<p><strong>对于key为{foo}.student1、{foo}.student2，{foo}student3，这类key一定是在同一个redis节点上。因为key中“{}”之间的字符串就是当前key的hash tags， 只有key中{ }中的部分才被用来做hash，因此计算出来的redis节点一定是同一个!</strong></p>
</blockquote>
<p><code>ps</code>:如果你用的是Proxy分片集群架构，例如Codis这种，会将mget/mset的多个key拆分成多个命令发往不同得redis实例，这里不多说。我推荐答的还是redis cluster。</p>
<p>问题6:你们有对Redis做读写分离么？<br><code>正常版</code>:没有做，至于原因额。。。额。。。额。。没办法了，硬着头皮扯~<br><code>高调版</code>:不做读写分离。我们用的是Redis Cluster的架构，是属于分片集群的架构。而redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</p>
<p><img src="/2020/12/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRedis%E4%B9%8B%E8%BF%9B%E9%98%B6/image-20210721103502584.png" alt="image-20210721103502584"></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>使用过程中经常会有各种大key的情况， 比如：</p>
<ul>
<li>单个简单的key存储的value很大</li>
<li>hash， set，zset，list 中存储过多的元素（以万为单位） 由于redis是单线程运行的，如果一次操作的value很大会对整个redis的响应时间造成负面影响，所以，业务上能拆则拆，下面举几个典型的分拆方案。 1. 单个简单的key存储的value很大 1.1 改对象需要每次都整存整取 可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；    </li>
</ul>
<h4 id="1-2-该对象每次只需要存取部分数据"><a href="#1-2-该对象每次只需要存取部分数据" class="headerlink" title="1.2 该对象每次只需要存取部分数据"></a>1.2 该对象每次只需要存取部分数据</h4><p>可以像第一种做法一样，分拆成几个key-value，  也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性    </p>
<h3 id="2-hash、set、zset、list-中存储过多的元素"><a href="#2-hash、set、zset、list-中存储过多的元素" class="headerlink" title="2. hash、set、zset、list 中存储过多的元素"></a>2. hash、set、zset、list 中存储过多的元素</h3><p>类似于场景一种的第一个做法，可以将这些元素分拆。</p>
<p>以hash为例，原先的正常存取流程是  hget(hashKey, field) ; hset(hashKey, field, value) 现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newHashKey  =  hashKey + (*hash*(field) % <span class="number">10000</span>）;   </span><br><span class="line">hset (newHashKey, field, value) ;  </span><br><span class="line">hget(newHashKey, field)</span><br></pre></td></tr></table></figure>

<p>set, zset, list 也可以类似上述做法.</p>
<p>但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">MQTT之简单使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-22 17:17:11" itemprop="dateCreated datePublished" datetime="2020-12-22T17:17:11+08:00">2020-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MQTT-Java-客户端库"><a href="#MQTT-Java-客户端库" class="headerlink" title="MQTT Java 客户端库"></a>MQTT Java 客户端库</h1><p><a target="_blank" rel="noopener" href="https://www.eclipse.org/paho/clients/java/">Eclipse Paho Java Client (opens new window)</a>是用 Java 编写的 MQTT 客户端库（MQTT Java Client），可用于 JVM 或其他 Java 兼容平台（例如Android）。</p>
<p>Eclipse Paho Java Client 提供了MqttAsyncClient 和 MqttClient 异步和同步 API。</p>
<h2 id="通过-Maven-安装-Paho-Java"><a href="#通过-Maven-安装-Paho-Java" class="headerlink" title="通过 Maven 安装 Paho Java"></a>通过 Maven 安装 Paho Java</h2><p>通过包管理工具 Maven 可以方便地安装 Paho Java 客户端库，截止目前最新版本安装如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.paho<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.paho.client.mqttv3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Paho-Java-使用示例"><a href="#Paho-Java-使用示例" class="headerlink" title="Paho Java 使用示例"></a>Paho Java 使用示例</h2><p>Java 体系中 Paho Java 是比较稳定、广泛应用的 MQTT 客户端库，本示例包含 Java 语言的 Paho Java 连接 EMQ X Broker，并进行消息收发完整代码：</p>
<p><strong>App.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.emqx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttClient;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttConnectOptions;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttException;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String subTopic = <span class="string">&quot;testtopic/#&quot;</span>;</span><br><span class="line">        String pubTopic = <span class="string">&quot;testtopic/1&quot;</span>;</span><br><span class="line">        String content = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> qos = <span class="number">2</span>;</span><br><span class="line">        String broker = <span class="string">&quot;tcp://broker.emqx.io:1883&quot;</span>;</span><br><span class="line">        String clientId = <span class="string">&quot;emqx_test&quot;</span>;</span><br><span class="line">        MemoryPersistence persistence = <span class="keyword">new</span> MemoryPersistence();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MqttClient client = <span class="keyword">new</span> MqttClient(broker, clientId, persistence);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MQTT 连接选项</span></span><br><span class="line">            MqttConnectOptions connOpts = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">            connOpts.setUserName(<span class="string">&quot;emqx_test&quot;</span>);</span><br><span class="line">            connOpts.setPassword(<span class="string">&quot;emqx_test_password&quot;</span>.toCharArray());</span><br><span class="line">            <span class="comment">// 保留会话</span></span><br><span class="line">            connOpts.setCleanSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置回调</span></span><br><span class="line">            client.setCallback(<span class="keyword">new</span> PushCallback());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Connecting to broker: &quot;</span> + broker);</span><br><span class="line">            client.connect(connOpts);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Connected&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Publishing message: &quot;</span> + content);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 订阅</span></span><br><span class="line">            client.subscribe(subTopic);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息发布所需参数</span></span><br><span class="line">            MqttMessage message = <span class="keyword">new</span> MqttMessage(content.getBytes());</span><br><span class="line">            message.setQos(qos);</span><br><span class="line">            client.publish(pubTopic, message);</span><br><span class="line">            System.out.println(<span class="string">&quot;Message published&quot;</span>);</span><br><span class="line"></span><br><span class="line">            client.disconnect();</span><br><span class="line">            System.out.println(<span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">            client.close();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MqttException me) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;reason &quot;</span> + me.getReasonCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;msg &quot;</span> + me.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;loc &quot;</span> + me.getLocalizedMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;cause &quot;</span> + me.getCause());</span><br><span class="line">            System.out.println(<span class="string">&quot;excep &quot;</span> + me);</span><br><span class="line">            me.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回调消息处理类 OnMessageCallback.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.emqx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttCallback;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnMessageCallback</span> <span class="keyword">implements</span> <span class="title">MqttCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionLost</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 连接丢失后，一般在这里面进行重连</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开，可以做重连&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageArrived</span><span class="params">(String topic, MqttMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// subscribe后得到的消息会执行到这里面</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息主题:&quot;</span> + topic);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息Qos:&quot;</span> + message.getQos());</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息内容:&quot;</span> + <span class="keyword">new</span> String(message.getPayload()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliveryComplete</span><span class="params">(IMqttDeliveryToken token)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;deliveryComplete---------&quot;</span> + token.isComplete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Paho-Java-MQTT-5-0-支持"><a href="#Paho-Java-MQTT-5-0-支持" class="headerlink" title="Paho Java MQTT 5.0 支持"></a>Paho Java MQTT 5.0 支持</h2><p>目前 Paho Java 还在适配 MQTT 5.0，尚未全面支持。</p>
<h2 id="离线数据"><a href="#离线数据" class="headerlink" title="离线数据"></a>离线数据</h2><p>满足以下条件：</p>
<ul>
<li>发布和订阅客户端的clientId必须一样，必须自己设置。如果不设置，emqtt服务端会自动产生一个唯一的id。</li>
<li>发布和订阅客户端setCleanSession(false);不清除session</li>
<li>客户端的QoS &gt;= 1</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">MQTT之Qos详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-22 16:59:29" itemprop="dateCreated datePublished" datetime="2020-12-22T16:59:29+08:00">2020-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/zero-50-79">程序锅</a><br>出处：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/80203905">https://zhuanlan.zhihu.com/p/80203905</a></p>
<h2 id="1-MQTT中的QoS等级"><a href="#1-MQTT中的QoS等级" class="headerlink" title="1. MQTT中的QoS等级"></a>1. MQTT中的QoS等级</h2><p>MQTT设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次QoS（Quality of Service）：</p>
<ul>
<li>QoS0，At most once，至多一次；</li>
<li>QoS1，At least once，至少一次；</li>
<li>QoS2，Exactly once，确保只有一次。</li>
</ul>
<p>QoS 是消息的发送方（Sender）和接受方（Receiver）之间达成的一个协议：</p>
<ul>
<li>QoS0 代表，Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了；</li>
<li>QoS1 代表，Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息；</li>
<li>QoS2 代表，Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。</li>
</ul>
<blockquote>
<p>注意：<br>QoS是Sender和Receiver之间的协议，而不是Publisher和Subscriber之间的协议。换句话说，Publisher发布了一条QoS1的消息，只能保证Broker能至少收到一次这个消息；而对于Subscriber能否至少收到一次这个消息，还要取决于Subscriber在Subscibe的时候和Broker协商的QoS等级。</p>
</blockquote>
<h3 id="1-1-QoS0"><a href="#1-1-QoS0" class="headerlink" title="1.1. QoS0"></a>1.1. QoS0</h3><p>QoS0等级下，Sender和Receiver之间一次消息的传递流程如下：</p>
<p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-c707d4103db77637e352e20f445f728c_r.jpg" alt="preview"></p>
<p>Sender向Receiver发送一个包含消息数据的PUBLISH包，然后不管结果如何，丢掉已发送的PUBLISH包，一条消息的发送完成。</p>
<h3 id="1-2-QoS1"><a href="#1-2-QoS1" class="headerlink" title="1.2. QoS1"></a>1.2. QoS1</h3><p>QoS1要保证消息至少到达一次，所以有一个应答的机制。Sender和Receiver的一次消息的传递流程如下：</p>
<p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-600d6162bdb9e17430437ce58bfcda8f_720w.jpg" alt="img"></p>
<ol>
<li>Sender向Receiver发送一个带有数据的PUBLISH包，并在本地保存这个PUBLISH包；</li>
<li>Receiver收到PUBLISH包以后，向Sender发送一个PUBACK数据包，PUBACK数据包没有消息体（Payload），在可变头中有一个包标识（Packet Identifier），和它收到的PUBLISH包中的Packet Identifier一致。</li>
<li>Sender收到PUBACK之后，根据PUBACK包中的Packet Identifier找到本地保存的PUBLISH包，然后丢弃掉，一次消息的发送完成。</li>
</ol>
<p>但是消息传递流程中可能会出现问题：</p>
<ul>
<li>如果Sender在一段时间内没有收到PUBLISH包对应的PUBACK，它将该PUBLISH包的DUP标识设为1（代表是重新发送的PUBLISH包），然后重新发送该PUBLISH包。</li>
<li>Receiver可能会重复收到消息，需自行去重。</li>
</ul>
<h3 id="1-3-QoS2"><a href="#1-3-QoS2" class="headerlink" title="1.3. QoS2"></a>1.3. QoS2</h3><p>相比QoS0和QoS1,QoS2不仅要确保Receiver能收到Sender发送的消息，还需要确保消息不重复。它的重传和应答机制就要复杂一些，同时开销也是最大的。QoS2下，一次消息的传递流程如下所示：</p>
<p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-f9be4b4af808507942cad20984b1d0d8_720w.jpg" alt="img"></p>
<ol>
<li>Sender发送QoS为2的PUBLISH数据包，数据包 Packet Identifier 为 P，并在本地保存该PUBLISH包；</li>
<li>Receiver收到PUBLISH数据包后，<strong>在本地保存PUBLISH包的Packet Identifier P</strong>，并回复Sender一个PUBREC数据包，PUBREC数据包可变头中的Packet Identifier为P，没有消息体（Payload）；</li>
<li>当Sender收到PUBREC，它就可以安全的丢弃掉初始Packet Identifier为P的PUBLISH数据包。同时保存该PUBREC数据包，并回复Receiver一个PUBREL数据包，PUBREL数据包可变头中的Packet Identifier为P，没有消息体；</li>
<li>当Receiver收到PUBREL数据包，它可以丢掉保存的PUBLISH包的Packet Identifier P，并回复Sender一个可变头中 Packet Identifier 为 P，没有消息体（Payload）的PUBCOMP数据包；</li>
<li>当Sender收到PUBCOMP包，那么认为传输已完成，则丢掉对应的PUBREC数据包；</li>
</ol>
<p>上面是一次完整无误的传输过程，然而传输过程中可能会出现以下情况：</p>
<ul>
<li>情况1：Sender发送PUBLISH数据包给Receiver的时候，发送失败；</li>
<li>情况2：Sender已经成功发送PUBLISH数据包给Receiver了，但是Receiver发送PUBREC数据包失败；</li>
<li>情况3：Sender已经成功收到了PUBREC数据包，但是PUBREL数据包发送失败；</li>
<li>情况4：Receiver已经收到了PUBREL数据包，但是发送PUBCOMP数据包时发送失败</li>
</ul>
<p>针对上述的问题，较为详细的处理方法如下：</p>
<ul>
<li>不管是情况1还是情况2，因为Sender在一定时间内没有收到PUBREC，那么它会把PUBLISH包的DUP标识设为1，重新发送该PUBLISH数据包；</li>
<li>不管是情况3还是情况4，因为Sender在一定时间内没有收到PUBCOMP包，那么它会重新发送PUBREL数据包；</li>
<li>针对情况2，Receiver可能会收到多个重复的PUBLISH包，更加完善的处理如下：<br>Receiver在收到PUBLISH数据包之后，马上回复一个PUBREC数据包。并会在本地保存PUBLISH包的Packet Identifier P，不管之后因为重传多少次这个Packet Identifier 为P的数据包，Receiver都认为是重复的，丢弃。同时Receiver接收到QoS为2的PUBLISH数据包后，<strong>并不马上投递给上层，</strong>而是在本地做持久化，将消息保存起来（这里需要是持久化而不是保存在内存）。</li>
<li>针对情况4，更加完善的处理如下：<br>Receiver收到PUBREL数据包后，正式将消息递交给上层应用层，投递之后销毁Packet Identifier P，并发送PUBCOMP数据包，销毁之前的持久化消息。之后不管接收到多少个PUBREL数据包，因为没有Packet Identifier P，直接回复PUBCOMP数据包即可。</li>
</ul>
<h2 id="2-QoS降级"><a href="#2-QoS降级" class="headerlink" title="2. QoS降级"></a>2. QoS降级</h2><p>在 MQTT 协议中，从 Broker 到 Subscriber 这段消息传递的实际 QoS 等于：Publisher 发布消息时指定的 QoS 等级和 Subscriber 在订阅时与 Broker 协商的 QoS 等级，这两个 QoS 等级中的最小那一个。</p>
<blockquote>
<p><strong>Actual Subscribe QoS = MIN(Publish QoS, Subscribe QoS)</strong></p>
</blockquote>
<p>如下面代码所示：</p>
<p>该subscriber订阅消息时指定的QoS为1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当代理响应订阅请求时被调用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_subscribe</span>(<span class="params">client, userdata, mid, granted_qos</span>):</span></span><br><span class="line">    print(<span class="string">&quot;granted_qos:&quot;</span>, granted_qos)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当收到关于客户订阅的主题的消息时调用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">client, userdata, message</span>):</span></span><br><span class="line">    print(<span class="string">&quot;message qos&quot;</span>, message.qos)</span><br><span class="line">    print(<span class="string">&quot;message topic&quot;</span>, message.topic)</span><br><span class="line">    print(<span class="string">&quot;message payload&quot;</span>, message.payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span></span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span> :</span><br><span class="line">        print(<span class="string">&quot;subscribing&quot;</span>)</span><br><span class="line">        client.subscribe(<span class="string">&quot;test&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;connection failed &quot;</span>, rc)</span><br><span class="line"></span><br><span class="line">mqtt_client = mqtt.Client(client_id=<span class="string">&quot;demo_mqtt_sub&quot;</span>, clean_session=<span class="literal">False</span>)</span><br><span class="line">mqtt_client.on_connect = on_connect</span><br><span class="line">mqtt_client.on_subscribe = on_subscribe</span><br><span class="line">mqtt_client.on_message = on_message</span><br><span class="line"></span><br><span class="line">mqtt_client.connect(<span class="string">&quot;192.168.10.239&quot;</span>, <span class="number">1883</span>)</span><br><span class="line">mqtt_client.loop_forever()</span><br></pre></td></tr></table></figure>

<p>运行上述代码输出的结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscribing</span><br><span class="line">granted_qos: (1,)</span><br></pre></td></tr></table></figure>

<p>之后运行下面的publisher代码，指定发送的PUBLISH数据包的QoS等级为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span></span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span>:</span><br><span class="line">        client.publish(<span class="string">&quot;test&quot;</span>, payload=<span class="string">&quot;hello world&quot;</span>, qos=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;connection failed &quot;</span>, rc)</span><br><span class="line"></span><br><span class="line">mqtt_client = mqtt.Client(client_id=<span class="string">&quot;demo_mqtt_pub&quot;</span>, clean_session=<span class="literal">False</span>)</span><br><span class="line">mqtt_client.on_connect = on_connect</span><br><span class="line"></span><br><span class="line">mqtt_client.connect(<span class="string">&quot;192.168.10.239&quot;</span>, <span class="number">1883</span>)</span><br><span class="line">mqtt_client.loop_forever()</span><br></pre></td></tr></table></figure>

<p>结果上面运行subscriber代码的终端输出如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message qos 0</span><br><span class="line">message topic <span class="built_in">test</span></span><br><span class="line">message payload b<span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上述的结果表示，订阅者收到的消息的qos等级为0。同样如果修改subscriber中的订阅主题的QoS等级为0，publisher中发布的PUBLISH包的QoS为1，那么输出结果同上。</p>
<h2 id="3-QoS和会话"><a href="#3-QoS和会话" class="headerlink" title="3. QoS和会话"></a>3. QoS和会话</h2><p>如果 Client 想接收离线消息，必须使用持久化的会话（Clean Session = 0）连接到 Broker，这样 Broker 才会存储 Client 在离线期间没有确认接收的 QoS 大于 等于1 的消息。</p>
<blockquote>
<p>在发送QoS为1或2的情况，Broker（此时为Sender）会将发送的PUBLISH数据包保存到本地，直到收到一系列回复的数据包，然而Client（此时为Receiver）在离线期间无法回复相应的数据包，所以会一直存储。</p>
</blockquote>
<h2 id="4-QoS等级使用建议"><a href="#4-QoS等级使用建议" class="headerlink" title="4. QoS等级使用建议"></a>4. QoS等级使用建议</h2><p><strong>在以下情况下你可以选择 QoS0</strong>：</p>
<ul>
<li>Client 和 Broker 之间的网络连接非常稳定，例如一个通过有线网络连接到 Broker 的测试用 Client；</li>
<li>可以接受丢失部分消息，比如你有一个传感器以非常短的间隔发布状态数据，所以丢一些也可以接受；</li>
<li>你不需要离线消息。</li>
</ul>
<p><strong>在以下情况下你应该选择 QoS1：</strong></p>
<ul>
<li>你需要接收所有的消息，而且你的应用可以接受并处理重复的消息；</li>
<li>你无法接受 QoS2 带来的额外开销，QoS1 发送消息的速度比 QoS2 快很多。</li>
</ul>
<p><strong>在以下情况下你应该选择 QoS2：</strong></p>
<ul>
<li>你的应用必须接收到所有的消息，而且你的应用在重复的消息下无法正常工作，同时你也能接受 QoS2 带来的额外开销。</li>
</ul>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a><strong>本文参考</strong></h2><ol>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/zerooffdate/article/details/78950907">MQTT协议QoS2 准确一次送达的实现</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">mysql之索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-22 16:28:36" itemprop="dateCreated datePublished" datetime="2020-12-22T16:28:36+08:00">2020-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MySQL索引方法"><a href="#MySQL索引方法" class="headerlink" title="MySQL索引方法"></a>MySQL索引方法</h2><ul>
<li>Hash （对于指定值查询很快，能直接定位，但是范围查询无效）</li>
<li>B+树 （提升查询效率）</li>
</ul>
<h2 id="B-树索引和哈希索引的区别"><a href="#B-树索引和哈希索引的区别" class="headerlink" title="B+树索引和哈希索引的区别"></a><strong>B+树索引和哈希索引的区别</strong></h2><p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</p>
<p><img src="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/1.jpeg" alt="img"></p>
<p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的，如下图所示：</p>
<p><img src="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/2.jpeg" alt="img"></p>
<h2 id="哈希索引的优缺点"><a href="#哈希索引的优缺点" class="headerlink" title="哈希索引的优缺点"></a>哈希索引的优缺点</h2><p><strong>等值查询，</strong>哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p>
<p><strong>缺点</strong></p>
<ol>
<li>不支持范围查询</li>
<li>不支持索引完成排序</li>
<li>不支持联合索引的最左前缀匹配规则</li>
</ol>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a><strong>B树和B+树的区别</strong></h2><p>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</p>
<p><img src="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/3.jpeg" alt="img"></p>
<p>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接</p>
<p>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p>
<p><img src="/2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/4.jpeg" alt="img"></p>
<h2 id="B-比B树更适合实际应用中操作系统的文件索引和数据库索引"><a href="#B-比B树更适合实际应用中操作系统的文件索引和数据库索引" class="headerlink" title="B+比B树更适合实际应用中操作系统的文件索引和数据库索引"></a><strong>B+比B树更适合实际应用中操作系统的文件索引和数据库索引</strong></h2><p>1、B+的磁盘读写代价更低。</p>
<p>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</p>
<p>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>2、B+tree的查询效率更加稳定。</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><ul>
<li>聚簇索引（clustered index ）</li>
<li>非聚簇索引（secondary index）</li>
</ul>
<p>​    InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p>
<p>​    MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<p>InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。并且和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ul>
<li>最左匹配原则</li>
<li>like使用，&gt; &lt;使用  都会让组合索引后面的字段不走索引</li>
<li>回表查询，覆盖索引</li>
<li>减少关联sql查询</li>
</ul>
<h2 id="Explain执行计划"><a href="#Explain执行计划" class="headerlink" title="Explain执行计划"></a>Explain执行计划</h2><p>id：SQL执行的顺利的标识,SQL从大到小的执行,先执行的语句编号大。</p>
<p>type：system &gt;const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt;unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p><strong>好的sql查询至少达到range级别，最好能达到ref</strong></p>
<p>依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL。</p>
<p>除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引。</p>
<p>system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p>
<p>const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描。</p>
<p>eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref。</p>
<p>ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p>
<p>fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引。</p>
<p>ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p>
<p>unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值。</p>
<p>index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p>
<p>range：索引范围扫描，常见于使用&gt;,&lt;,is null,between,in ,like等运算符的查询中。</p>
<p>index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能都不如range。</p>
<p>index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p>
<p>key， possible_keys,</p>
<p>rows: 大致估算出找到所需的记录所需要读取的行数</p>
<p>Extra:  Using filesort （排序时无法使用到索引时，就会出现这个。常见于orderby和group by语句中。）</p>
<p>​             Using temporary（表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。）</p>
<p>​            usingindex：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/mysql%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/mysql%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">mysql之存储引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-22 16:03:14" itemprop="dateCreated datePublished" datetime="2020-12-22T16:03:14+08:00">2020-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>MySQL 有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</span><br></pre></td></tr></table></figure>

<p>MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎：</p>
<ul>
<li><p><strong>MyISAM</strong>管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。</p>
</li>
<li><p><strong>MEMORY</strong>存储引擎提供”内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中。</p>
<p>注释：MEMORY存储引擎正式地被确定为HEAP引擎。</p>
</li>
<li><p><strong>InnoDB</strong>和BDB存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎。</p>
</li>
<li><p><strong>EXAMPLE</strong>存储引擎是一个”存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。</p>
</li>
<li><p><strong>NDB Cluster</strong>是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows。</p>
</li>
<li><p><strong>ARCHIVE</strong>存储引擎被用来无索引地，非常小地覆盖存储的大量数据。</p>
</li>
<li><p><strong>CSV</strong>存储引擎把数据以逗号分隔的格式存储在文本文件中。</p>
</li>
<li><p><strong>BLACKHOLE</strong>存储引擎接受但不存储数据，并且检索总是返回一个空集。</p>
</li>
<li><p><strong>FEDERATED</strong>存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动器或客户端连接方法连接到另外的数据源。</p>
</li>
</ul>
<h2 id="比较常用的是-MyISAM-和-InnoBD"><a href="#比较常用的是-MyISAM-和-InnoBD" class="headerlink" title="比较常用的是 MyISAM 和 InnoBD"></a>比较常用的是 MyISAM 和 InnoBD</h2><table>
<thead>
<tr>
<th></th>
<th><strong>MyISAM</strong></th>
<th><strong>InnoDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>构成上的区别：</strong></td>
<td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。  <br>     .frm文件存储表定义。   <br>     数据文件的扩展名为.MYD (MYData)。    <br>     索引文件的扩展名是.MYI (MYIndex)。</td>
<td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td>
</tr>
<tr>
<td><strong>事务处理上方面:</strong></td>
<td>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持</td>
<td>InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能</td>
</tr>
<tr>
<td><strong>SELECT  UPDATE,INSERT，Delete操作</strong></td>
<td>如果执行大量的SELECT，MyISAM是更好的选择</td>
<td><strong>1.**如果你的数据执行大量的</strong>INSERT<strong>或</strong>UPDATE<strong>，出于性能方面的考虑，应该使用InnoDB表   **2.DELETE  FROM table</strong>时，InnoDB不会重新建立表，而是一行一行的删除。   <strong>3.LOAD  TABLE FROM MASTER</strong>操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用</td>
</tr>
<tr>
<td><strong>对AUTO_INCREMENT的操作</strong></td>
<td>每表一个AUTO_INCREMEN列的内部处理。   <strong>MyISAM为INSERT和UPDATE操作自动更新这一列</strong>。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。   AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置   对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引   更好和更快的auto_increment处理</td>
<td>如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。   自动增长计数器仅被存储在主内存中，而不是存在磁盘上   关于该计算器的算法实现，请参考   <strong>AUTO_INCREMENT列在InnoDB里如何工作</strong></td>
</tr>
<tr>
<td><strong>表的具体行数</strong></td>
<td>select count(<em>) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(</em>)语句包含  where条件时，两种表的操作是一样的</td>
<td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行</td>
</tr>
<tr>
<td><strong>锁</strong></td>
<td>表锁</td>
<td>提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in   SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%”</td>
</tr>
</tbody></table>
<h2 id="MySQL-存储引擎-MyISAM-与-InnoDB-如何选择？"><a href="#MySQL-存储引擎-MyISAM-与-InnoDB-如何选择？" class="headerlink" title="MySQL 存储引擎 MyISAM 与 InnoDB 如何选择？"></a>MySQL 存储引擎 MyISAM 与 InnoDB 如何选择？</h2><p>虽然 MySQL 里的存储引擎不只是 MyISAM 与 InnoDB 这两个，但常用的就是它俩了。可能有站长并未注意过 MySQL 的存储引擎，其实存储引擎也是数据库设计里的一大重要点，那么博客系统应该使用哪种存储引擎呢？</p>
<p>下面我们分别来看两种存储引擎的区别。</p>
<ul>
<li>一、InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</li>
<li>二、MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</li>
<li>三、InnoDB支持外键，MyISAM不支持</li>
<li>四、MyISAM是默认引擎，InnoDB需要指定</li>
<li>五、InnoDB不支持FULLTEXT类型的索引</li>
<li>六、InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表</li>
<li>七、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引</li>
<li>八、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表</li>
<li>九、InnoDB支持行锁（某些情况下还是锁整表，如 <strong>update table set a=1 where user like ‘%lee%’</strong></li>
<li>索引区别</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">MQTT之基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-22 15:01:12" itemprop="dateCreated datePublished" datetime="2020-12-22T15:01:12+08:00">2020-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>出处：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/mqtt-intro.html">MQTT 入门介绍</a></p>
<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>
<p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<p><img src="/2020/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BMQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/mqtt-fidge-2.svg" alt="img"></p>
<hr>
<h2 id="二、设计规范"><a href="#二、设计规范" class="headerlink" title="二、设计规范"></a>二、设计规范</h2><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p>
<ul>
<li>（1）精简，不添加可有可无的功能；</li>
<li>（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</li>
<li>（3）允许用户动态创建主题，零运维成本；</li>
<li>（4）把传输量降到最低以提高传输效率；</li>
<li>（5）把低带宽、高延迟、不稳定的网络等因素考虑在内；</li>
<li>（6）支持连续的会话控制；</li>
<li>（7）理解客户端计算能力可能很低；</li>
<li>（8）提供服务质量管理；</li>
<li>（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li>
</ul>
<hr>
<h2 id="三、主要特性"><a href="#三、主要特性" class="headerlink" title="三、主要特性"></a>三、主要特性</h2><p>MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p>
<ul>
<li><p>（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</p>
<p>这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</p>
</li>
<li><p>（2）对负载内容屏蔽的消息传输。</p>
</li>
<li><p>（3）使用TCP/IP提供网络连接。</p>
<p>主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</p>
</li>
<li><p>（4）有三种消息发布服务质量：</p>
<p>“至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p>
<p>“至少一次”，确保消息到达，但消息重复可能会发生。</p>
<p>“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</p>
</li>
<li><p>（5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。</p>
<p>这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</p>
</li>
<li><p>（6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。</p>
<p>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</p>
<p>Testament：遗嘱机制，功能类似于Last Will。</p>
</li>
</ul>
<hr>
<h2 id="四、MQTT协议原理"><a href="#四、MQTT协议原理" class="headerlink" title="四、MQTT协议原理"></a>四、MQTT协议原理</h2><h3 id="4-1-MQTT协议实现方式"><a href="#4-1-MQTT协议实现方式" class="headerlink" title="4.1 MQTT协议实现方式"></a>4.1 MQTT协议实现方式</h3><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p>
<ul>
<li>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li>
<li>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li>
</ul>
<h3 id="4-2-网络传输与应用消息"><a href="#4-2-网络传输与应用消息" class="headerlink" title="4.2 网络传输与应用消息"></a>4.2 网络传输与应用消息</h3><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p>
<p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p>
<h3 id="4-3-MQTT客户端"><a href="#4-3-MQTT客户端" class="headerlink" title="4.3 MQTT客户端"></a>4.3 MQTT客户端</h3><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p>
<ul>
<li>（1）发布其他客户端可能会订阅的信息；</li>
<li>（2）订阅其它客户端发布的消息；</li>
<li>（3）退订或删除应用程序的消息；</li>
<li>（4）断开与服务器连接。</li>
</ul>
<h3 id="4-4-MQTT服务器"><a href="#4-4-MQTT服务器" class="headerlink" title="4.4 MQTT服务器"></a>4.4 MQTT服务器</h3><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p>
<ul>
<li>（1）接受来自客户的网络连接；</li>
<li>（2）接受客户发布的应用信息；</li>
<li>（3）处理来自客户端的订阅和退订请求；</li>
<li>（4）向订阅的客户转发应用程序消息。</li>
</ul>
<h3 id="4-5-MQTT协议中的订阅、主题、会话"><a href="#4-5-MQTT协议中的订阅、主题、会话" class="headerlink" title="4.5 MQTT协议中的订阅、主题、会话"></a>4.5 MQTT协议中的订阅、主题、会话</h3><p><strong>一、订阅（Subscription）</strong></p>
<p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p>
<p><strong>二、会话（Session）</strong></p>
<p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p>
<p><strong>三、主题名（Topic Name）</strong></p>
<p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p>
<p><strong>四、主题筛选器（Topic Filter）</strong></p>
<p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p>
<p><strong>五、负载（Payload）</strong></p>
<p>消息订阅者所具体接收的内容。</p>
<h3 id="4-6-MQTT协议中的方法"><a href="#4-6-MQTT协议中的方法" class="headerlink" title="4.6 MQTT协议中的方法"></a>4.6 MQTT协议中的方法</h3><p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p>
<ul>
<li>（1）Connect。等待与服务器建立连接。</li>
<li>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li>
<li>（3）Subscribe。等待完成订阅。</li>
<li>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li>
<li>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li>
</ul>
<hr>
<h2 id="五、MQTT协议数据包结构"><a href="#五、MQTT协议数据包结构" class="headerlink" title="五、MQTT协议数据包结构"></a>五、MQTT协议数据包结构</h2><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p>
<ul>
<li>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</li>
<li>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</li>
<li>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</li>
</ul>
<h3 id="5-1-MQTT固定头"><a href="#5-1-MQTT固定头" class="headerlink" title="5.1 MQTT固定头"></a>5.1 MQTT固定头</h3><p>固定头存在于所有MQTT数据包中，其结构如下：</p>
<p><strong>5.1.1 MQTT数据包类型</strong></p>
<p>位置：Byte 1中bits 7-4。</p>
<p>相于一个4位的无符号值，类型、取值及描述如下：</p>
<p><strong>5.1.2 标识位</strong></p>
<p>位置：Byte 1中bits 3-0。</p>
<p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p>
<p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p>
<p>（2）QoS：发布消息的服务质量，即：保证消息传递的次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ø00：最多一次，即：&lt;&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø01：至少一次，即：&gt;&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø10：一次，即：&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø11：预留</span><br></pre></td></tr></table></figure>

<p>（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。 5.1.3 剩余长度（Remaining Length）</p>
<p>地址：Byte 2。</p>
<p>固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0</p>
<h3 id="5-2-MQTT可变头"><a href="#5-2-MQTT可变头" class="headerlink" title="5.2 MQTT可变头"></a>5.2 MQTT可变头</h3><p>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p>
<p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p>
<h3 id="5-3-Payload消息体"><a href="#5-3-Payload消息体" class="headerlink" title="5.3 Payload消息体"></a>5.3 Payload消息体</h3><p>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：</p>
<ul>
<li>（1）CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</li>
<li>（2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</li>
<li>（3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</li>
<li>（4）UNSUBSCRIBE，消息体内容是要订阅的主题。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">分布式事务之Seata简单使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-22 13:33:18" itemprop="dateCreated datePublished" datetime="2020-12-22T13:33:18+08:00">2020-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：程序员内点事<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6899645923024355336">https://juejin.cn/post/6899645923024355336</a></p>
<h2 id="分布式事务由来"><a href="#分布式事务由来" class="headerlink" title="分布式事务由来"></a>分布式事务由来</h2><p>当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1ec31a8cda8745c9bf7793b7bd092616~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="分库分表、SOA"><a href="#分库分表、SOA" class="headerlink" title="分库分表、SOA"></a>分库分表、SOA</h3><p>可随着业务量的不断增长，单体架构渐渐扛不住巨大的流量，此时就需要对数据库、表做 <code>分库分表</code>处理，将应用 <code>SOA</code> 服务化拆分。也就产生了订单中心、用户中心、库存中心等，由此带来的问题就是业务间相互隔离，每个业务都维护着自己的数据库，数据的交换只能进行 <code>RPC</code> 调用。</p>
<p>当用户再次下单时，需同时对订单库 <code>order</code>、库存库 <code>storage</code>、用户库 <code>account</code> 进行操作，可此时我们只能保证自己本地的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7d920f9dedcf454faa0b9313bd17df43~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h2 id="Seata-优势"><a href="#Seata-优势" class="headerlink" title="Seata 优势"></a>Seata 优势</h2><p>实现分布式事务的方案比较多，常见的比如基于 <code>XA</code> 协议的 <code>2PC</code>、<code>3PC</code>，基于业务层的 <code>TCC</code>，还有应用消息队列 + 消息表实现的最终一致性方案，还有今天要说的 <code>Seata</code> 中间件，下边看看各个方案的优缺点。</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a><code>2PC</code></h3><p>基于 XA 协议实现的分布式事务，XA 协议中分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如 Oracle、MYSQL 这些数据库都实现了 XA 接口，而事务管理器则作为一个全局的调度者。</p>
<p>两阶段提交（<code>2PC</code>），对业务侵⼊很小，它最⼤的优势就是对使⽤⽅透明，用户可以像使⽤本地事务⼀样使⽤基于 XA 协议的分布式事务，能够严格保障事务 ACID 特性。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5d98e869a3d14c9da4ff308899222309~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>可 <code>2PC</code>的缺点也是显而易见，它是一个强一致性的同步阻塞协议，事务执⾏过程中需要将所需资源全部锁定，也就是俗称的 <code>刚性事务</code>。所以它比较适⽤于执⾏时间确定的短事务，整体性能比较差。</p>
<p>一旦事务协调者宕机或者发生网络抖动，会让参与者一直处于锁定资源的状态或者只有一部分参与者提交成功，导致数据的不一致。因此，在⾼并发性能⾄上的场景中，基于 XA 协议的分布式事务并不是最佳选择。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/a34f0af5f47a4ea686dae570643a019e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a><code>3PC</code></h3><p>三段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一种改进版本 ，为解决两阶段提交协议的阻塞问题，上边提到两段提交，当协调者崩溃时，参与者不能做出最后的选择，就会一直保持阻塞锁定资源。</p>
<p><code>2PC</code> 中只有协调者有超时机制，<code>3PC</code> 在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。而且在第一阶段和第二阶段中又插入了一个准备阶段（如下图，看着有点啰嗦），保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/08a0d09a1f684ac89d058ed599c5cb93~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>虽然 <code>3PC</code> 用超时机制，解决了协调者故障后参与者的阻塞问题，但与此同时却多了一次网络通信，性能上反而变得更差，也不太推荐。</p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>所谓的 <code>TCC</code> 编程模式，也是两阶段提交的一个变种，不同的是 <code>TCC</code> 为在业务层编写代码实现的两阶段提交。<code>TCC</code> 分别指 <code>Try</code>、<code>Confirm</code>、<code>Cancel</code> ，一个业务操作要对应的写这三个方法。必须引入一款 TCC 分布式事务框架，比如国内开源的 ByteTCC、himly、tcc-transaction。否则的话，感知各个阶段的执行情况以及推进执行下一个阶段的这些事情，不太可能自己手写实现，太复杂了。</p>
<p>以下单扣库存为例，<code>Try</code> 阶段去占库存，<code>Confirm</code> 阶段则实际扣库存，如果库存扣减失败 <code>Cancel</code> 阶段进行回滚，释放库存。</p>
<p>TCC 不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则 <code>Cancel</code> 来进行回滚补偿，这也就是常说的补偿性事务。</p>
<p>原本一个方法，现在却需要三个方法来支持，可以看到 TCC 对业务的侵入性很强，而且这种模式并不能很好地被复用，会导致开发量激增。还要考虑到网络波动等原因，为保证请求一定送达都会有重试机制，所以考虑到接口的幂等性。</p>
<h3 id="消息事务（最终一致性）"><a href="#消息事务（最终一致性）" class="headerlink" title="消息事务（最终一致性）"></a>消息事务（最终一致性）</h3><p>消息事务其实就是基于消息中间件的两阶段提交，将本地事务和发消息放在同一个事务里，保证本地操作和发送消息同时成功。 下单扣库存原理图：</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/55a8781c22844f1794a3edaadac37765~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li>订单系统向 <code>MQ</code> 发送一条预备扣减库存消息，<code>MQ</code> 保存预备消息并返回成功 <code>ACK</code></li>
<li>接收到预备消息执行成功 <code>ACK</code>，订单系统执行本地下单操作，为防止消息发送成功而本地事务失败，订单系统会实现 <code>MQ</code> 的回调接口，其内不断的检查本地事务是否执行成功，如果失败则 <code>rollback</code> 回滚预备消息；成功则对消息进行最终 <code>commit</code> 提交。</li>
<li>库存系统消费扣减库存消息，执行本地事务，如果扣减失败，消息会重新投，一旦超出重试次数，则本地表持久化失败消息，并启动定时任务做补偿。</li>
</ul>
<p>基于消息中间件的两阶段提交方案，通常用在高并发场景下使用，牺牲数据的强一致性换取性能的大幅提升，不过实现这种方式的成本和复杂度是比较高的，还要看实际业务情况。</p>
<h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p><code>Seata</code> 也是从两段提交演变而来的一种分布式事务解决方案，提供了 <code>AT</code>、<code>TCC</code>、<code>SAGA</code> 和 <code>XA</code> 等事务模式，这里重点介绍 <code>AT</code>模式。</p>
<p>既然 <code>Seata</code> 是两段提交，那我们看看它在每个阶段都做了点啥？下边我们还以下单扣库存、扣余额举例。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/f84a66ad84ea4db0bb3970d4a430a8df~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>先介绍 <code>Seata</code> 分布式事务的几种角色：</p>
<ul>
<li><code>Transaction Coordinator(TC)</code>:  全局事务协调者，用来协调全局事务和各个分支事务（不同服务）的状态， 驱动全局事务和各个分支事务的回滚或提交。</li>
<li><code>Transaction Manager(TM) </code>:  事务管理者，业务层中用来开启/提交/回滚一个整体事务（在调用服务的方法中用注解开启事务）。</li>
<li><code>Resource Manager(RM)</code>:  资源管理者，一般指业务数据库代表了一个分支事务（<code>Branch Transaction</code>），管理分支事务与 <code>TC</code> 进行协调注册分支事务并且汇报分支事务的状态，驱动分支事务的提交或回滚。</li>
</ul>
<blockquote>
<p>Seata 实现分布式事务，设计了一个关键角色 <code>UNDO_LOG</code> （回滚日志记录表），我们在每个应用分布式事务的业务库中创建这张表，这个表的核心作用就是，将业务数据在更新前后的数据镜像组织成回滚日志，备份在 <code>UNDO_LOG</code> 表中，以便业务异常能随时回滚。</p>
</blockquote>
<h3 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h3><p>比如：下边我们更新 <code>user</code> 表的 <code>name</code> 字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;小富最帅&#x27;</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;程序员内点事&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先 Seata 的 <code>JDBC</code> 数据源代理通过对业务 SQL 解析，提取 SQL 的元数据，也就是得到 SQL 的类型（<code>UPDATE</code>），表（<code>user</code>），条件（<code>where name = &#39;程序员内点事&#39;</code>）等相关的信息。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c78f6b5488ac4602acd18e3c9a978d5b~tplv-k3u1fbpfcp-zoom-1.image" alt="第一个阶段的流程图"></p>
<p>先查询数据前镜像，根据解析得到的条件信息，生成查询语句，定位一条数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;程序员内点事&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c195e1ddd8fb4621a9b8ea35077f35ec~tplv-k3u1fbpfcp-zoom-1.image" alt="数据前镜像"></p>
<p>紧接着执行业务 SQL，根据前镜像数据主键查询出后镜像数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1b4c7bad77e9441a89e47f530ef505cb~tplv-k3u1fbpfcp-zoom-1.image" alt="数据后镜像"></p>
<p>把业务数据在更新前后的数据镜像组织成回滚日志，将业务数据的更新和回滚日志在同一个本地事务中提交，分别插入到业务表和 <code>UNDO_LOG</code> 表中。</p>
<p>回滚记录数据格式如下：包括 <code>afterImage</code> 前镜像、<code>beforeImage</code> 后镜像、 <code>branchId</code> 分支事务ID、<code>xid</code> 全局事务ID</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;branchId&quot;</span>:<span class="number">641789253</span>,</span><br><span class="line">    <span class="attr">&quot;xid&quot;</span>:<span class="string">&quot;xid:xxx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;undoItems&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;afterImage&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;rows&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;fields&quot;</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>:<span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>:<span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;tableName&quot;</span>:<span class="string">&quot;product&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;beforeImage&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;rows&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;fields&quot;</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>:<span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>:<span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;tableName&quot;</span>:<span class="string">&quot;product&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;sqlType&quot;</span>:<span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以保证，任何提交的业务数据的更新一定有相应的回滚日志。</p>
<blockquote>
<p>在本地事务提交前，各分支事务需向 <code>全局事务协调者</code> TC 注册分支 ( <code>Branch Id</code>) ，为要修改的记录申请 <strong>全局锁</strong> ，要为这条数据加锁，利用 <code>SELECT FOR UPDATE</code> 语句。而如果一直拿不到锁那就需要回滚本地事务。TM 开启事务后会生成全局唯一的 <code>XID</code>，会在各个调用的服务间进行传递。</p>
</blockquote>
<p>有了这样的机制，本地事务分支（<code>Branch Transaction</code>）便可以在全局事务的第一阶段提交，并马上释放本地事务锁定的资源。相比于传统的 <code>XA</code> 事务在第二阶段释放资源，<code>Seata</code> 降低了锁范围提高效率，即使第二阶段发生异常需要回滚，也可以快速 从<code>UNDO_LOG</code> 表中找到对应回滚数据并反解析成 SQL 来达到回滚补偿。</p>
<p>最后本地事务提交，业务数据的更新和前面生成的 UNDO LOG 数据一并提交，并将本地事务提交的结果上报给全局事务协调者 TC。</p>
<h3 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h3><p>第二阶段是根据各分支的决议做提交或回滚：</p>
<p>如果决议是全局提交，此时各分支事务已提交并成功，这时 <code>全局事务协调者（TC）</code> 会向分支发送第二阶段的请求。收到 TC 的分支提交请求，该请求会被放入一个异步任务队列中，并马上返回提交成功结果给 TC。异步队列中会异步和批量地根据 <code>Branch ID</code> 查找并删除相应 <code>UNDO LOG</code> 回滚记录。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/592fc4836e8a4f9a9c4c1de690ba166d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>如果决议是全局回滚，过程比全局提交麻烦一点，<code>RM</code> 服务方收到 <code>TC</code> 全局协调者发来的回滚请求，通过 <code>XID</code> 和 <code>Branch ID</code> 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。</p>
<blockquote>
<p>注意：这里删除回滚日志记录操作，一定是在本地业务事务执行之后</p>
</blockquote>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1c40b2c8a80b45acae157850f58cac79~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>上边说了几种分布式事务各自的优缺点，下边实践一下分布式事务中间 Seata 感受一下。</p>
<h2 id="Seata-实践"><a href="#Seata-实践" class="headerlink" title="Seata 实践"></a>Seata 实践</h2><p>Seata 是一个需独立部署的中间件，所以先搭 Seata Server，这里以最新的 <code>seata-server-1.4.0</code> 版本为例，下载地址：<code>https://seata.io/en-us/blog/download.html</code></p>
<p>解压后的文件我们只需要关心 <code>\seata\conf</code> 目录下的 <code>file.conf</code> 和  <code>registry.conf</code> 文件。</p>
<h3 id="Seata-Server"><a href="#Seata-Server" class="headerlink" title="Seata Server"></a>Seata Server</h3><h3 id="file-conf"><a href="#file-conf" class="headerlink" title="file.conf"></a>file.conf</h3><p><code>file.conf</code> 文件用于配置持久化事务日志的模式，目前提供 <code>file</code>、<code>db</code>、<code>redis</code> 三种方式。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/136f615cd12e4e21a0c8ac8c41f6f2a2~tplv-k3u1fbpfcp-zoom-1.image" alt="file.conf 文件配置"></p>
<p><strong>注意</strong>：在选择 <code>db</code> 方式后，需要在对应数据库创建 <code>globalTable</code>（持久化全局事务）、<code>branchTable</code>（持久化各提交分支的事务）、 <code>lockTable</code>（持久化各分支锁定资源事务）三张表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="comment">-- 持久化全局事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`xid`</span>                       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>            <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`status`</span>                    <span class="built_in">TINYINT</span>      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`application_id`</span>            <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_name`</span>          <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    <span class="string">`timeout`</span>                   <span class="built_in">INT</span>,</span><br><span class="line">    <span class="string">`begin_time`</span>                <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`application_data`</span>          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>                DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>              DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="comment">-- 持久化各提交分支的事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`branch_id`</span>         <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>               <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>    <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`resource_id`</span>       <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`branch_type`</span>       <span class="built_in">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="string">`status`</span>            <span class="built_in">TINYINT</span>,</span><br><span class="line">    <span class="string">`client_id`</span>         <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    <span class="string">`application_data`</span>  <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>        DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="string">`gmt_modified`</span>      DATETIME(<span class="number">6</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="comment">-- 持久化每个分支锁表事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`row_key`</span>        <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>            <span class="built_in">VARCHAR</span>(<span class="number">96</span>),</span><br><span class="line">    <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>      <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`resource_id`</span>    <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`table_name`</span>     <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`pk`</span>             <span class="built_in">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>     DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>   DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_key`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_branch_id`</span> (<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br></pre></td></tr></table></figure>

<h3 id="registry-conf"><a href="#registry-conf" class="headerlink" title="registry.conf"></a>registry.conf</h3><p><code>registry.conf</code> 文件设置 注册中心 和 配置中心：</p>
<p>目前注册中心支持 <code>nacos</code> 、<code>eureka</code>、<code>redis</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code>、<code>sofa</code> 七种，这里我使用的 <code>eureka</code>作为注册中心 ； 配置中心支持 <code>nacos</code> 、<code>apollo</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code> 五种方式。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/2119d406e05e42268ac3536fa64866dc~tplv-k3u1fbpfcp-zoom-1.image" alt="registry.conf 文件配置"></p>
<p>配置完以后在 <code>\seata\bin</code> 目录下启动 <code>seata-server</code> 即可，到这 <code>Seata</code> 的服务端就搭建好了。</p>
<h3 id="Seata-Client"><a href="#Seata-Client" class="headerlink" title="Seata Client"></a>Seata Client</h3><p><code>Seata Server</code> 环境搭建完，接下来我们新建三个服务 <code>order-server</code>（下单服务）、<code>storage-server</code>（扣减库存服务）、<code>account-server</code>（账户金额服务），分别服务注册到 <code>eureka</code>。</p>
<p>每个服务的大体核心配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">storage-server</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">alibaba:</span></span><br><span class="line">            <span class="attr">seata:</span></span><br><span class="line">                <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://47.93.6.1:3306/seat-storage</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka 注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">serviceUrl:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="number">47.93</span><span class="number">.6</span><span class="number">.5</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>业务大致流程：用户发起下单请求，本地 order 订单服务创建订单记录，并通过 <code>RPC</code> 远程调用 <code>storage</code> 扣减库存服务和 <code>account</code> 扣账户余额服务，只有三个服务同时执行成功，才是一个完整的下单流程。如果某个服执行失败，则其他服务全部回滚。</p>
<p>Seata 对业务代码的侵入性非常小，代码中使用只需用 <code>@GlobalTransactional</code> 注解开启一个全局事务即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@GlobalTransactional(name = &quot;create-order&quot;, rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String xid = RootContext.getXID();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;交易开始&quot;</span>);</span><br><span class="line">    <span class="comment">//本地方法</span></span><br><span class="line">    orderDao.create(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程方法 扣减库存</span></span><br><span class="line">    storageApi.decrease(order.getProductId(), order.getCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程方法 扣减账户余额</span></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;扣减账户开始order中&quot;</span>);</span><br><span class="line">    accountApi.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;扣减账户结束order中&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;交易结束&quot;</span>);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;全局事务 xid： &#123;&#125;&quot;</span>, xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前边说过 Seata AT 模式实现分布式事务，必须在相关的业务库中创建 <code>undo_log</code> 表来存数据回滚日志，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`undo_log`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span>            <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;increment id&#x27;</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>     <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`xid`</span>           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`context`</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    <span class="string">`rollback_info`</span> LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    <span class="string">`log_status`</span>    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    <span class="string">`log_created`</span>   DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    <span class="string">`log_modified`</span>  DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>, <span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> =<span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这环境搭建的工作就完事了，完整案例会在后边贴出 <code>GitHub</code> 地址，就不在这占用篇幅了。</p>
</blockquote>
<h2 id="测试-Seata"><a href="#测试-Seata" class="headerlink" title="测试 Seata"></a>测试 Seata</h2><p>项目中的服务调用过程如下图：</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/40a44673f4c84450b2a29154accf7b1c~tplv-k3u1fbpfcp-zoom-1.image" alt="服务调用过程"></p>
<p>启动各个服务后，我们直接请求下单接口看看效果，只要 <code>order</code> 订单表创建记录成功，<code>storage</code> 库存表 <code>used</code> 字段数量递增、<code>account</code> 余额表 <code>used</code> 字段数量递增则表示下单流程成功。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d091e25fac5346dc92d1875df942e6de~tplv-k3u1fbpfcp-zoom-1.image" alt="原始数据"></p>
<p>请求后正向流程是没问题的，数据和预想的一样</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/9048853aec764d86a116473450270347~tplv-k3u1fbpfcp-zoom-1.image" alt="下单数据"></p>
<p>而且发现 <code>TM</code> 事务管理者 <code>order-server</code> 服务的控制台也打印出了两阶段提交的日志</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d13de839fd2a4db2af5f5e535d13e41a~tplv-k3u1fbpfcp-zoom-1.image" alt="控制台两次提交"></p>
<p>那么再看看如果其中一个服务异常，会不会正常回滚呢？在 <code>account-server</code> 服务中模拟超时异常，看能否实现全局事务回滚。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d5d73832fae544828d2bc33d67cd160b~tplv-k3u1fbpfcp-zoom-1.image" alt="全局事务回滚"></p>
<p>发现数据全没执行成功，说明全局事务回滚也成功了</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7307262d393244f890211618ec315630~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>那看一下 <code>undo_log</code> 回滚记录表的变化情况，由于 <code>Seata</code> 删除回滚日志的速度很快，所以要想在表中看见回滚日志，必须要在某一个服务上打断点才看的更明显。</p>
<p><img src="/2020/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/6b06cf8edcfe4bd997e57206b578a3e0~tplv-k3u1fbpfcp-zoom-1.image" alt="回滚记录"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上边简单介绍了 <code>2PC</code>、<code>3PC</code>、<code>TCC</code>、<code>MQ</code>、<code>Seata</code> 这五种分布式事务解决方案，还详细的实践了 <code>Seata</code> 中间件。但不管我们选哪一种方案，在项目中应用都要谨慎再谨慎，除特定的数据强一致性场景外，能不用尽量就不要用，因为无论它们性能如何优越，一旦项目套上分布式事务，整体效率会几倍的下降，在高并发情况下弊端尤为明显。</p>
<blockquote>
<p>本案例 github 地址：<a target="_blank" rel="noopener" href="https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-seata-transaction">https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-seata-transaction</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
