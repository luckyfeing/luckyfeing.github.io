<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/13/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法（七）之排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-04 10:18:11" itemprop="dateCreated datePublished" datetime="2020-12-04T10:18:11+08:00">2020-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="排序算法时间复杂度对比"><a href="#排序算法时间复杂度对比" class="headerlink" title="排序算法时间复杂度对比"></a>排序算法时间复杂度对比</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2^)</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2^)</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2^)</td>
</tr>
<tr>
<td>希尔排序</td>
<td>性能略优于O(n^2^),但又比不上O(nlog<del>2</del>n)</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog<del>2</del>n)</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog<del>2</del>n)</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog<del>2</del>n)</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n)</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n)</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 更新为最后一次交换元素的位置</span></span><br><span class="line">          lastExchangeIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortBorder = lastExchangeIndex;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    bubbleSort2(array);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>排序过程就像钟摆一样，第1轮从左到右，第2轮从右到左，第3轮再从左到右……</p>
<p>在大部分元素已经有序的情况下能发挥优势，减少排序的回合数；代码量几乎增加了1倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 有元素交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在偶数轮之前，将isSorted重新标记为true</span></span><br><span class="line">      isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 偶数轮，从右向左比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length - i - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">          array[j - <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一轮：从左到右，先从2开始比较，找到最大值</span></span><br><span class="line">    <span class="comment">//第二轮：从右到左，从8开始比较，找到最小值</span></span><br><span class="line">    <span class="comment">//之后轮询继续比较</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">算法（六）之二叉堆实现优先级队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-03 20:10:44" itemprop="dateCreated datePublished" datetime="2020-12-03T20:10:44+08:00">2020-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的特点是先进先出（FIFO）。 </p>
<ul>
<li>入队列，将新元素置于队尾。</li>
<li>出队列，队头元素最先被移出。</li>
</ul>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列不再遵循先入先出的原则，而是分为两种情况。</p>
<ul>
<li>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 </li>
<li>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队 </li>
</ul>
<h2 id="优先队列实现"><a href="#优先队列实现" class="headerlink" title="优先队列实现"></a>优先队列实现</h2><p>利用线性数据结构并非不能实现，但是时间复杂度较高。因此可以利用二叉堆的特性来实现优先队列。最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。</p>
<p><strong>二叉堆的特性</strong>：</p>
<ul>
<li><p>最大堆的堆顶是整个堆中的最大元素。 </p>
</li>
<li><p>最小堆的堆顶是整个堆中的最小元素。 </p>
</li>
</ul>
<p><strong>二叉堆的时间复杂度</strong>：</p>
<p>插入和删除操作都是O(logn)，构建二叉堆的时间复杂度为O(n)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列初始长度为</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队 * <span class="doctag">@param</span> key 入队元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列长度超出范围，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= array.length) &#123;</span><br><span class="line">      resize();</span><br><span class="line">    &#125;</span><br><span class="line">    array[size++] = key;</span><br><span class="line">    upAdjust();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;the queue is empty !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取堆顶元素</span></span><br><span class="line">    <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 让最后一个元素移动到堆顶</span></span><br><span class="line">    array[<span class="number">0</span>] = array[--size];</span><br><span class="line">    downAdjust();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “上浮”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex]) &#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childIndex] = array[parentIndex];</span><br><span class="line">      childIndex = parentIndex;</span><br><span class="line">      parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “下沉”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp 保存父节点的值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">        childIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点大于任何一个孩子的值，直接跳出</span></span><br><span class="line">      <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childIndex];</span><br><span class="line">      parentIndex = childIndex;</span><br><span class="line">      childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 队列扩容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列容量翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">    priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/" class="post-title-link" itemprop="url">算法（五）之二叉堆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-03 09:52:39" itemprop="dateCreated datePublished" datetime="2020-12-03T09:52:39+08:00">2020-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆本质上是一种完全二叉树，它分为两个类型。 </p>
<ol>
<li><p>最大堆。 最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值</p>
</li>
<li><p>最小堆。最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p>
<img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200307460.png" alt="image-20201203200307460" style="zoom:80%;">

</li>
</ol>
<p>二叉堆的根节点叫作<strong>堆顶</strong>。最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>插入节点：单一节点上浮，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li>
<li>删除节点：单一节点下沉，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li>
<li>构建二叉堆：要所有非叶子节点依次“下沉”，时间复杂度是O(n)</li>
</ul>
<p><strong>时间复杂度推导</strong></p>
<p>n为节点数，level为层级</p>
<ul>
<li>插入和删除：f(n) = level-1; n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=log<del>2</del>(n+1)-1，所以时间复杂度为O(log<del>2</del>n)</li>
<li>构建二叉堆：满二叉树堆则f(n) = 2^level-1^；n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=2^log(n+1)^-2=n-1,所以为O(n)</li>
</ul>
<h2 id="自我调整"><a href="#自我调整" class="headerlink" title="自我调整"></a>自我调整</h2><p>这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。</p>
<ol>
<li>插入节点 </li>
</ol>
<p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是 0。这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节点“上浮”，和父节点交换位置。继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。继续比较，最终新节点0“上浮”到了堆顶位置。<br><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203105517492.png" alt="image-20201203105517492"></p>
<ol start="2">
<li>删除节点 </li>
</ol>
<p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点。例如删除最小堆的堆顶节点1。这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到原本堆顶的位置。接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果左、右孩子节点中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。</p>
<img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203194844232.png" alt="image-20201203194844232">

<ol start="3">
<li>构建二叉堆</li>
</ol>
<p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，**<font color="red">本质就是让所有 非叶子节点依次“下沉”</font>**。</p>
<p>如下图的无序完全二叉树，找到第一个非叶子节点即10，与其子节点比较，节点6与节点10交互位置。数组方式存储，则下一个节点为节点3，与其子节点比较，节点3与节点2交互位置。下一个节点为1，与字节点比较，不用交换位置。最后一个节点为7，与其子节点比较，节点7下沉，与节点1交互位置，继续与子节点比较，子节点为6和5，最后于5节点交换位置。</p>
<img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200122412.png" alt="image-20201203200122412" style="zoom:80%;">

<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childrenIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&gt;<span class="number">0</span> &amp;&amp; temp&lt;array[parentIndex])&#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childrenIndex] = array[parentIndex];</span><br><span class="line">      childrenIndex = parentIndex;</span><br><span class="line">      parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childrenIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> array  待调整的堆</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parentIndex  要“下沉”的父节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> parentIndex,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&lt;length)&#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span>(childrenIndex+<span class="number">1</span>&lt;length &amp;&amp; array[childrenIndex+<span class="number">1</span>]&lt;array[childrenIndex])&#123;</span><br><span class="line">        childrenIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">      <span class="keyword">if</span>(temp&lt;array[childrenIndex])&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childrenIndex];</span><br><span class="line">      parentIndex = childrenIndex;</span><br><span class="line">      childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeapTree</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">      downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    upAdjust(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    buildHeapTree(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除是用最后一个节点值替换要删除的节点，之后再下沉自我调整</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    downAdjust(array,<span class="number">1</span>,array.length);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉堆的使用场景"><a href="#二叉堆的使用场景" class="headerlink" title="二叉堆的使用场景"></a>二叉堆的使用场景</h2><p>二叉堆是实现<strong>堆排序</strong>及<strong>优先队列</strong>的基础</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">算法（四）之树及二叉树和遍历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-01 13:43:57" itemprop="dateCreated datePublished" datetime="2020-12-01T13:43:57+08:00">2020-12-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="树概念"><a href="#树概念" class="headerlink" title="树概念"></a>树概念</h2><p>树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。 </p>
<ol>
<li>有且仅有一个特定的称为根的节点。</li>
<li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 <img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134605336.png" alt="image-20201201134605336" style="zoom: 33%;">

</li>
</ol>
<p>在上图中，节点1是根节点（root）；节点5、6、7、8是树的末端，没有“孩子”，被称为叶子节点（leaf）。图中的虚线部分，是根节点1的其中一个子树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134818417.png" alt="image-20201201134818417" style="zoom: 33%;"></p>
<p>树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如下。</p>
<p>在上图中，节点4的上一级节点，是节点4的<strong>父节点（parent）</strong>；从节点4衍生出来的节点，是节点4的<strong>孩子节点（child）</strong>；和节点4同级，由同一个父节点衍生出来的节点，是节点4的<strong>兄弟节点（sibling）</strong></p>
<p>树的最大层级数，被称为树的高度或深度。显然，上图这个树的高度是4。</p>
<h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135228229.png" alt="image-20201201135228229" style="zoom: 33%;"><br>二叉树节点的两个孩子节点，一个被称为<strong>左孩子（left child）</strong>，一个被称为<strong>右孩子（right child）</strong>。这两个孩子节点的顺序是固定的，就像人的左手就是左手，右手就是右手，不能够颠倒或混淆。</p>
<p>二叉树还有两种特殊形式，一个叫作<strong>满二叉树</strong>，另一个叫作<strong>完全二叉树</strong></p>
<h3 id="什么是满二叉树"><a href="#什么是满二叉树" class="headerlink" title="什么是满二叉树"></a>什么是满二叉树</h3><p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。简单点说，满二叉树的每一个分支都是满的。一棵深度为k且有2^K^-1个节点的二叉树称为满二叉树。满二叉树每一层的结点个数都达到了最大值, 即满二叉树的第i层上有2^i-1^个节点（i&gt;=1）<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135513962.png" alt="image-20201201135513962" style="zoom:33%;"></p>
<h3 id="什么是完全二叉树"><a href="#什么是完全二叉树" class="headerlink" title="什么是完全二叉树"></a>什么是完全二叉树</h3><p>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135646991.png" alt="image-20201201135646991" style="zoom:33%;"><br>在上图中，二叉树编号从1到12的12个节点，和前面满二叉树编号从1到12的节点位置完全对应。因此这个树是完全二叉树。<br>完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树</p>
<h3 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h3><p>链式存储结构。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140333971.png" alt="image-20201201140333971" style="zoom:25%;"></p>
<ul>
<li>存储数据的data变量 </li>
<li>指向左孩子的left指针 </li>
<li>指向右孩子的right指针</li>
</ul>
<p>数组。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140524048.png" alt="image-20201201140524048" style="zoom:25%;"><br>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p>
<p><strong>为什么这样设计</strong><br>因为这样可以更方便地在数组中定位二叉树的孩子节点和 父节点。</p>
<p>假设一个父节点的下标是parent，那么它的左孩子节点下标就是2×parent +1；右孩子节点下标就是2×parent + 2。<br>反过来，假设一个左孩子节点的下标是leftChild，那么它的父节点下标就是（leftChild-1）/ 2。<br>假如节点4在数组中的下标是3，节点4是节点2的左孩子，节点2的下标可以直接<br>通过计算得出。节点2的下标 = (3-1)/2 = 1 </p>
<p>显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p>
<p><strong>什么样的二叉树最适合用数组表示呢？</strong></p>
<p>一种特殊的完全二叉树，就是用数组来存储的。</p>
<h3 id="二叉树应用"><a href="#二叉树应用" class="headerlink" title="二叉树应用"></a>二叉树应用</h3><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行<strong>查找操作和维持相对顺序</strong>这两个方面。 </p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>二叉树的树形结构使它很适合扮演索引的角色。 <strong>二叉查找树（binary search tree）</strong>主要作用就是进行查找操作</p>
<p><strong>二叉查找树</strong><br>二叉查找树在二叉树的基础上增加了以下几个条件。 <font color="red"><strong>为了查找方便</strong></font>。</p>
<ul>
<li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值 </li>
<li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值 </li>
<li>左、右子树也都是二叉查找树<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141125488.png" alt="image-20201201141125488" style="zoom:25%;">
对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度是一样的。这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。 
#### **维持相对顺序**
二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。因此二叉查找树还有另一个名字——二叉排序树（binary sort tree）。 

</li>
</ul>
<h4 id="二叉查找树（二叉排序树）的问题"><a href="#二叉查找树（二叉排序树）的问题" class="headerlink" title="二叉查找树（二叉排序树）的问题"></a>二叉查找树（二叉排序树）的问题</h4><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141637961.png" alt="image-20201201141637961" style="zoom:25%;">
在根节点为10的节点情况下，插入9、8、7节点时，会出现如图的情况。查询节点的时间复杂度退化成O(n)。

<h4 id="二叉树自平衡"><a href="#二叉树自平衡" class="headerlink" title="二叉树自平衡"></a>二叉树自平衡</h4><p>二叉树自平衡的方式有多种，如红黑树、AVL树、树堆等</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>从节点之间位置关系的角度来看，二叉树的遍历分为4种</p>
<ul>
<li><p><strong>前序遍历</strong>：输出顺序是根节点、左子树、右子树。</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200256982.png" alt="image-20201201200256982" style="zoom:25%;">
</li>
<li><p><strong>中序遍历</strong>：输出顺序是左子树、根节点、右子树</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200341762.png" alt="image-20201201200341762" style="zoom:25%;">
</li>
<li><p><strong>后序遍历</strong>：输出顺序是左子树、右子树、根节点</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200417902.png" alt="image-20201201200417902" style="zoom:25%;">
</li>
<li><p>层序遍历。层级输出</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201202112654756.png" alt="image-20201202112654756" style="zoom:25%;">

</li>
</ul>
<p>从更宏观的角度来看，二叉树的遍历归结为两大类。</p>
<ul>
<li><p>深度优先遍历（前序遍历、中序遍历、后序遍历）。 所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。</p>
</li>
<li><p>广度优先遍历（层序遍历）。就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点 。</p>
<p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。 </p>
</li>
</ul>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(LinkedList list)</span> </span>&#123;</span><br><span class="line">    TreeNode treeNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(list) || list.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object o = list.removeFirst();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(o)) &#123;</span><br><span class="line">      treeNode = <span class="keyword">new</span> TreeNode();</span><br><span class="line">      treeNode.date = o;</span><br><span class="line">      treeNode.leftNode = createTree(list);</span><br><span class="line">      treeNode.rightNode = createTree(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeachWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode treeNode = root;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (treeNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        stack.push(treeNode.leftNode);</span><br><span class="line">        treeNode = treeNode.leftNode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop != <span class="keyword">null</span>) &#123;</span><br><span class="line">          treeNode = pop.rightNode;</span><br><span class="line">          stack.push(treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    Object date;</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList list = <span class="keyword">new</span> LinkedList(Arrays</span><br><span class="line">        .asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">7</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">10</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="number">4</span>&#125;));</span><br><span class="line">    TreeNode treeNode = createTree(list);</span><br><span class="line">    preOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    preOrderForeachWithStack(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    inOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    postOrderForeach(treeNode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderForeach</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">    TreeNode treeNode = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(treeNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.print(treeNode.date+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(treeNode.leftNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.leftNode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(treeNode.rightNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.rightNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">算法之数据结构线性结构和非线性结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-01 13:27:08" itemprop="dateCreated datePublished" datetime="2020-12-01T13:27:08+08:00">2020-12-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mr-wuxiansheng/">Mr_伍先生</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html">https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html</a></p>
<h2 id="线性结构："><a href="#线性结构：" class="headerlink" title="线性结构："></a>线性结构：</h2><p>一、概念</p>
<ol>
<li><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</p>
</li>
<li><p>线性结构拥有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</p>
</li>
<li><p>线性结构中存在两种操作受限的使用场景，即队列和栈。栈的操作只能在线性表的一端进行，就是我们常说的先进后出（FILO），队列的插入操作在线性表的一端进行而其他操作在线性表的另一端进行，先进先出（FIFO），由于线性结构存在两种存储结构，因 此队列和栈各存在两个实现方式。</p>
</li>
</ol>
<p>二、部分实现</p>
<ol>
<li><p>顺序表（顺序存储）</p>
<p>　　按照我们的习惯，存放东西时，一般是找一块空间，然后将需要存放的东西依次摆放，这就是顺序存储。计算机中的顺序存储是指在内存中用一块地址连续的空间依次存放数据元素，用这种方式存储的线性表叫顺序表其特点是表中相邻的数据元素在内存中存储位置也相邻，如下图：</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809140928262-492338500.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置线性表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     T tmp = <span class="keyword">default</span>(T);</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> len = GetLength() - <span class="number">1</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (i.Equals(len - i))</span><br><span class="line"><span class="number">10</span>         &#123;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>         tmp = data[i];</span><br><span class="line"><span class="number">15</span>         data[i] = data[len - i];</span><br><span class="line"><span class="number">16</span>         data[len - i] = tmp;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表（链式存储）</p>
<p>　　假如我们现在要存放一些物品，但是没有足够大的空间将所有的物品一次性放下（电脑中使用链式存储不是因为内存不够先事先说明一下…，具体原因后续会说到），同时设定我们因为脑容量很小，为了节省空间，只能记住一件物品位置。此时我们很机智的找到了解决方案：存放物品时每放置一件物品就在物品上贴一个小纸条，标明下一件物品放在那里，只记住第一件物品的位置，寻找的时候从第一件物品开始寻找，通过小纸条我们可以找到所有的物品，这就是链式存储。链表实现的时候不再像线性表一样只存储数据即可，还有下一个数据元素的地址，因此先定义一个节点类(Node)，记录物品信息和下一件物品的位置，我们把物品本身叫做数据域，存储下一件物品地址信息的小纸条称为引用域。链表结构示意图如下：</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809143506652-1333091670.png" alt="img"></p>
<p>　　寻找物品的时候发现了一个问题，我们从一件物品找下一件物品的时候很容易，但是如果要找上一件物品就得从头开始找，真的很麻烦。为了解决这个问题我们又机智了一把，模仿之前的做法，在存放物品的时候多放置一个小纸条记录上一件物品的位置，这样就可以很快的找到上一件物品了。我们把这种方式我们称为双向链表，前面只放置一张小纸条的方式称为单向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置单链表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; oldHead = Head;</span><br><span class="line"> <span class="number">5</span>     Node&lt;T&gt; tmp ;</span><br><span class="line"> <span class="number">6</span>     Head = <span class="keyword">null</span>;    <span class="comment">//清空链表，解除Head跟oldHead之间的相同引用</span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="keyword">while</span> (oldHead != <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">9</span>     &#123;</span><br><span class="line"><span class="number">10</span>         tmp = Head;</span><br><span class="line"><span class="number">11</span>         Head = oldHead;</span><br><span class="line"><span class="number">12</span>         <span class="comment">//解除Head跟oldHead之间的相同引用</span></span><br><span class="line"><span class="number">13</span>         oldHead = oldHead.Next;</span><br><span class="line"><span class="number">14</span>         Head.Next = tmp;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure>

<p>　　由于数据存储结构不同导致使用场景上的巨大差异，顺序表由于元素连续具有随机存储的特点，所以查找数据很方便效率很高，但是插入、删除操作为了确保数据元素连续，需要移动大量的数据导致效率很低。而链表由于存储空间不要求连续，插入、删除只需修改相邻元素的引用域地址即可，所以效率很高，但查询需要从头引用开始遍历链表，效率很低。因此，如果只是进行查找操作而不经常插入、删除线性表中的数据元素，则使用顺序存储结构，反之，使用链式存储结构。</p>
</li>
<li><p>栈</p>
<p>　　其实成功完成顺序表和链表之后，栈已经没太多可说的了，主要是逻辑上的不同，毕竟栈也是一种特殊的线性结构。栈是一种操作限定在表尾部进行的线性表，表尾称为栈顶（Top），另一端固定不动，称为栈底（Bottom）。进栈、出栈示意图如下：</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809151153090-1514548602.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链栈入驻</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; tmp = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Top == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Top = tmp;</span><br><span class="line"> <span class="number">8</span>     &#125;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>     &#123;</span><br><span class="line"><span class="number">11</span>         tmp.Next = Top;</span><br><span class="line"><span class="number">12</span>         Top = tmp;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     Num++;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">//顺序栈入栈</span></span><br><span class="line"><span class="number">18</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">19 </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">21</span>     &#123;</span><br><span class="line"><span class="number">22</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"><span class="number">25</span>     data[++Top] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列</p>
<p>　　队列与栈类似，仅仅是逻辑有一丢丢不同。队列是一种插入操作限定在表尾其他操作限定在表头的线性表。把进行插入操作的表尾称为队尾（Rear）,把进行其它操作的头部称为队首（Front）。入队、出队示意图如下：</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809152906777-1048463470.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链队入队</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Rear == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Rear = node;</span><br><span class="line"> <span class="number">8</span>         Front = Rear;</span><br><span class="line"> <span class="number">9</span>     &#125;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">11</span>     &#123;</span><br><span class="line"><span class="number">12</span>         Rear.Next = node;</span><br><span class="line"><span class="number">13</span>         Rear = Rear.Next;</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     ++num;</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span> <span class="comment">//循环队列入队</span></span><br><span class="line"><span class="number">19</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">20 </span>&#123;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">22</span>     &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span>     data[++Rear] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="非线性结构："><a href="#非线性结构：" class="headerlink" title="非线性结构："></a>非线性结构：</h2><h3 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a><strong>一、相关概念</strong></h3><p>　　树作为一种应用广泛的一对多非线性数据结构，不仅有数据间的指向关系，还有层级关系，示例见图一。因树的结构比较复杂，为了简化操作及存储，我们一般将树转换为二叉树处理，因此本文主要讨论二叉树。</p>
<ol>
<li><p><strong>二叉树</strong><br>　　二叉树是每个节点最多拥有两个子节点的树结构，若移除根节点则其余节点会被分成两个互不相交的子树，分别称为左子树和右子树。二叉树是有序树，左右子树有严格的次序，若颠倒则成为一棵不一样的二叉树。</p>
</li>
<li><p><strong>满二叉树</strong>　　</p>
<p>​       满二叉树，顾名思义除叶子节点外所有节点都拥有两个孩子，且叶子节点在同一层的二叉树，示例见图二。</p>
</li>
<li><p><strong>完全二叉树</strong>　　</p>
<p>​        完全二叉树，移除最后一层节点后是满二叉树，且最后一层的节点都连续集中在最左面，示例见图三。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812141855625-736751376.png" alt="img"></p>
</li>
</ol>
<h3 id="二、二叉树存储结构"><a href="#二、二叉树存储结构" class="headerlink" title="二、二叉树存储结构"></a>二、二叉树存储结构</h3><ol>
<li><p><strong>顺序存储</strong>　　</p>
<p>​        根据完全二叉树的特性，可以计算出任意节点n的双亲节点及左右孩子节点的序号，因此完全二叉树的节点可以按照从上到下从左到右的顺序依次存储到一维数组中。非完全二叉树存储时应先将其改造为完全二叉树，以空替代不存在的节点，比较浪费存储空间，存储示意图见图四。</p>
</li>
<li><p><strong>链式存储</strong></p>
<p>　　树结构链式存储类似线性结构链式存储，先定义包含数据域和引用域的节点(Node)，然后通过引用域存储节点之间的关系。根据二叉树的结构来看，节点Node至少包含数据域(Data)，引用域(左孩子LChild、右孩子RChild)，为了方便通过孩子节点查找父节点，引用域中可以考虑添加父节点引用(Parent)，存储示意图见图五。</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812161601265-1301764954.png" alt="img"> </p>
</li>
</ol>
<h3 id="三、树与二叉树的转换"><a href="#三、树与二叉树的转换" class="headerlink" title="三、树与二叉树的转换"></a>三、树与二叉树的转换</h3><ol>
<li><p>树转二叉树</p>
<p><strong>加线</strong>，所有兄弟结点之间加一条连线。<br><strong>抹线</strong>，对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812155626000-1300189010.png" alt="img"></p>
</li>
<li><p>二叉树转树</p>
<p><strong>加线</strong>，若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来。<br><strong>抹线</strong>，删除原二叉树中所有结点与其右孩子结点的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812160125515-698914833.png" alt="img"></p>
</li>
</ol>
<h3 id="四、树遍历实现"><a href="#四、树遍历实现" class="headerlink" title="四、树遍历实现"></a>四、树遍历实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"> <span class="number">2</span> <span class="comment">/// 先序遍历（DLR）</span></span><br><span class="line"> <span class="number">3</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"> <span class="number">4</span> <span class="comment">/// &lt;![CDATA[首先访问跟节点，然后遍历左子树，最后右子树]]&gt;</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function"> 6 </span>&#123;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     Print(root);</span><br><span class="line"><span class="number">13</span>     PreOrder(root.LChild);</span><br><span class="line"><span class="number">14</span>     PreOrder(root.RChild);</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/// 中序遍历（LDR）</span></span><br><span class="line"><span class="number">19</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">20</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后根节点，最后遍历右子树]]&gt;</span></span><br><span class="line"><span class="number">21</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">22 </span>&#123;</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">24</span>     &#123;</span><br><span class="line"><span class="number">25</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     InOrder(root.LChild);</span><br><span class="line"><span class="number">29</span>     Print(root);</span><br><span class="line"><span class="number">30</span>     InOrder(root.RChild);</span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">34</span> <span class="comment">/// 后序遍历（LRD）</span></span><br><span class="line"><span class="number">35</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">36</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后遍历右子树，最后遍历根节点]]&gt;</span></span><br><span class="line"><span class="number">37</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">38 </span>&#123;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">40</span>     &#123;</span><br><span class="line"><span class="number">41</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">42</span>     &#125;</span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>     PostOrder(root.LChild);</span><br><span class="line"><span class="number">45</span>     PostOrder(root.RChild);</span><br><span class="line"><span class="number">46</span>     Print(root);</span><br><span class="line"><span class="number">47</span> &#125;</span><br><span class="line"><span class="number">48</span> </span><br><span class="line"><span class="number">49</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">50</span> <span class="comment">/// 层序遍历</span></span><br><span class="line"><span class="number">51</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">52</span> <span class="comment">/// &lt;![CDATA[从上向下从左到右]]&gt;</span></span><br><span class="line"><span class="number">53</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">54 </span>&#123;</span><br><span class="line"><span class="number">55</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">56</span>     &#123;</span><br><span class="line"><span class="number">57</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">58</span>     &#125;</span><br><span class="line"><span class="number">59</span>     CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt; sq = <span class="keyword">new</span> CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt;(<span class="number">50</span>);</span><br><span class="line"><span class="number">60</span>     sq.In(root);</span><br><span class="line"><span class="number">61</span>     <span class="keyword">while</span> (!sq.IsEmpty())</span><br><span class="line"><span class="number">62</span>     &#123;</span><br><span class="line"><span class="number">63</span>         Node&lt;<span class="keyword">char</span>&gt; tmp = sq.Out();</span><br><span class="line"><span class="number">64</span>         Print(tmp);</span><br><span class="line"><span class="number">65</span> </span><br><span class="line"><span class="number">66</span>         <span class="keyword">if</span> (tmp.LChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">67</span>         &#123;</span><br><span class="line"><span class="number">68</span>             sq.In(tmp.LChild);</span><br><span class="line"><span class="number">69</span>         &#125;</span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">71</span>         <span class="keyword">if</span> (tmp.RChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">72</span>         &#123;</span><br><span class="line"><span class="number">73</span>             sq.In(tmp.RChild);</span><br><span class="line"><span class="number">74</span>         &#125;</span><br><span class="line"><span class="number">75</span>     &#125;</span><br><span class="line"><span class="number">76</span> &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">java线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 18:15:44" itemprop="dateCreated datePublished" datetime="2020-11-30T18:15:44+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程池关键类"><a href="#线程池关键类" class="headerlink" title="线程池关键类"></a>线程池关键类</h2><ul>
<li>Executors 线程池工具类</li>
<li>ExecutorService接口<ul>
<li>ThreadPoolExecutor实现类</li>
<li>ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService</li>
<li>ForkJoinPool</li>
</ul>
</li>
<li>RejectedExecutionHandler 拒绝执行处理器接口<ul>
<li>AbortPolicy 抛出RejectedExecutionException异常，默认策略</li>
<li>DiscardPolicy 忽略新任务</li>
<li>DiscardOldestPolicy 丢弃最旧的任务，执行新的任务</li>
<li>CallerRunsPolicy 由调用线程处理该任务</li>
</ul>
</li>
</ul>
<h2 id="新建线程池参数"><a href="#新建线程池参数" class="headerlink" title="新建线程池参数"></a>新建线程池参数</h2><ul>
<li>核心线程数corePoolSize</li>
<li>最大线程数maximumPoolSize</li>
<li>存活时间keepAliveTime</li>
<li>时间单位TimeUnit unit</li>
<li>堵塞队列BlockingQueue<Runnable> workQueue</Runnable></li>
<li>线程工厂ThreadFactory threadFactory</li>
<li>拒绝策略RejectedExecutionHandler handler</li>
</ul>
<h2 id="线程池内部实现"><a href="#线程池内部实现" class="headerlink" title="线程池内部实现"></a>线程池内部实现</h2><ul>
<li>Worker工作线程，使用的是HashSet保存，Worker继承了AbstractQueuedSynchronizer实现了Runnable,具有final Thread全局变量，初始化Worker时，会传入第一个任务，并初始化线程，Thread中的Runnable对象为Worker类自己。</li>
<li>工作队列BlockingQueue<Runnable> workQueue，堵塞队列。</Runnable></li>
<li>使用ReentrantLock获取锁之后，创建工作线程，保存到HashSet中，启动使用woker.thread.start()，最终还是使用的Worker类中的Run方法；运行时，死循环执行，获取任务（从BlockQueue中获取任务,task是Runnable对象），worker加锁，task.run()。</li>
</ul>
<h2 id="线程池工具类创建线程问题"><a href="#线程池工具类创建线程问题" class="headerlink" title="线程池工具类创建线程问题"></a>线程池工具类创建线程问题</h2><p>Executors返回的线程池对象弊端如下：</p>
<ol>
<li>FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。使用的队列为LinkedBlockingQueue，队列最大长度为Integer.MAX_VALUE</li>
<li>CacheThreadPool和ScheduledThreadPool：允许创建线程数量最大为Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM。分别使用的队列为<font color="red">SynchronousQueue</font>和<font color="red">DelayedWorkQueue</font></li>
</ol>
<h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><p>线程数固定的线程池,使用的是ThreadPoolExecutor，核心线程数和最大线程数一致，</p>
<h2 id="SingleThreadPool"><a href="#SingleThreadPool" class="headerlink" title="SingleThreadPool"></a>SingleThreadPool</h2><p>仅单线程执行的线程池，使用ThreadPoolExecutor，使用FinalizableDelegatedExecutorService委托类，finalize方法调用shutdown方法，保底</p>
<h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><p>线程数根据任务动态调整的线程池</p>
<h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行: FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行: 上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<ul>
<li>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</li>
<li>如果任务抛出了异常，后续任务是否继续执行？</li>
</ul>
<p>Java标准库还提供了一个<code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code>Timer</code>会对应一个<code>Thread</code>，所以，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用<code>ScheduledThreadPool</code>取代旧的<code>Timer</code>。</p>
<h2 id="线程池线程数量"><a href="#线程池线程数量" class="headerlink" title="线程池线程数量"></a>线程池线程数量</h2><ul>
<li>如果是CPU密集型应用，则线程池大小设置为N+1，所谓CPU密集型就是指系统大部分时间是在做程序正常的计算任务，例如数字运算、赋值、分配内存、内存拷贝、循环、查找、排序等，这些处理都需要CPU来完成</li>
<li>如果是IO密集型应用，则线程池大小设置为2N+1，是指系统大部分时间在跟I/O交互，而这个时间线程不会占用CPU来处理，即在这个时间范围内，可以由其他线程来使用CPU，因而可以多配置一些线程</li>
<li>最佳线程数 = CPU数量 * CPU利用率 *（线程等待时间/线程CPU时间 + 1）</li>
<li>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</li>
</ul>
<h2 id="线程大小总结"><a href="#线程大小总结" class="headerlink" title="线程大小总结"></a>线程大小总结</h2><p>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程</p>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>当新提交一个任务时：</p>
<ol>
<li>如果poolSize&lt;corePoolSize，新增加一个线程处理新的任务。</li>
<li>如果poolSize=corePoolSize，新任务会被放入阻塞队列等待。</li>
<li>如果阻塞队列的容量达到上限，且这时poolSize&lt;maximumPoolSize，新增线程来处理任务。</li>
<li>如果阻塞队列满了，且poolSize=maximumPoolSize，那么线程池已经达到极限，会根据饱和策略RejectedExecutionHandler拒绝新的任务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程池中加锁：addWorker（）新增工作线程加锁mainLock.lock()，工作线程存放在HashSet中，为非线程安全集合，</span><br><span class="line">			  执行工作线程中的t.start()方法，及执行新线程，调用Worker类中的run方法，调用runWorker方法，循环获取任务</span><br><span class="line">			  w.lock(); 加锁，不可重入锁，Worker实现AbstractQueuedSynchronizer重写方法，执行线程task.run（）方法</span><br><span class="line">线程池中工作线程为什么使用非重入锁</span><br><span class="line">			线程池执行shutdown（）和shutdownNow（）方法时会设置线程池状态为shutdown或stop ，工作线程获取锁成功，中断执行线程，设置状态为TIDYING</span><br><span class="line">			</span><br><span class="line">shutdownNow（） 会返回队列中未执行完的任务</span><br><span class="line">shutdown（）    不接收新任务，但能处理已添加的任务,中断工作线程，但是工作线程并没有退出</span><br><span class="line">shutdownNow（） 不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</span><br></pre></td></tr></table></figure>

<h2 id="线程池生命周期"><a href="#线程池生命周期" class="headerlink" title="线程池生命周期"></a>线程池生命周期</h2><p>线程池状态：Running、ShutDown、Stop、Tidying、Terminated</p>
<p>running  -》  shutdown（）  -》 shutdown   队列为空，且线程池执行的任务为空<br>tidying   -》  terminated（） 执行完毕   terminated<br>running  -》 shutdownNow（） -》 stop       线程池执行的任务为空 tidying  terminated（） 执行完毕   terminated</p>
<h2 id="并发线程池"><a href="#并发线程池" class="headerlink" title="并发线程池"></a>并发线程池</h2><p>ForkJoinPool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ForkJoin设计：并发处理框架，将大任务拆分为小任务，之后将结果聚合起来得到结果</span><br><span class="line">ForkJoin框架使用了工作窃取的思想（work-stealing），算法从其他队列中窃取任务来执行</span><br><span class="line">	ForkJoinPool 分割的子任务也会添加到当前工作线程的双端队列中，进入队列的头部。当一个工作线程中没有任务时，会从其他工作线程的队列尾部获取一个任务</span><br><span class="line">	ForkJoinTask 创建一个ForkJoin任务。它提供在任务中执行fork()和join的操作机制，通常我们不直接继承ForkjoinTask类，只需要直接继承其子类</span><br><span class="line">			1. RecursiveAction，用于没有返回结果的任务</span><br><span class="line">			2. RecursiveTask，用于有返回值的任务</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/566591/blog/1791994">https://my.oschina.net/u/566591/blog/1791994</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">java并发集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 18:15:10" itemprop="dateCreated datePublished" datetime="2020-11-30T18:15:10+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h2><p><code>implements ConcurrentMap</code>实现了<code>ConcurrentMap</code>，需要重新定义集合的并发操作。数据结构及逻辑与<code>HashMap</code>类似，增加了<code>CAS</code>和<code>synchronized</code>保证数据一致，线程安全。</p>
<h2 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a><code>ConcurrentLinkedDeque</code></h2><p>双向链表实现双端并发队列，使用<code>CAS</code>保证线程安全。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a><code>ConcurrentLinkedQueue</code></h2><p>单链表实现并发队列，使用<code>CAS</code>保证线程安全。</p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a><code>ConcurrentSkipListMap</code></h2><p><code>implements ConcurrentNavigableMap</code>实现了<code>ConcurrentNavigableMap</code>，定义了并发可导航访问的Map，如获取<code>headMap</code>。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunxianghuang/article/details/52221913">跳表（SkipList）及ConcurrentSkipListMap源码解析</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head; <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">    HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">        <span class="keyword">super</span>(node, down, right);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">    <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> Object value;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a><code>ConcurrentSkipListSet</code></h2><p><code>implements NavigableSet</code>，内部实现是使用<code>ConcurrentSkipListMap</code>，value为<code>Boolean.TRUE</code></p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h2><p>使用<code>ReentrantLock</code>实现写入时加锁，复制新的数组，写入到数组之后，替换掉以前的数组。读取时，使用原数组。</p>
<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a><code>CopyOnWriteArraySet</code></h2><p>内部使用<code>CopyOnWriteArrayList</code>，使用<code>addIfAbsent</code>方法，先判断是否存在，不存在则添加。使用<code>ReentrantLock</code>加锁，保证线程安全。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/java%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">java集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 18:12:46" itemprop="dateCreated datePublished" datetime="2020-11-30T18:12:46+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>​    开辟连续内存地址空间，数组长度固定，不能进行扩容，顺序存储。</p>
<hr>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h2><p>​    list集合可以使用数组或链表存储数据。</p>
<ul>
<li><p><code>ArrayList</code>使用数组进行存储。查找、更新效率高，插入、删除效率低，顺序存储，扩容为旧数组</p>
</li>
<li><p><code>LinkedList</code> 使用双向链表进行存储。查找、更新效率低，插入、删除效率高，随机存储，不需要考虑扩容。<font color="red">使用二分查找法</font></p>
</li>
<li><p><code>Vector</code> 使用数组进行存储，使用synchronized保证线程安全</p>
</li>
</ul>
<hr>
<h2 id="Map哈希表"><a href="#Map哈希表" class="headerlink" title="Map哈希表"></a><strong>Map哈希表</strong></h2><h3 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a><code>HashMap详解</code></h3><p>1.7中使用数组+单链表 ，1.8使用数组+单链表/红黑树(提升插入和查找的效率)，原容量的二倍扩容<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611175546307.png" alt="image-20210611175546307" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_INITIAL_CAPACITY <span class="comment">//初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</span></span><br><span class="line">MAXIMUM_CAPACITY <span class="comment">//哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</span></span><br><span class="line">DEFAULT_LOAD_FACTOR <span class="comment">//默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。存值之后扩容</span></span><br><span class="line">TREEIFY_THRESHOLD <span class="comment">//如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于等于 8 时，有可能会转化成树。</span></span><br><span class="line">UNTREEIFY_THRESHOLD <span class="comment">// 在哈希表扩容时，如果发现链表长度小于等于 6，则会由树重新退化为链表。</span></span><br><span class="line">MIN_TREEIFY_CAPACITY <span class="comment">//在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash <span class="comment">//计算下标</span></span><br></pre></td></tr></table></figure>

<h4 id="hash优化"><a href="#hash优化" class="headerlink" title="hash优化"></a>hash优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p><code>hashcdoe</code>值是32位，无符号右移16位，再与<code>hashcode</code>做^异或计算，使高位也参与计算，减少hash冲突</p>
<h4 id="寻址优化"><a href="#寻址优化" class="headerlink" title="寻址优化"></a>寻址优化</h4><p>h&amp;(n-1) 位与运算，等价于对n进行取模</p>
<h4 id="链表转换成树"><a href="#链表转换成树" class="headerlink" title="链表转换成树"></a>链表转换成树</h4><p>链表长度大等于8且键值对数量大于64</p>
<h4 id="树退化为链表"><a href="#树退化为链表" class="headerlink" title="树退化为链表"></a>树退化为链表</h4><p>链表长度小于等于6</p>
<h4 id="为何链表-→-红黑树的阈值是8"><a href="#为何链表-→-红黑树的阈值是8" class="headerlink" title="为何链表 → 红黑树的阈值是8"></a>为何链表 → 红黑树的阈值是8</h4><p>在理想的情况下随机hashCode算法下所有节点的分布频率会遵循<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Poisson_distribution">泊松分布(Poisson distribution)</a> ，链表长度达到8的概率是0.00000006，也就是说我们几乎不可能会使用到红黑树 , 所以作者使用8作为一个分水岭。<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611173731097.png" alt="image-20210611173731097" style="zoom: 67%;"></p>
<h4 id="为何链表-→-红黑树的阈值是6"><a href="#为何链表-→-红黑树的阈值是6" class="headerlink" title="为何链表 → 红黑树的阈值是6"></a>为何链表 → 红黑树的阈值是6</h4><p>假设<code>UNTREEIFY_THRESHOLD</code>的 = 7 , 当我们有频繁的添加和删除操作时 ,hash碰撞产生的节点数量 一旦在7附件徘徊就会造成红黑树和链表的频繁转换 , 此时我们大多数的性能就都耗费在了链表 → 红黑树和红黑树 → 链表` ,这样反而就得不偿失了 , 所以作者将长度为7作为一个缓存地段从而选取了6作为红黑树 → 链表的阈值</p>
<h3 id="LinkedHashMap详情"><a href="#LinkedHashMap详情" class="headerlink" title="LinkedHashMap详情"></a><code>LinkedHashMap详情</code></h3><p>继承<code>HashMap</code>,多了二个自定义的继承<code>HashMap</code>的Node(增加了Entry&lt;K,V&gt; before, after)类的Entry类型的变量head、tail。通过head和tail节点记录数据的<font color="red">插入顺序或者访问顺序。</font>默认是插入顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head; <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail; <span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">//访问顺序，默认为false</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向链表，确定顺序。<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/4843132-7abca1abd714341d.png" style="zoom:67%;"></p>
<h3 id="TreeMap详情"><a href="#TreeMap详情" class="headerlink" title="TreeMap详情"></a><code>TreeMap详情</code></h3><p>使用红黑树，可以自定义<font color="red">Comparator比较器</font>。自动通过key比较大小，如果key相等，则覆盖value的值</p>
<p>当比较器为null时，使用key对象的类，必须实现Comparable，强转为Comparable类型进行key比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//根节点</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WeakHashMap详解"><a href="#WeakHashMap详解" class="headerlink" title="WeakHashMap详解"></a><code>WeakHashMap详解</code></h3><p>弱键值对，与HashMap类似，使用的是数组+单链表，涉及到扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;(); <span class="comment">//弱引用队列</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弱引用——&gt;回收之后会存入引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashTable详解"><a href="#HashTable详解" class="headerlink" title="HashTable详解"></a><code>HashTable详解</code></h3><p> 线程安全的，与<code>HashMap</code>类似，使用数组+单链表，涉及到扩容。使用同步块Synchronized，保证线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a><code>EnumMap</code></h3><hr>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set集合</strong></h2><h3 id="HashSet详解"><a href="#HashSet详解" class="headerlink" title="HashSet详解"></a><code>HashSet详解</code></h3><p>使用的是<code>HashMap</code>进行数据存储，value为全局的Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSe详解"><a href="#LinkedHashSe详解" class="headerlink" title="LinkedHashSe详解"></a><code>LinkedHashSe详解</code></h3><p>继承<code>HashSet</code>，使用<code>LinkedHashMap</code>进行数据存储，value为全局的Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet详解"><a href="#TreeSet详解" class="headerlink" title="TreeSet详解"></a><code>TreeSet详解</code></h3><p>成员变量m的类型为<code>TreeMap</code>，value为全局的Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a><strong>Stack栈</strong></h2><p>先进后出（<code>FILO</code>）或者后进先出（LIFO），synchronized同步块保证线程安全，继承Vector，底层使用数组保存数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Vector,线程同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="位图BitSet"><a href="#位图BitSet" class="headerlink" title="位图BitSet"></a><strong>位图<code>BitSet</code></strong></h2><p> 使用数组存储，每位存储的值为0或者1，使用位运算。二倍原数组长度扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] words;</span><br><span class="line"><span class="comment">//计算value[值为0,1]在那个数组里下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;  <span class="comment">//ADDRESS_BITS_PER_WORD=6,&gt;&gt;6表示除以2的6次方即64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算bitIndex的值 1L&lt;&lt;64 还是等于为1</span></span><br><span class="line">(words[wordIndex] &amp; (<span class="number">1L</span> &lt;&lt; bitIndex)) != <span class="number">0</span></span><br><span class="line"><span class="comment">//设置bitIndex的值为1</span></span><br><span class="line">words[wordIndex] |= (<span class="number">1L</span> &lt;&lt; bitIndex);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="队列Queue和Deque双端队列"><a href="#队列Queue和Deque双端队列" class="headerlink" title="队列Queue和Deque双端队列"></a><strong><code>队列Queue和Deque双端队列</code></strong></h2><p>队列类图如下：<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/1182892-20171122100317930-842768608.png" style="zoom:67%;"></p>
<h3 id="ArrayDeque双端队列"><a href="#ArrayDeque双端队列" class="headerlink" title="ArrayDeque双端队列"></a><code>ArrayDeque双端队列</code></h3><h3 id="LinkedList-实现了Deque接口"><a href="#LinkedList-实现了Deque接口" class="headerlink" title="LinkedList 实现了Deque接口"></a><code>LinkedList 实现了Deque接口</code></h3><h3 id="PriorityQueue-优先级队列"><a href="#PriorityQueue-优先级队列" class="headerlink" title="PriorityQueue 优先级队列"></a><code>PriorityQueue 优先级队列</code></h3><h3 id="BlockingQueue-堵塞队列"><a href="#BlockingQueue-堵塞队列" class="headerlink" title="BlockingQueue 堵塞队列"></a><code>BlockingQueue 堵塞队列</code></h3><p>使用可重入锁<code>ReentrantLock</code>实现线程安全，使用Condition实现阻塞</p>
<ul>
<li><p><strong><code>LinkedBlockingQueue</code></strong> 的容量是没有上限的（说的不准确，在不指定时容量为<code>Integer.MAX_VALUE</code>，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，基于单链表的队列，此队列按 FIFO（先进先出）排序元素。（<code>LinkedBlockingDeque</code>）</p>
</li>
<li><p><strong><code>ArrayBlockingQueue</code></strong> 在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将<code>ReentrantLock</code>设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
</li>
<li><p>**<code>DelayQueue</code>**（基于<code>PriorityQueue</code>来实现的）是一个存放Delayed元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 <code>getDelay(TimeUnit.NANOSECONDS)</code> 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。 内部使用了优先级队列<code>PriorityQueue</code></p>
</li>
<li><p><strong><code>PriorityBlockingQueue</code></strong> 是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，<code>PriorityBlockingQueue</code>是对 <code>PriorityQueue</code>的再次包装，是基于堆数据结构的，而<code>PriorityQueue</code>是没有容量限制的，与<code>ArrayList</code>一样，所以在优先阻塞队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 <code>OutOfMemoryError</code>），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。</p>
</li>
<li><p><strong><code>SynchronousQueue</code></strong> 一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没 有元素可用于迭代。队列的头是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），<code>SynchronousQueue</code> 作为一个空 collection。此队列不允许 null 元素。</p>
<p>同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p>
<p>看起来很有意思吧。队列竟然是没有内部容量的。这个队列其实是<code>BlockingQueue</code>的一种实现。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。它给我们提供了在线程之间交换单一元素的极轻量级方法</p>
</li>
<li><p><code>LinkedTransferQueue implements TransferQueue</code>  LinkedBlockingDeque</p>
</li>
<li><p>ConcurrentLinkedQueue   ConcurrentLinkedDeque</p>
</li>
</ul>
<h3 id="队列中的方法"><a href="#队列中的方法" class="headerlink" title="队列中的方法"></a>队列中的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>add</strong></td>
<td>增加一个元索，如果队列已满，则抛出一个<code>IIIegaISlabEepeplian</code>异常</td>
</tr>
<tr>
<td><strong>remove</strong></td>
<td>移除并返回队列头部的元素，如果队列为空，则抛出一个<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td><strong>element</strong></td>
<td>返回队列头部的元素 ，如果队列为空，则抛出一个<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td><strong>offer</strong></td>
<td>添加一个元素并返回true ，如果队列已满，则返回false</td>
</tr>
<tr>
<td><strong>poll</strong></td>
<td>移除并返问队列头部的元素，如果队列为空，则返回null</td>
</tr>
<tr>
<td><strong>peek</strong></td>
<td>返回队列头部的元素，如果队列为空，则返回null</td>
</tr>
<tr>
<td><strong>put</strong></td>
<td>添加一个元素，如果队列满，则==阻塞==</td>
</tr>
<tr>
<td><strong>take</strong></td>
<td>移除并返回队列头部的元素，如果队列为空，则==阻塞==</td>
</tr>
</tbody></table>
<h2 id="快速失败fail-fast"><a href="#快速失败fail-fast" class="headerlink" title="快速失败fail-fast"></a>快速失败fail-fast</h2><p>集合中<strong>modCount</strong>变量，用modCount来记录修改集合修改次数。</p>
<ul>
<li>modCount成员变量，对集合进行增删改时，都会加1</li>
<li>集合迭代器操作时，会先赋值expectedModCount=modCount，遍历或删除等操作会判断expectedModCount与modCount 是否相等，如果不相等，throw new ConcurrentModificationException();</li>
</ul>
<h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历</li>
<li>java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">k8s之调度器和调度过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 14:16:25" itemprop="dateCreated datePublished" datetime="2020-11-30T14:16:25+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>本文作者</strong>：**<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xzkzzz/p/9963511.html">大胖猴</a>**<br><strong>本文链接</strong>：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xzkzzz/p/9963511.html">https://www.cnblogs.com/xzkzzz/p/9963511.html</a></p>
<h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><p>当Scheduler通过API server 的watch接口监听到新建Pod副本的信息后，它会检查所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。Scheduler在整个系统中承担了承上启下的作用，承上是负责接收创建的新Pod，为安排一个落脚的地（Node）,启下是安置工作完成后，目标Node上的kubelet服务进程接管后继工作，负责Pod生命周期的后半生。具体来说，Scheduler的作用是将待调度的Pod安装特定的调度算法和调度策略绑定到集群中的某个合适的Node上，并将绑定信息传给API server 写入etcd中。整个调度过程中涉及三个对象，分别是：待调度的Pod列表，可以的Node列表，以及调度算法和策略。</p>
<p>Kubernetes Scheduler 提供的调度流程分三步：</p>
<ol>
<li>预选策略(predicate) 遍历nodelist，选择出符合要求的候选节点，Kubernetes内置了多种预选规则供用户选择。</li>
<li>优选策略(priority) 在选择出符合要求的候选节点中，采用优选规则计算出每个节点的积分，最后选择得分最高的。</li>
<li>选定(select) 如果最高得分有好几个节点，select就会从中随机选择一个节点。</li>
</ol>
<p>如图：</p>
<p><img src="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/1076553-20181115142949847-1134192119.png" alt="img"></p>
<p>预选策略算法的集合在<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithm/predicates/predicates.go">官方源码</a></p>
<h3 id="常用的预选策略（代码里的策略不一定都会被使用）"><a href="#常用的预选策略（代码里的策略不一定都会被使用）" class="headerlink" title="常用的预选策略（代码里的策略不一定都会被使用）"></a>常用的预选策略（代码里的策略不一定都会被使用）</h3><ul>
<li>CheckNodeConditionPred 检查节点是否正常</li>
<li>GeneralPred HostName(如果pod定义hostname属性，会检查节点是否匹配。pod.spec.hostname)、PodFitsHostPorts（检查pod要暴露的hostpors是否被占用。pod.spec.containers.ports.hostPort）</li>
<li>MatchNodeSelector pod.spec.nodeSelector 看节点标签能否适配pod定义的nodeSelector</li>
<li>PodFitsResources 判断节点的资源能够满足Pod的定义（如果一个pod定义最少需要2C4G node上的低于此资源的将不被调度。用kubectl describe node NODE名称 可以查看资源使用情况）</li>
<li>NoDiskConflict 判断pod定义的存储是否在node节点上使用。（默认没有启用）</li>
<li>PodToleratesNodeTaints 检查pod上Tolerates的能否容忍污点（pod.spec.tolerations）</li>
<li>CheckNodeLabelPresence 检查节点上的标志是否存在 （默认没有启动）</li>
<li>CheckServiceAffinity 根据pod所属的service。将相同service上的pod尽量放到同一个节点（默认没有启动）</li>
<li>CheckVolumeBinding 检查是否可以绑定（默认没有启动）</li>
<li>NoVolumeZoneConflict 检查是否在一起区域（默认没有启动）</li>
<li>CheckNodeMemoryPressure 检查内存是否存在压力</li>
<li>CheckNodeDiskPressure  检查磁盘IO压力是否过大</li>
<li>CheckNodePIDPressure 检查pid资源是否过大</li>
</ul>
<h3 id="优选策略"><a href="#优选策略" class="headerlink" title="优选策略"></a>优选策略</h3><ul>
<li>least_requested 选择消耗最小的节点（根据空闲比率评估 cpu(总容量-sum(已使用)*10/总容量) ）**<br>**</li>
<li>balanced_resource_allocation 从节点列表中选出各项资源使用率最均衡的节点（CPU和内存）</li>
<li>node_prefer_avoid_pods 节点倾向</li>
<li>taint_toleration 将pod对象的spec.toleration与节点的taints列表项进行匹配度检查，匹配的条目越多，得分越低。</li>
<li>selector_spreading 与services上其他pod尽量不在同一个节点上，节点上通一个service的pod越少得分越高。</li>
<li>interpod_affinity 遍历node上的亲和性条目，匹配项越多的得分越高</li>
<li>most_requested 选择消耗最大的节点上（尽量将一个节点上的资源用完）</li>
<li>node_label 根据节点标签得分，存在标签既得分，没有标签没得分。标签越多 得分越高。</li>
<li>image_locality 节点上有所需要的镜像既得分，所需镜像越多得分越高。（根据已有镜像体积大小之和）</li>
</ul>
<h2 id="高级调度方式"><a href="#高级调度方式" class="headerlink" title="高级调度方式"></a>高级调度方式</h2><p>当我们想把调度到预期的节点，我们可以使用高级调度分为：</p>
<ul>
<li>节点选择器： nodeSelector、nodeName</li>
<li>节点亲和性调度： nodeAffinity</li>
<li>Pod亲和性调度：PodAffinity</li>
<li>Pod反亲和性调度：podAntiAffinity</li>
</ul>
<h3 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h3><p>我们定义一个pod,让其选择带有node=ssd这个标签的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-1</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  nodeSelector:</span><br><span class="line">    node: ssdkubectl apply -f test.yaml</span><br></pre></td></tr></table></figure>

<p>查看信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#get一下pod 一直处于Pending状态</span><br><span class="line">$ kubectl get pod </span><br><span class="line">NAME      READY     STATUS    RESTARTS   AGE</span><br><span class="line">pod-1     0&#x2F;1       Pending   0          7s</span><br><span class="line">#查看详细信息,是没有可用的selector</span><br><span class="line">$ kubectl describe pod pod-1</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  9s (x14 over 36s)  default-scheduler  0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line">#我们给node2打上这个标签</span><br><span class="line">$  kubectl label node k8s-node02 node&#x3D;ssd</span><br><span class="line">node&#x2F;k8s-node02 labeled</span><br><span class="line">#Pod正常启动</span><br><span class="line">$  kubectl describe pod pod-1</span><br><span class="line">....</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From                 Message</span><br><span class="line">  ----     ------            ----               ----                 -------</span><br><span class="line">  Warning  FailedScheduling  2m (x122 over 8m)  default-scheduler    0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line">  Normal   Pulled            7s                 kubelet, k8s-node02  Container image &quot;ikubernetes&#x2F;myapp:v1&quot; already present on machine</span><br><span class="line">  Normal   Created           7s                 kubelet, k8s-node02  Created container</span><br><span class="line">  Normal   Started           7s                 kubelet, k8s-node02  Started container</span><br></pre></td></tr></table></figure>

<h3 id="nodeAffinity"><a href="#nodeAffinity" class="headerlink" title="nodeAffinity"></a>nodeAffinity</h3><p>kubectl explain pod.spec.affinity.nodeAffinity </p>
<ul>
<li>requiredDuringSchedulingIgnoredDuringExecution 硬亲和性 必须满足亲和性。<ul>
<li>matchExpressions 匹配表达式,这个标签可以指定一段，例如pod中定义的key为zone，operator为In(包含那些)，values为 foo和bar。就是在node节点中包含foo和bar的标签中调度</li>
<li>matchFields 匹配字段 和上面的意思 不过他可以不定义标签值，可以定义</li>
</ul>
</li>
<li>preferredDuringSchedulingIgnoredDuringExecution  软亲和性 能满足最好，不满足也没关系。<ul>
<li>preference 优先级</li>
<li>weight 权重1-100范围内，对于满足所有调度要求的每个节点，调度程序将通过迭代此字段的元素计算总和，并在节点与对应的节点匹配时将“权重”添加到总和。</li>
</ul>
</li>
</ul>
<p>运算符包含：<code>In</code>，<code>NotIn</code>，<code>Exists</code>，<code>DoesNotExist</code>，<code>Gt</code>，<code>Lt</code>。可以使用<code>NotIn</code>和<code>DoesNotExist</code>实现节点反关联行为。</p>
<p>硬亲和性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - foo</span><br><span class="line">            - bar</span><br><span class="line">$ kubectl apply -f pod-affinity-demo.yaml </span><br><span class="line">$ kubectl describe pod node-affinity-pod </span><br><span class="line">.....</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  33s (x25 over 1m)  default-scheduler  0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line"># 给其中一个node打上foo的标签</span><br><span class="line">$ kubectl label node k8s-node03 zone&#x3D;foo</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                READY     STATUS    RESTARTS   AGE</span><br><span class="line">node-affinity-pod   1&#x2F;1       Running   0          8m</span><br></pre></td></tr></table></figure>

<p> 软亲和性：</p>
<p>与requiredDuringSchedulingIgnoredDuringExecution比较，这里需要注意的是preferredDuringSchedulingIgnoredDuringExecution是个列表项，而preference不是一个列表项了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod-2</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 50</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - foo</span><br><span class="line">            - bar$ kubectl get pod -o wide NAME                  READY     STATUS    RESTARTS   AGE       IP           NODEnode-affinity-pod     1&#x2F;1       Running   0          3h        10.244.3.2   k8s-node03node-affinity-pod-2   1&#x2F;1       Running   0          1m        10.244.3.3   k8s-node03</span><br></pre></td></tr></table></figure>

<h3 id="podAffinity"><a href="#podAffinity" class="headerlink" title="podAffinity"></a>podAffinity</h3><p>Pod亲和性场景，我们的k8s集群的节点分布在不同的区域或者不同的机房，当服务A和服务B要求部署在同一个区域或者同一机房的时候，我们就需要亲和性调度了。</p>
<p>kubectl explain pod.spec.affinity.podAffinity 和NodeAffinity是一样的，都是有硬亲和性和软亲和性</p>
<p>硬亲和性：</p>
<ul>
<li>labelSelector 选择跟那组Pod亲和</li>
<li>namespaces 选择哪个命名空间</li>
<li>topologyKey 指定节点上的哪个键</li>
</ul>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod1</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: service</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod2</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: front</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - podaffinity-myapp</span><br><span class="line">        topologyKey: kubernetes.io&#x2F;hostname </span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide </span><br><span class="line">NAME                  READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">node-affinity-pod1    1&#x2F;1       Running   0          12s       10.244.2.6   k8s-node02</span><br><span class="line">node-affinity-pod2    1&#x2F;1       Running   0          12s       10.244.2.5   k8s-node02</span><br></pre></td></tr></table></figure>

<h3 id="podAntiAffinity"><a href="#podAntiAffinity" class="headerlink" title="podAntiAffinity"></a>podAntiAffinity</h3><p>Pod反亲和性场景，当应用服务A和数据库服务B要求尽量不要在同一台节点上的时候。</p>
<p> kubectl explain pod.spec.affinity.podAntiAffinity 也分为硬反亲和性和软反亲和性调度（和podAffinity一样的配置）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#首先把两个node打上同一个标签。</span><br><span class="line">kubectl label node k8s-node02 zone&#x3D;foo </span><br><span class="line">kubectl label node k8s-node03 zone&#x3D;foo</span><br><span class="line">#反硬亲和调度</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod1</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: service</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod2</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: front</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - podaffinity-myapp</span><br><span class="line">        topologyKey: zone</span><br></pre></td></tr></table></figure>

<p>查看一下(因为zone这个key在每个node都有会，所以第二个Pod没有办法调度，所以一直Pending状态)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get  pod </span><br><span class="line">NAME                 READY     STATUS    RESTARTS   AGE</span><br><span class="line">node-affinity-pod1   1&#x2F;1       Running   0          11s</span><br><span class="line">node-affinity-pod2   0&#x2F;1       Pending   0          11s</span><br></pre></td></tr></table></figure>



<h3 id="污点容忍调度（Taint和Toleration）"><a href="#污点容忍调度（Taint和Toleration）" class="headerlink" title="污点容忍调度（Taint和Toleration）"></a>污点容忍调度（Taint和Toleration）</h3><p>前两种方式都是pod选择那个pod，而污点调度是node选择的pod，污点就是定义在节点上的键值属性数据。举要作用是让节点拒绝pod，拒绝不合法node规则的pod。Taint（污点）和 Toleration（容忍）是相互配合的，可以用来避免 pod 被分配到不合适的节点上,每个节点上都可以应用<strong>一个或多个</strong> taint ，这表示对于那些不能容忍这些 taint 的 pod，是不会被该节点接受的。</p>
<h4 id="Taint"><a href="#Taint" class="headerlink" title="Taint"></a>Taint</h4><p>Taint是节点上属性，我们看一下Taints如何定义</p>
<p>kubectl explain node.spec.taints（对象列表）</p>
<ul>
<li>key 定义一个key</li>
<li>value 定义一个值</li>
<li>effect pod不能容忍这个污点时，他的行为是什么，行为分为三种：NoSchedule 仅影响调度过程，对现存的pod不影响。PreferNoSchedule 系统将<em>尽量</em>避免放置不容忍节点上污点的pod，但这不是必需的。就是软版的NoSchedule NoExecute 既影响调度过程，也影响现存的pod，不满足的pod将被驱逐。</li>
</ul>
<h4 id="node-打-taint"><a href="#node-打-taint" class="headerlink" title="node 打 taint"></a>node 打 taint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint NODE NAME KEY_1&#x3D;VAL_1:TAINT_EFFECT_1 ... KEY_N&#x3D;VAL_N:TAINT_EFFECT_N [options]</span><br><span class="line">增加taint</span><br><span class="line">kubectl  taint node k8s-node02 node-type&#x3D;prod:NoSchedule</span><br><span class="line">删除taint</span><br><span class="line">kubectl  taint node k8s-node02 node-type:NoSchedule-</span><br></pre></td></tr></table></figure>

<h4 id="tolerations"><a href="#tolerations" class="headerlink" title="tolerations"></a>tolerations</h4><ul>
<li>key 被容忍的key</li>
<li>tolerationSeconds 被驱逐的宽限时间，默认是0 就是立即被驱逐</li>
<li>value 被容忍key的值</li>
<li>operator Exists只要key在就可以调度，Equal（等值比较）必须是值要相同</li>
<li>effect 节点调度后的操作</li>
</ul>
<p>创建一个容忍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-deploy</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">      release: dev</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myapp</span><br><span class="line">        release: dev</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myapp-containers</span><br><span class="line">        image: ikubernetes&#x2F;myapp:v2</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: &quot;node-type&quot;</span><br><span class="line">        operator: &quot;Equal&quot;</span><br><span class="line">        value: &quot;prod&quot;</span><br><span class="line">        effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0rancher/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E6%8E%A7%E5%88%B6%E5%8F%B0rancher/" class="post-title-link" itemprop="url">k8s控制台rancher</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 13:16:28" itemprop="dateCreated datePublished" datetime="2020-11-30T13:16:28+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">运维技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
