<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/" class="post-title-link" itemprop="url">JVM之垃圾回收器三色标记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-02 11:04:42" itemprop="dateCreated datePublished" datetime="2021-07-02T11:04:42+08:00">2021-07-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> JVM 中的垃圾回收是基于 标记-复制、标记-清除和标记-整理三种模式的，那么其中最重要的其实是如何标记，像Serial、Parallel这类的回收器，无论是单线程标记和多线程标记，其本质采用的是暂停用户线程进行全面标记的算法，这种算法的好处就是标记的很干净，而且实现简单，缺点就是标记时间相对很长，导致STW的时间很长。</p>
<p>那么后来就有了并发标记，适用于CMS和G1，并发标记的意思就是可以在不暂停用户线程的情况下对其进行标记，那么实现这种并发标记的算法就是三色标记法，三色标记法最大的特点就是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断来进行整个GC。</p>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>要找出存活对象，根据可达性分析，从GC Roots开始进行遍历访问，可达的则为存活对象：如下图，最终结果：A/D/E/F/G 可达</p>
<img src="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83Nzc5NjA3LTkwZmI1NmQxYjM2MmEwNzQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTA5" style="zoom:80%;">
我们把遍历对象图**过程**中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：

<ul>
<li><strong>白色</strong>：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。</li>
<li><strong>黑色</strong>：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了。</li>
<li><strong>灰色</strong>：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态。</li>
</ul>
<p><img src="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/20200730105400197.gif" alt="img"></p>
<h3 id="标记过程"><a href="#标记过程" class="headerlink" title="标记过程"></a>标记过程</h3><ol>
<li>在GC并发标记刚开始时，所以对象均为白色集合。</li>
<li>将所有GCRoots直接引用的对象标记为灰色集合。</li>
<li>判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将其所有的子引用对象放入灰色集合，当前对象放入黑色集合</li>
<li>按照步骤三，以此类推，直至灰色集合中的所有对象变成黑色后，本轮标记完成，且当前白色集合内的对象称为不可达对象，既垃圾对象。</li>
</ol>
<h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>由于此过程是在和用户线程并发运行的情况下，对象的引用处于随时可变的情况下，那么就会造成多标和漏标的问题。多标可以理解为浮动垃圾，只是导致部分对象不会被清除，占用内存空间。漏标的问题需要解决，漏标导致对象被清除，导致程序异常。</p>
<h3 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h3><p><strong>本应该被标记为白色的对象，没有被标记，造成该对象可能不会被回收</strong></p>
<ul>
<li>比如E对象在GC扫描D对象时,E还正在被D引用，那么此时E就被标记为灰色，此时业务逻辑的变化，D指向E的引用被置空了，这时候E以及后续子引用本应该被当成垃圾回收，但是此时E已经被标记为灰色，导致E对象以及其子对象没有被及时清理掉，变成了浮动垃圾，</li>
<li>还有在并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</li>
</ul>
<h3 id="漏标"><a href="#漏标" class="headerlink" title="漏标"></a>漏标</h3><p><strong>灰色对象指向白色对象的引用消失了，然后一个黑色的对象重新引用了白色对象。</strong></p>
<p>D对象引用E对象，E引用G，此时GC正好处于D已经变成黑色，E处于灰色，G是白色的情况下，此时因为业务逻辑的变化，E不引用G了，D对象引用了G，按照三色标记法看，黑色对象是已完成状态，不可能再去找子引用，所以G就不会变成灰色，这样就会造成白色对象此时正在被线程使用中，但是无法被标记成灰色或者白色，造成一个正在被使用的对象被错误回收。</p>
<img src="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/20200730143812205.png" style="zoom: 50%;">
<img src="/2021/07/02/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/20200730144111702.png">
漏标只有**同时满足**以下两个条件时才会发生：
**条件一：灰色对象 断开了 白色对象的引用；即灰色对象 原来成员变量的引用 发生了变化。
条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。**

<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>CMS：Incremental Update算法（增量更新）</p>
<p>当一个白色对象被一个黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。（破坏条件二）</p>
<p>G1：SATB（Snapshot At The Beginning）算法（原始快照）</p>
<p>当原来成员变量的引用发生变化之前，记录下原来的引用对象，既原始快照，当B和C之间的引用马上被断掉时，将这个引用记录下来，使GC依旧能够访问到，那样白色就不会漏标。在并发扫描结束之后，再将这些记录过得引用关系中的灰色对象为根，重新扫描一次。总而言之就是：无论引用关系删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。（破坏条件一）</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>SATB 算法是关注引用的删除。（B-&gt;C 的引用）</li>
<li>Incremental Update 算法关注引用的增加。（A-&gt;C 的引用）</li>
<li>G1 如果使用Incremental Update 算法，因为变成灰色的成员还要重新扫，重新再来一遍，效率太低了。所以G1 在处理并发标记的过程比CMS 效率要高，这个主要是解决漏标的算法决定的。</li>
</ul>
<h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010800201/article/details/107684597">三色标记</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/22/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E7%A7%92%E6%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/22/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E7%A7%92%E6%9D%80/" class="post-title-link" itemprop="url">解决方案之秒杀</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-22 15:18:04" itemprop="dateCreated datePublished" datetime="2021-06-22T15:18:04+08:00">2021-06-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708">qianshanding0708</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/95135402?spm=1001.2014.3001.5501">秒杀架构设计</a></p>
<h2 id="业务特点"><a href="#业务特点" class="headerlink" title="业务特点"></a>业务特点</h2><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEKSxScibv6T9bianNvT5pHicgKDBULz7GEe3ibED0eGKRCLefsTq6UmPpIw/640?wx_fmt=png" alt="640?wx_fmt=png" style="zoom:67%;">

<h3 id="瞬时并发量大"><a href="#瞬时并发量大" class="headerlink" title="瞬时并发量大"></a>瞬时并发量大</h3><p>秒杀时会有大量用户在同一时间进行抢购，瞬时并发访问量突增 10 倍，甚至 100 倍以上都有。</p>
<h3 id="库存量少"><a href="#库存量少" class="headerlink" title="库存量少"></a>库存量少</h3><p>一般秒杀活动商品量很少，这就导致了只有极少量用户能成功购买到。</p>
<h3 id="业务简单"><a href="#业务简单" class="headerlink" title="业务简单"></a>业务简单</h3><p>流程比较简单，一般都是下订单、扣库存、支付订单</p>
<h2 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h2><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEvy0e2h8XA8EQgw7NcDKlAymwjXkyEhepTyYZyiciagTkRf0UgYuWPtEw/640?wx_fmt=png" alt="640?wx_fmt=png" style="zoom:50%;">

<h3 id="现有业务的冲击"><a href="#现有业务的冲击" class="headerlink" title="现有业务的冲击"></a>现有业务的冲击</h3><p>秒杀是营销活动中的一种，如果和其他营销活动应用部署在同一服务器上，肯定会对现有其他活动造成冲击，极端情况下可能导致整个电商系统服务宕机</p>
<h3 id="直接下订单"><a href="#直接下订单" class="headerlink" title="直接下订单"></a>直接下订单</h3><p>下单页面是一个正常的 URL 地址，需要控制在秒杀开始前，不能下订单，只能浏览对应活动商品的信息。简单来说，需要 Disable 订单按钮</p>
<h3 id="页面流量突增"><a href="#页面流量突增" class="headerlink" title="页面流量突增"></a>页面流量突增</h3><p>秒杀活动开始前后，会有很多用户请求对应商品页面，会造成后台服务器的流量突增，同时对应的网络带宽增加，需要控制商品页面的流量不会对后台服务器、DB、Redis 等组件的造成过大的压力</p>
<h2 id="架构设计思想"><a href="#架构设计思想" class="headerlink" title="架构设计思想"></a>架构设计思想</h2><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEdUNMCLQrhkpIRBuA5PTPPkRHK8lOP7XSaSlA4pBiabu2QVEicZtZELxg/640?wx_fmt=png" alt="640?wx_fmt=png" style="zoom:50%;">

<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>由于活动库存量一般都是很少，对应的只有少部分用户才能秒杀成功。所以我们需要限制大部分用户流量，只准少量用户流量进入后端服务器</p>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>秒杀开始的那一瞬间，会有大量用户冲击进来，所以在开始时候会有一个瞬间流量峰值。如何把瞬间的流量峰值变得更平缓，是能否成功设计好秒杀系统的关键因素。实现流量削峰填谷，一般的采用缓存和 MQ 中间件来解决</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>秒杀其实可以当做高并发系统来处理，在这个时候，可以考虑从业务上做兼容，将同步的业务，设计成异步处理的任务，提高网站的整体可用性</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>秒杀系统的瓶颈主要体现在下订单、扣减库存流程中。在这些流程中主要用到 OLTP 的数据库，类似 MySQL、SQLServer、Oracle。由于数据库底层采用 B+ 树的储存结构，对应我们随机写入与读取的效率，相对较低。如果我们把部分业务逻辑迁移到内存的缓存或者 Redis 中，会极大的提高并发效率</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEGpnGxb5tSJic2cLzOMhUu7840yBRMC9DO3C3NOC1vBibDkvqUF4Mzwog/640?wx_fmt=png" alt="img" style="zoom:67%;">

<h3 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h3><p>客户端优化主要有两个问题</p>
<h4 id="秒杀页面"><a href="#秒杀页面" class="headerlink" title="秒杀页面"></a>秒杀页面</h4><p>秒杀活动开始前，其实就有很多用户访问该页面了。如果这个页面的一些资源，比如 CSS、JS、图片、商品详情等，都访问后端服务器，甚至 DB 的话，服务肯定会出现不可用的情况。所以一般我们会把这个页面整体进行静态化，并将页面静态化之后的页面分发到 CDN 边缘节点上，起到压力分散的作用</p>
<h4 id="防止提前下单"><a href="#防止提前下单" class="headerlink" title="防止提前下单"></a>防止提前下单</h4><p>防止提前下单主要是在静态化页面中加入一个 JS 文件引用，该 JS 文件包含活动是否开始的标记以及开始时的动态下单页面的 URL 参数。同时，这个 JS 文件是不会被 CDN 系统缓存的，会一直请求后端服务的，所以这个 JS 文件一定要很小。当活动快开始的时候（比如提前），通过后台接口修改这个 JS 文件使之生效</p>
<h3 id="API-接入层优化"><a href="#API-接入层优化" class="headerlink" title="API 接入层优化"></a>API 接入层优化</h3><p>客户端优化，对于不是搞计算机方面的用户还是可以防止住的。但是稍有一定网络基础的用户就起不到作用了，因此服务端也需要加些对应控制，不能信任客户端的任何操作。一般控制分为 2 大类</p>
<h4 id="限制用户维度访问频率"><a href="#限制用户维度访问频率" class="headerlink" title="限制用户维度访问频率"></a>限制用户维度访问频率</h4><p>针对同一个用户（ Userid 维度），做页面级别缓存，单元时间内的请求，统一走缓存，返回同一个页面</p>
<h4 id="限制商品维度访问频率"><a href="#限制商品维度访问频率" class="headerlink" title="限制商品维度访问频率"></a>限制商品维度访问频率</h4><p>大量请求同时间段查询同一个商品时，可以做页面级别缓存，不管下回是谁来访问，只要是这个页面就直接返回</p>
<h3 id="SOA-服务层优化"><a href="#SOA-服务层优化" class="headerlink" title="SOA 服务层优化"></a>SOA 服务层优化</h3><p>上面两层只能限制异常用户访问，如果秒杀活动运营的比较好，很多用户都参加了，就会造成系统压力过大甚至宕机，因此需要后端流量控制</p>
<p>对于后端系统的控制可以通过消息队列、异步处理、提高并发等方式解决。对于超过系统水位线的请求，直接采取 「Fail-Fast」原则，拒绝掉</p>
<h2 id="秒杀整体流程图"><a href="#秒杀整体流程图" class="headerlink" title="秒杀整体流程图"></a>秒杀整体流程图</h2><p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XCETLoXzTr9zVJAwVmj6r1RSFqliblyBEVCxOtzmOCmxhmRiaGOxcF3aA0vwPzgVqYJVqJ7X4oHiczIK4ibTicclGicQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<p>秒杀系统核心在于层层过滤，逐渐递减瞬时访问压力，减少最终对数据库的冲击。通过上面流程图就会发现压力最大的地方在哪里？</p>
<p>MQ 排队服务，只要 MQ 排队服务顶住，后面下订单与扣减库存的压力都是自己能控制的，根据数据库的压力，可以定制化创建订单消费者的数量，避免出现消费者数据量过多，导致数据库压力过大或者直接宕机。</p>
<p>库存服务专门为秒杀的商品提供库存管理，实现提前锁定库存，避免超卖的现象。同时，通过超时处理任务发现已抢到商品，但未付款的订单，并在规定付款时间后，处理这些订单，将恢复订单商品对应的库存量</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>核心思想：层层过滤</p>
<ul>
<li>尽量将请求拦截在上游，降低下游的压力</li>
<li>充分利用缓存与消息队列，提高请求处理速度以及削峰填谷的作用</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">中间件之Kafka实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-22 10:34:18" itemprop="dateCreated datePublished" datetime="2021-06-22T10:34:18+08:00">2021-06-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Kafka如何保证消息的顺序性"><a href="#Kafka如何保证消息的顺序性" class="headerlink" title="Kafka如何保证消息的顺序性"></a>Kafka如何保证消息的顺序性</h2><p><strong>生产端</strong></p>
<ul>
<li>生产者发送消息时可以指定Key，如订单号，客户端会对Key进行hash计算，将hash值相同的数据发送到同一个partition中</li>
<li>生产者发送消息时可以指定partition</li>
<li>生产者发送消息时可以自定义路由</li>
</ul>
<p><strong>消费端</strong></p>
<ul>
<li>消费端可以启动对应partition数量的消费端，保证一个消费者只消费一个partition中的数据 </li>
<li>提升单线程消费性能，消费者可以将批量获取的数据根据Hash算法，存放到多个内存队列中，自动提交改为手动提交，保证多线程下消息顺序性<img src="/2021/06/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E5%AE%9E%E6%88%98/顺序.png" alt="img" style="zoom:67%;">

</li>
</ul>
<h2 id="Kafka-交付语义–机制详解"><a href="#Kafka-交付语义–机制详解" class="headerlink" title="Kafka-交付语义–机制详解"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74212257?from_voters_page=true">Kafka-交付语义–机制详解</a></h2><h2 id="Kafka消息丢失（自带生产端重试）"><a href="#Kafka消息丢失（自带生产端重试）" class="headerlink" title="Kafka消息丢失（自带生产端重试）"></a>Kafka消息丢失（自带生产端重试）</h2><p>重试机制：KafkaProducer通过设定参数<code>retries</code>，如果发送消息到broker时抛出异常，且是允许重试的异常，那么就会最大重试retries参数指定的次数。</p>
<h3 id="哪些异常可以重试"><a href="#哪些异常可以重试" class="headerlink" title="哪些异常可以重试"></a>哪些异常可以重试</h3><ol>
<li>重试次数少于参数<code>retries</code>指定的值；</li>
<li>异常是<strong>RetriableException</strong>类型或者TransactionManager允许重试；</li>
</ol>
<h3 id="如何实现重试"><a href="#如何实现重试" class="headerlink" title="如何实现重试"></a>如何实现重试</h3><ol>
<li>new KafkaProducer()后创建一个后台线程KafkaThread扫描RecordAccumulator中是否有消息；</li>
<li>调用KafkaProducer.send()发送消息，实际上只是把消息保存到RecordAccumulator中；</li>
<li>后台线程KafkaThread扫描到RecordAccumulator中有消息后，将消息发送到kafka集群；</li>
<li>如果发送成功，那么返回成功；</li>
<li>如果发送失败，那么判断是否允许重试。如果不允许重试，那么返回失败的结果；如果允许重试，把消息再保存到RecordAccumulator中，等待后台线程KafkaThread扫描再次发送；</li>
</ol>
<p>RecordAccumulator是保存需要发送的消息或者重试消息的核心。发送消息之前先把消息存放在这里，异步线程KafkaThread启动后从这里取消息然后发送到broker。当发送出错且允许重试时，又会把这些需要重试的消息保存到这里再进行重试。当发送出错且允许重试时，会调用reenqueue()方法将消息暂时存放。保存需要发送的（重试）消息的核心数据结构是Deque。且创建队列时是<code>new ArrayDeque()</code>，没有指定初始容量。</p>
<h2 id="Kafka消费端重试机制（自己实现）"><a href="#Kafka消费端重试机制（自己实现）" class="headerlink" title="Kafka消费端重试机制（自己实现）"></a>Kafka消费端重试机制（自己实现）</h2><p><img src="/2021/06/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BKafka%E5%AE%9E%E6%88%98/image-20210719105825408.png" alt="image-20210719105825408"></p>
<h2 id="kafka发送消息的三种方式"><a href="#kafka发送消息的三种方式" class="headerlink" title="kafka发送消息的三种方式"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010442302/article/details/106456474?utm_term=kafka%E4%BD%BF%E7%94%A8callback&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-2-106456474&spm=3001.4430">kafka发送消息的三种方式</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8BDDD%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8BDDD%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">设计之DDD设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-21 16:34:36" itemprop="dateCreated datePublished" datetime="2021-06-21T16:34:36+08:00">2021-06-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/102952620?spm=1001.2014.3001.5501">架构设计实践五部曲（三）：从领域模型提取数据架构</a></p>
<p>风控系统为例，文章中采用四色原型法进行业务模型的抽象。</p>
<p>四色模型</p>
<ul>
<li>Moment-Interval Archetype 时标性原型</li>
</ul>
<p>表示事物在某个时刻或某一段时间内发生的。使用红色表示，简写为 MI.</p>
<ul>
<li>Part-Place-Thing Archetype 参与方 - 地点 - 物品原型.</li>
</ul>
<p>表示参与扮演不同角色的人或事物。使用绿色表示。简写为 PPT。</p>
<ul>
<li>Role Archetype 角色原型</li>
</ul>
<p>角色是一种参与方式，它由人或组织机构、地点或物品来承担。使用黄色表示。简写为 Role。</p>
<ul>
<li>Description Archetype 描述原型</li>
</ul>
<p>表示资料类型的资源，它可以被其它原型反复使用，并为其它原型提供行为。使用蓝色表示。简写为 DESC。</p>
<h2 id="领域驱动设计DDD和CQRS落地"><a href="#领域驱动设计DDD和CQRS落地" class="headerlink" title="领域驱动设计DDD和CQRS落地"></a><a target="_blank" rel="noopener" href="http://deepoove.com/blog/#/posts/69">领域驱动设计DDD和CQRS落地</a></h2><h2 id="对应的源码"><a href="#对应的源码" class="headerlink" title="对应的源码"></a><a target="_blank" rel="noopener" href="https://github.com/luckyfeing/ddd-cargo">对应的源码</a></h2><h2 id="DDD领域驱动设计基本理论知识总结"><a href="#DDD领域驱动设计基本理论知识总结" class="headerlink" title="DDD领域驱动设计基本理论知识总结"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html">DDD领域驱动设计基本理论知识总结</a></h2><h2 id="Spring-Boot实现DDD的货运Cargo微服务案例源码"><a href="#Spring-Boot实现DDD的货运Cargo微服务案例源码" class="headerlink" title="Spring Boot实现DDD的货运Cargo微服务案例源码"></a><a target="_blank" rel="noopener" href="https://github.com/practicalddd/implementations/tree/master/springboot/sb%2Brabbit%2Bmysql">Spring Boot实现DDD的货运Cargo微服务案例源码</a></h2><h3 id="DDD-cargo事例"><a href="#DDD-cargo事例" class="headerlink" title="DDD cargo事例"></a><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/mistbow-1394856">DDD cargo事例</a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">设计之架构设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-21 13:35:34" itemprop="dateCreated datePublished" datetime="2021-06-21T13:35:34+08:00">2021-06-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/102889690?spm=1001.2014.3001.5501">架构设计实践五部曲（一）：架构与架构图</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/102927609?spm=1001.2014.3001.5501">架构设计实践五部曲（二）：业务架构与产品架构设计实践</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/102952620?spm=1001.2014.3001.5501">架构设计实践五部曲（三）：从领域模型提取数据架构</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/102952622?spm=1001.2014.3001.5501">架构设计实践五部曲（四）：单体式与分布式的应用架构</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/102982579?spm=1001.2014.3001.5501">架构设计实践五部曲（五）：技术架构的战略和战术原则</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023053758">分布式单体起因及解决</a></p>
<p><a target="_blank" rel="noopener" href="https://jsldl.blog.csdn.net/article/details/103046573?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.nonecase">中台和微服务区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/102813594?spm=1001.2014.3001.5501">没有中台，但有微服务和 PaaS，一样吗？</a></p>
<p>微服务架构通常采用前后端分离方式，按照一定的规则拆分为多个可以独立运行、独立开发、独立部署、独立运维的微服务或者页面聚合，从而满足业务快速变化及分布式多团队并行开发的需求，还可实现前端页面的复用，做到“一次开发，多端复用”，这也与中台服务的共享理念非常类似。所以，很多企业在进行中台实践时会将两者混淆。</p>
<p>从使用者的角度来看，大部分的微服务架构都是在支撑一个前台，而中台解决的是企业级能力复用，而这种能力复用一定是多前台、跨部门的。当然，微服务中也会提到复用问题，但这种复用一般指的是组件级别的复用，并未达到企业级的层面。一般而言，一个业务中台会同时抽调多个前台业务中可共享的能力，最终统一支持多个前台业务。</p>
<p>简单讲就是：中台不一定非得采用微服务架构，能够达到多前台能力复用的目标即可；而微服务架构也不一定要同时支持多前台应用，单应用的微服务化其实更多见。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianshangding0708/article/details/100017275?spm=1001.2014.3001.5501">我的一年中台实战录</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247521183&idx=1&sn=ad72b0e253fb2bc4281b2a09e44cc27b&chksm=fa4aec2ecd3d6538b51e869bad42d05b663e7237bef6347f8c0dbf4518807669c70c67166648&mpshare=1&scene=24&srcid=07136qesxhWYbCLJZCg7kJtB&sharer_sharetime=1626171770894&sharer_shareid=29c86683e1453c750f38cb077074e5d6#rd">分布式单体</a></p>
<p><font color="red">架构是面向业务功能、成本、实现难度、时间等因素的取舍，而不是绝对地追求高性能、高并发及高可用等非功能性指标。</font></p>
<h2 id="平台化和个性化"><a href="#平台化和个性化" class="headerlink" title="平台化和个性化"></a>平台化和个性化</h2><p>平台化要求我们做到通用性，能够适用于不同的业务场景，减少开发和部署的时间，降低实施成本；个性化却要求我们做到灵活性，能够满足不同业务的需求，并可以进行快速迭代，通过差异化构建竞争壁垒！</p>
<h2 id="前台和中台"><a href="#前台和中台" class="headerlink" title="前台和中台"></a>前台和中台</h2><p>“中台+前台”模式的最难之处在于如何进行“中台”和“前台”解耦：到底是采用“薄（小）中台、厚（大）前台”模式，还是倒过来采用“厚（大）中台、薄（小）前台”的模式，是许多平台化企业都面临的两难抉择。</p>
<p><strong>回归本质，一切应以业务出发！</strong></p>
<p>对于模式尚未成型，客户价值尚未清晰，需要快速迭代的业务，应采用“薄中台、厚前台”的模式，给予前台足够的机动性和灵活度，流程和系统紧贴业务快速奔跑。</p>
<p>相反，对于模式较为确定，客户价值相对清晰，发展趋势较为明确的业务，则应采用“厚中台、薄前台”的模式，提高系统的规范化、流程化的能力，通过效率的提升来逐步降低成本，但同时依然为前台的灵活操作留有一定的空间。</p>
<p>当然，从前者到后者往往是个渐变的过程，没有办法一刀切。这就需要中台的架构师具有超强的服务意识，能够时刻掌握业务的发展状况、业务的迭代方向，并在这个过程中将前台所采用的“土办法”进行总结、将通用性的能力逐步在中台进行沉淀。逐步形成中央化、模块化、标准化的“武器库”，再通过不同的组合和配置为前台作战小组随时提供其所需的、能够因地制宜的“炮火支援”。</p>
<p>一把钥匙虽然打不开天下所有的锁，但“中台+前台”的模式就如同为我们提供了一个能够在现场快速“配钥匙”的工具+远程的在线指导。那么哪怕遇上再难打开的锁，再难完成的任务，我们也能信心满满地就地解决了！</p>
<h2 id="平台和中台"><a href="#平台和中台" class="headerlink" title="平台和中台"></a>平台和中台</h2><p>中台不是凭空而来，亦不是平台化架构换个名字。中台化架构是平台化架构的自然演进。一定规模的互联网IT公司都可能有一个叫共享平台或者平台技术这样的部门，就是把业务基础设施和技术基础设施下沉，然后由对应的研发和产品部门去负责。但久而久之，共享平台就成了资源中心，前端业务找你就是要人干活，平台做的也是接客干活。如前文所述，各平台接客模式协同负责度高，周期长。一个商业系统不仅仅是组织几个component，而是需要解决方案。中台提供的能力可以是service、可以是由service组合的组合能力、亦可以是解决方案(solution)的直接输出。</p>
<h3 id="中台是平台的自然演进"><a href="#中台是平台的自然演进" class="headerlink" title="中台是平台的自然演进"></a><strong>中台是平台的自然演进</strong></h3><p>前面提到平台化目标是高内聚、低耦合；职责边界清晰；易于集成等。那么中台化架构进一步可总结为：高内聚、低耦合；数据完整性原则；业务可运营原则。当然，从架构方法来讲，宜采用渐进式架构的演进原则。如果一个中台把若干平台聚拢起来，对业务支持的SLA没有变化、也没有在业务运营上有所改变，一定是失败的。</p>
<img src="/2021/06/21/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20210720181432244.png" alt="image-20210720181432244" style="zoom:67%;">
以上图为例，业务在发展过程中，会有若干业务系统。平台化的架构是按项目模式，把公共平台和业务系统的架构师，开发，测试，产品搞在一起协同、排期、研发、上线。中台化架构可以在进一步把平台能力按能力、服务、实体进行管理。把平台划分为系统运行、业务运营2部分。实现80% 甚至更多的业务需求由业务团队自助进入。这反映到前端业务上支持效能提升了，中台的代码基本不用研发，沟通成本也急剧下降。其2，中台的架构师和研发队伍可以把精力放到中台能力提升，从运营视角发掘类似业务全息查询、数据产品这样的创新。

<h2 id="平台、中台与康威定律-传统企业IT架构转型的辛酸史"><a href="#平台、中台与康威定律-传统企业IT架构转型的辛酸史" class="headerlink" title="平台、中台与康威定律 - 传统企业IT架构转型的辛酸史"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29b5222f23bb">平台、中台与康威定律 - 传统企业IT架构转型的辛酸史</a></h2><h2 id="架构设计-如何做电商业务中台"><a href="#架构设计-如何做电商业务中台" class="headerlink" title="架构设计-如何做电商业务中台"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwc/p/14100516.html">架构设计-如何做电商业务中台</a></h2><h2 id="架构设计-从中台到平台"><a href="#架构设计-从中台到平台" class="headerlink" title="架构设计-从中台到平台"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwc/p/14100442.html">架构设计-从中台到平台</a></h2><h2 id="一文了解前台、中台、后台的职责与关联"><a href="#一文了解前台、中台、后台的职责与关联" class="headerlink" title="一文了解前台、中台、后台的职责与关联 "></a><a target="_blank" rel="noopener" href="https://www.sohu.com/a/434689774_617676?sec=wd">一文了解前台、中台、后台的职责与关联 </a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8Bnacos%E9%AB%98%E5%8F%AF%E7%94%A8/" class="post-title-link" itemprop="url">微服务之nacos高可用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-18 16:10:25" itemprop="dateCreated datePublished" datetime="2021-06-18T16:10:25+08:00">2021-06-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1802966?from=information.detail.nacos%E9%AB%98%E5%8F%AF%E7%94%A8">Nacos 服务模型</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1768701?from=information.detail.nacos%E9%AB%98%E5%8F%AF%E7%94%A8">Nacos服务注册高可用</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI0NzEyODIyOA==&mid=2247485760&idx=1&sn=37a08f5a5d4c8f6182cfce127c0f0921&chksm=e9b5808bdec2099de368de44db5c0e2752c41ed7c8fa8009e3bb1052ecc8c35aa1081550d3b8&scene=21#wechat_redirect">Nacos2.0与1.0比较</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1810137?from=information.detail.nacos%E9%AB%98%E5%8F%AF%E7%94%A8">Nacos 2.0性能优化</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/17/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/17/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">解决方案之二级缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-17 18:11:32" itemprop="dateCreated datePublished" datetime="2021-06-17T18:11:32+08:00">2021-06-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="有赞实现多级缓存的架构设计方案"><a href="#有赞实现多级缓存的架构设计方案" class="headerlink" title="有赞实现多级缓存的架构设计方案"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/uWInyKQYkASVKPN8lblkPQ">有赞实现多级缓存的架构设计方案</a></h2><h2 id="什么是二级缓存"><a href="#什么是二级缓存" class="headerlink" title="什么是二级缓存"></a>什么是二级缓存</h2><p>redis cluster提供分布式缓存服务，可以在应用中也缓存一份数据，提供性能。但是可能有数据一致性问题。</p>
<h2 id="为什么要做二级缓存"><a href="#为什么要做二级缓存" class="headerlink" title="为什么要做二级缓存"></a>为什么要做二级缓存</h2><p>当有热点key或使用次数过多且变动少的数据时，可以将数据缓存在应用中，减少请求到redis中，冲击分布式缓存系统，大量占据内网带宽，最终影响应用层系统稳定性；</p>
<ul>
<li>实现思路：<font color="red">有赞TMC，Caffeine(通过Redis 发布订阅做数据同步)</font></li>
</ul>
<h2 id="多级缓存解决方案的痛点"><a href="#多级缓存解决方案的痛点" class="headerlink" title="多级缓存解决方案的痛点"></a>多级缓存解决方案的痛点</h2><ul>
<li>热点探测：如何快速且准确的发现 <strong>热点访问 key</strong> ？</li>
<li>数据一致性：前置在应用层的本地缓存，如何保障与分布式缓存系统的数据一致性？</li>
<li>效果验证：如何让应用层查看本地缓存命中率、热点 key 等数据，验证多级缓存效果？</li>
<li>透明接入：整体解决方案如何减少对应用系统的入侵，做到快速平滑接入？</li>
</ul>
<h2 id="有赞二级缓存TMC实现"><a href="#有赞二级缓存TMC实现" class="headerlink" title="有赞二级缓存TMC实现"></a>有赞二级缓存TMC实现</h2><p>TMC，即“透明多级缓存（Transparent Multilevel Cache）”，应用提供的整体缓存解决方案。</p>
<ul>
<li>应用层热点探测</li>
<li>应用层本地缓存</li>
<li>应用层缓存命中统计</li>
</ul>
<p>以帮助应用层解决缓存使用过程中出现的热点访问问题。</p>
<p>Sass平台，商家会不定期做一些“商品秒杀”、“商品推广”活动，导致“营销活动”、“商品详情”、“交易下单”等链路应用出现<strong>缓存热点访问</strong>的情况：</p>
<ul>
<li>活动时间、活动类型、活动商品之类的信息不可预期，导致 缓存热点访问 情况不可提前预知；</li>
<li>缓存热点访问 出现期间，应用层少数 <strong>热点访问 key</strong> 产生大量缓存访问请求：冲击分布式缓存系统，大量占据内网带宽，最终影响应用层系统稳定性；</li>
</ul>
<p>为了应对以上问题，需要一个能够 自动发现热点 并 将热点缓存访问请求前置在应用层本地缓存的解决方案，这就是 TMC 产生的原因。</p>
<p><font color="red">热点数据发现，将热点数据缓存到本地，实现二级缓存</font></p>
<h2 id="TMC-整体架构"><a href="#TMC-整体架构" class="headerlink" title="TMC 整体架构"></a>TMC 整体架构</h2><img src="/2021/06/17/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/640" alt="图片" style="zoom:67%;">
TMC 整体架构如上图，共分为三层：

<ul>
<li>存储层：提供基础的 kv 数据存储能力，针对不同的业务场景选用不同的存储服务（codis/zankv/aerospike）；</li>
<li>代理层：为应用层提供统一的缓存使用入口及通信协议，承担分布式数据水平切分后的路由功能转发工作；</li>
<li>应用层：提供统一客户端给应用服务使用，内置“热点探测”、“本地缓存”等功能，对业务透明；</li>
</ul>
<p>本篇聚焦在应用层客户端的“热点探测”、“本地缓存”功能。</p>
<h2 id="TMC-本地缓存"><a href="#TMC-本地缓存" class="headerlink" title="TMC 本地缓存"></a>TMC 本地缓存</h2><h3 id="如何透明"><a href="#如何透明" class="headerlink" title="如何透明"></a>如何透明</h3><p>TMC 是如何减少对业务应用系统的入侵，做到透明接入的？对于公司 Java 应用服务，在缓存客户端使用方式上分为两类：</p>
<ul>
<li>基于 <code>spring.data.redis</code>包，使用 <code>RedisTemplate</code>编写业务代码；</li>
<li>基于 <code>youzan.framework.redis</code>包，使用 <code>RedisClient</code>编写业务代码；</li>
</ul>
<p>不论使用以上那种方式，最终通过 <code>JedisPool</code>创建的 <code>Jedis</code>对象与缓存服务端代理层做请求交互。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5ia9kIeBOeacxAL8g8PV9NS1ujWkgXa6XiazPtAJl84GkrUPN9SCu73tfQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>TMC 对原生 jedis 包的 <code>JedisPool</code>和 <code>Jedis</code>类做了改造，在 JedisPool 初始化过程中集成 TMC“热点发现”+“本地缓存”功能 <code>Hermes-SDK</code>包的初始化逻辑</p>
<p>使 <code>Jedis</code>客户端与缓存服务端代理层交互时先与 <code>Hermes-SDK</code>交互，从而完成 “热点探测”+“本地缓存”功能的透明接入。</p>
<p>对于 Java 应用服务，只需使用特定版本的 jedis-jar 包，无需修改代码，即可接入 TMC 使用“热点发现”+“本地缓存”功能，做到了对应用系统的最小入侵。</p>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaccMcwZB3NGaia669PGFbVtUNS9gAgZ3WRwMeADBiaNAI8AF19479UJBQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><p>TMC 本地缓存整体结构分为如下模块：</p>
<ul>
<li><strong>Jedis-Client</strong>：Java 应用与缓存服务端交互的直接入口，接口定义与原生 Jedis-Client 无异；</li>
<li><strong>Hermes-SDK</strong>：自研“热点发现+本地缓存”功能的 SDK 封装，Jedis-Client 通过与它交互来集成相应能力；</li>
<li><strong>Hermes 服务端集群</strong>：接收 Hermes-SDK 上报的缓存访问数据，进行热点探测，将热点 key 推送给 Hermes-SDK 做本地缓存；</li>
<li><strong>缓存集群</strong>：由代理层和存储层组成，为应用客户端提供统一的分布式缓存服务入口；</li>
<li><strong>基础组件</strong>：etcd 集群、Apollo 配置中心，为 TMC 提供“集群推送”和“统一配置”能力；</li>
</ul>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>1）key 值获取</p>
<ul>
<li>Java 应用调用 <strong>Jedis-Client</strong> 接口获取 key 的缓存值时，<strong>Jedis-Client</strong> 会询问 <strong>Hermes-SDK</strong> 该 key 当前是否是 <strong>热点key</strong>；</li>
<li>对于 <strong>热点key</strong> ，直接从 <strong>Hermes-SDK</strong> 的 热点模块 获取热点 key 在本地缓存的 value 值，不去访问 <strong>缓存集群</strong> ，从而将访问请求前置在应用层；</li>
<li>对于非 <strong>热点key</strong> ，<strong>Hermes-SDK</strong> 会通过 <code>Callable</code>回调 <strong>Jedis-Client</strong> 的原生接口，从 <strong>缓存集群</strong> 拿到 value 值；</li>
<li>对于 <strong>Jedis-Client</strong> 的每次 key 值访问请求，<strong>Hermes-SDK</strong> 都会通过其 通信模块 将 <strong>key 访问事件</strong> 异步上报给 <strong>Hermes 服务端集群</strong> ，以便其根据上报数据进行“热点探测”；</li>
</ul>
<p>2）key 值过期</p>
<ul>
<li>Java 应用调用 <strong>Jedis-Client</strong> 的 <code>set()</code> <code>del()</code> <code>expire()</code>接口时会导致对应 key 值失效，<strong>Jedis-Client</strong> 会同步调用 <strong>Hermes-SDK</strong> 的 <code>invalid()</code>方法告知其“key 值失效”事件；</li>
<li>对于 <strong>热点 key</strong> ，<strong>Hermes-SDK</strong> 的 热点模块 会先将 key 在本地缓存的 value 值失效，以达到本地数据<strong>强一致</strong>。同时 通信模块 会异步将“key 值失效”事件通过 <strong>etcd 集群</strong> 推送给 Java 应用集群中其他 <strong>Hermes-SDK</strong> 节点；</li>
<li>其他 <strong>Hermes-SDK</strong> 节点的通信模块收到 “key 值失效”事件后，会调用热点模块将key在本地缓存的value值失效，以达到集群数据<strong>最终一致</strong>；</li>
</ul>
<p>3）热点发现</p>
<ul>
<li><p><strong>Hermes 服务端集群</strong> 不断收集 <strong>Hermes-SDK</strong>上报的 <strong>key 访问事件</strong>，对不同业务应用集群的缓存访问数据进行周期性（3s 一次）分析计算，以探测业务应用集群中的<strong>热点 key</strong>列表；</p>
</li>
<li><p>对于探测到的<strong>热点 key</strong>列表，<strong>Hermes 服务端集群</strong> 将其通过 <strong>etcd 集群</strong> 推送给不同业务应用集群的 <strong>Hermes-SDK</strong> 通信模块，通知其对<strong>热点 key</strong>列表进行本地缓存；</p>
</li>
</ul>
<p>4）配置读取</p>
<ul>
<li><strong>Hermes-SDK</strong> 在启动及运行过程中，会从 <strong>Apollo 配置中心</strong> 读取其关心的配置信息（如：启动关闭配置、黑白名单配置、etcd 地址…）；</li>
<li><strong>Hermes 服务端集群</strong> 在启动及运行过程中，会从 <strong>Apollo 配置中心</strong> 读取其关心的配置信息（如：业务应用列表、热点阈值配置、etcd 地址…）</li>
</ul>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>TMC 本地缓存稳定性表现在以下方面：</p>
<ul>
<li>数据上报异步化：<strong>Hermes-SDK</strong> 使用 <code>rsyslog技术</code>对“key 访问事件”进行异步化上报，不会阻塞业务；</li>
<li>通信模块线程隔离：<strong>Hermes-SDK</strong> 的 通信模块 使用独立线程池+有界队列，保证事件上报&amp;监听的 I/O 操作与业务执行线程隔离，即使出现非预期性异常也不会影响基本业务功能；</li>
<li>缓存管控：<strong>Hermes-SDK</strong> 的 热点模块 对本地缓存大小上限进行了管控，使其占用内存不超过 64MB（LRU），杜绝 JVM 堆内存溢出的可能；</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>TMC 本地缓存一致性表现在以下方面：</p>
<ul>
<li><strong>Hermes-SDK</strong> 的 热点模块 仅缓存 <strong>热点 key</strong> 数据，绝大多数非热点 key数据由 <strong>缓存集群</strong> 存储；</li>
<li><strong>热点 key</strong> 变更导致 value 失效时，<strong>Hermes-SDK</strong> 同步失效本地缓存，保证 <strong>本地强一致</strong>；</li>
<li><strong>热点 key</strong> 变更导致 value 失效时，<strong>Hermes-SDK</strong> 通过 <strong>etcd 集群</strong> 广播事件，异步失效业务应用集群中其他节点的本地缓存，保证 <strong>集群最终一致</strong>；</li>
</ul>
<h2 id="热点发现"><a href="#热点发现" class="headerlink" title="热点发现"></a>热点发现</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaWWO0sYEvUUfGAicpBbGic4ficlDscJzoFvvjnwzVjKPRJ3lH0EiaIN6C1w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>TMC 热点发现流程分为四步：</p>
<ul>
<li><strong>数据收集</strong>：收集 <strong>Hermes-SDK</strong> 上报的 key 访问事件；</li>
<li><strong>热度滑窗</strong>：对 App 的每个 Key，维护一个时间轮，记录基于当前时刻滑窗的访问热度；</li>
<li><strong>热度汇聚</strong>：对 App 的所有 Key，以 的形式进行 热度排序汇总；</li>
<li><strong>热点探测</strong>：对 App，从 热 Key 排序汇总 结果中选出 TopN 的热点 Key ，推送给 <strong>Hermes-SDK</strong>；</li>
</ul>
<h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p><strong>Hermes-SDK</strong>通过本地 <code>rsyslog</code>将 <strong>key 访问事件</strong>以协议格式放入 <strong>kafka</strong>，<strong>Hermes 服务端集群</strong>的每个节点消费 kafka 消息，实时获取 <strong>key 访问事件</strong>。</p>
<p>访问事件协议格式如下：</p>
<ul>
<li>appName：集群节点所属业务应用</li>
<li>uniqueKey：业务应用 key 访问事件 的 key</li>
<li>sendTime：业务应用 key 访问事件 的发生时间</li>
<li>weight：业务应用 key 访问事件 的访问权值</li>
</ul>
<p><strong>Hermes 服务端集群</strong>节点将收集到的 <strong>key 访问事件</strong>存储在本地内存中，内存数据结构为 <code>Map&lt;string,map&gt;</code>，对应业务含义映射为 <code>Map&lt;appname,map&gt;</code>。</p>
<h3 id="热度滑窗"><a href="#热度滑窗" class="headerlink" title="热度滑窗"></a>热度滑窗</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaAzSRicYl2QyaMK92FhbCk0iaXAicFS9FI6iclPPvNh9RFSCmWcjvuic12sQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="时间滑窗"><a href="#时间滑窗" class="headerlink" title="时间滑窗"></a>时间滑窗</h3><p><strong>Hermes 服务端集群</strong>节点，对每个 App 的每个 key，维护了一个 <strong>时间轮</strong>：</p>
<ul>
<li><p>时间轮中共 10 个 <strong>时间片</strong>，每个时间片记录当前 key 对应 3 秒时间周期的总访问次数；</p>
</li>
<li><p>时间轮 10 个时间片的记录累加即表示当前 key 从当前时间向前 30 秒时间窗口内的总访问次数；</p>
</li>
</ul>
<h3 id="映射任务"><a href="#映射任务" class="headerlink" title="映射任务"></a>映射任务</h3><p><strong>Hermes 服务端集群</strong>节点，对每个 App 每 3 秒 生成一个 <strong>映射任务</strong>，交由节点内 “缓存映射线程池” 执行。<strong>映射任务</strong>内容如下：</p>
<ul>
<li><p>对当前 App，从 <code>Map&lt;appname,map&gt;&lt; appname,map&lt;=&quot;&quot; code=&quot;&quot;&gt;中取出 appName 对应的 Map Map&gt;；</code></p>
</li>
<li><p><code>遍历 Map&gt;中的 key，对每个 key 取出其热度存入其 **时间轮** 对应的时间片中；</code></p>
</li>
</ul>
<h3 id="热度汇聚"><a href="#热度汇聚" class="headerlink" title="热度汇聚"></a>热度汇聚</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaib5p9EelHYkAp1IFFGKE3H1Rghuz0Rmw7oIkJSQ6YsElj46Zic1iar6sA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>完成第二步“热度滑窗”后，<strong>映射任务</strong>继续对当前 App 进行“热度汇聚”工作：</p>
<ul>
<li><p><code>遍历 App 的 key，将每个 key 的 **时间轮** 热度进行汇总（即 30 秒时间窗口内总热度）得到探测时刻 **滑窗总热度**；</code></p>
</li>
<li><p><code>将 &lt; key , 滑窗总热度 &gt; 以排序集合的方式存入 Redis 存储服务 中，即 **热度汇聚结果**；</code></p>
</li>
</ul>
<h3 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h3><ul>
<li><p>在前几步，<strong>每 3 秒</strong> 一次的 <strong>映射任务</strong> 执行，对每个 App 都会产生一份当前时刻的 <strong>热度汇聚结果</strong>`</p>
</li>
<li><p><strong>Hermes 服务端集群</strong> 中的“热点探测”节点，对每个 App，只需周期性从其最近一份 <strong>热度汇聚结果</strong> 中取出达到热度阈值的 TopN 的 key 列表，即可得到本次探测的 <strong>热点 key 列表</strong>；</p>
</li>
</ul>
<p>TMC 热点发现整体流程如下图：<br><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iauF3LXU9IZGEmjDWcouSbPCKTosmsDAtOxelRQ2u1VJnuH57dKQFwLw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h2><h3 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a><code>实时性</code></h3><p><strong>Hermes-SDK</strong> 基于rsyslog + kafka 实时上报 <strong>key 访问事件</strong>。<strong>映射任务</strong>3 秒一个周期完成“热度滑窗” + “热度汇聚”工作，当有 <strong>热点访问场景</strong>出现时最长 3 秒即可探测出对应 <strong>热点 key</strong>。</p>
<h3 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a><code>准确性</code></h3><p>key 的<strong>热度汇聚结果</strong>由“基于时间轮实现的滑动窗口”汇聚得到，相对准确地反应当前及最近正在发生访问分布。</p>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a><code>扩展性</code></h3><p><strong>Hermes 服务端集群</strong>节点无状态，节点数可基于 kafka 的 partition 数量横向扩展。<br>“热度滑窗” + “热度汇聚” 过程基于 App 数量，在单节点内多线程扩展。</p>
<h2 id="实战效果"><a href="#实战效果" class="headerlink" title="实战效果"></a>实战效果</h2><h3 id="快手商家某次商品营销活动"><a href="#快手商家某次商品营销活动" class="headerlink" title="快手商家某次商品营销活动"></a>快手商家某次商品营销活动</h3><p>有赞商家通过快手直播平台为某商品搞活动，造成该商品短时间内被集中访问产生访问热点，活动期间 TMC 记录的实际热点访问效果数据如下：</p>
<p><code>某核心应用的缓存请求&amp;命中率曲线图</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaYeXwQYPHJzIAwxe0IYr1QovhIuy4SsMnNF5sXnwjC7NCm8lgAJoUFA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><code>上图蓝线为应用集群调用get()方法访问缓存次数</code></li>
<li><code>上图绿线为获取缓存操作命中TMC本地缓存的次数</code></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iae7PHukxPgHAMHMV6J0DuPW3C5Omp9QicrRPoyXTMe55ERyqSEdPT9Zw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><code>上图为本地缓存命中率曲线图</code></li>
</ul>
<p>可以看出活动期间缓存请求量及本地缓存命中量均有明显增长，本地缓存命中率达到近 80%（即应用集群中 80% 的缓存查询请求被 TMC 本地缓存拦截）。</p>
<h3 id="热点缓存对应用访问的加速效果"><a href="#热点缓存对应用访问的加速效果" class="headerlink" title="热点缓存对应用访问的加速效果"></a>热点缓存对应用访问的加速效果</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaPxQnM4gynHMK9SjBrFmyX3UJicicAaSz5pfVDXKSEcZILXv6ibiaGMyBNQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><code>上图为应用接口 QPS 曲线</code></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iamtSn9gZruicrEDeYz0Bkt9BpguuH2ojUcslWuqRpOwrDcPodN8mpy5g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><code>上图为应用接口 RT 曲线</code></li>
</ul>
<p>可以看出活动期间应用接口的请求量有明显增长，由于 TMC 本地缓存的效果应用接口的 RT 反而出现下降。</p>
<h3 id="双十一期间部分应用-TMC-效果展示"><a href="#双十一期间部分应用-TMC-效果展示" class="headerlink" title="双十一期间部分应用 TMC 效果展示"></a>双十一期间部分应用 TMC 效果展示</h3><h4 id="商品域核心应用效果"><a href="#商品域核心应用效果" class="headerlink" title="商品域核心应用效果"></a><code>商品域核心应用效果</code></h4><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaFQcib5MA6WmF8RgOqFh74KWyXHOKcIBRNV1cZud4UVpZwwZrAYicibhSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="活动域核心应用效果"><a href="#活动域核心应用效果" class="headerlink" title="活动域核心应用效果"></a><code>活动域核心应用效果</code></h4><p><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaOJXDKynCBVfw1ziaQMHr6hia6LWzlDxstmoCBCof2vkovLPA76Fo3Izw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZb8b3k2DjtOgfiaj2iboVD5iaj9SmSB5R42ERiaWdLiaYw2Iy6qw02GWHg7HZqFKCJx5zNKxeWeLiaVcaA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="功能展望"><a href="#功能展望" class="headerlink" title="功能展望"></a>功能展望</h2><p>TMC 目前已为商品中心、物流中心、库存中心、营销活动、用户中心、网关&amp;消息等多个核心应用模块提供服务，后续应用也在陆续接入中。<br>TMC 在提供“热点探测” + “本地缓存”的核心能力同时，也为应用服务提供了灵活的配置选择，应用服务可以结合实际业务情况在“热点阈值”、“热点 key 探测数量”、“热点黑白名单”维度进行自由配置以达到更好的使用效果。</p>
<h2 id><a href="#" class="headerlink" title></a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/16/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0ForkJoin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/16/java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0ForkJoin/" class="post-title-link" itemprop="url">java线程之线程池ForkJoin</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-16 14:34:37" itemprop="dateCreated datePublished" datetime="2021-06-16T14:34:37+08:00">2021-06-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>
<p>我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure>

<p>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure>

<p>如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure>

<p>这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">long</span> expectedSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> SumTask(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Long result = ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="keyword">long</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="keyword">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, start, middle);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        Long result = subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个大的计算任务0~2000首先分裂为两个小任务0~1000和1000~2000，这两个小任务仍然太大，继续分裂为更小的0~500，500~1000，1000~1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p>
<p>核心代码<code>SumTask</code>继承自<code>RecursiveTask</code>，在<code>compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="comment">// 获得子任务的结果:</span></span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        <span class="comment">// 汇总结果:</span></span><br><span class="line">        <span class="keyword">return</span> subresult1 + subresult2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fork/Join线程池在Java标准库中就有应用。Java标准库提供的<code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。使用Fork/Join模式可以进行并行计算以提高效率。</p>
<p><code>ForkJoinPool</code>线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p>
<p><code>RecursiveAction</code>不带返回值，<code>RecursiveTask</code>带返回值,都是抽象类，继承抽象类<code>ForkJoinTask</code>，而它又实现Future接口。</p>
<p>重写了protected final boolean exec() 方法，调用方法protected abstract V compute();区别就是这个方法是否带有返回值。</p>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><ul>
<li><p>ForkJoinPool</p>
</li>
<li><p>ForkJoinTask implements Future<V></V></p>
</li>
<li><p>ForkJoinWorkerThread extends Thread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;                  <span class="comment">// the pool this thread works in</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue;   <span class="comment">// work-stealing mechanics</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/16/java%E7%BA%BF%E7%A8%8B%E4%B9%8BCompletableFuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/16/java%E7%BA%BF%E7%A8%8B%E4%B9%8BCompletableFuture/" class="post-title-link" itemprop="url">java线程之CompletableFuture</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-16 11:45:12" itemprop="dateCreated datePublished" datetime="2021-06-16T11:45:12+08:00">2021-06-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><p>提交给 CompletableFuture 执行的任务 有四种类型：Runnable、Consumer、Supplier、Function。简单说明这四种任务原型的对比。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/d7YzaYDnrxE0T1fr2rUd1MBuVib4u5Uh3B041DqplUOJbT6mPpfbialfeia7rOlNibGxfeqajjQIGxsKO3jicgVNkhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>runAsync 与 supplierAsync 是 CompletableFutre 的<strong>静态方法</strong>；而thenAccept、thenAsync、thenApply 是CompletableFutre的成员方法。<br><strong>runAsync（Runnable）</strong>    没有返回值的任务<br><strong>supplyAsync（Supplier）</strong>有返回值的任务。</p>
<p><strong>thenRun（Runnable）</strong> 跟的是一个无参数、无返回值的方法，即 Runnable，所以最终的返回值是 CompletableFuture<Void>类 型<br><strong>thenAccept（Consumer）</strong>跟的是一个有参数、无返回值的方法，称为 Consumer，返回值也是 CompletableFuture<Void>；类型。顾名 思义，只进不出，所以称为 Consumer；前面的 Supplier，是无参数，有返回值，只出不进，和 Consumer 刚好相反。<font color="red">异步任务结束时，会自动回调某个对象的方法；</font><br><strong>thenApply（Function）</strong>跟的是一个有参数、有返回值的方法，称为 Function。返回值是 CompletableFuture<String>；类型。而参数接收的是前一个任务，即 supplyAsync（..）这个任务的返回 值。因此这里只能用 supplyAsync，不能用 runAsync。因为 runAsync 没有返回值，不能为下一个链式方法传入参数。<br><strong>thenApplyAsync（Function）</strong> 异步任务结束之后再异步执行函数<br>exceptionally(e -&gt; { e.printStackTrace(); }) <font color="red">异步任务出错时，会自动回调某个对象的方法；</font>handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);也可以处理异常。区别是handle方法的回调函数，除了可以获取到异常还能获取到正常的返回值，即不管任务是否出错，都会执行handle流程。<br>get() 和join() 提供了<code>join()</code> 方法，它的功能和 get() 方法是一样的，都是阻塞获取值，它们的区别在于 join() 抛出的是 unchecked Exception。</String></Void></Void></p>
<p>因为初始的时候没有 CompletableFuture 对象，也没有参数可传，所以提交的只能是 Runnable 或者 Supplier，只能是静态方法；</p>
<p>通过静态方法生成 CompletableFuture 对象之后，便可以链式地提交其他任务了，这个时候就可以提交 Runnable、Consumer、Function且都是<strong>成员方法</strong>。</p>
<h2 id="串行和并行"><a href="#串行和并行" class="headerlink" title="串行和并行"></a>串行和并行</h2><p>串行执行：使用thenXXX方法，上一个任务执行完成之后执行下一个任务。<br>并行执行：</p>
<ul>
<li><p>多个任务并行：<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”。由于 allOf 聚合了多个 CompletableFuture 实例，所以它是没有返回值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture cfA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>);</span><br><span class="line">CompletableFuture cfB = CompletableFuture.supplyAsync(() -&gt; <span class="number">123</span>);</span><br><span class="line">CompletableFuture cfC = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultC&quot;</span>);</span><br><span class="line"> </span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.allOf(cfA, cfB, cfC);</span><br><span class="line"><span class="comment">// 所以这里的 join() 将阻塞，直到所有的任务执行结束</span></span><br><span class="line">future.join();</span><br></pre></td></tr></table></figure>
</li>
<li><p>二个任务并行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cfB = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultB&quot;</span>);</span><br><span class="line"><span class="comment">// 两个任务都执行完成，就执行指定的操作。</span></span><br><span class="line">cfA.thenAcceptBoth(cfB, (resultA, resultB) -&gt; &#123;&#125;);  <span class="comment">//后续的处理不需要返回值</span></span><br><span class="line">cfA.thenCombine(cfB, (resultA, resultB) -&gt; <span class="string">&quot;result A + B&quot;</span>); <span class="comment">//需要返回值</span></span><br><span class="line">cfA.runAfterBoth(cfB, () -&gt; &#123;&#125;);<span class="comment">//不需要 resultA 和 resultB</span></span><br><span class="line"><span class="comment">//两个任务中的其中一个执行完成，就执行指定的操作。</span></span><br><span class="line">cfA.acceptEither(cfB, result -&gt; &#123;&#125;);</span><br><span class="line">cfA.acceptEitherAsync(cfB, result -&gt; &#123;&#125;);</span><br><span class="line">cfA.acceptEitherAsync(cfB, result -&gt; &#123;&#125;, executorService);</span><br><span class="line"> </span><br><span class="line">cfA.applyToEither(cfB, result -&gt; &#123;<span class="keyword">return</span> result;&#125;);</span><br><span class="line">cfA.applyToEitherAsync(cfB, result -&gt; &#123;<span class="keyword">return</span> result;&#125;);</span><br><span class="line">cfA.applyToEitherAsync(cfB, result -&gt; &#123;<span class="keyword">return</span> result;&#125;, executorService);</span><br><span class="line"> </span><br><span class="line">cfA.runAfterEither(cfA, () -&gt; &#123;&#125;);</span><br><span class="line">cfA.runAfterEitherAsync(cfB, () -&gt; &#123;&#125;);</span><br><span class="line">cfA.runAfterEitherAsync(cfB, () -&gt; &#123;&#125;, executorService);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p>
<p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;System.out.println(<span class="string">&quot;price: &quot;</span> + result);&#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;&#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并行处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">queryCode</span><span class="params">(String name, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query code from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;601857&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">(String code, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query price from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>加了 <strong>Async</strong> 后缀的方法，代表将需要执行的任务放到 ForkJoinPool.commonPool() 中执行(非完全严谨)</p>
<p>CompletableFuture同时实现了两个接口，分别为Future和CompletionStage，CompletionStage是CompletableFuture提供的一些非常丰富的接口，可以借助这些接口来实现非常复杂的异步计算工作.</p>
<h2 id="CompletableFuture与Future区别"><a href="#CompletableFuture与Future区别" class="headerlink" title="CompletableFuture与Future区别"></a>CompletableFuture与Future区别</h2><p>Future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：</p>
<ol>
<li>将多个异步计算的结果合并成一个</li>
<li>等待Future集合中的所有任务都完成</li>
<li>Future完成事件（即，任务完成以后触发执行动作）</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/15/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/15/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">java并发之并发工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-15 10:55:34" itemprop="dateCreated datePublished" datetime="2021-06-15T10:55:34+08:00">2021-06-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理是Sync实现了<code>AQS</code>，初始化的时候确定count值。await()方法获取资源，当state不为0时，返回失败，失败则通过<code>addWaiter()</code>添加到同步队列中，堵塞线程；<code>countDown()</code>释放资源，使用<code>CAS</code>判断count的数量，<code>doReleaseShared()</code>唤醒等待队列中的线程。这二个方法tryAcquireShared(int acquires)和tryReleaseShared(int arg)，Sync静态内部类进行了重写。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h2><p>所有线程会等待全部线程到达栅栏之后才会继续执行，并且最后到达的线程会完成 Runnable 的任务。重点是使用Condition，堵塞在==等待队列==中。调用await()方法时，count=parties-1，当count为0时，执行barrierAction的run方法，重置generation对象，并执行trip.signalAll()方法将等待队列的线程，加入到同步队列中，LockSupport.unpark(node.thread)唤醒当前线程；当count不为0时，执行trip.await()或trip.awaitNanos(nanos)，将当前线程堵塞在等待队列中，LockSupport.park(this)暂停当前线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span>  <span class="comment">//用于唤醒/加入等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"><span class="comment">/** The number of parties */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span>  <span class="comment">//parties 是参与线程的个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> <span class="comment">//barrierAction最后一个到达线程要做的任务</span></span></span><br><span class="line"><span class="function"><span class="comment">//线程调用 await() 表示自己已经到达栅栏——》trip.await();</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class="line"><span class="function"><span class="comment">//BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="CyclicBarrier-与-CountDownLatch-区别"><a href="#CyclicBarrier-与-CountDownLatch-区别" class="headerlink" title="CyclicBarrier 与 CountDownLatch 区别"></a>CyclicBarrier 与 CountDownLatch 区别</h2><p>CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的</p>
<p>CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的。</p>
<p>CyclicBarrier的计数器由自己控制，而CountDownLatch的计数器则由使用者来控制，在CyclicBarrier中线程调用await方法不仅会将自己阻塞还会将计数器减1，而在CountDownLatch中线程调用await方法只是将自己阻塞而不会减少计数器的值。</p>
<p>另外，CountDownLatch只能拦截一轮，而CyclicBarrier可以实现循环拦截。一般来说用CyclicBarrier可以实现CountDownLatch的功能，而反之则不能</p>
<hr>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，线程池隔离。基于AQS实现，支持公平和非公平二种，堵塞在==同步队列==中。</p>
<p>实现互斥锁（计数器为 1） 我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p>
<h4 id="semaphore申请许可"><a href="#semaphore申请许可" class="headerlink" title="semaphore申请许可"></a>semaphore申请许可</h4><p>.acquire();</p>
<h4 id="semaphore释放许可"><a href="#semaphore释放许可" class="headerlink" title="semaphore释放许可"></a>semaphore释放许可</h4><p>.release();</p>
<h4 id="Semaphore与ReentrantLock"><a href="#Semaphore与ReentrantLock" class="headerlink" title="Semaphore与ReentrantLock"></a>Semaphore与ReentrantLock</h4><p>Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p>
<p>此外，Semaphore也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire与tryLock 不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p>
<p>Semaphore的锁释放操作也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在finally代码块中完成。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
