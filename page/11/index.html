<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/11/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java之IO流详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-17 20:06:42" itemprop="dateCreated datePublished" datetime="2020-12-17T20:06:42+08:00">2020-12-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://home.cnblogs.com/u/yichunguo/">宜春</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yichunguo/p/11775270.html">https://www.cnblogs.com/yichunguo/p/11775270.html</a></p>
<p>io流用到的地方很多，就比如上传下载，传输，设计模式等….基础打扎实了，才能玩更高端的。</p>
<p>真正懂IO流的优秀程序员每次在使用IO流之前都会明确分析如下四点：</p>
<blockquote>
<p>（1）明确要操作的数据是数据源还是数据目的(也就是要读还是要写)<br>（2）明确要操作的设备上的数据是字节还是文本<br>（3）明确数据所在的具体设备<br>（4）明确是否需要额外功能（比如是否需要转换流、高效流等）</p>
</blockquote>
<h1 id="1、IO流的四点明确"><a href="#1、IO流的四点明确" class="headerlink" title="1、IO流的四点明确"></a>1、IO流的四点明确</h1><p>（1）明确要操作的数据是数据源还是数据目的(要读还是要写)</p>
<blockquote>
<p>　源：<strong>InputStream　　Reader</strong><br>目的：<strong>OutputStream　　Writer</strong><br>（2）明确要操作的设备上的数据是字节还是文本<br>　源：字节： <strong>InputStream</strong>    文本： <strong>Reader</strong><br>目的：字节： <strong>OutputStream</strong>  文本： <strong>Writer</strong><br>（3）明确数据所在的具体设备<br>　　　源设备：<br>　　　　　　　　硬盘：文件 <code>File</code>开头<br>　　　　　　　　内存：数组，字符串<br>　　　　　　　　键盘：<code>System.in</code><br>　　　　　　　　网络：<code>Socket</code><br>　　对应目的设备：<br>　　　　　　　　硬盘：文件 <code>File</code>开头<br>　　　　　　　　内存：数组，字符串<br>　　　　　　　　屏幕：<code>System.out</code><br>　　　　　　　　网络：<code>Socket</code><br>（4）明确是否需要额外功能<br>　　需要转换—— 转换流 <strong>InputStreamReader 、OutputStreamWriter</strong><br>　　需要高效—— 缓冲流<strong>Bufferedxxx</strong><br>　　多个源—— 序列流 <strong>SequenceInputStream</strong><br>　　对象序列化—— <strong>ObjectInputStream、ObjectOutputStream</strong><br>　　保证数据的输出形式—— 打印流<strong>PrintStream 、Printwriter</strong><br>　　操作基本数据，保证字节原样性——<strong>DataOutputStream、DataInputStream</strong><br>到这里，我们再来看看IO流的分类吧<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014111930276.png" alt="在这里插入图片描述"></p>
</blockquote>
<h1 id="2、File类"><a href="#2、File类" class="headerlink" title="2、File类"></a>2、File类</h1><p>至于IO流，也就是输入输出流，从文件出发到文件结束，至始至终都离不开文件，所以IO流还得从文件File类讲起。</p>
<h2 id="1-1-File概述"><a href="#1-1-File概述" class="headerlink" title="1.1 File概述"></a>1.1 File概述</h2><p><code>java.io.File</code> 类是专门对文件进行操作的类，只能对文件本身进行操作，不能对文件内容进行操作。<br><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<p>怎么理解上面两句话？其实很简单！</p>
<p>第一句就是说File跟流无关，File类不能对文件进行读和写也就是输入和输出！<br>第二句就是说File主要表示类似<code>D:\\文件目录1</code>与<code>D:\\文件目录1\\文件.txt</code>,前者是文件夹（Directory）后者则是文件(file)，而File类就是操作这两者的类。</p>
<h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><p>在java中，一切皆是对象，File类也不例外，不论是哪个对象都应该从该对象的构造说起，所以博主来分析分析<code>File</code>类的构造方法。首先从API开始着手<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013095030887.png" alt="在这里插入图片描述"><br>我们主要来学习一下比较常用的三个：</p>
<p>1、 <code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。<br>2、 <code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。<br>3、 <code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。</p>
<p>看字描述不够生动不够形象不得劲？没得事，下面进行构造举例，马上就生动形象了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 一个File对象代表硬盘中实际存在的一个文件或者目录。</span><br><span class="line"><span class="number">2.</span>  File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。</span><br><span class="line"><span class="comment">// 文件路径名 </span></span><br><span class="line">String path = <span class="string">&quot;D:\\123.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(path); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String path2 = <span class="string">&quot;D:\\1\\2.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path2);     -------------相当于D:\\<span class="number">1</span>\\<span class="number">2.</span>txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;F:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);  --------相当于F:\\aaa\\bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;F:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child); --------相当于F:\\aaa\\bbb.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>File类的注意点：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><p>File的常用方法主要分为获取功能、获取绝对路径和相对路径、判断功能、创建删除功能的方法</p>
<h3 id="1-3-1-获取功能的方法"><a href="#1-3-1-获取功能的方法" class="headerlink" title="1.3.1 获取功能的方法"></a>1.3.1 获取功能的方法</h3><p>1、<code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。<br>2、<code>public String getPath()</code> ：将此File转换为路径名字符串。<br>3、<code>public String getName()</code> ：返回由此File表示的文件或目录的名称。<br>4、<code>public long length()</code> ：返回由此File表示的文件的长度。<br>以上方法测试，代码如下【注意测试以自己的电脑文件夹为准】：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">2116</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">3236</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>length()</code>，表示文件的长度。但是<code>File</code>对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="1-3-2-绝对路径和相对路径"><a href="#1-3-2-绝对路径和相对路径" class="headerlink" title="1.3.2 绝对路径和相对路径"></a>1.3.2 绝对路径和相对路径</h3><p><strong>绝对路径</strong>：一个完整的路径，以盘符开头，例如<code>F://aaa.txt</code>。<br><strong>相对路径</strong>：一个简化的路径，不以盘符开头,例如<code>//aaa.txt//b.txt</code>。</p>
<blockquote>
<p>1、<strong>路径是不区分大小写</strong><br>2、路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\java\bbb.java</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3判断功能的方法"><a href="#1-3-3判断功能的方法" class="headerlink" title="1.3.3判断功能的方法"></a>1.3.3判断功能的方法</h3><p>1、 <code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。<br>2、 <code>public boolean isDirectory()</code> ：此File表示的是否为目录。<br>3、<code>public boolean isFile()</code> ：此File表示的是否为文件。</p>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-创建删除功能的方法"><a href="#1-3-4-创建删除功能的方法" class="headerlink" title="1.3.4 创建删除功能的方法"></a>1.3.4 创建删除功能的方法</h3><ul>
<li><code>public boolean createNewFile()</code> ：文件不存在，创建一个新的空文件并返回<code>true</code>，文件存在，不创建文件并返回<code>false</code>。</li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。</li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<p>其中，<code>mkdirs()</code>和<code>mkdir()</code>方法类似，但<code>mkdir()</code>，只能创建一级目录，<code>mkdirs()</code>可以创建多级目录比如<code>//a//b//c</code>，所以<strong>开发中一般用</strong><code>mkdirs()</code>;</p>
<blockquote>
<p>这些方法中值得注意的是<strong>createNewFile</strong>方法以及<strong>mkdir</strong>与<strong>mkdirs</strong>的区别</p>
</blockquote>
<p>方法测试，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// 以及创建过了所以再使用createNewFile返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2= <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());	<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>delete</code>方法，如果此<code>File</code>表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul>
<li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;G:\光标&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013114927925.png" alt="在这里插入图片描述"><br><strong>listFiles</strong>在获取指定目录下的文件或者文件夹时必须满足下面两个条件</p>
<p>1，<strong>指定的目录必须存在</strong></p>
<p>2，<strong>指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException异常</strong></p>
<h2 id="1-5-递归遍历文件夹下所有文件以及子文件"><a href="#1-5-递归遍历文件夹下所有文件以及子文件" class="headerlink" title="1.5 递归遍历文件夹下所有文件以及子文件"></a>1.5 递归遍历文件夹下所有文件以及子文件</h2><p>不说啥了，直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归遍历文件夹下所有的文件</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RecursionDirectory</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">      File file=<span class="keyword">new</span> File(<span class="string">&quot;D:\\java专属IO测试&quot;</span>);</span><br><span class="line">        Recursion(file);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">Recursion</span>(<span class="params">File file</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1、判断传入的是否是目录</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">!file.isDirectory()</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//不是目录直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经确保了传入的file是目录</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">//遍历files</span></span><br><span class="line">        <span class="keyword">for</span> (File f: files) &#123;</span><br><span class="line">            <span class="comment">//如果该目录下文件还是个文件夹就再进行递归遍历其子目录</span></span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">f.isDirectory()</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                Recursion(f);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果该目录下文件是个文件，则打印对应的名字</span></span><br><span class="line">                System.out.println(f.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果对上面的代码有疑问，可以随时联系我，博主一直都在！</p>
<h1 id="3、初探IO流"><a href="#3、初探IO流" class="headerlink" title="3、初探IO流"></a>3、初探IO流</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>我想在座各位肯定经历都过这样的场景。当你编辑一个文本文件也好用eclipse打代码也罢，忘记了<code>ctrl+s</code> ，在你关闭文件的哪一瞬间手残点了个不该点的按钮，但你反应过来，心早已拔凉拔凉的了。</p>
<p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p>
<p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入也叫做读取数据，输出也叫做作写出数据</strong>。</p>
<h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong> 和 <strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。</li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p>根据数据的类型分为：<strong>字节流</strong> 和 <strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<p><strong>分类之后对应的超类</strong>（V8提示：超类也就是父类的意思）</p>
<table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td>字节输入流 <strong>InputStream</strong></td>
<td>字节输出流 <strong>OutputStream</strong></td>
</tr>
<tr>
<td>字符流</td>
<td>字符输入流 <strong>Reader</strong></td>
<td>字符输出流 <strong>Writer</strong></td>
</tr>
</tbody></table>
<p><strong>注</strong>：<br><strong>由这四个类的子类名称基本都是以其父类名作为子类名的后缀</strong>。<br>如：InputStream的子类FileInputStream。<br>如：Reader的子类FileReader。<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/image-20201217200816367.png" alt="image-20201217200816367" style="zoom:80%;"></p>
<h2 id="1-3-关于IO的分流向说明"><a href="#1-3-关于IO的分流向说明" class="headerlink" title="1.3 关于IO的分流向说明"></a>1.3 关于IO的分流向说明</h2><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013151622369.png" alt="在这里插入图片描述" style="zoom:80%;">
<img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015144401127.png" alt="在这里插入图片描述" style="zoom:80%;">

<h2 id="字节流OutputStream与InputStream的故事"><a href="#字节流OutputStream与InputStream的故事" class="headerlink" title="字节流OutputStream与InputStream的故事"></a>字节流OutputStream与InputStream的故事</h2><p>OutputStream与InputStream的继承关系<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015145625281.png" alt="在这里插入图片描述" style="zoom:80%;"></p>
<h2 id="2-1-文件的世界里一切皆为字节"><a href="#2-1-文件的世界里一切皆为字节" class="headerlink" title="2.1 文件的世界里一切皆为字节"></a>2.1 文件的世界里一切皆为字节</h2><p>我们必须明确一点的是，一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h2 id="2-2-字节输出流（OutputStream）"><a href="#2-2-字节输出流（OutputStream）" class="headerlink" title="2.2 字节输出流（OutputStream）"></a>2.2 字节输出流（OutputStream）</h2><p><code>java.io.OutputStream</code>抽象类是表示<strong>字节输出流</strong>的所有类的<strong>超类</strong>（父类），将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法，不要问我<code>OutputStream</code>为啥可以定义字节输出流的基本共性功能方法，熊dei啊，上一句说过了<strong>OutputStream是字节输出流的所有类的超类</strong>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44543508/article/details/102375196">继承</a>知识，懂？(如果是真的不理解的小白同学，可以点击蓝色字体<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44543508/article/details/102375196">继承</a>进入补习)</p>
<p><strong>字节输出流的基本共性功能方法</strong>:</p>
<blockquote>
<p>1、 <code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。<br>2、 <code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。<br>3、 <code>public void write(byte[] b)</code>：将 b.length个字节从指定的字节数组写入此输出流。<br>4、 <code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 <strong>也就是说从off个字节数开始读取一直到len个字节结束</strong><br>5、 <code>public abstract void write(int b)</code> ：将指定的字节输出流。</p>
</blockquote>
<blockquote>
<p><strong>以上五个方法则是字节输出流都具有的方法，由父类OutputStream定义提供，子类都会共享以上方法</strong></p>
</blockquote>
<h4 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h4><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类FileOutputStream开始。看名字就知道是文件输出流，用于将数据写出到文件。</p>
<h4 id="FileOutputStream构造方法"><a href="#FileOutputStream构造方法" class="headerlink" title="FileOutputStream构造方法"></a>FileOutputStream构造方法</h4><p>不管学啥子，只有是对象，就从构造方法开始！</p>
<blockquote>
<p>1、 <code>public FileOutputStream(File file)</code>：根据File对象为参数创建对象。<br>2、 <code>public FileOutputStream(String name)</code>： 根据名称字符串为参数创建对象。</p>
</blockquote>
<p><strong>推荐第二种构造方法</strong>【开发常用】：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;abc.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>就以上面这句代码来讲，类似这样创建字节输出流对象都做了<strong>三件事情</strong>：<br>1、调用系统功能去创建文件【输出流对象才会自动创建】<br>2、创建outputStream对象<br>3、把foutputStream对象指向这个文件</p>
<blockquote>
<p>注意：<br>创建输出流对象的时候，系统会自动去对应位置创建对应文件，而创建输出流对象的时候，文件不存在则会报FileNotFoundException异常，也就是系统找不到指定的文件异常。</p>
</blockquote>
<p>当你创建一个流对象时，必须直接或者间接传入一个文件路径。比如现在我们创建一个<code>FileOutputStream</code>流对象，在该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。有兴趣的童鞋可以测试一下，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\自动创建的文件夹\\a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileOutputStream写出字节数据"><a href="#FileOutputStream写出字节数据" class="headerlink" title="FileOutputStream写出字节数据"></a>FileOutputStream写出字节数据</h4><p>使用FileOutputStream写出字节数据主要通过<code>Write</code>方法，而<code>write</code>方法分如下三种</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> write(int b)</span><br><span class="line">public <span class="keyword">void</span> write(byte[] b)</span><br><span class="line">public <span class="keyword">void</span> write(byte[] b,int off,int len)  <span class="comment">//从`off`索引开始，`len`个字节</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol>
<li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;麻麻我想吃烤山药&quot;</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">麻麻我想吃烤山药</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从<code>off</code>索引开始，<code>len</code>个字节，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<h4 id="FileOutputStream实现数据追加续写、换行"><a href="#FileOutputStream实现数据追加续写、换行" class="headerlink" title="FileOutputStream实现数据追加续写、换行"></a>FileOutputStream实现数据追加续写、换行</h4><p>经过以上的代码测试，每次程序运行，每次创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续<strong>追加新数据</strong>呢？并且实现<strong>换行</strong>呢？其实很简单，这个时候我们又要再学习<code>FileOutputStream</code>的另外两个构造方法了，如下：</p>
<p>1、<code>public FileOutputStream(File file, boolean append)</code></p>
<p>2、<code>public FileOutputStream(String name, boolean append)</code></p>
<p>这两个构造方法，第二个参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示不追加也就是清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，至于Windows换行则是 <code>\n\r</code> ，下面将会详细讲到。</p>
<p>实现数据追加续写代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>

<p>Windows系统里，换行符号是<code>\r\n</code> ,具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>回车符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\r</span><br></pre></td></tr></table></figure>

<p>和换行符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  ：</p>
<ul>
<li><p>回车符：回到一行的开头（return）。</p>
</li>
<li><p>换行符：下一行（newline）。</p>
</li>
<li><p>系统中的换行：</p>
<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-3-字节输入流（InputStream）"><a href="#2-3-字节输入流（InputStream）" class="headerlink" title="2.3 字节输入流（InputStream）"></a>2.3 字节输入流（InputStream）</h2><p><code>java.io.InputStream</code>抽象类是表示<strong>字节输入流</strong>的所有类的<strong>超类</strong>（父类），可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<p><strong>字节输入流的基本共性功能方法</strong>:</p>
<blockquote>
<p>1、 <code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。<br>2、<code>public abstract int read()</code>： 从输入流读取数据的下一个字节。</p>
<p>3、 <code>public int read(byte[] b)</code>： 该方法返回的int值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1</p>
</blockquote>
<h4 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h4><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p>
<h4 id="FileInputStream的构造方法"><a href="#FileInputStream的构造方法" class="headerlink" title="FileInputStream的构造方法"></a>FileInputStream的构造方法</h4><blockquote>
<p>1、 <code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。<br>2、 <code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。</p>
</blockquote>
<p>同样的，推荐使用第二种构造方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileInputStream读取字节数据"><a href="#FileInputStream读取字节数据" class="headerlink" title="FileInputStream读取字节数据"></a>FileInputStream读取字节数据</h4><ol>
<li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码测试如下【read.txt文件中内容为abcde】：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);<span class="comment">//read.txt文件中内容为abcde</span></span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// read.txt文件中内容为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>由于<code>read.txt</code>文件中内容为<code>abcde</code>，而错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全<strong>替换</strong>【注意是替换，看下图】，所以要通过<code>len</code> ，获取有效的字节<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015160242904.png" alt="在这里插入图片描述" style="zoom:80%;"><br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>在开发中一般强烈推荐使用数组读取文件，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">input2</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>)</span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">            int len = <span class="number">0</span> ;</span><br><span class="line">            byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="built_in">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节流FileInputstream复制图片"><a href="#字节流FileInputstream复制图片" class="headerlink" title="字节流FileInputstream复制图片"></a>字节流FileInputstream复制图片</h4><p><strong>复制图片原理</strong><br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013204020152.png" alt="在这里插入图片描述" style="zoom:80%;"></p>
<p><strong>代码实现</strong></p>
<p>复制图片文件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：<strong>复制文本、图片、mp3、视频等的方式一样</strong>。</p>
<p>到这里，已经从File类讲到了字节流OutputStream与InputStream，而现在将主要从字符流Reader和Writer的故事开展。</p>
<h1 id="字符流Reader和Writer的故事"><a href="#字符流Reader和Writer的故事" class="headerlink" title="字符流Reader和Writer的故事"></a>字符流Reader和Writer的故事</h1><p>字符流Reader和Writer的故事从它们的继承图开始，啥都不说了，直接看图<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015171311217.png" alt="在这里插入图片描述" style="zoom:80%;"></p>
<h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p>字符流的由来：因为数据编码的不同，因而有了对字符进行高效操作的流对象，字符流本质其实就是基于字节流读取时，去查了指定的码表，而字节流直接读取数据会有乱码的问题（读中文会乱码），这个时候小白同学就看不懂了，没事，咋们先来看个程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//FileInputStream为操作文件的字符输入流</span></span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//内容为哥敢摸屎</span></span><br><span class="line"></span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print((char)len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：   ??￥??￠????±</span><br></pre></td></tr></table></figure>

<p>具体现状分析<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014113505625.png" alt="在这里插入图片描述" style="zoom:80%;"><br>话说，就是你哥我敢摸si,那你哥我肯定也不认识这玩意啊： <code>??￥??￠????±</code></p>
<blockquote>
<p>字节流读取中文字符时，可能不会显示完整的字符，那是因为一个中文字符占用多个字节存储。</p>
</blockquote>
<p>那字节流就没办法了吗？不，字节流依旧有办法，只是麻烦了点，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        byte[] bytes = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print(<span class="keyword">new</span> <span class="built_in">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果： 哥敢摸屎</span><br></pre></td></tr></table></figure>

<p>这是为啥呢？没错解码的正是<code>String</code>，查看<code>new String()</code>的源码，<code>String</code>构造方法有解码功能，并且默认编码是<code>utf-8</code>，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line"> </span><br><span class="line"> 再点进decode，循序渐进发现，默认编码是UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>尽管字节流也能有办法决绝乱码问题，但是还是比较麻烦，于是java就有了字符流，<code>字符为单位</code>读写数据，字符流<code>专门用于处理文本</code>文件。如果处理纯文本的数据优先考虑字符流，其他情况就只能用字节流了（图片、视频、等等<code>只文本</code>例外）。</p>
<blockquote>
<p>从另一角度来说：<strong>字符流 = 字节流 + 编码表</strong></p>
</blockquote>
<h1 id="1、-字符输入流（Reader）"><a href="#1、-字符输入流（Reader）" class="headerlink" title="1、 字符输入流（Reader）"></a>1、 字符输入流（Reader）</h1><p><code>java.io.Reader</code>抽象类是<strong>字符输入流</strong>的所有类的<strong>超类</strong>（父类），可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<p><strong>字符输入流的共性方法</strong>：</p>
<blockquote>
<p>1、<code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。<br>2、 <code>public int read()</code>： 从输入流读取一个字符。<br>3、 <code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</p>
</blockquote>
<h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<p>1、<code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的<strong>File对象</strong>。<br>2、 <code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的<strong>字符串名称</strong>。</p>
</blockquote>
<p>构造方法的使用就算不写应该都很熟悉了吧，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileReader读取字符数据"><a href="#FileReader读取字符数据" class="headerlink" title="FileReader读取字符数据"></a>FileReader读取字符数据</h3><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于读取的写法类似字节流的写法，只是读取单位不同罢了。</p>
<h1 id="2、字符输出流（Writer）"><a href="#2、字符输出流（Writer）" class="headerlink" title="2、字符输出流（Writer）"></a>2、字符输出流（Writer）</h1><p><code>java.io.Writer</code>抽象类是<strong>字符输出流</strong>的所有类的<strong>超类</strong>（父类），将指定的字符信息写出到目的地。它同样定义了字符输出流的基本共性功能方法。</p>
<p><strong>字符输出流的基本共性功能方法</strong>：</p>
<blockquote>
<p>1、<code>void write(int c)</code> 写入单个字符。<br>2、<code>void write(char[] cbuf)</code>写入字符数组。<br>3、 <code>abstract void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>4、 <code>void write(String str)</code>写入字符串。<br>5、<code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>6、<code>void flush()</code>刷新该流的缓冲。<br>7、<code>void close()</code> 关闭此流，但要先刷新它。</p>
</blockquote>
<h2 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h2><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、 <code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。<br>2、<code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</p>
<p>依旧是熟悉的构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 第一种：使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 第二种：使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileWriter写出数据"><a href="#FileWriter写出数据" class="headerlink" title="FileWriter写出数据"></a>FileWriter写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC</span><br></pre></td></tr></table></figure>

<blockquote>
<p>【注意】<strong>关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</strong></p>
</blockquote>
<h3 id="关闭close和刷新flush"><a href="#关闭close和刷新flush" class="headerlink" title="关闭close和刷新flush"></a>关闭close和刷新flush</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<p><code>flush</code> ：刷新缓冲区，流对象可以继续使用。<br><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<p>flush还是比较有趣的，童鞋们不自己运行一下还真不好体会，现在博主就写个程序让你体会体会：<br>字符流</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlushDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//源   也就是输入流【读取流】 读取a.txt文件</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);  <span class="comment">//必须要存在a.txt文件，否则报FileNotFoundException异常</span></span><br><span class="line">        <span class="comment">//目的地  也就是输出流</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);  <span class="comment">//系统会自动创建b.txt，因为它是输出流！</span></span><br><span class="line">        int len;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(len=fr.read())!=-<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">           fw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">   注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014222100212.png" alt="在这里插入图片描述" style="zoom:80%;">
运行效果是怎么样的呢？答案是b.txt文件中依旧是空的，是的并没有任何东西，为啥呢？熊dei啊，我在上面就用红色字体特别标注过了，就是这句话： 【注意】**关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。**这个时候反应过来了吧，可见实践例子的重要性，**编程就是这样，不去敲，永远学不会**！！！所以一定要去敲，博主没敲过10万行代码真的没有脸出去说自己是学java的。所以，大家一定要多思考，多敲啊！！！

<p>所以，我们在以上的代码中再添加下面三句代码，就完美了，b.txt文件就能复制到源文件的数据了！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fr.close();</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>flush()</code>这个函数是清空的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再用数据写到文件中，那么当你数据读完时，我们如果这时调用<code>close()</code>方法关闭读写流，这时就可能造成数据丢失，为什么呢？因为，读入数据完成时不代表写入数据完成，一部分数据可能会留在缓存区中，这个时候<code>flush()</code>方法就格外重要了。</p>
</blockquote>
<p>好了，接下来close使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h3 id="FileWriter的续写和换行"><a href="#FileWriter的续写和换行" class="headerlink" title="FileWriter的续写和换行"></a>FileWriter的续写和换行</h3><p><strong>续写和换行</strong>：操作类似于FileOutputStream操作（上一篇博客讲到过），直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;哥敢&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">      	fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">  		fw.write(<span class="string">&quot;摸屎&quot;</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">哥敢</span><br><span class="line">摸屎</span><br></pre></td></tr></table></figure>

<h3 id="FileReader和FileWriter类完成文本文件复制"><a href="#FileReader和FileWriter类完成文本文件复制" class="headerlink" title="FileReader和FileWriter类完成文本文件复制"></a>FileReader和FileWriter类完成文本文件复制</h3><p>直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\新建文件夹\\aa.txt&quot;</span>);<span class="comment">//文件不存在会抛出java.io.FileNotFoundException</span></span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\copyaa.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*创建输出流做的工作：</span></span><br><span class="line"><span class="comment">         *      1、调用系统资源创建了一个文件</span></span><br><span class="line"><span class="comment">         *      2、创建输出流对象</span></span><br><span class="line"><span class="comment">         *      3、把输出流对象指向文件        </span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//文本文件复制，一次读一个字符</span></span><br><span class="line">        copyMethod1(fr, fw);</span><br><span class="line">        <span class="comment">//文本文件复制，一次读一个字符数组</span></span><br><span class="line">        copyMethod2(fr, fw);</span><br><span class="line">        </span><br><span class="line">        fr.close();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> copyMethod1(FileReader fr, FileWriter fw) throws IOException &#123;</span><br><span class="line">        int ch;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(ch=fr.read())!=-<span class="number">1</span></span>)</span> &#123;<span class="comment">//读数据</span></span><br><span class="line">            fw.write(ch);<span class="comment">//写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> copyMethod2(FileReader fr, FileWriter fw) throws IOException &#123;</span><br><span class="line">        char chs[]=<span class="keyword">new</span> char[<span class="number">1024</span>];</span><br><span class="line">        int len=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(len=fr.read(chs))!=-<span class="number">1</span></span>)</span> &#123;<span class="comment">//读数据</span></span><br><span class="line">            fw.write(chs,<span class="number">0</span>,len);<span class="comment">//写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyFile</span><br></pre></td></tr></table></figure>

<img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014213256773.png" alt="在这里插入图片描述" style="zoom:80%;">

<blockquote>
<p><strong>最后再次强调：<br>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流</strong></p>
</blockquote>
<h3 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h3><p>我们在学习的过程中可能习惯把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，格式代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;哥敢摸si&quot;</span>); <span class="comment">//哥敢摸si</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果对异常不是特别熟练的童鞋可以参考这篇文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44543508/article/details/102211261">【java基础之异常】死了都要try，不淋漓尽致地catch我不痛快！</a></p>
<p>好了，到这里，字符流Reader和Writer的故事的到这里了！</p>
<p>前面主要写了一些基本的流作为IO流的入门。从这里开始将要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等，而这些强大的流都是在基本的流对象基础之上而来的！这些强大的流将伴随着我们今后的开发！</p>
<h1 id="1、缓冲流【掌握】"><a href="#1、缓冲流【掌握】" class="headerlink" title="1、缓冲流【掌握】"></a>1、缓冲流【掌握】</h1><h2 id="1-1-简要概述"><a href="#1-1-简要概述" class="headerlink" title="1.1 简要概述"></a>1.1 简要概述</h2><p>首先我们来认识认识一下缓冲流,也叫高效流，是对4个<code>FileXxx</code> 流的“增强流”。</p>
<p><strong>缓冲流的基本原理</strong>：</p>
<blockquote>
<p>1、使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。<br>2、通过缓冲区的read()方法从缓冲区获取具体的字符数据，这样就提高了效率。<br>3、如果用read方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了readLine()功能。</p>
</blockquote>
<p>也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<p>缓冲书写格式为<code>BufferedXxx</code>，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code></li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>InputStream</strong>。</li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>OutputStream</strong>。</li>
</ul>
<p>构造举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方式一： 创建字节缓冲输入流【但是开发中一般常用下面的格式申明】</span></span><br><span class="line">FileInputStream fps = <span class="keyword">new</span> FileInputStream(b.txt);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fps)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方式一： 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">///构造方式二： 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="感受缓冲流的高效"><a href="#感受缓冲流的高效" class="headerlink" title="感受缓冲流的高效"></a>感受缓冲流的高效</h3><p>缓冲流读写方法与基本的流是一致的，我们通过复制370多MB的大文件，测试它的效率。</p>
<ol>
<li>基本流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>);<span class="comment">//exe文件够大</span></span><br><span class="line">        	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>)</span><br><span class="line">        )&#123;</span><br><span class="line">        	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不好意思十分钟过去了还在玩命复制中...</span><br></pre></td></tr></table></figure>

<ol>
<li>缓冲流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">         BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>));</span><br><span class="line">	     BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure>

<p>有的童鞋就要说了，我要更快的速度！最近看速度与激情7有点上头，能不能再快些？答案是当然可以</p>
<p>想要更快可以使用数组的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">      	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">		 BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>));</span><br><span class="line">		 BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">521</span> 毫秒  </span><br></pre></td></tr></table></figure>

<h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><p>相同的来看看其构造，其格式以及原理和字节缓冲流是一样一样的！</p>
<ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>Reader</strong>。</li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>Writer</strong>。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流特有方法"><a href="#字符缓冲流特有方法" class="headerlink" title="字符缓冲流特有方法"></a>字符缓冲流特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的<strong>特有</strong>方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: <strong>读一行数据</strong>。 读取到最后返回null</li>
<li>BufferedWriter：<code>public void newLine()</code>: <strong>换行</strong>,由系统属性定义符号。</li>
</ul>
<p><code>readLine</code>方法演示代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	 <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newLine</code>方法演示代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    	<span class="comment">// 创建流对象</span></span><br><span class="line">  	BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line">    	<span class="comment">// 写出数据</span></span><br><span class="line">      bw.write(<span class="string">&quot;哥&quot;</span>);</span><br><span class="line">    	<span class="comment">// 写出换行</span></span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;敢&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;摸屎&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;你敢吗？&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">  	<span class="comment">// 释放资源</span></span><br><span class="line">      bw.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">哥</span><br><span class="line">敢</span><br><span class="line">摸屎</span><br><span class="line">你敢吗？</span><br></pre></td></tr></table></figure>

<h2 id="1-4-字符缓冲流练习"><a href="#1-4-字符缓冲流练习" class="headerlink" title="1.4 字符缓冲流练习"></a>1.4 字符缓冲流练习</h2><p>字符缓冲流练习啥捏？先放松一下吧各位，先欣赏欣赏我写的下面的诗篇</p>
<blockquote>
<p>6.你说你的程序叫简单，我说我的代码叫诗篇<br>1.一想到你我就哦豁豁豁豁豁豁豁豁豁豁….哦nima个头啊，完全不理人家受得了受不了<br>8.Just 简单你和我 ，Just 简单程序员<br>3.约了地点却忘了见面 ，懂得寂寞才明白浩瀚<br>5.沉默是最大的发言权<br>2.总是喜欢坐在电脑前， 总是喜欢工作到很晚<br>7.向左走 又向右走，我们转了好多的弯<br>4.你从来就不问我，你还是不是那个程序员</p>
</blockquote>
<p>欣赏完了咩？没错咋们就练习如何使用缓冲流的技术把上面的诗篇归顺序，都编过号了就是前面的1到8的编号</p>
<p>分析：首先用字符输入缓冲流创建个源，里面放没有排过序的文字，之后用字符输出缓冲流创建个目标接收，排序的过程就要自己写方法了哦，可以从每条诗词的共同点“.”符号下手！</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象  源</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//目标</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            String key = String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            String value = lineMap.get(key);</span><br><span class="line">          	<span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">&quot;.&quot;</span>+value);</span><br><span class="line">          	<span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>一想到你我就哦豁豁豁豁豁豁豁豁豁豁…哦nima个头啊，完全不理人家受得了受不了</span><br><span class="line"><span class="number">2.</span>总是喜欢坐在电脑前， 总是喜欢工作到很晚</span><br><span class="line"><span class="number">3.</span>约了地点却忘了见面 ，懂得寂寞才明白浩瀚</span><br><span class="line"><span class="number">4.</span>你从来就不问我，你还是不是那个程序员</span><br><span class="line"><span class="number">5.</span>沉默是最大的发言权</span><br><span class="line"><span class="number">6.</span>你说你的程序叫简单，我说我的代码叫诗篇</span><br><span class="line"><span class="number">7.</span>向左走 又向右走，我们转了好多的弯</span><br><span class="line"><span class="number">8.</span>Just 简单你和我 ，Just 简单程序员</span><br></pre></td></tr></table></figure>

<h1 id="2、转换流【掌握】"><a href="#2、转换流【掌握】" class="headerlink" title="2、转换流【掌握】"></a>2、转换流【掌握】</h1><p>何谓转换流？为何由来？暂时带着问题让我们先来了解了解字符编码和字符集！<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/2019101609401732.png" alt="在这里插入图片描述" style="zoom:80%;"></p>
<h3 id="2-1-字符编码与解码"><a href="#2-1-字符编码与解码" class="headerlink" title="2.1 字符编码与解码"></a>2.1 字符编码与解码</h3><p>众所周知，计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照<code>A</code>规则存储，同样按照<code>A</code>规则解析，那么就能显示正确的文本符号。反之，按照<code>A</code>规则存储，再按照<code>B</code>规则解析，就会导致乱码现象。</p>
<p>简单一点的说就是：</p>
<blockquote>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
</blockquote>
<p>代码解释则是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName):通过指定的字符集解码字节数组</span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组</span><br><span class="line"></span><br><span class="line">编码:把看得懂的变成看不懂的</span><br><span class="line">String -- <span class="keyword">byte</span>[]</span><br><span class="line"></span><br><span class="line">解码:把看不懂的变成看得懂的</span><br><span class="line"><span class="keyword">byte</span>[] -- String</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>字符编码</strong> <code>Character Encoding</code>: 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>而<strong>编码表</strong>则是生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li><strong>字符集</strong> <code>Charset</code>：也叫<strong>编码表</strong>。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有<code>ASCII</code>字符集、<code>GBK</code>字符集、<code>Unicode</code>字符集等。<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016090127127.png" alt="在这里插入图片描述" style="zoom:80%;"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><p>ASCII字符集：</p>
<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
</ul>
</li>
<li><p>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</p>
</li>
<li><p>ISO-8859-1字符集：</p>
<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
</ul>
</li>
<li><p>ISO-8859-1使用单字节编码，兼容ASCII编码。</p>
</li>
<li><p>GBxxx字符集：</p>
<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
</ul>
</li>
<li><p><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p>
<ul>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><p>Unicode字符集：</p>
<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
</ul>
</li>
<li><p>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</p>
<ul>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：</li>
</ul>
<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。</li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
<h2 id="2-2-编码问题导致乱码"><a href="#2-2-编码问题导致乱码" class="headerlink" title="2.2 编码问题导致乱码"></a>2.2 编码问题导致乱码</h2><p>在java开发工具IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：���</span><br></pre></td></tr></table></figure>

<p>那么如何读取GBK编码的文件呢？ 这个时候就得讲讲转换流了！</p>
<blockquote>
<p>从另一角度来讲：<strong>字符流=字节流+编码表</strong></p>
</blockquote>
<h2 id="2-3-InputStreamReader类—–-字节流到字符流的桥梁"><a href="#2-3-InputStreamReader类—–-字节流到字符流的桥梁" class="headerlink" title="2.3 InputStreamReader类—–(字节流到字符流的桥梁)"></a>2.3 InputStreamReader类—–(字节流到字符流的桥梁)</h2><p>转换流<code>java.io.InputStreamReader</code>，是<code>Reader</code>的子类，从字面意思可以看出它是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<p><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。<br><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p>
</blockquote>
<p>构造代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用转换流解决编码问题"><a href="#使用转换流解决编码问题" class="headerlink" title="使用转换流解决编码问题"></a>使用转换流解决编码问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        String FileName = <span class="string">&quot;C:\\A.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">      	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">		<span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">      	<span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read); <span class="comment">// �����ʺ      </span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 哥敢摸屎</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-OutputStreamWriter类—–-字符流到字节流的桥梁"><a href="#2-4-OutputStreamWriter类—–-字符流到字节流的桥梁" class="headerlink" title="2.4 OutputStreamWriter类—–(字符流到字节流的桥梁)"></a>2.4 OutputStreamWriter类—–(字符流到字节流的桥梁)</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，字面看容易混淆会误以为是转为字符流，其实不然，OutputStreamWriter为从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<p><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。<br><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p>
</blockquote>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="指定编码构造代码"><a href="#指定编码构造代码" class="headerlink" title="指定编码构造代码"></a>指定编码构造代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径</span></span><br><span class="line">        String FileName = <span class="string">&quot;C:\\s.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw.write(<span class="string">&quot;哥敢&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 定义文件路径</span></span><br><span class="line">		String FileName2 = <span class="string">&quot;D:\\A.txt&quot;</span>;</span><br><span class="line">     	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw2.write(<span class="string">&quot;摸屎&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016100612927.png" alt="在这里插入图片描述"><br>为了达到<strong>最高效率</strong>，可以考虑在 <code>BufferedReader</code> 内包装 <code>InputStreamReader</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader <span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))；</span><br></pre></td></tr></table></figure>

<h1 id="3、序列化流【理解】"><a href="#3、序列化流【理解】" class="headerlink" title="3、序列化流【理解】"></a>3、序列化流【理解】</h1><blockquote>
<p>(1)可以把对象写入文本文件或者在网络中传输<br>(2)如何实现序列化呢?<br>让被序列化的对象所属类实现序列化接口。<br>该接口是一个标记接口。没有功能需要实现。<br>(3)注意问题：<br>把数据写到文件后，在去修改类会产生一个问题。<br>如何解决该问题呢?<br>在类文件中，给出一个固定的序列化id值。<br>而且，这样也可以解决黄色警告线问题<br>(4)面试题：<br>什么时候序列化?<br>如何实现序列化?<br>什么是反序列化?</p>
</blockquote>
<h2 id="3-1-何谓序列化"><a href="#3-1-何谓序列化" class="headerlink" title="3.1 何谓序列化"></a>3.1 何谓序列化</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化：<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016100818120.png" alt="在这里插入图片描述"></p>
<h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</p>
<p>构造代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aa.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>

<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<p>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</p>
<p>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写出对象方法</p>
<p><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    	Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    	e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    	e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">    	e.age = <span class="number">20</span>; </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">      		<span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">        	<span class="comment">// 写出对象</span></span><br><span class="line">        	out.writeObject(e);</span><br><span class="line">        	<span class="comment">// 释放资源</span></span><br><span class="line">        	out.close();</span><br><span class="line">        	fileOut.close();</span><br><span class="line">        	System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</p>
<h3 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</p>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;		</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">             ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        	<span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);	<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong></p>
<h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a>反序列化操作2</h3><p>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。发生这个异常的原因如下：</p>
<blockquote>
<p>1、该类的序列版本号与从流中读取的类描述符的版本号不匹配<br>2、该类包含未知数据类型<br>2、该类没有可访问的无参数构造方法</p>
</blockquote>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-序列化集合练习"><a href="#3-4-序列化集合练习" class="headerlink" title="3.4 序列化集合练习"></a>3.4 序列化集合练习</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例代码实现"><a href="#案例代码实现" class="headerlink" title="案例代码实现"></a>案例代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 学生对象</span></span><br><span class="line">		Student student = <span class="keyword">new</span> Student(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;laow&quot;</span>);</span><br><span class="line">		Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;老张&quot;</span>, <span class="string">&quot;laoz&quot;</span>);</span><br><span class="line">		Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;老李&quot;</span>, <span class="string">&quot;laol&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		arrayList.add(student);</span><br><span class="line">		arrayList.add(student2);</span><br><span class="line">		arrayList.add(student3);</span><br><span class="line">		<span class="comment">// 序列化操作</span></span><br><span class="line">		<span class="comment">// serializ(arrayList);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 反序列化  </span></span><br><span class="line">		ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">		ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line">		</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          	Student s = list.get(i);</span><br><span class="line">        	System.out.println(s.getName()+<span class="string">&quot;--&quot;</span>+ s.getPwd());</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 序列化流 </span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 写出对象</span></span><br><span class="line">		oos.writeObject(arrayList);</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、打印流【掌握】"><a href="#4、打印流【掌握】" class="headerlink" title="4、打印流【掌握】"></a>4、打印流【掌握】</h1><h2 id="4-1-何谓打印流"><a href="#4-1-何谓打印流" class="headerlink" title="4.1 何谓打印流"></a>4.1 何谓打印流</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，各位用了这么久的输出语句肯定没想过这两个方法都来自于<code>java.io.PrintStream</code>类吧，哈哈。该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<p><strong>打印流分类</strong>：</p>
<blockquote>
<p>字节打印流PrintStream，字符打印流PrintWriter</p>
</blockquote>
<p><strong>打印流特点</strong>：</p>
<blockquote>
<p>A:只操作目的地,不操作数据源<br>B:可以操作任意类型的数据<br>C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新<br>D:可以直接操作文件</p>
</blockquote>
<p>这个时候有同学就要问了，哪些流可以直接操作文件呢?答案很简单，<strong>如果该流的构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的</strong>！</p>
<p>PrintStream是OutputStream的子类，PrintWriter是Writer的子类，两者处于对等的位置上，所以它们的API是非常相似的。二者区别无非一个是字节打印流，一个是字符打印流。</p>
<h2 id="4-2-字节输出打印流PrintStream复制文本文件"><a href="#4-2-字节输出打印流PrintStream复制文本文件" class="headerlink" title="4.2 字节输出打印流PrintStream复制文本文件"></a>4.2 字节输出打印流PrintStream复制文本文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;copy.txt&quot;</span>));</span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> PrintStream(<span class="string">&quot;printcopy.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> line;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(line=br.readLine())!=<span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            ps.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-字符输出打印流PrintWriter复制文本文件"><a href="#4-3-字符输出打印流PrintWriter复制文本文件" class="headerlink" title="4.3 字符输出打印流PrintWriter复制文本文件"></a>4.3 字符输出打印流PrintWriter复制文本文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用打印流复制文本文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;aa.txt&quot;</span>));</span><br><span class="line">        PrintWriter pw=<span class="keyword">new</span> PrintWriter(<span class="string">&quot;printcopyaa.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> line;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(line=br.readLine())!=<span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            pw.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、Properties属性类"><a href="#5、Properties属性类" class="headerlink" title="5、Properties属性类"></a>5、Properties属性类</h1><p>我想各位对这个Properties类多多少少也接触过了，首先Properties类并不在IO包下，那为啥要和IO流一起讲呢？原因很简单因为properties类经常和io流的联合一起使用。</p>
<blockquote>
<p>(1)是一个集合类，Hashtable的子类<br>(2)特有功能<br>A:public Object setProperty(String key,String value)<br>B:public String getProperty(String key)<br>C:public Set stringPropertyNames()<br>(3)和IO流结合的方法<br>把键值对形式的文本文件内容加载到集合中<br>public void load(Reader reader)<br>public void load(InputStream inStream)<br>把集合中的数据存储到文本文件中<br>public void store(Writer writer,String comments)<br>public void store(OutputStream out,String comments)</p>
</blockquote>
<h2 id="5-1-Properties概述"><a href="#5-1-Properties概述" class="headerlink" title="5.1 Properties概述"></a>5.1 Properties概述</h2><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public Properties()</code> :创建一个空的属性列表。</p>
<h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li>
<li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><p><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</p>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。现在文本数据格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename=Properties.txt</span><br><span class="line">length=<span class="number">123</span></span><br><span class="line">location=C:\Properties.txt</span><br></pre></td></tr></table></figure>

<p>加载代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Properties.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- Properties.txt</span><br><span class="line">length -- <span class="number">123</span></span><br><span class="line">location -- C:\Properties.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">Spring注解之@Import注解的三种使用方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-17 18:27:26" itemprop="dateCreated datePublished" datetime="2020-12-17T18:27:26+08:00">2020-12-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1、-Import注解须知"><a href="#1、-Import注解须知" class="headerlink" title="1、@Import注解须知"></a>1、@Import注解须知</h2><blockquote>
<p>1、**@Import只能用在类上** ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中</p>
<p>2、加入IOC容器的方式有很多种，@Import注解就相对很牛皮了，**@Import注解可以用于导入第三方包** ，当然@Bean注解也可以，但是@Import注解快速导入的方式更加便捷</p>
<p>3、@Import注解有三种用法</p>
</blockquote>
<h2 id="2、-Import的三种用法"><a href="#2、-Import的三种用法" class="headerlink" title="2、@Import的三种用法"></a>2、@Import的三种用法</h2><p>@Import的三种用法主要包括：</p>
<blockquote>
<p>1、直接填class数组方式<br>2、ImportSelector方式【重点】<br>3、ImportBeanDefinitionRegistrar方式</p>
</blockquote>
<h4 id="2-1、第一种用法：直接填class数组"><a href="#2-1、第一种用法：直接填class数组" class="headerlink" title="2.1、第一种用法：直接填class数组"></a>2.1、第一种用法：直接填class数组</h4><p><strong>直接填对应的class数组，class数组可以有0到多个。</strong></p>
<p>语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123; 类名.class , 类名.class... &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的import的bean都将加入到spring容器中，这些在容器中bean名称是该类的<strong>全类名</strong> ，比如com.yc.类名</p>
<h4 id="2-2、第二种用法：ImportSelector方式【重点】"><a href="#2-2、第二种用法：ImportSelector方式【重点】" class="headerlink" title="2.2、第二种用法：ImportSelector方式【重点】"></a>2.2、第二种用法：ImportSelector方式【重点】</h4><p>这种方式的前提就是一个类要实现ImportSelector接口，假如我要用这种方法，目标对象是Myclass这个类，分析具体如下：</p>
<p>创建Myclass类并实现ImportSelector接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"><span class="comment">//既然是接口肯定要实现这个接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析实现接口的selectImports方法中的：</p>
<ul>
<li>1、返回值： 就是我们实际上要导入到容器中的组件全类名【<strong>重点</strong> 】</li>
<li>2、参数： AnnotationMetadata表示当前被@Import注解给标注的所有注解信息【不是重点】</li>
</ul>
<blockquote>
<p>需要注意的是selectImports方法可以返回空数组但是不能返回null，否则会报空指针异常！</p>
</blockquote>
<p>以上分析完毕之后，具体用法步骤如下：</p>
<p>第一步：创建Myclass类并实现ImportSelector接口，这里用于演示就添加一个全类名给其返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> <span class="title">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span>[] <span class="function"><span class="title">selectImports</span>(<span class="params">AnnotationMetadata annotationMetadata</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">&quot;com.yc.Test.TestDemo3&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：编写TestDemo 类，并标注上使用ImportSelector方式的Myclass类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;TestDemo2.class,Myclass.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AccountDao2 <span class="title">accountDao2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AccountDao2();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，宜春故意挑了个龙套角色@Bean注解，若对@Bean注解不是很清晰的童鞋可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44543508/article/details/103718958">大白话讲解Spring的@bean注解</a></p>
<p>第三步：编写打印容器中的组件测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印容器中的组件测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext=<span class="keyword">new</span> AnnotationConfigApplicationContext(TestDemo.class);  <span class="comment">//这里的参数代表要做操作的类</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : beanDefinitionNames)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：运行结果<br><img src="/2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/20191227145414510.png" alt="在这里插入图片描述"></p>
<h4 id="2-3、第三种用法：ImportBeanDefinitionRegistrar方式"><a href="#2-3、第三种用法：ImportBeanDefinitionRegistrar方式" class="headerlink" title="2.3、第三种用法：ImportBeanDefinitionRegistrar方式"></a>2.3、第三种用法：ImportBeanDefinitionRegistrar方式</h4><p>同样是一个接口，类似于第二种ImportSelector用法，相似度80%，只不过这种用法比较自定义化注册，具体如下：</p>
<p>第一步：创建Myclass2类并实现ImportBeanDefinitionRegistrar接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass2</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="comment">//该实现方法默认为空</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数分析：</p>
<ul>
<li>第一个参数：annotationMetadata 和之前的ImportSelector参数一样都是表示当前被@Import注解给标注的所有注解信息</li>
<li>第二个参数表示用于注册定义一个bean</li>
</ul>
<p>第二步：编写代码，自定义注册bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass2</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定bean定义信息（包括bean的类型、作用域...）</span></span><br><span class="line">        RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(TestDemo4.class);</span><br><span class="line">        <span class="comment">//注册一个bean指定bean名字（id）</span></span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">&quot;TestDemo4444&quot;</span>,rootBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：编写TestDemo 类，并标注上使用ImportBeanDefinitionRegistrar方式的Myclass2类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;TestDemo2.class,Myclass.class,Myclass2.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AccountDao2 <span class="title">accountDao222</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AccountDao2();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：运行结果<br><img src="/2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/2019122715572214.png" alt="在这里插入图片描述"></p>
<h2 id="3、-Import注解的三种使用方式总结"><a href="#3、-Import注解的三种使用方式总结" class="headerlink" title="3、@Import注解的三种使用方式总结"></a>3、@Import注解的三种使用方式总结</h2><blockquote>
<p>第一种用法：<code>@Import</code>（{ 要导入的容器中的组件 } ）：容器会自动注册这个组件，<strong>id默认是全类名</strong></p>
<p>第二种用法：<code>ImportSelector</code>：返回需要导入的组件的全类名数组，springboot底层用的特别多【<strong>重点</strong> 】</p>
<p>第三种用法：<code>ImportBeanDefinitionRegistrar</code>：手动注册bean到容器</p>
</blockquote>
<p><strong>以上三种用法方式皆可混合在一个@Import中使用，特别注意第一种和第二种都是以全类名的方式注册，而第三中可自定义方式。</strong></p>
<p>@Import注解本身在springboot中用的很多，特别是其中的第二种用法ImportSelector方式在springboot中使用的特别多，尤其要掌握！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Spring生态简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-17 18:10:46" itemprop="dateCreated datePublished" datetime="2020-12-17T18:10:46+08:00">2020-12-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/nuccch/">2Simple</a><br>出处：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/nuccch/">http://www.cnblogs.com/nuccch/</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>做Java开发的人一提起Spring，首先在脑海中浮现出的就是“IoC”，“AOP”，“Spring MVC”，“Spring Security”等等这些名词，甚至大有“无Spring不Java”的感慨。<br>实际上，时至今日Spring已不再是一个简单的编程框架了，从最初的“SSH框架”发展到今天，Struts和Hibernate都几乎快要从程序员视野中消失了，而Spring却发展成了一个非常庞大且完整的生态。<br>所以说，除非特别指明是Spring生态中的某个具体框架，否则提起“Spring”应该指的是整个Spring生态。<br>说句不夸张的话，Java程序员只要精通了Spring，也就掌握了Java开发的精髓。</p>
<p>在整个Spring生态中包含了许多应用在特定场景的具体框架，如：“Spring Framework”，“Spring Security”，“Spring Boot”，“Spring Cloud”等等，其中“Spring Framework”框架是整个生态的核心基础，其他框架都需要依赖“Spring Framework”提供的基础功能，而且每个框架都有自己独立的代码仓库。</p>
<h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p>Spring生态下的项目分为3类：主要项目（Main Projects），社区项目（Community Projects），已经终止但是目前还保留的项目（Projects in the Attic）。<br>最新的Spring生态项目列表详见：<a target="_blank" rel="noopener" href="https://spring.io/projects">https://spring.io/projects</a> 。</p>
<h3 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h3><p>目前，Spring生态中包含22个主要活跃的项目。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014708455-34471552.png" alt="Spring生态主要项目"></p>
<p><strong>1.Spring Framework</strong></p>
<p>Spring Framework项目是整个Spring生态的基础，包含了Spring最核心的功能，如：IoC，AOP，Spring MVC等，其他项目都需要依赖Spring Framework。<br>另外，还<strong>需要注意</strong>的是Spring Framework项目又包含多个子模块，如：spring-core，spring-beans，spring-context，spring-aop，spring-web，spring-webmvc等等。实际上，Spring Framework项目是一个模块化的架构，各模块之间又存在依赖关系。我们在Java Web后台项目中使用得最多的Spring MVC实际上就是模块spring-webmvc，它与其他模块的依赖关系如下所示：<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014737034-413265330.png" alt="Spring MVC对其他模块的依赖关系"></p>
<p>显然，<code>spring-webmvc</code>模块依赖<code>spring-context</code>，<code>spring-aop</code>和<code>spring-web</code>。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014801760-484921515.png" alt="spring-webmvc模块的依赖关系"></p>
<p><strong>2.Spring Boot</strong></p>
<p>Spring Boot是一个开发基于Spring的脚手架项目，它默认集成了嵌入式Tomcat，配置注解化，支持快速集成第三方开发组件（如MyBatis），大大降低了使用Spring的门槛，而且内置了许多可以直接用于生产环境的功能，是目前用于开发微服务架构项目的不二选择。<br><strong>值得注意的是：</strong> 许多人刚接触Spring Boot的人把它神话了，固然使用Spring Boot能快速开发一个健壮的、可直接运行的项目，但是它的核心和基础来源于Spring Framework。对于重度依赖Spring的开发人员，应该先去吃透Spring Framework，只要真正掌握了Spring Framework中各个模块的实现原理，对于在实际开发中使用Spring Boot遇到的问题也就迎刃而解了。</p>
<p><strong>3.Spring Cloud</strong></p>
<p>Spring Cloud为开发基于微服务架构的软件系统提供了一整套工具集合，其中包含了开发各个微服务组件的具体项目，如：Spring Cloud Config（配置中心），Spring Cloud Netflix（服务注册中心），Spring Cloud Sleuth（服务调用监控），Spring Cloud Gateway（服务网关）等等。<br>Spring Cloud的基础是Spring Boot，基于Spring Boot可以大大简化开发各微服务组件的流程。</p>
<p><strong>4.Spring Cloud Data Flow</strong></p>
<p>Spring Cloud Data Flow用于构建在云环境或K8S中基于微服务的实时或批数据处理架构，具体来讲就是支持一系列需要进行数据处理的场景，如：ETL，数据导入/导出，事件流，预测分析等等。</p>
<p><strong>5.Spring Data</strong></p>
<p>Spring Data旨在提供一套基于Spring编程模型的数据访问API，是一个数据访问框架集合，其中包含了多个具体的支持不同方式访问特定数据库类型的子模块，如：Spring Data JDBC（使用JDBC方式访问关系型数据库），Spring Data MongoDB（访问MongoDB数据库）等。<br>这个模块的功能类似于<a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis</a>这样的专门的ORM框架，在实际开发中可以根据需求进行灵活选择。</p>
<p><strong>6.Spring Integration</strong></p>
<p>Spring Integration的目的是提供一个简单的模型，用于构建企业级应用集成解决方案。</p>
<p><strong>7.Spring Batch</strong></p>
<p>Spring Batch是一个轻量级的批处理框架，旨在开发对企业系统日常运营至关重要的强大批处理应用程序。<br>支持事务管理，提供了基于Web的管理接口。</p>
<p><strong>8.Spring Security</strong></p>
<p>Spring Security是用于实现认证和授权，以及访问控制的安全框架，在Java生态与之提供类似的功能还有一个框架：<a target="_blank" rel="noopener" href="https://shiro.apache.org/">Apache Shiro</a>。<br>Spring Security依赖于Spring Framework，也就是说如果要Spring Security，那么应用架构也必须是基于Spring Framework的，这大大限制了Spring Security的使用场景；反之，Shiro就没有这样限制，而且从项目架构上Shiro更加简洁。当然，Spring Security提供了非常丰富的安全控制的功能，在某些方面甚至比Shiro更加完善，与之对应的是掌握的Spring Security的复杂度比较大。因此，对于在应用中是否选择Spring Security需要根据实际需求来决定。</p>
<p><strong>9.Spring HATEOAS</strong></p>
<p>如果Web应用基于Spring框架（即：使用了Spring MVC）开发，那么可以直接使用<code>Spring HATEOAS</code>来开发满足<code>HATEOAS</code>约束的RESTFul服务。<br>这里需要理解一个单词简写：“HATEOAS”。HATEOAS（Hypermedia as the engine of application state）是REST架构风格中最复杂的约束，也是构建成熟REST服务的核心。它的重要性在于打破了客户端和服务器之间严格的契约，使得客户端可以更加智能和自适应，而 REST 服务本身的演化和更新也变得更加容易。</p>
<p><strong>10.Spring REST Docs</strong></p>
<p>Spring REST Docs是一个文档工具，用于为REST架构风格的Web服务自动生成相应的文档，这样可以解放开发者专门撰写API文档的工作。</p>
<p><strong>11.Spring AMQP</strong></p>
<p>Spring AMQP项目旨在将核心的Spring概念应用于基于AMQP的消息传递解决方案的开发中，它提供了一个“模板”的抽象用于发送和接收消息。</p>
<p><strong>12.Spring Mobile</strong></p>
<p>Spring Mobile是对Spring MVC的扩展，旨在简化移动Web应用的开发。<br>Spring Mobile可以检测出当前请求使用的设备是PC、还是手机或者是平板以及用户设备是安卓平台还是iOS平台，然后根据请求设备的不同，返回适合该设备的视图。</p>
<p><strong>13.Spring For Android</strong></p>
<p>虽然官方的说法是Spring For Android旨在简化原声Android应用的开发，但其实这个有点太过于牵强。<br>Spring For Android提供了2个对原生Android应用开发的支持：<br>(1)提供了一个REST客户端<br>(2)支持访问安全API时的认证</p>
<p><strong>14.Spring Web Flow</strong></p>
<p>Spring Web Flow主要应用于需要在Web页面上创建引导用户执行类似“下一步”这样的基于流程的应用场景，该框架构建于Spring MVC之上。</p>
<p><strong>15.Spring Web Services</strong></p>
<p>Spring Web Services用于开发WebService服务，类似的框架如：<a target="_blank" rel="noopener" href="https://cxf.apache.org/">Apache CXF</a>，<a target="_blank" rel="noopener" href="http://axis.apache.org/axis2/java/core/">Apache Axis2</a>。</p>
<p><strong>16.Spring LDAP</strong></p>
<p>Spring LDAP是一个工具，用于为基于Spring的应用程序使用LDAP（Lightweight Directory Access Protocol）协议。</p>
<p><strong>17.Spring Session</strong></p>
<p>Spring Session提供了管理用户Session信息的API和对应实现，Spring Session使得支持集群会话变得简单，而不依赖于特定于应用程序容器的解决方案。<br>简单来讲，传统的Session方案依赖于特定的容器（如：Tomcat），Spring Session就是提供独立于特定容器的Session解决方案。<br>其实，针对Tomcat容器，Session集群化也有一个开源方案：<a target="_blank" rel="noopener" href="https://github.com/jcoleman/tomcat-redis-session-manager">tomcat-redis-session-manager</a>。</p>
<p><strong>18.Spring Shell</strong></p>
<p>Spring Shell用于开发基于命令行交互的应用。</p>
<p><strong>19.Spring FLO</strong></p>
<p>Spring FLO是一个JavaScript类库，是Spring Cloud Data Flow中流构建器的基础。</p>
<p><strong>20.Spring Kafka</strong></p>
<p>Spring Kafka用于在Spring项目中与Kafka交互。</p>
<p><strong>21.Spring Statemachine</strong></p>
<p>Spring Statemachine是一个为开发人员在Spring项目中使用状态机的框架，帮助开发者简化状态机的开发过程，让状态机结构更加层次化。</p>
<p><strong>22.Spring IO Platform</strong></p>
<p>简单来说，Spring IO Platform是一个对项目依赖进行统一版本管理的工具。本质就是一个pom文件，它记录了Spring项目和其它第三方库对应的版本信息。</p>
<h3 id="社区项目"><a href="#社区项目" class="headerlink" title="社区项目"></a>社区项目</h3><p>社区项目目前只有2个：Spring ROO，Spring Scala。</p>
<p>1.Spring ROO：这是一个开发工具包，旨在快速构建一个Java应用。<br>2.Spring Scala：支持在Scala中使用Spring框架。</p>
<h3 id="保留项目"><a href="#保留项目" class="headerlink" title="保留项目"></a>保留项目</h3><p>某些项目已经终止了，但是仍然保留着，不必赘述。</p>
<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>Spring是一个生态系统，提供许多有用的编程框架或工具集。<br>本文的目的不在于详细介绍Spring生态的每一个项目，而是通过一个全面的整理，对Spring生态有一个完整的认识，在实际中根据需要灵活选择对应的组件来使用即可。<br>可以明确的是，当下最为流行的Spring项目是这4个：<strong>Spring Framework</strong>，<strong>Spring Security</strong>，<strong>Spring Boot</strong>，<strong>Spring Cloud</strong>。<br>如下图所示，再次对Spring生态做一个概括性总结。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014836702-2034259504.png" alt="Spring生态概括"></p>
<p>【参考】<br><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-SpringHATEOAS/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-SpringHATEOAS/index.html</a> 使用 Spring HATEOAS 开发 REST 服务<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f9024eb3f252">https://www.jianshu.com/p/f9024eb3f252</a> 使用Spring Mobile实现网站移动端适配及更换主题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_xuexiaoqiang/article/details/65938744">https://blog.csdn.net/csdn_xuexiaoqiang/article/details/65938744</a> Spring学习笔记之Spring Web Flow<br><a target="_blank" rel="noopener" href="https://www.hifreud.com/2015/02/27/08-spring-mvc-spring-web-service/">https://www.hifreud.com/2015/02/27/08-spring-mvc-spring-web-service/</a> Spring 使用笔记之(五) - Spring-ws实现基于契约优先的WebService<br><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/web/wa-spring-session-architecture-and-design/index.html">https://www.ibm.com/developerworks/cn/web/wa-spring-session-architecture-and-design/index.html</a> 详解 Spring Session 架构与设计<br><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/spring-shell-application/index.html">https://www.ibm.com/developerworks/cn/java/spring-shell-application/index.html</a> 使用 Spring Shell 开发 Java 命令行应用<br><a target="_blank" rel="noopener" href="http://blog.didispace.com/spring-statemachine/">http://blog.didispace.com/spring-statemachine/</a> 使用Spring StateMachine框架实现状态机<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd0baba45f52">https://www.jianshu.com/p/dd0baba45f52</a> Spring IO Platform 简介<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012743018">https://segmentfault.com/a/1190000012743018</a> Spring IO Platform项目的介绍和应用<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenpi/p/6295855.html">https://www.cnblogs.com/chenpi/p/6295855.html</a> Spring IO Platform简介及示例</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Spring-boot-admin配置属性详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-16 18:11:38" itemprop="dateCreated datePublished" datetime="2020-12-16T18:11:38+08:00">2020-12-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/springboot/" itemprop="url" rel="index"><span itemprop="name">springboot</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="client端配置属性详解"><a href="#client端配置属性详解" class="headerlink" title="client端配置属性详解"></a>client端配置属性详解</h2><p><strong>spring.boot.admin.client.enabled</strong>：是否启用springbootAdmin客户端，默认为true；<br><strong>spring.boot.admin.client.url</strong>：要注册的server端的url地址。如果要同时在多个server端口注册，则用逗号分隔各个server端的url地址；<br><strong>spring.boot.admin.client.api-path</strong>：默认值是instances。server端获取client信息的路径，默认情况下server通过访问/instances请求来获取到client端的信息。（client端向server端注册，注册成功后server端会给该client创建一个唯一的clientID值。当server端需要获取client的信息，比如health信息时，server端会发送<a target="_blank" rel="noopener" href="http://111.11.11.1:8080/instances/clientID/actuator/health%E5%8D%B3%E5%8F%AF%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84http://111.11.11.1:8080%E6%98%AFclient%E6%89%80%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8Cinstances%E5%B0%B1%E6%98%AF%E8%AF%A5%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%EF%BC%89">http://111.11.11.1:8080/instances/clientID/actuator/health即可，这里的http://111.11.11.1:8080是client所在服务器的IP地址，instances就是该属性的值）</a></p>
<p><strong>spring.boot.admin.client.username</strong>：如果server端需要进行认证时，该属性用于配置用户名。<br><strong>spring.boot.admin.client.password</strong>：如果server端需要进行认证时，该属性用于配置密码。</p>
<p><strong>spring.boot.admin.client.period</strong>：注册时间间隔，单位是毫秒；默认值是10秒钟注册一次。（client通过持续不断地向server端进行注册来保持client端与server端的连接）</p>
<p><strong>spring.boot.admin.client.connect-timeout</strong>：注册连接超时时间，单位是毫秒，默认值是5秒。当client向server进行注册时，如果5秒钟没有注册完成则认为本次注册失败；</p>
<p><strong>spring.boot.admin.client.read-timeout</strong>：注册读取超时，单位是毫秒，默认值是5秒；</p>
<p><strong>spring.boot.admin.client.auto-registration</strong>：是否开启自动注册，默认值是true。</p>
<p><strong>spring.boot.admin.client.auto-deregistration</strong>：是否开启自动注销，默认值是null。如果服务端运行在云平台，默认值是true；</p>
<p><strong>spring.boot.admin.client.register-once</strong>：默认值为true。如果值为true的话，client只会在一个server端进行注册（按照spring.boot.admin.client.url中设置的server的顺序）。如果该server端宕机，会自动在下一个server端进行注册。如果该属性值为false，则会在所有的server端进行注册；</p>
<p><strong>spring.boot.admin.client.instance.management-url</strong>：注册的management-url，如果可用的url不同的话可以重写该值。如果不配置该属性的话，默认该属性值与management-base-url 和 management.context-path两个属性值有关。比如工程中该值为：managementUrl=<a target="_blank" rel="noopener" href="http://192.168.200.165:8080/actuator%EF%BC%8C%E5%85%B6%E4%B8%AD[http://192.168.200.165:8080](http://192.168.200.165:8080/)%E4%B8%BAmanagement-base-url%EF%BC%8C/actuator%E6%98%AFmanagement.context-path%EF%BC%88%E8%AF%A5%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AFspring">http://192.168.200.165:8080/actuator，其中[http://192.168.200.165:8080](http://192.168.200.165:8080/)为management-base-url，/actuator是management.context-path（该属性值是spring</a> actuator的属性值）；</p>
<p><strong>spring.boot.admin.client.instance.management-base-url</strong>：用于计算management-url 的基本URL。该路径值在运行时进行获取并赋值给 base url。如果不配置该属性值的话，默认该属性值与management.port, service-url 以及server.servlet-path有关。比如工程中该值为<a target="_blank" rel="noopener" href="http://192.168.200.165:8080/">http://192.168.200.165:8080，其中8080</a>端口是配置的获取actuator信息的端口。192.168.200.165是设置的service-url值，如果没有设置service-url的话，则为配置的server.servlet-path值（项目的启动路径）。</p>
<p><strong>spring.boot.admin.client.instance.health-url</strong>：注册的health-url地址，如果可用的url不同可以重写该值。如果不配置该属性的话，默认该属性值与management-url 以及endpoints.health.id有关。比如工程中该值为：healthUrl=<a target="_blank" rel="noopener" href="http://192.168.200.165:8080/actuator/health%EF%BC%8C%E5%85%B6%E4%B8%ADhttp://192.168.200.165:8080/actuator%E6%98%AFmanagement-url%EF%BC%8Chealth%E6%98%AFendpoints.health.id%E3%80%82">http://192.168.200.165:8080/actuator/health，其中http://192.168.200.165:8080/actuator是management-url，health是endpoints.health.id。</a></p>
<p><strong>spring.boot.admin.client.instance.service-base-url</strong>：用于计算service-url 的基本URL。该路径值在运行时进行获取并赋值给 base url。如果不配置该属性值的话，默认该属性值与hostname, server.port有关。比如工程中该值为<a target="_blank" rel="noopener" href="http://p-v-9:8080/">http://p-v-9:8080，其中8080</a>端口是配置的server.port。p-v-9是client所在服务器的hostname。</p>
<p><strong>spring.boot.admin.client.instance.service-url</strong>：注册的service-url值。如果不配置该属性值的话，基于 service-base-url 和 server.context-path进行赋值。比如工程中为<a target="_blank" rel="noopener" href="http://p-v-9:8080/,%E5%85%B6%E4%B8%ADp-v-9%E6%98%AFbase-url%EF%BC%8C/%E6%98%AF%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%9A%84">http://p-v-9:8080/,其中p-v-9是base-url，/是工程配置的</a> server.context-path值。（这里要注意的是，当server端与client端不在同一台服务器上的时候，要配置该属性的值。如果不配置的话，server端就会根据默认的命名规则来配置该值，比如<a target="_blank" rel="noopener" href="http://p-v-9:8080/%EF%BC%8C%E5%A6%82%E6%9E%9Cserver%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%80%BC%E6%9D%A5%E8%8E%B7%E5%8F%96client%E7%9A%84%E5%90%84%E7%A7%8D%E6%80%A7%E8%83%BD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%AF%9D%E6%98%AF%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%9A%84%EF%BC%89%EF%BC%9B">http://p-v-9:8080/，如果server使用这个值来获取client的各种性能信息的话是获取不到的）；</a></p>
<p><strong>spring.boot.admin.client.instance.name</strong>：客户端工程的名字。默认值是配置的spring.application.name的值，如果没有配置该属性的话，默认值是spring-boot-application；</p>
<p><strong>spring.boot.admin.client.instance.prefer-ip</strong>：是否使用注册的ip地址来取代上述各个url中hostname的值，默认值是false（也就是说默认情况下上述各个url中会使用hostname的值，比如我的电脑的hostname为p-v-9）。如果设置了server.address或management.address的话ip地址就是该值，如果没有设置这两个属性的话ip地址值是InetAddress.getLocalHost()的值。</p>
<p>*<em>spring.boot.admin.client.instance.metadata.**</em>：与该应用有关的元数据，以键值对的形式赋值。</p>
<h2 id="server端配置属性详解"><a href="#server端配置属性详解" class="headerlink" title="server端配置属性详解"></a>server端配置属性详解</h2><p>spring.boot.admin.context-path：server端的访问路径，默认是/。默认情况下server的访问地址是<a target="_blank" rel="noopener" href="https://blog.csdn.net/">http://<strong>.</strong>.<strong>.</strong>:**/</a>,这里**.<strong>.</strong>.**:**是server所在服务器的ip地址。我们的工程设置该值是springbootAdmin，那么工程的server端访问地址是<a target="_blank" rel="noopener" href="http://111.11.11.1:8000/springbootAdmin">http://111.11.11.1:8000/springbootAdmin</a>;</p>
<p><strong>spring.boot.admin.monitor.period</strong>:更新client端状态的时间间隔，单位是毫秒，默认值是10秒钟；</p>
<p><strong>spring.boot.admin.monitor.status-lifetime</strong>：client端状态的生命周期，该生命周期内不会更新client状态。单位是毫秒，默认值是10秒钟；</p>
<p><strong>spring.boot.admin.monitor.connect-timeout</strong>：查询client状态信息时的连接超时时间，单位是毫秒，默认是2秒（如果2秒内没有获取到client的状态信息，则认为连接已经断开）。</p>
<p><strong>spring.boot.admin.monitor.read-timeout</strong>：查询client状态信息时的读取超时时间，单位是毫秒，默认是2秒（如果2秒内没有获取到client的状态信息，则认为读取失败）。</p>
<p><strong>spring.boot.admin.metadata-keys-to-sanitize</strong>：要被过滤掉的元数据（当与正则表达式相匹配时，这些数据会在输出的json数据中过滤掉），默认值是”.<strong>password$”, “.*secret$”, “.*key$”, “.</strong>$token$”, “.<strong>credentials.</strong>“, “.*vcap_services$”；</p>
<p><strong>spring.boot.admin.probed-endpoints</strong>：要获取的client的端点信息，默认是”health”, “env”, “metrics”, “httptrace:trace”, “threaddump:dump”, “jolokia”, “info”, “logfile”, “refresh”, “flyway”, “liquibase”, “heapdump”, “loggers”, “auditevents”；</p>
<p><strong>spring.boot.admin.instance-proxy.ignored-headers</strong>：向client发起请求时不会被转发的headers信息，默认值是”Cookie”, “Set-Cookie”, “Authorization”；</p>
<p><strong>spring.boot.admin.ui.brand</strong>：在导航栏中显示的brand值，默认是”<img src="/2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/img/icon-spring-boot-admin.svg"><span>Spring Boot Admin</span>“；</p>
<p><strong>spring.boot.admin.ui.title</strong>：显示的页面标题，默认是”Spring Boot Admin”</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%9B%91%E6%8E%A7admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Spring-boot-admin简单使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-16 17:41:38" itemprop="dateCreated datePublished" datetime="2020-12-16T17:41:38+08:00">2020-12-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/springboot/" itemprop="url" rel="index"><span itemprop="name">springboot</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Spring Boot Admin 用于监控基于 Spring Boot 的应用，它是在 Spring Boot Actuator 的基础上提供简洁的可视化 WEB UI。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Spring Boot Admin 提供了很多功能，如显示 name、id 和 version，显示在线状态，Loggers 的日志级别管理，Threads 线程管理，Environment 管理等。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>在 Spring Boot 项目中，Spring Boot Admin 作为 Server 端，其他的要被监控的应用作为 Client 端</p>
<h2 id="简单使用（Spring-Boot-项目）"><a href="#简单使用（Spring-Boot-项目）" class="headerlink" title="简单使用（Spring Boot 项目）"></a>简单使用（Spring Boot 项目）</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>代码配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootAdminApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8788</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.boot.admin.client.url</span>: <span class="string">&quot;http://localhost:8788&quot;  </span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>: <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上的配置，就可以实现 Spring Boot 项目中 Spring Boot Admin 监控其他应用了。</p>
<h2 id="进阶使用（Spring-Cloud-项目）"><a href="#进阶使用（Spring-Cloud-项目）" class="headerlink" title="进阶使用（Spring Cloud 项目）"></a>进阶使用（Spring Cloud 项目）</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>此处使用Eureka,端口8761，暂不详解</p>
<h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p><strong>pom配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>启动类配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootAdminApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Profile(&quot;insecure&quot;)</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityPermitAllConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.authorizeRequests().anyRequest().permitAll()<span class="comment">//</span></span><br><span class="line">                    .and().csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Profile(&quot;secure&quot;)</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecuritySecureConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String adminContextPath;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SecuritySecureConfig</span><span class="params">(AdminServerProperties adminServerProperties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.adminContextPath = adminServerProperties.getContextPath();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// @formatter:off</span></span><br><span class="line">            SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">            successHandler.setTargetUrlParameter(<span class="string">&quot;redirectTo&quot;</span>);</span><br><span class="line">            http.authorizeRequests()</span><br><span class="line">                    .antMatchers(adminContextPath + <span class="string">&quot;/assets/**&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(adminContextPath + <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">                    .anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin().loginPage(adminContextPath + <span class="string">&quot;/login&quot;</span>).successHandler(successHandler).and()</span><br><span class="line">                    .logout().logoutUrl(adminContextPath + <span class="string">&quot;/logout&quot;</span>).and()</span><br><span class="line">                    .httpBasic().and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">            <span class="comment">// @formatter:on</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-admin</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secure</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8788</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span>   </span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">leaseRenewalIntervalInSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">health-check-url-path:</span> <span class="string">/actuator/health</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registryFetchIntervalSeconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;EUREKA_SERVICE_URL:http://localhost:8761&#125;/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">insecure</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">secure</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">user.name:</span> <span class="string">&quot;user&quot;</span>         <span class="comment">#These two are needed so that the server</span></span><br><span class="line">      <span class="attr">user.password:</span> <span class="string">&quot;password&quot;</span> <span class="comment">#can access the protected client endpoints</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>配置文件修改</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8281</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="comment"># 向每个注册中心注册</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/,http://localhost:8762/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-demo-service</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">      <span class="attr">health:</span></span><br><span class="line">        <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Spring-boot-amqp自动配置详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-15 13:37:28" itemprop="dateCreated datePublished" datetime="2020-12-15T13:37:28+08:00">2020-12-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/springboot/" itemprop="url" rel="index"><span itemprop="name">springboot</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="RabbitMQ自动装配类：RabbitAutoConfiguration"><a href="#RabbitMQ自动装配类：RabbitAutoConfiguration" class="headerlink" title="RabbitMQ自动装配类：RabbitAutoConfiguration"></a>RabbitMQ自动装配类：RabbitAutoConfiguration</h2><p>1、@EnableConfigurationProperties启动配置文件RabbitProperties<br>2、@Import导入RabbitAnnotationDrivenConfiguration</p>
<h3 id="RabbitConnectionFactoryCreator静态内部类："><a href="#RabbitConnectionFactoryCreator静态内部类：" class="headerlink" title="RabbitConnectionFactoryCreator静态内部类："></a>RabbitConnectionFactoryCreator静态内部类：</h3><p>1、RabbitConnectionFactoryBean配置，创建ConnectionFactory对象，内部单例是<strong>com.rabbitmq.client.ConnectionFactory</strong><br>2、使用spring-rabbitmq的<strong>CachingConnectionFactory</strong>包装ConnectionFactory</p>
<h3 id="RabbitTemplateConfiguration静态内部类："><a href="#RabbitTemplateConfiguration静态内部类：" class="headerlink" title="RabbitTemplateConfiguration静态内部类："></a>RabbitTemplateConfiguration静态内部类：</h3><p>1、@Import(RabbitConnectionFactoryCreator.class)<br>2、RabbitTemplate(操作spring-amqp中的Message对象)<br>3、AmqpAdmin</p>
<h3 id="MessagingTemplateConfiguration静态内部类："><a href="#MessagingTemplateConfiguration静态内部类：" class="headerlink" title="MessagingTemplateConfiguration静态内部类："></a>MessagingTemplateConfiguration静态内部类：</h3><p>1、(@Import(RabbitTemplateConfiguration.class))<br>2、RabbitMessagingTemplate（操作spring-message中的Message对象，底层也是使用RabbitTemplate）</p>
<h2 id="RabbitAnnotationDrivenConfiguration注解驱动配置类"><a href="#RabbitAnnotationDrivenConfiguration注解驱动配置类" class="headerlink" title="RabbitAnnotationDrivenConfiguration注解驱动配置类"></a>RabbitAnnotationDrivenConfiguration注解驱动配置类</h2><p>1、<strong>EnableRabbitConfiguration</strong>静态内部类（**@EnableRabbit**）<br>2、SimpleRabbitListenerContainerFactoryConfigurer配置，创建SimpleRabbitListenerContainerFactoryConfigurer<br>3、SimpleRabbitListenerContainerFactory（默认，spring.rabbitmq.listener.type=simple）通过configure方法配置SimpleRabbitListenerContainerFactory工厂对象的属性<br>4、DirectRabbitListenerContainerFactoryConfigurer配置，创建DirectRabbitListenerContainerFactoryConfigurer<br>5、DirectRabbitListenerContainerFactory(spring.rabbitmq.listener.type=direct,只能存在一个)通过configure方法配置DirectRabbitListenerContainerFactory工厂对象的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function">DirectRabbitListenerContainerFactoryConfigurer <span class="title">directRabbitListenerContainerFactoryConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactoryConfigurer configurer = <span class="keyword">new</span> DirectRabbitListenerContainerFactoryConfigurer();</span><br><span class="line">    configurer.setMessageConverter(<span class="keyword">this</span>.messageConverter.getIfUnique());</span><br><span class="line">    configurer.setMessageRecoverer(<span class="keyword">this</span>.messageRecoverer.getIfUnique());</span><br><span class="line">    configurer.setRetryTemplateCustomizers(</span><br><span class="line">        <span class="keyword">this</span>.retryTemplateCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">    configurer.setRabbitProperties(<span class="keyword">this</span>.properties);</span><br><span class="line">    <span class="keyword">return</span> configurer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean(name = &quot;rabbitListenerContainerFactory&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;rabbitListenerContainerFactory&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.rabbitmq.listener&quot;, name = &quot;type&quot;, havingValue = &quot;direct&quot;)</span></span><br><span class="line"><span class="function">DirectRabbitListenerContainerFactory <span class="title">directRabbitListenerContainerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DirectRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactory factory = <span class="keyword">new</span> DirectRabbitListenerContainerFactory();</span><br><span class="line">    <span class="comment">//为ListenerContainerFactory配置属性</span></span><br><span class="line">    configurer.configure(factory, connectionFactory);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象的RabbitListenerContainerFactory 公用参数使用</span></span><br><span class="line">AbstractRabbitListenerContainerFactory&lt;C extends AbstractMessageListenerContainer&gt;</span><br><span class="line">  implements RabbitListenerContainerFactory&lt;C&gt;, ApplicationContextAware, ApplicationEventPublisherAware</span><br><span class="line"><span class="comment">//使用模板方法创建ListenerContainer  -》注册的时候使用-&gt;创建ListenerContainer    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> C <span class="title">createListenerContainer</span><span class="params">(RabbitListenerEndpoint endpoint)</span> </span>&#123;</span><br><span class="line">    C instance = createContainerInstance();</span><br><span class="line">    <span class="comment">//... 设置公用参数</span></span><br><span class="line">    <span class="comment">//初始化实例，设置不同容器的不同配置参数</span></span><br><span class="line">    initializeContainer(instance, endpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EnableRabbit注解类"><a href="#EnableRabbit注解类" class="headerlink" title="EnableRabbit注解类"></a>EnableRabbit注解类</h2><h3 id="Import-RabbitListenerConfigurationSelector-class"><a href="#Import-RabbitListenerConfigurationSelector-class" class="headerlink" title="@Import(RabbitListenerConfigurationSelector.class)"></a>@Import(RabbitListenerConfigurationSelector.class)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitListenerConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; RabbitBootstrapConfiguration.class.getName() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>selectImports方法，导入RabbitBootstrapConfiguration</p>
<h2 id="RabbitBootstrapConfiguration"><a href="#RabbitBootstrapConfiguration" class="headerlink" title="RabbitBootstrapConfiguration"></a>RabbitBootstrapConfiguration</h2><p>RabbitBootstrapConfiguration implements <strong>ImportBeanDefinitionRegistrar</strong>，用于注册BeanDefinition。</p>
<p>registerBeanDefinitions方法注册BeanDefinition<br>1、RabbitListenerAnnotationBeanPostProcessor<br>2、RabbitListenerEndpointRegistry</p>
<h2 id="RabbitListenerAnnotationBeanPostProcessor后置处理器"><a href="#RabbitListenerAnnotationBeanPostProcessor后置处理器" class="headerlink" title="RabbitListenerAnnotationBeanPostProcessor后置处理器"></a>RabbitListenerAnnotationBeanPostProcessor后置处理器</h2><p>主要实现了SmartInitializingSingleton，BeanPostProcessor接口，创建<strong>RabbitListenerEndpointRegistrar</strong> <strong>registrar</strong>成员变量，设置setBeanFactory</p>
<h4 id="afterSingletonsInstantiated方法"><a href="#afterSingletonsInstantiated方法" class="headerlink" title="afterSingletonsInstantiated方法"></a>afterSingletonsInstantiated方法</h4><p>1、**<font color="red">RabbitListenerConfigurer</font><strong>接口可以扩展，configurer.configureRabbitListeners(this.registrar);<br>2、this.registrar.setEndpointRegistry(this.endpointRegistry); 从容器中获取</strong>RabbitListenerEndpointRegistry<strong>对象<br>3、MessageHandlerMethodFactory handlerMethodFactory = this.registrar.getMessageHandlerMethodFactory();<br>4、</strong>this.registrar.afterPropertiesSet()**; //此时注册所有的Endpoints，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerAllEndpoints</span><span class="params">()</span> </span>&#123;   <span class="comment">//每个endpoint创建一个容器</span></span><br><span class="line">    <span class="comment">//通过endpoint注册监听容器</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AmqpListenerEndpointDescriptor descriptor : <span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.endpointRegistry.registerListenerContainer(<span class="comment">// NOSONAR never null</span></span><br><span class="line">                descriptor.endpoint, resolveContainerFactory(descriptor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.startImmediately = <span class="keyword">true</span>;  <span class="comment">// trigger immediate startup</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="postProcessAfterInitialization方法"><a href="#postProcessAfterInitialization方法" class="headerlink" title="postProcessAfterInitialization方法"></a>postProcessAfterInitialization方法</h4><p>1、Bean处理器，获取类、方法上的@RabbitListener，@RabbitHandler[处理不同content_type的消息]注解的元数据(方法上可使用@Payload String body, @Headers Map&lt;String,Object&gt; headers,@Header String token,Message message,String message)<br>2、processAmqpListener（）——&gt;处理RabbitListener的监听——&gt;MethodRabbitListenerEndpoint<br>3、processMultiMethodListeners==》处理RabbitHandler的监听——&gt;MultiMethodRabbitListenerEndpoint<br>4、生成MethodRabbitListenerEndpoint或者MultiMethodRabbitListenerEndpoint的实例Endpoint对象，Endpoint包含监听的相关信息（group，id,queue,exchange,相关执行方法）<br>5、最终：<strong>this.registrar.registerEndpoint(endpoint, factory);</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AmqpListenerEndpointDescriptor descriptor = <span class="keyword">new</span> AmqpListenerEndpointDescriptor(endpoint, factory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.startImmediately) &#123; <span class="comment">// Register and start immediately  </span></span><br><span class="line">        <span class="keyword">this</span>.endpointRegistry.registerListenerContainer(descriptor.endpoint, <span class="comment">// NOSONAR never null</span></span><br><span class="line">                                                        resolveContainerFactory(descriptor), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.endpointDescriptors.add(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RabbitListenerEndpointRegistry"><a href="#RabbitListenerEndpointRegistry" class="headerlink" title="RabbitListenerEndpointRegistry"></a>RabbitListenerEndpointRegistry</h2><p>主要实现了DisposableBean, SmartLifecycle接口，SmartLifecycle具有生命周期，负责创建MessageListenerContainer实例，并管理所有监听容器的启动与停止等。</p>
<p>RabbitListenerEndpointRegistry实例创建的MessageListenerContainer实例在其整个生命周期都是有状态的。<br>SimpleMessageListenerContainer的start()方法，负责创建消费者并启动对消息队列的监听。<br>SimpleMessageListenerContainer的stop()方法，负责销毁消费者并停止对消息队列的监听。</p>
<p><strong>registerListenerContainer</strong>方法， 注册监听的容器即创建监听容器<br>1、MessageListenerContainer container = createListenerContainer(endpoint, factory);<br>2、this.listenerContainers.put(id, container);<br>3、containerGroup.add(container);<br>4、startIfNecessary(MessageListenerContainer listenerContainer)——》<strong>listenerContainer.start();</strong></p>
<h2 id="MessageListenerContainer"><a href="#MessageListenerContainer" class="headerlink" title="MessageListenerContainer"></a>MessageListenerContainer</h2><img src="/2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/MessageListenerContainer.png" style="zoom: 67%;">

<h3 id="AbstractMessageListenerContainer"><a href="#AbstractMessageListenerContainer" class="headerlink" title="AbstractMessageListenerContainer"></a>AbstractMessageListenerContainer</h3><p><strong>listenerContainer.start();</strong><br>1、configureAdminIfNeeded();<br>2、checkMismatchedQueues();<br>3、最后doStart();</p>
<p><strong>doStart();</strong><br>1、DirectMessageListenerContainer#doStart();<br>2、SimpleMessageListenerContainer#doStart();</p>
<h3 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Executor taskExecutor = <span class="keyword">new</span> SimpleAsyncTaskExecutor();</span><br><span class="line"><span class="comment">//容器开始</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> newConsumers = initializeConsumers();</span><br><span class="line">    Set&lt;AsyncMessageProcessingConsumer&gt; processors = <span class="keyword">new</span> HashSet&lt;AsyncMessageProcessingConsumer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (BlockingQueueConsumer consumer : <span class="keyword">this</span>.consumers) &#123;</span><br><span class="line">        AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">        processors.add(processor);</span><br><span class="line">        getTaskExecutor().execute(processor);</span><br><span class="line">        <span class="keyword">if</span> (getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    waitForConsumersToStart(processors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">receiveAndExecute</span><span class="params">(<span class="keyword">final</span> BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">// NOSONAR</span></span><br><span class="line">    PlatformTransactionManager transactionManager = getTransactionManager();</span><br><span class="line">    <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.transactionTemplate == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.transactionTemplate =</span><br><span class="line">                    <span class="keyword">new</span> TransactionTemplate(transactionManager, getTransactionAttribute());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.transactionTemplate</span><br><span class="line">                .execute(status -&gt; &#123; <span class="comment">// NOSONAR null never returned</span></span><br><span class="line">                    RabbitResourceHolder resourceHolder = ConnectionFactoryUtils.bindResourceToTransaction(</span><br><span class="line">                        <span class="keyword">new</span> RabbitResourceHolder(consumer.getChannel(), <span class="keyword">false</span>),</span><br><span class="line">                        getConnectionFactory(), <span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// unbound in ResourceHolderSynchronization.beforeCompletion()</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> doReceiveAndExecute(consumer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (RuntimeException e1) &#123;</span><br><span class="line">                        prepareHolderForRollback(resourceHolder, e1);</span><br><span class="line">                        <span class="keyword">throw</span> e1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> WrappedTransactionException(e2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (WrappedTransactionException e) &#123; <span class="comment">// NOSONAR exception flow control</span></span><br><span class="line">            <span class="keyword">throw</span> (Exception) e.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doReceiveAndExecute</span><span class="params">(BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//NOSONAR</span></span><br><span class="line">        Channel channel = consumer.getChannel();</span><br><span class="line">        List&lt;Message&gt; messages = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> deliveryTag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.batchSize; i++) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Waiting for message from consumer.&quot;</span>);</span><br><span class="line">            Message message = consumer.nextMessage(<span class="keyword">this</span>.receiveTimeout);</span><br><span class="line">            <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.consumerBatchEnabled) &#123;</span><br><span class="line">                Collection&lt;MessagePostProcessor&gt; afterReceivePostProcessors = getAfterReceivePostProcessors();</span><br><span class="line">                <span class="keyword">if</span> (afterReceivePostProcessors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Message original = message;</span><br><span class="line">                    deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">                    <span class="keyword">for</span> (MessagePostProcessor processor : getAfterReceivePostProcessors()) &#123;</span><br><span class="line">                        message = processor.postProcessMessage(message);</span><br><span class="line">                        <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.logger.debug(</span><br><span class="line">                                    <span class="string">&quot;Message Post Processor returned &#x27;null&#x27;, discarding message &quot;</span> + original);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (messages == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        messages = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.batchSize);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isDeBatchingEnabled() &amp;&amp; getBatchingStrategy().canDebatch(message.getMessageProperties())) &#123;</span><br><span class="line">                        <span class="keyword">final</span> List&lt;Message&gt; messageList = messages;</span><br><span class="line">                        getBatchingStrategy().deBatch(message, fragment -&gt; messageList.add(fragment));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        messages.add(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executeListener(channel, message);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (ImmediateAcknowledgeAmqpException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;User requested ack for failed delivery &#x27;&quot;</span></span><br><span class="line">                                          + e.getMessage() + <span class="string">&quot;&#x27;: &quot;</span></span><br><span class="line">                                          + message.getMessageProperties().getDeliveryTag());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.debug(<span class="string">&quot;User requested ack for failed delivery: &quot;</span></span><br><span class="line">                                              + message.getMessageProperties().getDeliveryTag());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (getTransactionManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getTransactionAttribute().rollbackOn(ex)) &#123;</span><br><span class="line">                            RabbitResourceHolder resourceHolder = (RabbitResourceHolder) TransactionSynchronizationManager</span><br><span class="line">                                .getResource(getConnectionFactory());</span><br><span class="line">                            <span class="keyword">if</span> (resourceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                consumer.clearDeliveryTags();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">								 * If we don&#x27;t actually have a transaction, we have to roll back</span></span><br><span class="line"><span class="comment">								 * manually. See prepareHolderForRollback().</span></span><br><span class="line"><span class="comment">								 */</span></span><br><span class="line">                                consumer.rollbackOnExceptionIfNecessary(ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">throw</span> ex; <span class="comment">// encompassing transaction will handle the rollback.</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.logger.debug(<span class="string">&quot;No rollback for &quot;</span> + ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        consumer.rollbackOnExceptionIfNecessary(ex);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.consumerBatchEnabled &amp;&amp; messages != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executeWithList(channel, messages, deliveryTag, consumer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> consumer.commitIfNecessary(isChannelLocallyTransacted());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1、this.consumers = new HashSet<BlockingQueueConsumer>(this.concurrentConsumers);当前消费者数量<br>2、<strong>BlockingQueueConsumer</strong> consumer = createBlockingQueueConsumer();每个消费者处理预处理条数（prefetchCount，batchSize谁大选谁）<br>3、private final BlockingQueue<Delivery> queue =new <strong>LinkedBlockingQueue</strong><Delivery>(prefetchCount，batchSize谁大选谁); BlockingQueueConsumer 里的成员变量<br>3、循环生成<strong>AsyncMessageProcessingConsumer</strong> processor = new AsyncMessageProcessingConsumer(consumer); 私有线程内部类，实现<strong>Runnable</strong><br>4、getTaskExecutor().execute(processor); 线程池执行器执行线程</Delivery></Delivery></BlockingQueueConsumer></p>
<h4 id="BlockingQueueConsumer"><a href="#BlockingQueueConsumer" class="headerlink" title="BlockingQueueConsumer"></a>BlockingQueueConsumer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, InternalConsumer&gt; consumers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] queues; <span class="comment">//队列名称-》一个监听容器可以监听多个队列，会创建多个Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setQosAndreateConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.acknowledgeMode.isAutoAck() &amp;&amp; !cancelled()) &#123;</span><br><span class="line">        <span class="comment">// Set basicQos before calling basicConsume (otherwise if we are not acking the broker</span></span><br><span class="line">        <span class="comment">// will send blocks of 100 messages)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cancelled()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String queueName : <span class="keyword">this</span>.queues) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.missingQueues.contains(queueName)) &#123;</span><br><span class="line">                    consumeFromQueue(queueName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeFromQueue</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InternalConsumer consumer = <span class="keyword">new</span> InternalConsumer(<span class="keyword">this</span>.channel, queue);</span><br><span class="line">    String consumerTag = <span class="keyword">this</span>.channel.basicConsume(queue, <span class="keyword">this</span>.acknowledgeMode.isAutoAck(),</span><br><span class="line">                                                   (<span class="keyword">this</span>.tagStrategy != <span class="keyword">null</span> ?                        <span class="keyword">this</span>.tagStrategy.createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="keyword">this</span>.noLocal,</span><br><span class="line">                                                   <span class="keyword">this</span>.exclusive, <span class="keyword">this</span>.consumerArgs,</span><br><span class="line">                                                   consumer);</span><br><span class="line">    <span class="keyword">if</span> (consumerTag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.consumers.put(queue, consumer);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Started on queue &#x27;&quot;</span> + queue + <span class="string">&quot;&#x27; with tag &quot;</span> + consumerTag + <span class="string">&quot;: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Null consumer tag received for queue &quot;</span> + queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AsyncMessageProcessingConsumer"><a href="#AsyncMessageProcessingConsumer" class="headerlink" title="AsyncMessageProcessingConsumer"></a>AsyncMessageProcessingConsumer</h4><p>SimpleMessageListenerContainer内部类，实现了Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AsyncMessageProcessingConsumer(BlockingQueueConsumer consumer) &#123;</span><br><span class="line"><span class="keyword">this</span>.consumer = consumer;</span><br><span class="line"><span class="keyword">this</span>.start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// NOSONAR - complexity - many catch blocks</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、redeclareElementsIfNecessary();根据容器中的Queue、Exchange、Binding,在broker中创建</span></span><br><span class="line">    <span class="comment">//2、this.consumer.start();  调用BlockingQueueConsumer中start()。</span></span><br><span class="line">    <span class="comment">//passiveDeclarations();setQosAndreateConsumers();设置Qos</span></span><br><span class="line">    initialize(); </span><br><span class="line">    <span class="comment">//boolean receivedOk = receiveAndExecute(this.consumer);处理堵塞队列message</span></span><br><span class="line">    mainLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InternalConsumer"><a href="#InternalConsumer" class="headerlink" title="InternalConsumer"></a>InternalConsumer</h4><p>InternalConsumer 是BlockingQueueConsumer的私有内部类，继承com.rabbitmq.client.<strong>DefaultConsumer</strong>。handleDelivery方法会向BlockingQueueConsumer实例的成员变量queue中添加数据，等待消费</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">byte</span>[] body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Storing delivery for consumerTag: &#x27;&quot;</span></span><br><span class="line">                     + consumerTag + <span class="string">&quot;&#x27; with deliveryTag: &#x27;&quot;</span> + envelope.getDeliveryTag() + <span class="string">&quot;&#x27; in &quot;</span></span><br><span class="line">                     + BlockingQueueConsumer.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (BlockingQueueConsumer.<span class="keyword">this</span>.abortStarted &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!BlockingQueueConsumer.<span class="keyword">this</span>.queue.offer(</span><br><span class="line">                <span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body, <span class="keyword">this</span>.queueName),</span><br><span class="line">                BlockingQueueConsumer.<span class="keyword">this</span>.shutdownTimeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line"></span><br><span class="line">                Channel channelToClose = <span class="keyword">super</span>.getChannel();</span><br><span class="line">                RabbitUtils.setPhysicalCloseRequired(channelToClose, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// Defensive - should never happen</span></span><br><span class="line">                BlockingQueueConsumer.<span class="keyword">this</span>.queue.clear();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.canceled) &#123;</span><br><span class="line">                    RabbitUtils.cancel(channelToClose, consumerTag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channelToClose.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> TimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">// no-op</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//核心</span></span><br><span class="line">            BlockingQueueConsumer.<span class="keyword">this</span>.queue</span><br><span class="line">                .put(<span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body, <span class="keyword">this</span>.queueName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        BlockingQueueConsumer.logger.warn(<span class="string">&quot;Unexpected exception during delivery&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DerictMessaeListenerContainer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Executor taskExecutor = <span class="keyword">new</span> SimpleAsyncTaskExecutor();</span><br><span class="line"><span class="comment">//容器开始</span></span><br><span class="line">doStart()&#123;</span><br><span class="line">    actualStart();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真的开始，一个异步线程开始创建监听的Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">actualStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queueNames.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        doRedeclareElementsIfNecessary();</span><br><span class="line">        getTaskExecutor().execute(() -&gt; &#123; <span class="comment">// NOSONAR never null here</span></span><br><span class="line">            startConsumers(queueNames);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过监听的队列名称创建Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startConsumers</span><span class="params">(<span class="keyword">final</span> String[] queueNames)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String queue : queueNames) &#123;</span><br><span class="line">        consumeFromQueue(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更加配置的consumersPerQueue为每个队列创建对应数量的Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeFromQueue</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">    List&lt;SimpleConsumer&gt; list = <span class="keyword">this</span>.consumersByQueue.get(queue);</span><br><span class="line">    <span class="comment">// Possible race with setConsumersPerQueue and the task launched by start()</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.consumersPerQueue; i++) &#123;</span><br><span class="line">            doConsumeFromQueue(queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Consuemer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doConsumeFromQueue</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">    SimpleConsumer consumer = consume(queue, connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SimpleConsumer <span class="title">consume</span><span class="params">(String queue, Connection connection)</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    SimpleConsumer consumer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = connection.createChannel(isChannelTransacted());</span><br><span class="line">        channel.basicQos(getPrefetchCount());</span><br><span class="line">        consumer = <span class="keyword">new</span> SimpleConsumer(connection, channel, queue);</span><br><span class="line">        channel.queueDeclarePassive(queue);</span><br><span class="line">        consumer.consumerTag = channel.basicConsume(queue, getAcknowledgeMode().isAutoAck(),</span><br><span class="line">                                                    (getConsumerTagStrategy() != <span class="keyword">null</span></span><br><span class="line">                                                     ? getConsumerTagStrategy().createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="comment">// NOSONAR never null</span></span><br><span class="line">                                                    isNoLocal(), isExclusive(), getConsumerArguments(), consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AmqpApplicationContextClosedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AmqpConnectException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        RabbitUtils.closeChannel(channel);</span><br><span class="line">        RabbitUtils.closeConnection(connection);</span><br><span class="line"></span><br><span class="line">        consumer = handleConsumeException(queue, consumer, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二个消费者容器区别"><a href="#二个消费者容器区别" class="headerlink" title="二个消费者容器区别"></a>二个消费者容器区别</h2><p><img src="/2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/image-20201216160611728.png" alt="image-20201216160611728"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/14/Spring-boot-amqp%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/14/Spring-boot-amqp%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Spring-boot-amqp配置原理解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-14 12:07:13" itemprop="dateCreated datePublished" datetime="2020-12-14T12:07:13+08:00">2020-12-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/springboot/" itemprop="url" rel="index"><span itemprop="name">springboot</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CachingConnectionFactory"><a href="#CachingConnectionFactory" class="headerlink" title="CachingConnectionFactory"></a>CachingConnectionFactory</h2><p>连接工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">getCachingConnectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    factory.setAddresses(rabbitProperties.getAddresses());</span><br><span class="line">    factory.setUsername(rabbitProperties.getUsername());</span><br><span class="line">    factory.setPassword(rabbitProperties.getPassword());</span><br><span class="line">    factory.setVirtualHost(rabbitProperties.getVirtualHost());</span><br><span class="line">    factory.setPublisherConfirms(rabbitProperties.isPublisherConfirms());</span><br><span class="line">    factory.setPublisherReturns(rabbitProperties.isPublisherReturns());</span><br><span class="line">    factory.addChannelListener(rabbitChannelListener);</span><br><span class="line">    factory.addConnectionListener(rabbitConnectionListener);</span><br><span class="line">    factory.setRecoveryListener(rabbitRecoveryListener);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean(&quot;test-consumer-connection-factory&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">consumerCachingConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getCachingConnectionFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">cachingConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getCachingConnectionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在一个应用里面同时存在消费者和生产者时，为了<strong>避免消费者由于生产者阻塞而阻塞</strong>，需要特别注意：</p>
<ul>
<li>使用一个具有相同选项的单独CachingConnectionFactory实例—一个用于生产者，一个用于消费者</li>
<li>rabbitTemplate.setUsePublisherConnection(true);</li>
</ul>
<h2 id="RabbitTemplate"><a href="#RabbitTemplate" class="headerlink" title="RabbitTemplate"></a>RabbitTemplate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(CachingConnectionFactory factory)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;caching factory: &#123;&#125;&quot;</span>, factory.getChannelCacheSize());</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(factory);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(rabbitConfirmCallback);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当mandatory标志位设置为true时</span></span><br><span class="line"><span class="comment">         * 如果exchange根据自身类型和消息routingKey无法找到一个合适的queue存储消息</span></span><br><span class="line"><span class="comment">         * 那么broker会调用basic.return方法将消息返还给生产者</span></span><br><span class="line"><span class="comment">         * 当mandatory设置为false时，出现上述情况broker会直接将消息丢弃</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">    rabbitTemplate.setReturnCallback(rabbitReturnCallback);</span><br><span class="line">    <span class="comment">//使用单独的发送连接，避免生产者由于各种原因阻塞而导致消费者同样阻塞</span></span><br><span class="line">    rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfirmCallback：ConfirmCallback接口用于实现消息发送到RabbitMQ交换器后接收ack回调，不管是否到交换机都会进行回调<br>ReturnCallback：ReturnCallback接口用于实现消息发送到RabbitMQ交换器后，但无相应队列与交换器绑定时的回调，即无法消息从交换机中入相应队列的回调，如果成功入队列则不回调</p>
<h3 id="发送的消息中携带其它信息，如唯一值"><a href="#发送的消息中携带其它信息，如唯一值" class="headerlink" title="发送的消息中携带其它信息，如唯一值"></a>发送的消息中携带其它信息，如唯一值</h3><ul>
<li><p>可以使用header存放，使用MessagePostProcessor设置header属性</p>
</li>
<li><p>可以发送的时候携带CorrelationData对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData correlationData = <span class="keyword">new</span> CorrelationData();</span><br><span class="line">correlationData.setId(dataId);</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName, rountingKey, message, correlationData);</span><br></pre></td></tr></table></figure>

<p>从2.1版本开始，CorrelationData对象具有ListenableFuture，可用于获取结果，而不是在rabbitTemplate上使用ConfirmCallback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData cd1 = <span class="keyword">new</span> CorrelationData();</span><br><span class="line"><span class="keyword">this</span>.templateWithConfirmsEnabled.convertAndSend(<span class="string">&quot;exchange&quot;</span>, queue.getName(), <span class="string">&quot;foo&quot;</span>, cd1);</span><br><span class="line">assertTrue(cd1.getFuture().get(<span class="number">10</span>, TimeUnit.SECONDS).isAck());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Message实体"><a href="#Message实体" class="headerlink" title="Message实体"></a>Message实体</h2><ul>
<li>Message包含属性：MessageProperties messageProperties包含属性：Map&lt;String, Object&gt; headers</li>
<li>Message包含属性：byte[] body</li>
<li>MessagePostProcessor 对Message进行处理</li>
</ul>
<h2 id="交换机队列绑定"><a href="#交换机队列绑定" class="headerlink" title="交换机队列绑定"></a>交换机队列绑定</h2><ul>
<li>通过rabbitAdmin进行创建交换机、队列及绑定key</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTopicExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建交换机，类型为topic, durable 参数表示是否持久化</span></span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> TopicExchange(<span class="string">&quot;test.topic&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// 创建队列 durable 参数表示是否持久化</span></span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">//链式写法</span></span><br><span class="line">    rabbitAdmin.declareBinding(</span><br><span class="line">        BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="keyword">false</span>)) <span class="comment">// 直接创建队列</span></span><br><span class="line">        .to(<span class="keyword">new</span> TopicExchange(<span class="string">&quot;test.topic&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)) <span class="comment">// 直接创建交换机，并建立关联关系</span></span><br><span class="line">        .with(<span class="string">&quot;routing_topic.*&quot;</span>) <span class="comment">// 指定路由 key</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createHeadersExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> HeadersExchange(<span class="string">&quot;test.headers&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.headers.queue&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;headers&quot;</span>);</span><br><span class="line">    Binding binding = BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.headers.queue&quot;</span>, <span class="keyword">false</span>))</span><br><span class="line">        .to(<span class="keyword">new</span> HeadersExchange(<span class="string">&quot;test.headers&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">        .whereAll(map).match();</span><br><span class="line">    rabbitAdmin.declareBinding(binding);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDirectExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue1&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue2&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareBinding(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue1&quot;</span>, <span class="keyword">false</span>)</span><br><span class="line">        ).to(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)).with(<span class="string">&quot;test.direct.routing&quot;</span>));</span><br><span class="line">    rabbitAdmin.declareBinding(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue2&quot;</span>, <span class="keyword">false</span>)</span><br><span class="line">        ).to(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)).with(<span class="string">&quot;test.direct.routing&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>简单方式即直接创建Bean即可，会帮助在broker上创建对应队列等<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">posThemeExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(posThemeExchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">posThemeQueueName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(posThemeQueueName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bindingPosThemeQueueName</span><span class="params">(FanoutExchange posThemeExchange,Queue posThemeQueueName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(posThemeQueueName).to(posThemeExchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//topic模式</span></span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.topic&quot;</span>, <span class="string">&quot;routing_topic.1&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message1&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.topic&quot;</span>, <span class="string">&quot;routing_topic.2&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message2&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br><span class="line"><span class="comment">//headers模式</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;headers&quot;</span>);</span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.headers&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message3&quot;</span>.getBytes(), messageProperties));</span><br><span class="line"><span class="comment">//direct模式</span></span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.direct&quot;</span>, <span class="string">&quot;test.direct.routing&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message4&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br></pre></td></tr></table></figure>

<h2 id="消息监听（监听的是队列）"><a href="#消息监听（监听的是队列）" class="headerlink" title="消息监听（监听的是队列）"></a>消息监听（监听的是队列）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(factory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="string">&quot;test.headers.queue&quot;</span>, <span class="string">&quot;test.direct.queue1&quot;</span>, <span class="string">&quot;test.direct.queue2&quot;</span>);</span><br><span class="line">    container.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到：&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SimpleMessageListenerContainer和DirectMessageListenerContainer"><a href="#SimpleMessageListenerContainer和DirectMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer和DirectMessageListenerContainer"></a>SimpleMessageListenerContainer和DirectMessageListenerContainer</h2><p>在版本2.0之前的版本中，只有一种MessageListenerContainer—SimpleMessageListenerContainer;</p>
<p>2.0之后有第二个容器——DirectMessageListenerContainer</p>
<h4 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h4><p>默认情况下，侦听器容器将启动单个使用者，该使用者将从队列接收消息。控制并发性的属性concurrentConsumers，它只创建(固定的)将并发处理消息的使用者数量。还添加了一个新的属性maxConcurrentConsumers，容器将根据工作负载动态调整并发性。与四个附加属性一起工作:continutiveactivetrigger、startConsumerMinInterval、continutiveidletrigger、stopConsumerMinInterval。</p>
<p>在默认设置下，增加消费者的算法工作如下：</p>
<p>如果尚未到达maxConcurrentConsumers，并且已有的使用者连续10个周期处于活动状态，并且自上一个使用者启动以来至少已经过了10秒，那么将启动一个新的使用者。如果使用者在txSize *中接收到至少一条消息，则认为该使用者处于活动状态。</p>
<p>在默认设置下，减少消费者的算法工作如下:</p>
<p>如果有多个concurrentConsumers正在运行，并且某个consumer检测到10个连续超时(空闲)，并且上一个consumer至少在60秒之前停止，那么该consumer将停止。超时取决于receiveTimeout和txSize属性。如果使用者在txSize *中没有接收到任何消息，则认为它是空闲的。因此，在默认超时(1秒)和txSize为4的情况下，在40秒的空闲时间(4个超时对应1个空闲检测)之后将考虑停止使用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">simpleRabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="comment">//初始化消费者数量</span></span><br><span class="line">    factory.setConcurrentConsumers(<span class="keyword">this</span>.concurrentConsumers);</span><br><span class="line">    <span class="comment">//最大消费者数量</span></span><br><span class="line">    factory.setMaxConcurrentConsumers(<span class="keyword">this</span>.maxConcurrentConsumers);</span><br><span class="line">    <span class="comment">//手动确认消息</span></span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">    factory.setErrorHandler(rabbitErrorHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DirectMessageListenerContainer"><a href="#DirectMessageListenerContainer" class="headerlink" title="DirectMessageListenerContainer"></a>DirectMessageListenerContainer</h4><p>使用DirectMessageListenerContainer，您需要确保ConnectionFactory配置了一个任务执行器，该执行器在使用该ConnectionFactory的所有侦听器容器中具有足够的线程来支持所需的并发性。默认连接池大小仅为5。</p>
<p>并发性基于配置的队列和consumersPerQueue。每个队列的每个使用者使用一个单独的通道，并发性由rabbit客户端库控制;默认情况下，它使用5个线程池;您可以配置taskExecutor来提供所需的最大并发性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectRabbitListenerContainerFactory <span class="title">directRabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactory factory = <span class="keyword">new</span> DirectRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="comment">//每个队列的消费者数量</span></span><br><span class="line">    factory.setConsumersPerQueue(<span class="keyword">this</span>.consumersPerQueue);</span><br><span class="line">    <span class="comment">//手动确认消息</span></span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">    factory.setErrorHandler(rabbitErrorHandler);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>SimpleMessageListenerContainer提供了以下特性，但DirectMessageListenerContainer不提供:</p>
<ul>
<li>txSize—使用SimpleMessageListenerContainer，您可以将其设置为控制事务中传递的消息数量和/或减少ack的数量，但这可能会导致失败后重复传递的数量增加。(与txSize和SimpleMessageListenerContainer一样，DirectMessageListenerContainer也有mesagesPerAck，可以用来减少ack，但不能用于事务—每个消息都在单独的事务中交付和打包)。</li>
<li>maxconcurrentconsumer和consumer伸缩间隔/触发器—DirectMessageListenerContainer中没有自动伸缩;但是，它允许您以编程方式更改consumersPerQueue属性，并相应地调整使用者。</li>
</ul>
<p>与SimpleMessageListenerContainer相比，DirectMessageListenerContainer有以下优点:</p>
<ul>
<li>在运行时添加和删除队列更有效;使用SimpleMessageListenerContainer，整个使用者线程重新启动(所有使用者取消并重新创建);对于DirectMessageListenerContainer，不受影响的使用者不会被取消。</li>
<li>避免了RabbitMQ客户机线程和使用者线程之间的上下文切换。</li>
<li>线程是跨使用者共享的，而不是为SimpleMessageListenerContainer中的每个使用者都有一个专用线程。但是，请参阅“线程和异步使用者”一节中有关连接工厂配置的重要说明。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yingziisme/category_8289776.html">RabbitMQ</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/" class="post-title-link" itemprop="url">RabbitMQ基础之事件监听</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-14 11:01:06" itemprop="dateCreated datePublished" datetime="2020-12-14T11:01:06+08:00">2020-12-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yingziisme">yingziisme</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yingziisme/article/details/86418540">https://blog.csdn.net/yingziisme/article/details/86418540</a></p>
<h2 id="ChannelListener"><a href="#ChannelListener" class="headerlink" title="ChannelListener"></a>ChannelListener</h2><p>用于监听通道的创建和销毁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitChannelListener</span> <span class="keyword">implements</span> <span class="title">ChannelListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;======================onCreate channel: &#123;&#125;, transactional: &#123;&#125;&quot;</span>, channel, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可根据isHardError判断是channel断开还是connection断开</span></span><br><span class="line">        <span class="keyword">if</span>(signal.isHardError())&#123;</span><br><span class="line">            AMQImpl.Connection.Close close = (AMQImpl.Connection.Close) signal.getReason();</span><br><span class="line">            log.warn(<span class="string">&quot;=====================Connection onShutDown replyCode: &#123;&#125;, methodId: &#123;&#125;, classId: &#123;&#125;, replyText: &#123;&#125;&quot;</span>,</span><br><span class="line">                    close.getReplyCode(), close.getMethodId(), close.getClassId(), close.getReplyText());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            AMQImpl.Channel.Close close = (AMQImpl.Channel.Close) signal.getReason();</span><br><span class="line">            log.warn(<span class="string">&quot;=====================Channel onShutDown replyCode: &#123;&#125;, methodId: &#123;&#125;, classId: &#123;&#125;, replyText: &#123;&#125;&quot;</span>,</span><br><span class="line">                    close.getReplyCode(), close.getMethodId(), close.getClassId(), close.getReplyText());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConnectionListener"><a href="#ConnectionListener" class="headerlink" title="ConnectionListener"></a>ConnectionListener</h2><p>用于监听连接的创建和关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConnectionListener</span> <span class="keyword">implements</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onCreate: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onClose: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onShutDown: &#123;&#125;&quot;</span>, signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RecoveryListener"><a href="#RecoveryListener" class="headerlink" title="RecoveryListener"></a>RecoveryListener</h2><p>监听自动重连的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitRecoveryListener</span> <span class="keyword">implements</span> <span class="title">RecoveryListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecovery</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================handleRecovery: &#123;&#125;&quot;</span>, recoverable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecoveryStarted</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================handleRecoveryStarted: &#123;&#125;&quot;</span>, recoverable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BlockedListener"><a href="#BlockedListener" class="headerlink" title="BlockedListener"></a>BlockedListener</h2><p>监听连接阻塞情况的监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitBlockedListener</span> <span class="keyword">implements</span> <span class="title">BlockedListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBlocked</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;=========================connection blocked, reason: &#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUnblocked</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;==============================connection unblocked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="是在RabbitMQ-connection连接上的时候设置进去的"><a href="#是在RabbitMQ-connection连接上的时候设置进去的" class="headerlink" title="是在RabbitMQ connection连接上的时候设置进去的"></a>是在RabbitMQ connection连接上的时候设置进去的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConnectionListener</span> <span class="keyword">implements</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitBlockedListener rabbitBlockedListener;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onCreate: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">        connection.addBlockedListener(rabbitBlockedListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onClose: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onShutDown: &#123;&#125;&quot;</span>, signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，RabbitMQ的状态是这样的</p>
<p><img src="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/20190113143502400.jpg" alt="在这里插入图片描述"></p>
<h4 id="测试内存报警"><a href="#测试内存报警" class="headerlink" title="测试内存报警"></a>测试内存报警</h4><p>RabbitMQ内存报警水位是由vm_memory_high_watermark来控制的</p>
<p>在RabbitMQ使用 rabbitmqctl set_vm_memory_high_watermark 0.01</p>
<ul>
<li>设置内存报警的水位，当内存使用达到了该水位时，RabbitMQ将产生报警</li>
<li>可以通过rabbitmqctl status | grep vm_memory_high_watermark查看当前的水位设置，默认时0.4</li>
</ul>
<p>此时查看报警时的RabbitMQ的状态</p>
<p><img src="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/201901131435132.jpg" alt="在这里插入图片描述"></p>
<p>此时往RabbitMQ发送一条消息，将会收到BlockedListener的消息，且reason会提示具体的错误原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">49</span>:<span class="number">53.408</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : =========================connection blocked, reason:low on memory</span><br></pre></td></tr></table></figure>

<p>再将水位修改回来<br>rabbitmqctl set_vm_memory_high_watermark 0.4</p>
<p>查看此时的程序的打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">51</span>:<span class="number">40.386</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">2</span>:<span class="number">351</span>:<span class="number">40.396</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">51</span>:<span class="number">40.398</span>  INFO <span class="number">73408</span> --- [cTaskExecutor-<span class="number">4</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h4 id="测试磁盘报警"><a href="#测试磁盘报警" class="headerlink" title="测试磁盘报警"></a>测试磁盘报警</h4><p>同样的修改磁盘的配置rabbitmqctl set_disk_free_limit  48G</p>
<ul>
<li>设置空闲磁盘的大小，空闲值小于该值时产生报警，默认时48M</li>
<li>也可以使用这个命令将磁盘和内存的大小关联起来设置 xx时磁盘和内存的配比 rabbitmqctl set_disk_free_limit mem_relative xx</li>
</ul>
<p>此时查看RabbitMQ的控制台<br><img src="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/20190113143526140.jpg" alt="在这里插入图片描述"></p>
<p>此时往RabbitMQ发送一条消息，将会收到BlockedListener的消息，且reason会提示具体的错误原因</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-01-09 23:58:17.318  INFO 49240 --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;connection blocked, reason:low on disk</span><br></pre></td></tr></table></figure>

<p>再将磁盘限制修改回来rabbitmqctl set_disk_free_limit 48M</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.793</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.801</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.806</span>  INFO <span class="number">49240</span> --- [cTaskExecutor-<span class="number">3</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h4 id="测试同时报警"><a href="#测试同时报警" class="headerlink" title="测试同时报警"></a>测试同时报警</h4><p>同时设置内存和磁盘报警<br><img src="/2020/12/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/2019011314353976.jpg" alt="在这里插入图片描述"><br>发送消息到队列，则会在这个监听器产生报警信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">08.811</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : =========================connection blocked, reason:low on disk &amp; memory</span><br></pre></td></tr></table></figure>

<p>需要同时解除内存和磁盘的报警才会收到unblock的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">764</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">765</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">766</span>  INFO <span class="number">49240</span> --- [cTaskExecutor-<span class="number">2</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Ribbon源码解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-11 18:15:40" itemprop="dateCreated datePublished" datetime="2020-12-11T18:15:40+08:00">2020-12-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/trust-freedom/">Trust_FreeDom</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/trust-freedom/p/11216280.html#3560239013">https://www.cnblogs.com/trust-freedom/p/11216280.html#3560239013</a></p>
<p>事情的起因是这样的，公司内部要实现基于Zuul网关的灰度路由，在上线时进行灰度测试，故需要配置业务微服务向Eureka注册的metadata元数据，和自定义Ribbon的负载规则达到只访问灰度服务的目的。这样就需要自定义Ribbon的IRule，实现灰度请求只会负载到带有灰度标签元数据的业务微服务上，当自定义IRule规则开发好后，问题是如何将这个IRule规则配置给某个Ribbon Client或者全局生效。</p>
<blockquote>
<p>本次使用Spring Cloud Dalston.SR5版本</p>
<p>在其 <a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi_spring-cloud-ribbon.html">官方文档</a> 中其实已经给出了一些如何针对某个Client 或者 修改默认配置的方式，但没有说明为什么这样使用</p>
</blockquote>
<p>下面将按照这样的思路分析：</p>
<ul>
<li>简单分析Spring Cloud Ribbon启动时如何自动配置的，以了解其装配到Spring中的Bean</li>
<li>Spring Cloud Ribbon Client的懒加载</li>
<li>Spring Cloud Ribbon Client的配置加载，包含全局配置及Client配置</li>
<li>如何自定义Client配置、全局配置</li>
<li>解释官方文档中的一些注意事项<h2 id="Spring-Cloud-Ribbon自动配置"><a href="#Spring-Cloud-Ribbon自动配置" class="headerlink" title="Spring Cloud Ribbon自动配置"></a>Spring Cloud Ribbon自动配置</h2></li>
</ul>
<p>当前版本中的Netflix所有自动配置都在<code>spring-cloud-netflix-core-xxx.jar</code>中，根据其<code>META-INF/spring.factories</code>中的配置得知，Spring Cloud Ribbon的自动配置类为 <strong><code>RibbonAutoConfiguration</code></strong><br><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/677054-20190719235138006-1969052898.jpg" alt="img"></p>
<h2 id="RibbonAutoConfiguration"><a href="#RibbonAutoConfiguration" class="headerlink" title="RibbonAutoConfiguration"></a>RibbonAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; IClient.class, RestTemplate.class, AsyncRestTemplate.class, Ribbon.class&#125;)</span></span><br><span class="line"><span class="meta">@RibbonClients</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(name = &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RibbonEagerLoadProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有针对某个RibbonClient指定的配置</span></span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ribbon是否懒加载的配置文件</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会给每个RibbonClient创建独立的ApplicationContext上下文</span></span><br><span class="line">    <span class="comment">// 并在其上下文中创建RibbonClient对应的Bean：如IClient、ILoadbalancer等</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">		factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring创建的带负载均衡功能的Client，会使用SpringClientFactory创建对应的Bean和配置</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(LoadBalancerClient.class)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(springClientFactory());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到Spring environment中加载针对某个Client的Ribbon的核心接口实现类</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PropertiesFactory <span class="title">propertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PropertiesFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果不是懒加载，启动时就使用RibbonApplicationContextInitializer加载并初始化客户端配置</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(value = &quot;ribbon.eager-load.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RibbonApplicationContextInitializer <span class="title">ribbonApplicationContextInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RibbonApplicationContextInitializer(springClientFactory(),</span><br><span class="line">				ribbonEagerLoadProperties.getClients());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>RibbonAutoConfiguration</code>创建的Bean主要分以下几类：</p>
<ul>
<li>为Ribbon Client创建环境及获取配置<ul>
<li><strong>SpringClientFactory</strong>： 会给每个Ribbon Client创建一个独立的Spring应用上下文ApplicationContext，并在其中加载对应的配置及Ribbon核心接口的实现类</li>
<li><strong>PropertiesFactory</strong>： 用于从Spring enviroment环境中获取针对某个Ribbon Client配置的核心接口实现类，并实例化</li>
</ul>
</li>
<li>创建<code>RibbonLoadBalancerClient</code>，并将springClientFactory注入，方便从中获取对应的配置及实现类，<code>RibbonLoadBalancerClient</code>是Spring对<code>LoadBalancerClient</code>接口的实现类，其<code>execute()</code>方法提供客户端负载均衡能力</li>
<li>懒加载相关<ul>
<li>RibbonEagerLoadProperties： 懒加载配置项Properties，可以指定是否懒加载，及哪些Client不懒加载</li>
<li>RibbonApplicationContextInitializer： 启动时就加载RibbonClient配置（非懒加载）的初始化器</li>
</ul>
</li>
</ul>
<p>可以看到默认启动流程中并没有加载RibbonClient的上下文和配置信息，而是在使用时才加载，即懒加载</p>
<h2 id="Spring-Cloud-RibbonClient的懒加载"><a href="#Spring-Cloud-RibbonClient的懒加载" class="headerlink" title="Spring Cloud RibbonClient的懒加载"></a>Spring Cloud RibbonClient的懒加载</h2><p>既然是在使用时才会加载，那么以Zuul网关为例，在其<code>RibbonRoutingFilter</code>中会创建RibbonCommand，其包含了Ribbon的负载均衡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## RibbonRoutingFilter  Zuul负责路由的Filter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRoutingFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">		<span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			RibbonCommandContext commandContext = buildCommandContext(context);</span><br><span class="line">			ClientHttpResponse response = forward(commandContext);</span><br><span class="line">			setResponse(response);</span><br><span class="line">			<span class="keyword">return</span> response;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ZuulException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">forward</span><span class="params">(RibbonCommandContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; info = <span class="keyword">this</span>.helper.debug(context.getMethod(),</span><br><span class="line">				context.getUri(), context.getHeaders(), context.getParams(),</span><br><span class="line">				context.getRequestEntity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ribbonCommandFactory创建RibbonCommand</span></span><br><span class="line">		RibbonCommand command = <span class="keyword">this</span>.ribbonCommandFactory.create(context);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ClientHttpResponse response = command.execute();</span><br><span class="line">			<span class="keyword">this</span>.helper.appendDebug(info, response.getStatusCode().value(),</span><br><span class="line">					response.getHeaders());</span><br><span class="line">			<span class="keyword">return</span> response;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (HystrixRuntimeException ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> handleException(info, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行<code>RibbonRoutingFilter#run()</code>进行路由时会执行<code>forward()</code>方法，由于此处是在<strong>HystrixCommand</strong>内部执行Ribbon负载均衡调用，故使用ribbonCommandFactory创建RibbonCommand，Ribbon客户端的懒加载就在这个方法内，这里我们看<code>HttpClientRibbonCommandFactory</code>实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.zuul.filters.route.apache.HttpClientRibbonCommandFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonCommandFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRibbonCommandFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HttpClientRibbonCommand <span class="title">create</span><span class="params">(<span class="keyword">final</span> RibbonCommandContext context)</span> </span>&#123;</span><br><span class="line">		ZuulFallbackProvider zuulFallbackProvider = getFallbackProvider(context.getServiceId());</span><br><span class="line">		<span class="keyword">final</span> String serviceId = context.getServiceId();</span><br><span class="line">        <span class="comment">// 通过SpringClientFactory获取IClient接口实例</span></span><br><span class="line">		<span class="keyword">final</span> RibbonLoadBalancingHttpClient client = <span class="keyword">this</span>.clientFactory.getClient(</span><br><span class="line">				serviceId, RibbonLoadBalancingHttpClient.class);</span><br><span class="line">		client.setLoadBalancer(<span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommand(serviceId, client, context, zuulProperties, zuulFallbackProvider,</span><br><span class="line">				clientFactory.getClientConfig(serviceId));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建<code>RibbonLoadBalancingHttpClient</code>的逻辑在 <code>SpringClientFactory#getClient(serviceId, RibbonLoadBalancingHttpClient.class)</code>，如下：</p>
<ul>
<li>SpringClientFactory#getInstance(name, clientClass)<ul>
<li>NamedContextFactory#getInstance(name, type)：<ul>
<li>获取Client对应的ApplicationContext，如没有则调用createContext()创建，其中包含注册统一默认配置类RibbonClientConfiguration，或@RibbonClient、@RibbonClients(defaultConfiguration=xxx) 设置的配置类的逻辑</li>
<li>从ApplicationContext中根据类型获取实例，如没有使用反射创建，并通过IClientConfig配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如上执行完毕RibbonClient就基本懒加载完成了，就可以到RibbonClient对应的ApplicationContext中继续获取其它核心接口的实现类了，这些实现类都是根据 <strong>默认/全局/Client自定义</strong> 配置创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.SpringClientFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringClientFactory</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">RibbonClientSpecification</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String NAMESPACE = <span class="string">&quot;ribbon&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SpringClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(RibbonClientConfiguration.class, NAMESPACE, <span class="string">&quot;ribbon.client.name&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Get the rest client associated with the name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> RuntimeException if any error occurs</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> &lt;C extends IClient&lt;?, ?&gt;&gt; <span class="function">C <span class="title">getClient</span><span class="params">(String name, Class&lt;C&gt; clientClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getInstance(name, clientClass);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// name代表当前Ribbon客户端，type代表要获取的实例类型，如IClient、IRule</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">getInstance</span><span class="params">(String name, Class&lt;C&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先从父类NamedContextFactory中直接从客户端对应的ApplicationContext中获取实例</span></span><br><span class="line">        <span class="comment">// 如果没有就根据IClientConfig中的配置找到具体的实现类，并通过反射初始化后放到Client对应的ApplicationContext中</span></span><br><span class="line">		C instance = <span class="keyword">super</span>.getInstance(name, type);</span><br><span class="line">		<span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;</span><br><span class="line">		IClientConfig config = getInstance(name, IClientConfig.class);</span><br><span class="line">		<span class="keyword">return</span> instantiateWithConfig(getContext(name), type, config);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用IClientConfig实例化</span></span><br><span class="line">    <span class="keyword">static</span> &lt;C&gt; <span class="function">C <span class="title">instantiateWithConfig</span><span class="params">(AnnotationConfigApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">										Class&lt;C&gt; clazz, IClientConfig config)</span> </span>&#123;</span><br><span class="line">		C result = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过以IClientConfig为参数的构造创建clazz类实例</span></span><br><span class="line">			Constructor&lt;C&gt; constructor = clazz.getConstructor(IClientConfig.class);</span><br><span class="line">			result = constructor.newInstance(config);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">			<span class="comment">// Ignored</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果没创建成功，使用无惨构造</span></span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			result = BeanUtils.instantiate(clazz);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 调用初始化配置方法</span></span><br><span class="line">			<span class="keyword">if</span> (result <span class="keyword">instanceof</span> IClientConfigAware) &#123;</span><br><span class="line">				((IClientConfigAware) result).initWithNiwsConfig(config);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 处理自动织入</span></span><br><span class="line">			<span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">				context.getAutowireCapableBeanFactory().autowireBean(result);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//## 父类 org.springframework.cloud.context.named.NamedContextFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 维护Ribbon客户端对应的ApplicationContext上下文</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 维护Ribbon客户端的@Configuration配置类</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt; defaultConfigType;  <span class="comment">// 默认配置类为 RibbonClientConfiguration</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String propertySourceName;  <span class="comment">// 默认为 ribbon</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String propertyName;  <span class="comment">// 默认读取RibbonClient名的属性为ribbon.client.name</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NamedContextFactory</span><span class="params">(Class&lt;?&gt; defaultConfigType, String propertySourceName,</span></span></span><br><span class="line"><span class="function"><span class="params">			String propertyName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.defaultConfigType = defaultConfigType;</span><br><span class="line">		<span class="keyword">this</span>.propertySourceName = propertySourceName;</span><br><span class="line">		<span class="keyword">this</span>.propertyName = propertyName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果包含Client上下文直接返回</span></span><br><span class="line">	<span class="comment">// 如果不包含，调用createContext(name)，并放入contexts集合</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">					<span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建名为name的RibbonClient的ApplicationContext上下文</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// configurations集合中是否包含当前Client相关配置类，包含即注入到ApplicationContext</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">					.getConfiguration()) &#123;</span><br><span class="line">				context.register(configuration);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//configurations集合中是否包含default.开头的通过@RibbonClients(defaultConfiguration=xxx)配置的默认配置类</span></span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line">				<span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">					context.register(configuration);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 注册PropertyPlaceholderAutoConfiguration、RibbonClientConfiguration</span></span><br><span class="line">		context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line">				<span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">		<span class="comment">// 添加 ribbon.client.name=具体RibbonClient name的enviroment配置	 	</span></span><br><span class="line">		context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line">				<span class="keyword">this</span>.propertySourceName,</span><br><span class="line">				Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 设置父ApplicationContext，这样可以使得当前创建的子ApplicationContext可以使用父上下文中的Bean</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">			context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">		&#125;</span><br><span class="line">		context.refresh();  <span class="comment">//刷新Context</span></span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line">		<span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">				type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> context.getBean(type);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面比较重要的就是在创建每个RibbonClient的ApplicationContext的<code>createContext(name)</code>方法，其中包含了根据哪个@Configuration配置类创建Ribbon核心接口的实现类的逻辑，故需重点分析（Ribbon核心接口讲解 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhxdick/article/details/79710960">参考</a>）</p>
<p>那么在<code>createContext(name)</code>方法创建当前Ribbon Client相关的上下文，并注入配置类时，除了默认配置类<code>RibbonClientConfiguration</code>是写死的，其它的配置类，如default全局配置类，针对某个Ribbon Client的配置类，又是怎么配置的呢？</p>
<h2 id="Spring-Cloud-RibbonClient的配置加载，包含全局配置及Client配置"><a href="#Spring-Cloud-RibbonClient的配置加载，包含全局配置及Client配置" class="headerlink" title="Spring Cloud RibbonClient的配置加载，包含全局配置及Client配置"></a>Spring Cloud RibbonClient的配置加载，包含全局配置及Client配置</h2><h2 id="创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类"><a href="#创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类" class="headerlink" title="创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类"></a>创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.context.named.NamedContextFactory#createContext()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、注册专门为RibbonClient指定的configuration配置类，@RibbonClient注解</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">				.getConfiguration()) &#123;</span><br><span class="line">			context.register(configuration);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、将为所有RibbonClient的configuration配置类注册到ApplicationContext</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">				context.register(configuration);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、注册defaultConfigType，即Spring的默认配置类 RibbonClientConfiguration</span></span><br><span class="line">	context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line">			<span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">	context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line">			<span class="keyword">this</span>.propertySourceName,</span><br><span class="line">			Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">		context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">	&#125;</span><br><span class="line">	context.refresh();  <span class="comment">// 刷新上下文</span></span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据如上逻辑可以看出会从3个地方将Ribbon相关的Configuration配置类注册到专门为其准备的ApplicationContext上下文，并根据配置类创建Ribbon核心接口的实现类，即达到配置RibbonClient的目的</p>
<ol>
<li>从configurations这个Map中根据RibbonClient name获取专门为其指定的configuration配置类，并注册到其对应的ApplicationContext上下文</li>
<li>从configurations这个Map中找到 <strong>default. 开头</strong> 的配置类，即为所有RibbonClient的默认配置，并注册到其对应的ApplicationContext上下文</li>
<li>如果不是开发者单独指定的话，前两项都是没有数据的，还会注册Spring Cloud的默认配置类<code>RibbonClientConfiguration</code></li>
</ol>
<p>那么configurations这个Map里的配置类数据是从哪儿来的呢？？下面逐步分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## RibbonAutoConfiguration</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">	factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是在RibbonAutoConfiguration自动配置类创建<code>SpringClientFactory</code>是设置的，这个configurations集合是@Autowired的Spring容器内的<code>RibbonClientSpecification</code>集合，那么<code>RibbonClientSpecification</code>集合是何时被注册的？？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.RibbonClientConfigurationRegistrar</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfigurationRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、@RibbonClients注解</span></span><br><span class="line">		Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(</span><br><span class="line">				RibbonClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 1.1 value是RibbonClient[]，遍历针对具体的RibbonClient配置的configuration配置类，并注册</span></span><br><span class="line">		<span class="keyword">if</span> (attrs != <span class="keyword">null</span> &amp;&amp; attrs.containsKey(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">			AnnotationAttributes[] clients = (AnnotationAttributes[]) attrs.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (AnnotationAttributes client : clients) &#123;</span><br><span class="line">				registerClientConfiguration(registry, getClientName(client),</span><br><span class="line">						client.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 1.2 找到@RibbonClients注解的defaultConfiguration，即默认配置</span></span><br><span class="line">        <span class="comment">//     注册成以default.Classname.RibbonClientSpecification为名的RibbonClientSpecification</span></span><br><span class="line">		<span class="keyword">if</span> (attrs != <span class="keyword">null</span> &amp;&amp; attrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">			String name;</span><br><span class="line">			<span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">				name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">			&#125;</span><br><span class="line">			registerClientConfiguration(registry, name,</span><br><span class="line">					attrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、@RibbonClient注解</span></span><br><span class="line">        <span class="comment">// 注册某个具体Ribbon Client的configuration配置类</span></span><br><span class="line">		Map&lt;String, Object&gt; client = metadata.getAnnotationAttributes(</span><br><span class="line">				RibbonClient.class.getName(), <span class="keyword">true</span>);</span><br><span class="line">		String name = getClientName(client);</span><br><span class="line">		<span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">			registerClientConfiguration(registry, name, client.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(Map&lt;String, Object&gt; client)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String value = (String) client.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(value)) &#123;</span><br><span class="line">			value = (String) client.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(value)) &#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;Either &#x27;name&#x27; or &#x27;value&#x27; must be provided in @RibbonClient&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">			Object name, Object configuration)</span> </span>&#123;</span><br><span class="line">		BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">				.genericBeanDefinition(RibbonClientSpecification.class);</span><br><span class="line">		builder.addConstructorArgValue(name);</span><br><span class="line">		builder.addConstructorArgValue(configuration);</span><br><span class="line">		registry.registerBeanDefinition(name + <span class="string">&quot;.RibbonClientSpecification&quot;</span>,</span><br><span class="line">				builder.getBeanDefinition());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上可知，configurations配置类集合是根据<code>@RibbonClient</code> 和 <code>@RibbonClients</code> 注解配置的，分别有 <em>针对具体某个RibbonClient的配置</em> 和 <em>default默认配置</em></p>
<p>总结一下，Ribbon相关的@Configuration配置类是如何加载的</p>
<ol>
<li>在创建完RibbonClient对应的AnnotationConfigApplicationContext后，先从根据<code>@RibbonClient</code> 和 <code>@RibbonClients</code> 注解加载的configurations集合中找当前RibbonClient name对应的配置类，如有，就注册到上下文</li>
<li>再从configurations集合中找根据<code>@RibbonClients</code>注解加载的 <strong>default.开头</strong> 的默认配置类，如有，就注册到上下文</li>
<li>最后注册Spring Cloud默认的 <code>RibbonClientConfiguration</code></li>
</ol>
<p>上面说是如何创建RibbonClient相关的ApplicationContext上下文及注册Ribbon Client相关的配置类的逻辑，在确定配置类后，其中会用到Ribbon的<code>IClientConfig</code>相关的客户端配置来加载Ribbon客户端相关的配置信息，如超时配置、具体创建哪个核心接口的实现类等，可以从Spring Cloud默认注册的 <code>RibbonClientConfiguration</code>来一探究竟</p>
<h2 id="RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建"><a href="#RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建" class="headerlink" title="RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建"></a>RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration</span></span><br><span class="line"><span class="meta">@Import(&#123;OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;ribbon.client.name&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">&quot;client&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span></span><br><span class="line">	<span class="comment">// associated with ribbon clients</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IClientConfig <span class="title">ribbonClientConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		DefaultClientConfigImpl config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">		config.loadProperties(<span class="keyword">this</span>.name);</span><br><span class="line">		<span class="keyword">return</span> config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">		&#125;</span><br><span class="line">		ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">		rule.initWithNiwsConfig(config);</span><br><span class="line">		<span class="keyword">return</span> rule;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上面只截取了一段代码，给出了Ribbon相关的 <code>IClientConfig</code>客户端配置 和 某一个核心接口<code>IRule</code>实现类 是如何加载配置并创建的</p>
<p><strong>IClientConfig</strong></p>
<p><code>IClientConfig</code>就是Ribbon客户端配置的接口，可以看到先是创建了<code>DefaultClientConfigImpl</code>默认实现类，再<code>config.loadProperties(this.name)</code>加载当前Client相关的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## com.netflix.client.config.DefaultClientConfigImpl#loadProperties()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load properties for a given client. It first loads the default values for all properties,</span></span><br><span class="line"><span class="comment"> * and any properties already defined with Archaius ConfigurationManager.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(String restClientName)</span></span>&#123;</span><br><span class="line">    enableDynamicProperties = <span class="keyword">true</span>;</span><br><span class="line">    setClientName(restClientName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、使用Netflix Archaius的ConfigurationManager从Spring env中加载“ribbon.配置项”这类默认配置</span></span><br><span class="line">    <span class="comment">//   如没加载到有默认静态配置</span></span><br><span class="line">    loadDefaultValues();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、使用Netflix Archaius的ConfigurationManager从Spring env中加载“client名.ribbon.配置项”这类针对某个Client的配置信息</span></span><br><span class="line">    Configuration props = ConfigurationManager.getConfigInstance().subset(restClientName);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;String&gt; keys = props.getKeys(); keys.hasNext(); )&#123;</span><br><span class="line">        String key = keys.next();</span><br><span class="line">        String prop = key;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prop.startsWith(getNameSpace()))&#123;</span><br><span class="line">                prop = prop.substring(getNameSpace().length() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setPropertyInternal(prop, getStringValue(props, key));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;Property %s is invalid&quot;</span>, prop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据如上注释，如果你没有在项目中指定ribbon相关配置，那么会使用<code>DefaultClientConfigImpl</code>中的默认静态配置，如果Spring enviroment中包含“ribbon.配置项”这类针对所有Client的配置会被加载进来，有“client名.ribbon.配置项”这类针对某个Client的配置信息也会被加载进来</p>
<p><strong>静态配置如下：</strong></p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/677054/201907/677054-20190719235215286-1439271885.jpg"><img src="https://img2018.cnblogs.com/blog/677054/201907/677054-20190719235215286-1439271885.jpg" alt="img"></a></p>
<p><strong>RibbonClient核心接口实现类配置加载及创建</strong></p>
<p>上面说完<code>IClientCOnfig</code>配置项是如何加载的，按道理说其中已经包含了当前RibbonClient使用哪个核心接口实现类的配置，但Spring Cloud在此处定义了自己的实现逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看propertiesFactory是否有关于当前接口的配置，如有就使用，并创建实例返回</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spring cloud 默认配置</span></span><br><span class="line">	ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">	rule.initWithNiwsConfig(config);</span><br><span class="line">	<span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看<code>PropertiesFactory</code>的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">PropertiesFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PropertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		classToProperty.put(ILoadBalancer.class, <span class="string">&quot;NFLoadBalancerClassName&quot;</span>);</span><br><span class="line">		classToProperty.put(IPing.class, <span class="string">&quot;NFLoadBalancerPingClassName&quot;</span>);</span><br><span class="line">		classToProperty.put(IRule.class, <span class="string">&quot;NFLoadBalancerRuleClassName&quot;</span>);</span><br><span class="line">		classToProperty.put(ServerList.class, <span class="string">&quot;NIWSServerListClassName&quot;</span>);</span><br><span class="line">		classToProperty.put(ServerListFilter.class, <span class="string">&quot;NIWSServerListFilterClassName&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看当前clazz是否在classToProperty管理的几个核心接口之一</span></span><br><span class="line">    <span class="comment">// 如是，查看Spring environment中是否能找到 “clientName.ribbon.核心接口配置项”的配置信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StringUtils.hasText(getClassName(clazz, name));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">			String classNameProperty = <span class="keyword">this</span>.classToProperty.get(clazz);</span><br><span class="line">			String className = environment.getProperty(name + <span class="string">&quot;.&quot;</span> + NAMESPACE + <span class="string">&quot;.&quot;</span> + classNameProperty);</span><br><span class="line">			<span class="keyword">return</span> className;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是先调用getClassName()获取Spring enviroment中配置的核心接口实现类名</span></span><br><span class="line">    <span class="comment">// 再使用IClientConfig配置信息创建其实例</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">get</span><span class="params">(Class&lt;C&gt; clazz, IClientConfig config, String name)</span> </span>&#123;</span><br><span class="line">		String className = getClassName(clazz, name);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(className)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Class&lt;?&gt; toInstantiate = Class.forName(className);</span><br><span class="line">				<span class="keyword">return</span> (C) instantiateWithConfig(toInstantiate, config);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown class to load &quot;</span>+className+<span class="string">&quot; for class &quot;</span> + clazz + <span class="string">&quot; named &quot;</span> + name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故以上面创建<code>IRule</code>接口实现类的逻辑</p>
<ul>
<li>先通过<strong>propertiesFactory</strong>查看Spring enviroment中是否配置了针对当前Ribbon Client的IRule核心接口实现类的配置信息，如有，就创建其实例返回（相关配置格式： clientName.ribbon.NFLoadBalancerRuleClassName=具体IRule实现类）</li>
<li>如没有，那么没有直接使用Netflix在其<code>DefaultClientConfigImpl</code>中的静态配置，而是使用Spring Cloud自定义的默认实现类，拿<code>IRule</code>规则接口来说是<code>ZoneAvoidanceRule</code></li>
</ul>
<blockquote>
<p><strong>总结：</strong></p>
<p>首先会创建RibbonClient的ApplicationContext上下文，并确定使用哪个Configuration配置类</p>
<p>1、@RibbonClients注册的全局默认配置类</p>
<p>2、@RibbonClient注册的某个Client配置类</p>
<p>3、Spring Cloud 默认的RibbonClientConfiguration配置类</p>
<p>确定配置类后就是加载Client相关的IClientConfig配置信息，并创建核心接口实现类</p>
<p>如果没有自定义全局/客户端配置类，那么就是使用<code>RibbonClientConfiguration</code>，而其规则是</p>
<p>对于超时等配置（除核心接口实现类以外）：使用Netflix的配置逻辑，通过 <strong>ribbon.xxx</strong> 作为默认配置，以 <strong>clientName.ribbon.xxx</strong> 作为客户端定制配置</p>
<p>对于核心接口实现类配置：客户端定制配置仍然使用 <strong>clientName.ribbon.xxx</strong>，但默认配置是Spring Cloud在<code>RibbonClientConfiguration</code>方法中写死的默认实现类</p>
</blockquote>
<p>已经知道大概的逻辑了，下面就看看具体如何自定义Client配置、全局配置</p>
<h2 id="如何自定义RibbonClient配置、全局配置"><a href="#如何自定义RibbonClient配置、全局配置" class="headerlink" title="如何自定义RibbonClient配置、全局配置"></a>如何自定义RibbonClient配置、全局配置</h2><p>这部分在Spring Cloud官方reference中有说明 <a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi_spring-cloud-ribbon.html#_customizing_the_ribbon_client">16.2 Customizing the Ribbon Client</a></p>
<p><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BRibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/677054-20190719235233605-1701546833.jpg" alt="img"></p>
<p>大致意思如下：</p>
<ul>
<li><p>一部分配置（非核心接口实现类的配置）可以使用Netflix原生API提供的方式，即使用如 *<em>.ribbon.**</em> 的方式配置，具体有哪些配置项，可以参考 <code>com.netflix.client.config.CommonClientConfigKey</code></p>
</li>
<li><p>如果想比较全面的控制RibbonClient并添加一些额外配置，可以使用 <code>@RibbonClient</code> 或 <code>@RibbonClients</code> 注解，并配置一个配置类，如上的 FooConfiguration</p>
<ul>
<li><p>@RibbonClient(name = “foo”, configuration = FooConfiguration.class) 是针对名为 foo 的RibbonClient的配置类，也可以使用@RibbonClients({@RibbonClient数组}) 的形式给某几个RibbonClient设置配置类</p>
</li>
<li><p>@RibbonClients( defaultConfiguration = { xxx.class } ) 是针对所有RIbbonClient的默认配置</p>
<ul>
<li><p>官方文档说 FooConfiguration配置类 必须是@Configuration的，这样就必须注意，SpringBoot主启动类不能扫描到FooConfiguration，否则针对某个RibbonClient的配置就会变成全局的，原因是在创建每个RibbonClient时会为其创建ApplicationContext上下文，其parent就是主启动类创建的ApplicationContext，子ApplicationContext中可以使用父ApplicationContext中的Bean，且创建Bean时都使用了<code>@ConditionalOnMissingBean</code>，所以FooConfiguration如果被主启动类的上下文加载，且创建了比如IRule的实现类，在某个RIbbonClient创建其子ApplicationContext并@Bean想创建其自定义IRule实现类时，会发现parent ApplicationContext已经存在，就不会创建了，配置就失效了</p>
<blockquote>
<p>但在我的实验中，即使FooConfiguration不加@Configuration注解也可以加载为RibbonClient的配置，且由于没有@Configuration了，也不会被主启动类扫描到</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所以主要分成2种配置：</p>
<p>（1）超时时间等静态配置，使用 <strong>ribbon.*** 配置所有Client，使用 *<em>.ribbon.</em></strong> 配置某个Client</p>
<p>（2）使用哪种核心接口实现类配置，使用**@RibbonClients注解<strong>做默认配置，使用</strong>@RibbonClient**做针对Client的配置（注意@Configuration不要被SpringBoot主启动类扫描到的问题）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Spring-cloud-loadbalancer入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-11 10:10:21" itemprop="dateCreated datePublished" datetime="2020-12-11T10:10:21+08:00">2020-12-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:27" itemprop="dateModified" datetime="2024-07-12T10:34:27+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/user/1219867">冷冷</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1491013">https://cloud.tencent.com/developer/article/1491013</a></p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><strong>加入 loadbalancer pom坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置使用还是和 ribbon 一样配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LbConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://big-provider-server/demo&quot;</span>, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="LoadBalancerClient-实现"><a href="#LoadBalancerClient-实现" class="headerlink" title="LoadBalancerClient 实现"></a>LoadBalancerClient 实现</h3><p><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/1.jpeg"></p>
<ul>
<li>目前版本只提供了 BlockingLoadBalancerClient 的实现， 注意看中文注释</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除只保留了核心代码注意</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingLoadBalancerClient</span> <span class="keyword">implements</span> <span class="title">LoadBalancerClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 根据 服务名称去查询可用实例</span></span><br><span class="line">		ServiceInstance serviceInstance = choose(serviceId);</span><br><span class="line">		<span class="keyword">return</span> execute(serviceId, serviceInstance, request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// 获取负载均衡策略</span></span><br><span class="line">		ReactiveLoadBalancer&lt;ServiceInstance&gt; loadBalancer = loadBalancerClientFactory</span><br><span class="line">				.getInstance(serviceId);</span><br><span class="line">		<span class="comment">// 执行负载均衡策略获取可以实例</span></span><br><span class="line">		Response&lt;ServiceInstance&gt; loadBalancerResponse = Mono.from(loadBalancer.choose())</span><br><span class="line">				.block();</span><br><span class="line">		<span class="keyword">return</span> loadBalancerResponse.getServer();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loadBalancer-负载均衡策略实现"><a href="#loadBalancer-负载均衡策略实现" class="headerlink" title="loadBalancer 负载均衡策略实现"></a>loadBalancer <a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>策略实现</h3><p><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/2.jpeg">目前只有一个RoundRobinLoadBalancer 轮询选择server的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="title">implements</span> <span class="title">ReactorServiceInstanceLoadBalancer</span> </span>&#123;</span><br><span class="line">	public Mono&lt;Response&lt;ServiceInstance&gt;&gt; <span class="function"><span class="title">choose</span>(<span class="params">Request request</span>)</span> &#123;</span><br><span class="line">		ServiceInstanceSupplier supplier = <span class="built_in">this</span>.serviceInstanceSupplier.getIfAvailable();</span><br><span class="line">		<span class="keyword">return</span> supplier.get().collectList().map(instances -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line">				log.warn(<span class="string">&quot;No servers available for service: &quot;</span> + <span class="built_in">this</span>.serviceId);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> EmptyResponse();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> enforce order?</span></span><br><span class="line">			int pos = <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.position.incrementAndGet());</span><br><span class="line"></span><br><span class="line">			ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> DefaultResponse(instance);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="和ribbon-比较"><a href="#和ribbon-比较" class="headerlink" title="和ribbon 比较"></a>和ribbon 比较</h2><h3 id="默认负载均衡比较"><a href="#默认负载均衡比较" class="headerlink" title="默认负载均衡比较"></a>默认负载均衡比较</h3><ul>
<li><p>ribbon 提供7中默认的负载均衡策略，常见的常见都有覆盖，一般我们都是使用 ZoneAvoidanceRule复合判断server所在区域的性能和server的可用性选择server</p>
<p><img src="/2020/12/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1loadbalancer%E5%85%A5%E9%97%A8/3.jpeg"></p>
</li>
</ul>
<h3 id="配置方面丰富性"><a href="#配置方面丰富性" class="headerlink" title="配置方面丰富性"></a>配置方面丰富性</h3><ul>
<li><p>目前<code>spring-cloud-loadbalancer</code> 仅支持 重试操作的配置</p>
</li>
<li><p>ribbon 支持超时、懒加载处理、重试及其和 hystrix整合高级属性等</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
