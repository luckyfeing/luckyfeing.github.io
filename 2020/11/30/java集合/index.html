<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="数组​    开辟连续内存地址空间，数组长度固定，不能进行扩容，顺序存储。  List集合​    list集合可以使用数组或链表存储数据。  ArrayList使用数组进行存储。查找、更新效率高，插入、删除效率低，顺序存储，扩容为旧数组  LinkedList 使用双向链表进行存储。查找、更新效率低，插入、删除效率高，随机存储，不需要考虑扩容。使用二分查找法  Vector 使用数组进行存储，使">
<meta property="og:type" content="article">
<meta property="og:title" content="java集合">
<meta property="og:url" content="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="数组​    开辟连续内存地址空间，数组长度固定，不能进行扩容，顺序存储。  List集合​    list集合可以使用数组或链表存储数据。  ArrayList使用数组进行存储。查找、更新效率高，插入、删除效率低，顺序存储，扩容为旧数组  LinkedList 使用双向链表进行存储。查找、更新效率低，插入、删除效率高，随机存储，不需要考虑扩容。使用二分查找法  Vector 使用数组进行存储，使">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611175546307.png">
<meta property="og:image" content="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611173731097.png">
<meta property="og:image" content="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/4843132-7abca1abd714341d.png">
<meta property="og:image" content="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/1182892-20171122100317930-842768608.png">
<meta property="article:published_time" content="2020-11-30T10:12:46.000Z">
<meta property="article:modified_time" content="2024-07-12T02:34:26.993Z">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta property="article:tag" content="java集合">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611175546307.png">


<link rel="canonical" href="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>java集合 | 个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E9%9B%86%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">List集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">Map哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.1.</span> <span class="nav-text">HashMap详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hash%E4%BC%98%E5%8C%96"><span class="nav-number">3.1.1.</span> <span class="nav-text">hash优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E4%BC%98%E5%8C%96"><span class="nav-number">3.1.2.</span> <span class="nav-text">寻址优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A0%91"><span class="nav-number">3.1.3.</span> <span class="nav-text">链表转换成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E9%80%80%E5%8C%96%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.4.</span> <span class="nav-text">树退化为链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E9%93%BE%E8%A1%A8-%E2%86%92-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%98%88%E5%80%BC%E6%98%AF8"><span class="nav-number">3.1.5.</span> <span class="nav-text">为何链表 → 红黑树的阈值是8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E9%93%BE%E8%A1%A8-%E2%86%92-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%98%88%E5%80%BC%E6%98%AF6"><span class="nav-number">3.1.6.</span> <span class="nav-text">为何链表 → 红黑树的阈值是6</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap%E8%AF%A6%E6%83%85"><span class="nav-number">3.2.</span> <span class="nav-text">LinkedHashMap详情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap%E8%AF%A6%E6%83%85"><span class="nav-number">3.3.</span> <span class="nav-text">TreeMap详情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakHashMap%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.4.</span> <span class="nav-text">WeakHashMap详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.5.</span> <span class="nav-text">HashTable详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EnumMap"><span class="nav-number">3.6.</span> <span class="nav-text">EnumMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E9%9B%86%E5%90%88"><span class="nav-number">4.</span> <span class="nav-text">Set集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.1.</span> <span class="nav-text">HashSet详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSe%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.2.</span> <span class="nav-text">LinkedHashSe详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.3.</span> <span class="nav-text">TreeSet详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack%E6%A0%88"><span class="nav-number">5.</span> <span class="nav-text">Stack栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E5%9B%BEBitSet"><span class="nav-number">6.</span> <span class="nav-text">位图BitSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97Queue%E5%92%8CDeque%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">7.</span> <span class="nav-text">队列Queue和Deque双端队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayDeque%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">7.1.</span> <span class="nav-text">ArrayDeque双端队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList-%E5%AE%9E%E7%8E%B0%E4%BA%86Deque%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.2.</span> <span class="nav-text">LinkedList 实现了Deque接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityQueue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">7.3.</span> <span class="nav-text">PriorityQueue 优先级队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue-%E5%A0%B5%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">7.4.</span> <span class="nav-text">BlockingQueue 堵塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">7.5.</span> <span class="nav-text">队列中的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5fail-fast"><span class="nav-number">8.</span> <span class="nav-text">快速失败fail-fast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fail-safe"><span class="nav-number">9.</span> <span class="nav-text">fail-safe</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 18:12:46" itemprop="dateCreated datePublished" datetime="2020-11-30T18:12:46+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-07-12 10:34:26" itemprop="dateModified" datetime="2024-07-12T10:34:26+08:00">2024-07-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>​    开辟连续内存地址空间，数组长度固定，不能进行扩容，顺序存储。</p>
<hr>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h2><p>​    list集合可以使用数组或链表存储数据。</p>
<ul>
<li><p><code>ArrayList</code>使用数组进行存储。查找、更新效率高，插入、删除效率低，顺序存储，扩容为旧数组</p>
</li>
<li><p><code>LinkedList</code> 使用双向链表进行存储。查找、更新效率低，插入、删除效率高，随机存储，不需要考虑扩容。<font color="red">使用二分查找法</font></p>
</li>
<li><p><code>Vector</code> 使用数组进行存储，使用synchronized保证线程安全</p>
</li>
</ul>
<hr>
<h2 id="Map哈希表"><a href="#Map哈希表" class="headerlink" title="Map哈希表"></a><strong>Map哈希表</strong></h2><h3 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a><code>HashMap详解</code></h3><p>1.7中使用数组+单链表 ，1.8使用数组+单链表/红黑树(提升插入和查找的效率)，原容量的二倍扩容<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611175546307.png" alt="image-20210611175546307" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_INITIAL_CAPACITY <span class="comment">//初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</span></span><br><span class="line">MAXIMUM_CAPACITY <span class="comment">//哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</span></span><br><span class="line">DEFAULT_LOAD_FACTOR <span class="comment">//默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。存值之后扩容</span></span><br><span class="line">TREEIFY_THRESHOLD <span class="comment">//如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于等于 8 时，有可能会转化成树。</span></span><br><span class="line">UNTREEIFY_THRESHOLD <span class="comment">// 在哈希表扩容时，如果发现链表长度小于等于 6，则会由树重新退化为链表。</span></span><br><span class="line">MIN_TREEIFY_CAPACITY <span class="comment">//在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash <span class="comment">//计算下标</span></span><br></pre></td></tr></table></figure>

<h4 id="hash优化"><a href="#hash优化" class="headerlink" title="hash优化"></a>hash优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p><code>hashcdoe</code>值是32位，无符号右移16位，再与<code>hashcode</code>做^异或计算，使高位也参与计算，减少hash冲突</p>
<h4 id="寻址优化"><a href="#寻址优化" class="headerlink" title="寻址优化"></a>寻址优化</h4><p>h&amp;(n-1) 位与运算，等价于对n进行取模</p>
<h4 id="链表转换成树"><a href="#链表转换成树" class="headerlink" title="链表转换成树"></a>链表转换成树</h4><p>链表长度大等于8且键值对数量大于64</p>
<h4 id="树退化为链表"><a href="#树退化为链表" class="headerlink" title="树退化为链表"></a>树退化为链表</h4><p>链表长度小于等于6</p>
<h4 id="为何链表-→-红黑树的阈值是8"><a href="#为何链表-→-红黑树的阈值是8" class="headerlink" title="为何链表 → 红黑树的阈值是8"></a>为何链表 → 红黑树的阈值是8</h4><p>在理想的情况下随机hashCode算法下所有节点的分布频率会遵循<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Poisson_distribution">泊松分布(Poisson distribution)</a> ，链表长度达到8的概率是0.00000006，也就是说我们几乎不可能会使用到红黑树 , 所以作者使用8作为一个分水岭。<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/image-20210611173731097.png" alt="image-20210611173731097" style="zoom: 67%;"></p>
<h4 id="为何链表-→-红黑树的阈值是6"><a href="#为何链表-→-红黑树的阈值是6" class="headerlink" title="为何链表 → 红黑树的阈值是6"></a>为何链表 → 红黑树的阈值是6</h4><p>假设<code>UNTREEIFY_THRESHOLD</code>的 = 7 , 当我们有频繁的添加和删除操作时 ,hash碰撞产生的节点数量 一旦在7附件徘徊就会造成红黑树和链表的频繁转换 , 此时我们大多数的性能就都耗费在了链表 → 红黑树和红黑树 → 链表` ,这样反而就得不偿失了 , 所以作者将长度为7作为一个缓存地段从而选取了6作为红黑树 → 链表的阈值</p>
<h3 id="LinkedHashMap详情"><a href="#LinkedHashMap详情" class="headerlink" title="LinkedHashMap详情"></a><code>LinkedHashMap详情</code></h3><p>继承<code>HashMap</code>,多了二个自定义的继承<code>HashMap</code>的Node(增加了Entry&lt;K,V&gt; before, after)类的Entry类型的变量head、tail。通过head和tail节点记录数据的<font color="red">插入顺序或者访问顺序。</font>默认是插入顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head; <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail; <span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">//访问顺序，默认为false</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向链表，确定顺序。<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/4843132-7abca1abd714341d.png" style="zoom:67%;"></p>
<h3 id="TreeMap详情"><a href="#TreeMap详情" class="headerlink" title="TreeMap详情"></a><code>TreeMap详情</code></h3><p>使用红黑树，可以自定义<font color="red">Comparator比较器</font>。自动通过key比较大小，如果key相等，则覆盖value的值</p>
<p>当比较器为null时，使用key对象的类，必须实现Comparable，强转为Comparable类型进行key比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//根节点</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WeakHashMap详解"><a href="#WeakHashMap详解" class="headerlink" title="WeakHashMap详解"></a><code>WeakHashMap详解</code></h3><p>弱键值对，与HashMap类似，使用的是数组+单链表，涉及到扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;(); <span class="comment">//弱引用队列</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弱引用——&gt;回收之后会存入引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashTable详解"><a href="#HashTable详解" class="headerlink" title="HashTable详解"></a><code>HashTable详解</code></h3><p> 线程安全的，与<code>HashMap</code>类似，使用数组+单链表，涉及到扩容。使用同步块Synchronized，保证线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a><code>EnumMap</code></h3><hr>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set集合</strong></h2><h3 id="HashSet详解"><a href="#HashSet详解" class="headerlink" title="HashSet详解"></a><code>HashSet详解</code></h3><p>使用的是<code>HashMap</code>进行数据存储，value为全局的Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSe详解"><a href="#LinkedHashSe详解" class="headerlink" title="LinkedHashSe详解"></a><code>LinkedHashSe详解</code></h3><p>继承<code>HashSet</code>，使用<code>LinkedHashMap</code>进行数据存储，value为全局的Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet详解"><a href="#TreeSet详解" class="headerlink" title="TreeSet详解"></a><code>TreeSet详解</code></h3><p>成员变量m的类型为<code>TreeMap</code>，value为全局的Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a><strong>Stack栈</strong></h2><p>先进后出（<code>FILO</code>）或者后进先出（LIFO），synchronized同步块保证线程安全，继承Vector，底层使用数组保存数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Vector,线程同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="位图BitSet"><a href="#位图BitSet" class="headerlink" title="位图BitSet"></a><strong>位图<code>BitSet</code></strong></h2><p> 使用数组存储，每位存储的值为0或者1，使用位运算。二倍原数组长度扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] words;</span><br><span class="line"><span class="comment">//计算value[值为0,1]在那个数组里下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;  <span class="comment">//ADDRESS_BITS_PER_WORD=6,&gt;&gt;6表示除以2的6次方即64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算bitIndex的值 1L&lt;&lt;64 还是等于为1</span></span><br><span class="line">(words[wordIndex] &amp; (<span class="number">1L</span> &lt;&lt; bitIndex)) != <span class="number">0</span></span><br><span class="line"><span class="comment">//设置bitIndex的值为1</span></span><br><span class="line">words[wordIndex] |= (<span class="number">1L</span> &lt;&lt; bitIndex);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="队列Queue和Deque双端队列"><a href="#队列Queue和Deque双端队列" class="headerlink" title="队列Queue和Deque双端队列"></a><strong><code>队列Queue和Deque双端队列</code></strong></h2><p>队列类图如下：<br><img src="/2020/11/30/java%E9%9B%86%E5%90%88/1182892-20171122100317930-842768608.png" style="zoom:67%;"></p>
<h3 id="ArrayDeque双端队列"><a href="#ArrayDeque双端队列" class="headerlink" title="ArrayDeque双端队列"></a><code>ArrayDeque双端队列</code></h3><h3 id="LinkedList-实现了Deque接口"><a href="#LinkedList-实现了Deque接口" class="headerlink" title="LinkedList 实现了Deque接口"></a><code>LinkedList 实现了Deque接口</code></h3><h3 id="PriorityQueue-优先级队列"><a href="#PriorityQueue-优先级队列" class="headerlink" title="PriorityQueue 优先级队列"></a><code>PriorityQueue 优先级队列</code></h3><h3 id="BlockingQueue-堵塞队列"><a href="#BlockingQueue-堵塞队列" class="headerlink" title="BlockingQueue 堵塞队列"></a><code>BlockingQueue 堵塞队列</code></h3><p>使用可重入锁<code>ReentrantLock</code>实现线程安全，使用Condition实现阻塞</p>
<ul>
<li><p><strong><code>LinkedBlockingQueue</code></strong> 的容量是没有上限的（说的不准确，在不指定时容量为<code>Integer.MAX_VALUE</code>，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，基于单链表的队列，此队列按 FIFO（先进先出）排序元素。（<code>LinkedBlockingDeque</code>）</p>
</li>
<li><p><strong><code>ArrayBlockingQueue</code></strong> 在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将<code>ReentrantLock</code>设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
</li>
<li><p>**<code>DelayQueue</code>**（基于<code>PriorityQueue</code>来实现的）是一个存放Delayed元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 <code>getDelay(TimeUnit.NANOSECONDS)</code> 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。 内部使用了优先级队列<code>PriorityQueue</code></p>
</li>
<li><p><strong><code>PriorityBlockingQueue</code></strong> 是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，<code>PriorityBlockingQueue</code>是对 <code>PriorityQueue</code>的再次包装，是基于堆数据结构的，而<code>PriorityQueue</code>是没有容量限制的，与<code>ArrayList</code>一样，所以在优先阻塞队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 <code>OutOfMemoryError</code>），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。</p>
</li>
<li><p><strong><code>SynchronousQueue</code></strong> 一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没 有元素可用于迭代。队列的头是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），<code>SynchronousQueue</code> 作为一个空 collection。此队列不允许 null 元素。</p>
<p>同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p>
<p>看起来很有意思吧。队列竟然是没有内部容量的。这个队列其实是<code>BlockingQueue</code>的一种实现。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。它给我们提供了在线程之间交换单一元素的极轻量级方法</p>
</li>
<li><p><code>LinkedTransferQueue implements TransferQueue</code>  LinkedBlockingDeque</p>
</li>
<li><p>ConcurrentLinkedQueue   ConcurrentLinkedDeque</p>
</li>
</ul>
<h3 id="队列中的方法"><a href="#队列中的方法" class="headerlink" title="队列中的方法"></a>队列中的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>add</strong></td>
<td>增加一个元索，如果队列已满，则抛出一个<code>IIIegaISlabEepeplian</code>异常</td>
</tr>
<tr>
<td><strong>remove</strong></td>
<td>移除并返回队列头部的元素，如果队列为空，则抛出一个<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td><strong>element</strong></td>
<td>返回队列头部的元素 ，如果队列为空，则抛出一个<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td><strong>offer</strong></td>
<td>添加一个元素并返回true ，如果队列已满，则返回false</td>
</tr>
<tr>
<td><strong>poll</strong></td>
<td>移除并返问队列头部的元素，如果队列为空，则返回null</td>
</tr>
<tr>
<td><strong>peek</strong></td>
<td>返回队列头部的元素，如果队列为空，则返回null</td>
</tr>
<tr>
<td><strong>put</strong></td>
<td>添加一个元素，如果队列满，则==阻塞==</td>
</tr>
<tr>
<td><strong>take</strong></td>
<td>移除并返回队列头部的元素，如果队列为空，则==阻塞==</td>
</tr>
</tbody></table>
<h2 id="快速失败fail-fast"><a href="#快速失败fail-fast" class="headerlink" title="快速失败fail-fast"></a>快速失败fail-fast</h2><p>集合中<strong>modCount</strong>变量，用modCount来记录修改集合修改次数。</p>
<ul>
<li>modCount成员变量，对集合进行增删改时，都会加1</li>
<li>集合迭代器操作时，会先赋值expectedModCount=modCount，遍历或删除等操作会判断expectedModCount与modCount 是否相等，如果不相等，throw new ConcurrentModificationException();</li>
</ul>
<h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历</li>
<li>java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E9%9B%86%E5%90%88/" rel="tag"># java集合</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/30/%E5%AE%B9%E5%99%A8%E4%B9%8Bk8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/" rel="prev" title="k8s之调度器和调度过程">
                  <i class="fa fa-chevron-left"></i> k8s之调度器和调度过程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/30/java%E9%9B%86%E5%90%88%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/" rel="next" title="java并发集合">
                  java并发集合 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
